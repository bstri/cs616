1, 'org.eclipse.ui.PlatformUI', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/PlatformUI.html', 'extends Object The central class for access to the Eclipse Platform User Interface. This class cannot be instantiated; all functionality is provided by static methods. Features provided: creation of the workbench. access to the workbench. See Also: IWorkbench '
2, 'org.eclipse.swt.widgets.Display', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/widgets/Display.html', 'Implementers of Drawable can have a graphics context (GC) created for them, and then they can be drawn on by sending messages to their associated GC. SWT images, and device objects such as the Display device and the Printer device, are drawables. IMPORTANT: This interface is not part of the SWT public API. It is marked public only so that it can be shared within the packages provided by SWT. It should never be referenced from application code. See Also: Device, Image, GC provides inter-thread communication methods which allow threads other than the user-interface thread to request that it perform operations on their behalf.) The thread is not allowed to construct other Displays until that display has been disposed. (Note that, this is in addition to the restriction mentioned above concerning platform support for multiple displays. Thus, the only way to have multiple simultaneously active displays, even on platforms which support it, is to have multiple threads.) Enforcing these attributes allows SWT to be implemented directly on the underlying operating system\'s event model. This has numerous benefits including smaller footprint, better use of resources, safer memory management, clearer program logic, better performance, and fewer overall operating system threads required. The down side however, is that care must be taken (only) when constructing multi-threaded applications to use the inter-thread communication mechanisms which this class provides when required. All SWT API methods which may only be called from the user-interface thread are distinguished in their documentation by indicating that they throw the \"ERROR_THREAD_INVALID_ACCESS\" SWT exception. Styles: (none) Events: Close, Dispose, OpenDocument, Settings, Skin IMPORTANT: This class is not intended to be subclassed. See Also: syncExec(java.lang.Runnable), asyncExec(java.lang.Runnable), wake(), readAndDispatch(), sleep(), Device.dispose(), Display snippets, Sample code and further information Restriction: This class is not intended to be subclassed by clients. '
3, 'org.eclipse.ui.application.WorkbenchAdvisor', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/application/WorkbenchAdvisor.html', 'extends Object Public base class for configuring the workbench. Note that the workbench advisor object is created in advance of creating the workbench. However, by the time the workbench starts calling methods on this class, PlatformUI.getWorkbench is guaranteed to have been properly initialized. Example of creating and running a workbench (in an IPlatformRunnable): public class MyApplication implements IPlatformRunnable { public Object run(Object args) { WorkbenchAdvisor workbenchAdvisor = new MyWorkbenchAdvisor(); Display display = PlatformUI.createDisplay(); int returnCode = PlatformUI.createAndRunWorkbench(display, workbenchAdvisor); if (returnCode == PlatformUI.RETURN_RESTART) { return IPlatformRunnable.EXIT_RESTART; } else { return IPlatformRunnable.EXIT_OK; } } An application should declare a subclass of WorkbenchAdvisor and override methods to configure the workbench to suit the needs of the particular application. The following advisor methods are called at strategic points in the workbench\'s lifecycle (all occur within the dynamic scope of the call to PlatformUI.createAndRunWorkbench): initialize - called first; before any windows; use to register things preStartup - called second; after initialize but before first window is opened; use to temporarily disable things during startup or restore postStartup - called third; after first window is opened; use to reenable things temporarily disabled in previous step postRestore - called after the workbench and its windows has been recreated from a previously saved state; use to adjust the restored workbench preWindowOpen - called as each window is being opened; use to configure aspects of the window other than actions bars fillActionBars - called after preWindowOpen to configure a window\'s action bars postWindowRestore - called after a window has been recreated from a previously saved state; use to adjust the restored window postWindowCreate - called after a window has been created, either from an initial state or from a restored state; used to adjust the window openIntro - called immediately before a window is opened in order to create the introduction component, if any. postWindowOpen - called after a window has been opened; use to hook window listeners, etc. preWindowShellClose - called when a window\'s shell is closed by the user; use to pre-screen window closings eventLoopException - called to handle the case where the event loop has crashed; use to inform the user that things are not well eventLoopIdle - called when there are currently no more events to be processed; use to perform other work or to yield until new events enter the queue preShutdown - called immediately prior to workbench shutdown before any windows have been closed; allows the advisor to veto the shutdown postShutdown - called last; after event loop has terminated and all windows have been closed; use to deregister things registered during initialize Since: 3.0 '
4, 'org.eclipse.core.runtime.IStatus', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/runtime/IStatus.html', 'A status object represents the outcome of an operation. All CoreExceptions carry a status object to indicate what went wrong. Status objects are also returned by methods needing to provide details of failures (e.g., validation methods). A status carries the following information: plug-in identifier (required) severity (required) status code (required) message (required) - localized to current locale exception (optional) - for problems stemming from a failure at a lower level Some status objects, known as multi-statuses, have other status objects as children. The class Status is the standard public implementation of status objects; the subclass MultiStatus is the implements multi-status objects. This interface can be used without OSGi running. See Also: MultiStatus, Status '
5, 'org.eclipse.ui.IMemento', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/IMemento.html', 'Interface to a memento used for saving the important state of an object in a form that can be persisted in the file system. Mementos were designed with the following requirements in mind: Certain objects need to be saved and restored across platform sessions. When an object is restored, an appropriate class for an object might not be available. It must be possible to skip an object in this case. When an object is restored, the appropriate class for the object may be different from the one when the object was originally saved. If so, the new class should still be able to read the old form of the data. Mementos meet these requirements by providing support for storing a mapping of arbitrary string keys to primitive values, and by allowing mementos to have other mementos as children (arranged into a tree). A robust external storage format based on XML is used. The key for an attribute may be any alpha numeric value that doesn\'t start with a number. eg: [A-Za-z][A-Za-z0-9]* Using \'.\' is unsupported. However, the value of TAG_ID is reserved for internal use. The default implementation can throw a DOMException for createChild and put operations. See XMLMemento. This interface is not intended to be implemented or extended by clients. See Also: IPersistableElement, IElementFactory, XMLMemento Restriction: This interface is not intended to be implemented by clients. '
6, 'org.eclipse.ui.application.IWorkbenchConfigurer', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/application/IWorkbenchConfigurer.html', 'Interface providing special access for configuring the workbench. Note that these objects are only available to the main application (the plug-in that creates and owns the workbench). This interface is not intended to be implemented by clients. Since: 3.0 See Also: WorkbenchAdvisor.initialize(org.eclipse.ui.application.IWorkbenchConfigurer) Restriction: This interface is not intended to be implemented by clients. '
7, 'org.eclipse.ui.application.WorkbenchWindowAdvisor', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/application/WorkbenchWindowAdvisor.html', 'extends Object Public base class for configuring a workbench window. The workbench window advisor object is created in response to a workbench window being created (one per window), and is used to configure the window. An application should declare a subclass of WorkbenchWindowAdvisor and override methods to configure workbench windows to suit the needs of the particular application. The following advisor methods are called at strategic points in the workbench window\'s lifecycle (as with the workbench advisor, all occur within the dynamic scope of the call to PlatformUI.createAndRunWorkbench): preWindowOpen - called as the window is being opened; use to configure aspects of the window other than actions bars postWindowRestore - called after the window has been recreated from a previously saved state; use to adjust the restored window postWindowCreate - called after the window has been created, either from an initial state or from a restored state; used to adjust the window openIntro - called immediately before the window is opened in order to create the introduction component, if any. postWindowOpen - called after the window has been opened; use to hook window listeners, etc. preWindowShellClose - called when the window\'s shell is closed by the user; use to pre-screen window closings Since: 3.1 '
8, 'org.eclipse.ui.application.IWorkbenchWindowConfigurer', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/application/IWorkbenchWindowConfigurer.html', 'Interface providing special access for configuring workbench windows. Window configurer objects are in 1-1 correspondence with the workbench windows they configure. Clients may use get/setData to associate arbitrary state with the window configurer object. Note that these objects are only available to the main application (the plug-in that creates and owns the workbench). This interface is not intended to be implemented by clients. Since: 3.0 See Also: IWorkbenchConfigurer.getWindowConfigurer(org.eclipse.ui.IWorkbenchWindow), WorkbenchAdvisor.preWindowOpen(org.eclipse.ui.application.IWorkbenchWindowConfigurer) Restriction: This interface is not intended to be implemented by clients. '
9, 'org.eclipse.ui.application.ActionBarAdvisor', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/application/ActionBarAdvisor.html', 'extends Object Public base class for configuring the action bars of a workbench window. An application should declare a subclass of ActionBarAdvisor and override methods to configure a window\'s action bars to suit the needs of the particular application. The following advisor methods are called at strategic points in the workbench\'s lifecycle (all occur within the dynamic scope of the call to PlatformUI.createAndRunWorkbench): fillActionBars - called after WorkbenchWindowAdvisor.preWindowOpen to configure a window\'s action bars Since: 3.1 See Also: WorkbenchWindowAdvisor.createActionBarAdvisor(IActionBarConfigurer) '
10, 'org.eclipse.ui.application.IActionBarConfigurer', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/application/IActionBarConfigurer.html', 'Interface providing special access for configuring the action bars of a workbench window. Note that these objects are only available to the main application (the plug-in that creates and owns the workbench). This interface is not intended to be implemented by clients. Since: 3.0 See Also: WorkbenchAdvisor.fillActionBars(org.eclipse.ui.IWorkbenchWindow, org.eclipse.ui.application.IActionBarConfigurer, int) Restriction: This interface is not intended to be implemented by clients. '
11, 'org.eclipse.ui.XMLMemento', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/XMLMemento.html', 'Interface to a memento used for saving the important state of an object in a form that can be persisted in the file system. Mementos were designed with the following requirements in mind: Certain objects need to be saved and restored across platform sessions. When an object is restored, an appropriate class for an object might not be available. It must be possible to skip an object in this case. When an object is restored, the appropriate class for the object may be different from the one when the object was originally saved. If so, the new class should still be able to read the old form of the data. Mementos meet these requirements by providing support for storing a mapping of arbitrary string keys to primitive values, and by allowing mementos to have other mementos as children (arranged into a tree). A robust external storage format based on XML is used. The key for an attribute may be any alpha numeric value that doesn\'t start with a number. eg: [A-Za-z][A-Za-z0-9]* Using \'.\' is unsupported. However, the value of TAG_ID is reserved for internal use. The default implementation can throw a DOMException for createChild and put operations. See XMLMemento. This interface is not intended to be implemented or extended by clients. See Also: IPersistableElement, IElementFactory, XMLMemento Restriction: This interface is not intended to be implemented by clients. extends Object implements IMemento This class represents the default implementation of the IMemento interface. This class is not intended to be extended by clients. See Also: IMemento '
12, 'org.eclipse.core.runtime.IPath', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/runtime/IPath.html', 'extends Cloneable A path is an ordered collection of string segments, separated by a standard separator character, \"/\". A path may also have a leading and/or a trailing separator. Paths may also be prefixed by an optional device id, which includes the character(s) which separate the device id from the rest of the path. For example, \"C:\" and \"Server/Volume:\" are typical device ids. A device independent path has null for a device id. Note that paths are value objects; all operations on paths return a new path; the path that is operated on is unscathed. UNC paths are denoted by leading double-slashes such as //Server/Volume/My/Path. When a new path is constructed all double-slashes are removed except those appearing at the beginning of the path. This interface can be used without OSGi running. This interface is not intended to be implemented by clients. See Also: Path Restriction: This interface is not intended to be implemented by clients. Restriction: This interface is not intended to be extended by clients. '
13, 'org.eclipse.swt.widgets.Shell', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/widgets/Shell.html', 'Implementers of Drawable can have a graphics context (GC) created for them, and then they can be drawn on by sending messages to their associated GC. SWT images, and device objects such as the Display device and the Printer device, are drawables. IMPORTANT: This interface is not part of the SWT public API. It is marked public only so that it can be shared within the packages provided by SWT. It should never be referenced from application code. See Also: Device, Image, GC extends Decorations Instances of this class represent the \"windows\" which the desktop or \"window manager\" is managing. Instances that do not have a parent (that is, they are built using the constructor, which takes a Display as the argument) are described as top level shells. Instances that do have a parent are described as secondary or dialog shells. Instances are always displayed in one of the maximized, minimized or normal states: When an instance is marked as maximized, the window manager will typically resize it to fill the entire visible area of the display, and the instance is usually put in a state where it can not be resized (even if it has style RESIZE) until it is no longer maximized. When an instance is in the normal state (neither maximized or minimized), its appearance is controlled by the style constants which were specified when it was created and the restrictions of the window manager (see below). When an instance has been marked as minimized, its contents (client area) will usually not be visible, and depending on the window manager, it may be \"iconified\" (that is, replaced on the desktop by a small simplified representation of itself), relocated to a distinguished area of the screen, or hidden. Combinations of these changes are also possible. The modality of an instance may be specified using style bits. The modality style bits are used to determine whether input is blocked for other shells on the display. The PRIMARY_MODAL style allows an instance to block input to its parent. The APPLICATION_MODAL style allows an instance to block input to every other shell in the display. The SYSTEM_MODAL style allows an instance to block input to all shells, including shells belonging to different applications. Note: The styles supported by this class are treated as HINTs, since the window manager for the desktop on which the instance is visible has ultimate control over the appearance and behavior of decorations and modality. For example, some window managers only support resizable windows and will always assume the RESIZE style, even if it is not set. In addition, if a modality style is not supported, it is \"upgraded\" to a more restrictive modality style that is supported. For example, if PRIMARY_MODAL is not supported, it would be upgraded to APPLICATION_MODAL. A modality style may also be \"downgraded\" to a less restrictive style. For example, most operating systems no longer support SYSTEM_MODAL because it can freeze up the desktop, so this is typically downgraded to APPLICATION_MODAL. Styles: BORDER, CLOSE, MIN, MAX, NO_TRIM, RESIZE, TITLE, ON_TOP, TOOL, SHEET APPLICATION_MODAL, MODELESS, PRIMARY_MODAL, SYSTEM_MODAL Events: Activate, Close, Deactivate, Deiconify, Iconify Class SWT provides two \"convenience constants\" for the most commonly required style combinations: SHELL_TRIM the result of combining the constants which are required to produce a typical application top level shell: (that is, CLOSE | TITLE | MIN | MAX | RESIZE) DIALOG_TRIM the result of combining the constants which are required to produce a typical application dialog shell: (that is, TITLE | CLOSE | BORDER) Note: Only one of the styles APPLICATION_MODAL, MODELESS, PRIMARY_MODAL and SYSTEM_MODAL may be specified. IMPORTANT: This class is not intended to be subclassed. See Also: Decorations, SWT, Shell snippets, SWT Example: ControlExample, Sample code and further information Restriction: This class is not intended to be subclassed by clients. '
14, 'org.eclipse.ui.IWorkbenchWindow', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/IWorkbenchWindow.html', 'A page service tracks the page and perspective lifecycle events within a workbench window. This service can be acquired from your service locator: IPageService service = (IPageService) getSite().getService(IPageService.class); This service is not available globally, only from the workbench window level down. See Also: IWorkbenchWindow, IPageListener, IPerspectiveListener, IServiceLocator.getService(Class) Restriction: This interface is not intended to be implemented by clients. Interface for UI components which can execute a long-running operation in the form of an IRunnableWithProgress. The context is responsible for displaying a progress indicator and Cancel button to the end user while the operation is in progress; the context supplies a progress monitor to be used from code running inside the operation. Note that an IRunnableContext is not a runnable itself. For examples of UI components which implement this interface, see ApplicationWindow, ProgressMonitorDialog, and WizardDialog. See Also: IRunnableWithProgress, ApplicationWindow, ProgressMonitorDialog, WizardDialog A component with which one or more services are registered. The services can be retrieved from this locator using some key -- typically the class representing the interface the service must implement. For example: IHandlerService service = (IHandlerService) workbenchWindow .getService(IHandlerService.class); This interface is not to be implemented or extended by clients. Since: 3.2 Interface for objects that can return a shell. This is normally used for opening child windows. An object that wants to open child shells can take an IShellProvider in its constructor, and the object that implements IShellProvider can dynamically choose where child shells should be opened. Since: 3.1 extends IPageService, IRunnableContext, IServiceLocator, IShellProvider A workbench window is a top level window in a workbench. Visually, a workbench window has a menubar, a toolbar, a status bar, and a main area for displaying a single page consisting of a collection of views and editors. Each workbench window has a collection of 0 or more pages; the active page is the one that is being presented to the end user; at most one page is active in a window at a time. The workbench window supports a few services by default. If these services are used to allocate resources, it is important to remember to clean up those resources after you are done with them. Otherwise, the resources will exist until the workbench window is closed. The supported services are: ICommandService IContextService IHandlerService IBindingService. Resources allocated through this service will not be cleaned up until the workbench shuts down. This interface is not intended to be implemented by clients. See Also: IWorkbenchPage Restriction: This interface is not intended to be implemented by clients. '
15, 'org.eclipse.core.runtime.IAdaptable', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/runtime/IAdaptable.html', 'An interface for an adaptable object. Adaptable objects can be dynamically extended to provide different interfaces (or \"adapters\"). Adapters are created by adapter factories, which are in turn managed by type by adapter managers. For example, IAdaptable a = [some adaptable]; IFoo x = (IFoo)a.getAdapter(IFoo.class); if (x != null) [do IFoo things with x] This interface can be used without OSGi running. Clients may implement this interface, or obtain a default implementation of this interface by subclassing PlatformObject. See Also: IAdapterFactory, IAdapterManager, PlatformObject '
16, 'org.eclipse.ui.IWindowListener', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/IWindowListener.html', 'Interface for listening to window lifecycle events. This interface may be implemented by clients. '
17, 'org.eclipse.swt.graphics.Rectangle', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/graphics/Rectangle.html', 'extends Object implements org.eclipse.swt.internal.SerializableCompatibility Instances of this class represent rectangular areas in an (x, y) coordinate system. The top left corner of the rectangle is specified by its x and y values, and the extent of the rectangle is specified by its width and height. The coordinate space for rectangles and points is considered to have increasing values downward and to the right from its origin making this the normal, computer graphics oriented notion of (x, y) coordinates rather than the strict mathematical one. The hashCode() method in this class uses the values of the public fields to compute the hash value. When storing instances of the class in hashed collections, do not modify these fields after the object has been inserted. Application code does not need to explicitly release the resources managed by each instance when those instances are no longer required, and thus no dispose() method is provided. See Also: Point, Sample code and further information, Serialized Form '
18, 'org.eclipse.ui.IWorkbenchPage', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/IWorkbenchPage.html', 'A part service tracks the creation and activation of parts within a workbench page. This service can be acquired from your service locator: IPartService service = (IPartService) getSite().getService(IPartService.class); This service is not available globally, only from the workbench window level down. See Also: IWorkbenchPage, IServiceLocator.getService(Class) Restriction: This interface is not intended to be implemented by clients. A selection service tracks the selection within an object. A listener that wants to be notified when the selection becomes null must implement the INullSelectionListener interface. This service can be acquired from your service locator: ISelectionService service = (ISelectionService) getSite().getService(ISelectionService.class); This service is not available globally, only from the workbench window level down. See Also: ISelectionListener, INullSelectionListener, IServiceLocator.getService(Class) Restriction: This interface is not intended to be implemented by clients. extends IPartService, ISelectionService, org.eclipse.ui.internal.ICompatibleWorkbenchPage A workbench page consists of an arrangement of views and editors intended to be presented together to the user in a single workbench window. A page can contain 0 or more views and 0 or more editors. These views and editors are contained wholly within the page and are not shared with other pages. The layout and visible action set for the page is defined by a perspective. The number of views and editors within a page is restricted to simplify part management for the user. In particular: Unless a view explicitly allows for multiple instances in its plug-in declaration there will be only one instance in a given workbench page. Only one editor can exist for each editor input within a page. This interface is not intended to be implemented by clients. See Also: IPerspectiveDescriptor, IEditorPart, IViewPart Restriction: This interface is not intended to be implemented by clients. '
19, 'org.eclipse.ui.IWorkbench', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/IWorkbench.html', 'An interface for an adaptable object. Adaptable objects can be dynamically extended to provide different interfaces (or \"adapters\"). Adapters are created by adapter factories, which are in turn managed by type by adapter managers. For example, IAdaptable a = [some adaptable]; IFoo x = (IFoo)a.getAdapter(IFoo.class); if (x != null) [do IFoo things with x] This interface can be used without OSGi running. Clients may implement this interface, or obtain a default implementation of this interface by subclassing PlatformObject. See Also: IAdapterFactory, IAdapterManager, PlatformObject A component with which one or more services are registered. The services can be retrieved from this locator using some key -- typically the class representing the interface the service must implement. For example: IHandlerService service = (IHandlerService) workbenchWindow .getService(IHandlerService.class); This interface is not to be implemented or extended by clients. Since: 3.2 extends IAdaptable, IServiceLocator A workbench is the root object for the Eclipse Platform user interface. A workbench has one or more main windows which present to the end user information based on some underlying model, typically on resources in an underlying workspace. A workbench usually starts with a single open window, and automatically closes when its last window closes. Each workbench window has a collection of pages; the active page is the one that is being presented to the end user; at most one page is active in a window at a time. Each workbench page has a collection of workbench parts, of which there are two kinds: views and editors. A page\'s parts are arranged (tiled or stacked) for presentation on the screen. The arrangement is not fixed; the user can arrange the parts as they see fit. A perspective is a template for a page, capturing a collection of parts and their arrangement. The platform creates a workbench when the workbench plug-in is activated; since this happens at most once during the life of the running platform, there is only one workbench instance. Due to its singular nature, it is commonly referred to as the workbench. The workbench supports a few services by default. If these services are used to allocate resources, it is important to remember to clean up those resources after you are done with them. Otherwise, the resources will exist until the workbench shuts down. The supported services are: IBindingService ICommandService IContextService IHandlerService This interface is not intended to be implemented by clients. See Also: PlatformUI.getWorkbench() Restriction: This interface is not intended to be implemented by clients. '
20, 'org.eclipse.ui.IWorkbenchListener', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/IWorkbenchListener.html', 'Interface for listening to workbench lifecycle events. This interface may be implemented by clients. Since: 3.2 See Also: IWorkbench.addWorkbenchListener(org.eclipse.ui.IWorkbenchListener), IWorkbench.removeWorkbenchListener(org.eclipse.ui.IWorkbenchListener) '
21, 'org.eclipse.jface.action.IAction', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/action/IAction.html', 'An action represents the non-UI side of a command which can be triggered by the end user. Actions are typically associated with buttons, menu items, and items in tool bars. The controls for a command are built by some container, which furnished the context where these controls appear and configures them with data from properties declared by the action. When the end user triggers the command via its control, the action\'s run method is invoked to do the real work. Actions support a predefined set of properties (and possibly others as well). Clients of an action may register property change listeners so that they get notified whenever the value of a property changes. Clients should subclass the abstract base class Action to define concrete actions rather than implementing IAction from scratch. This interface exists only to define the API for actions. It is not intended to be implemented by clients. See Also: Action Restriction: This interface is not intended to be implemented by clients. '
22, 'org.eclipse.jface.action.ICoolBarManager', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/action/ICoolBarManager.html', 'A contribution manager organizes contributions to such UI components as menus, toolbars and status lines. A contribution manager keeps track of a list of contribution items. Each contribution item may has an optional identifier, which can be used to retrieve items from a manager, and for positioning items relative to each other. The list of contribution items can be subdivided into named groups using special contribution items that serve as group markers. The IContributionManager interface provides general protocol for adding, removing, and retrieving contribution items. It also provides convenience methods that make it convenient to contribute actions. This interface should be implemented by all objects that wish to manage contributions. There are several implementions of this interface in this package, including ones for menus (MenuManager), tool bars (ToolBarManager), and status lines (StatusLineManager). extends IContributionManager The ICoolBarManager interface provides protocol for managing contributions to a cool bar. A cool bar manager delegates responsibility for creating child controls to its contribution items by calling IContributionItem.fill(CoolBar, int). This interface is internal to the framework; it should not be implemented outside the framework. This package provides a concrete cool bar manager implementation, CoolBarManager, which clients may instantiate or subclass. Since: 3.0 See Also: ToolBarContributionItem '
23, 'org.eclipse.jface.action.IMenuManager', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/action/IMenuManager.html', 'A contribution item represents a contribution to a shared UI resource such as a menu or tool bar. More generally, contribution items are managed by a contribution manager. For instance, in a tool bar a contribution item is a tool bar button or a separator. In a menu bar a contribution item is a menu, and in a menu a contribution item is a menu item or separator. A contribution item can realize itself in different SWT widgets, using the different fill methods. The same type of contribution item can be used with a MenuBarManager, ToolBarManager, CoolBarManager, or a StatusLineManager. This interface is internal to the framework; it should not be implemented outside the framework. See Also: IContributionManager Restriction: This interface is not intended to be implemented by clients. A contribution manager organizes contributions to such UI components as menus, toolbars and status lines. A contribution manager keeps track of a list of contribution items. Each contribution item may has an optional identifier, which can be used to retrieve items from a manager, and for positioning items relative to each other. The list of contribution items can be subdivided into named groups using special contribution items that serve as group markers. The IContributionManager interface provides general protocol for adding, removing, and retrieving contribution items. It also provides convenience methods that make it convenient to contribute actions. This interface should be implemented by all objects that wish to manage contributions. There are several implementions of this interface in this package, including ones for menus (MenuManager), tool bars (ToolBarManager), and status lines (StatusLineManager). extends IContributionManager, IContributionItem The IMenuManager interface provides protocol for managing contributions to a menu bar and its sub menus. An IMenuManager is also an IContributionItem, allowing sub-menus to be nested in parent menus. This interface is internal to the framework; it should not be implemented outside the framework. This package provides a concrete menu manager implementation, MenuManager. Restriction: This interface is not intended to be implemented by clients. '
24, 'org.eclipse.jface.action.IStatusLineManager', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/action/IStatusLineManager.html', 'A contribution manager organizes contributions to such UI components as menus, toolbars and status lines. A contribution manager keeps track of a list of contribution items. Each contribution item may has an optional identifier, which can be used to retrieve items from a manager, and for positioning items relative to each other. The list of contribution items can be subdivided into named groups using special contribution items that serve as group markers. The IContributionManager interface provides general protocol for adding, removing, and retrieving contribution items. It also provides convenience methods that make it convenient to contribute actions. This interface should be implemented by all objects that wish to manage contributions. There are several implementions of this interface in this package, including ones for menus (MenuManager), tool bars (ToolBarManager), and status lines (StatusLineManager). extends IContributionManager The IStatusLineManager interface provides protocol for displaying messages on a status line, for monitoring progress, and for managing contributions to the status line. Note: An error message overrides the current message until the error message is cleared. This package also provides a concrete status line manager implementation, StatusLineManager. '
25, 'org.eclipse.swt.widgets.Control', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/widgets/Control.html', 'Implementers of Drawable can have a graphics context (GC) created for them, and then they can be drawn on by sending messages to their associated GC. SWT images, and device objects such as the Display device and the Printer device, are drawables. IMPORTANT: This interface is not part of the SWT public API. It is marked public only so that it can be shared within the packages provided by SWT. It should never be referenced from application code. See Also: Device, Image, GC extends Widget implements Drawable Control is the abstract superclass of all windowed user interface classes. Styles: BORDER LEFT_TO_RIGHT, RIGHT_TO_LEFT, FLIP_TEXT_DIRECTION Events: DragDetect, FocusIn, FocusOut, Help, KeyDown, KeyUp, MenuDetect, MouseDoubleClick, MouseDown, MouseEnter, MouseExit, MouseHover, MouseUp, MouseMove, MouseWheel, MouseHorizontalWheel, MouseVerticalWheel, Move, Paint, Resize, Traverse Only one of LEFT_TO_RIGHT or RIGHT_TO_LEFT may be specified. IMPORTANT: This class is intended to be subclassed only within the SWT implementation. See Also: Control snippets, SWT Example: ControlExample, Sample code and further information Restriction: This class is not intended to be subclassed by clients. '
26, 'org.eclipse.swt.widgets.Composite', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/widgets/Composite.html', 'Implementers of Drawable can have a graphics context (GC) created for them, and then they can be drawn on by sending messages to their associated GC. SWT images, and device objects such as the Display device and the Printer device, are drawables. IMPORTANT: This interface is not part of the SWT public API. It is marked public only so that it can be shared within the packages provided by SWT. It should never be referenced from application code. See Also: Device, Image, GC extends Scrollable Instances of this class are controls which are capable of containing other controls. Styles: NO_BACKGROUND, NO_FOCUS, NO_MERGE_PAINTS, NO_REDRAW_RESIZE, NO_RADIO_GROUP, EMBEDDED, DOUBLE_BUFFERED Events: (none) Note: The NO_BACKGROUND, NO_FOCUS, NO_MERGE_PAINTS, and NO_REDRAW_RESIZE styles are intended for use with Canvas. They can be used with Composite if you are drawing your own, but their behavior is undefined if they are used with subclasses of Composite other than Canvas. Note: The CENTER style, although undefined for composites, has the same value as EMBEDDED which is used to embed widgets from other widget toolkits into SWT. On some operating systems (GTK, Motif), this may cause the children of this composite to be obscured. This class may be subclassed by custom control implementors who are building controls that are constructed from aggregates of other controls. See Also: Canvas, Composite snippets, Sample code and further information '
27, 'org.eclipse.ui.part.ViewPart', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/part/ViewPart.html', 'An interface for an adaptable object. Adaptable objects can be dynamically extended to provide different interfaces (or \"adapters\"). Adapters are created by adapter factories, which are in turn managed by type by adapter managers. For example, IAdaptable a = [some adaptable]; IFoo x = (IFoo)a.getAdapter(IFoo.class); if (x != null) [do IFoo things with x] This interface can be used without OSGi running. Clients may implement this interface, or obtain a default implementation of this interface by subclassing PlatformObject. See Also: IAdapterFactory, IAdapterManager, PlatformObject Interface for executable extension classes that require access to their configuration element, or implement an extension adapter. Extension adapters are typically required in cases where the extension implementation does not follow the interface rules specified by the provider of the extension point. In these cases, the role of the adapter is to map between the extension point interface, and the actual extension implementation. In general, adapters are used when attempting to plug-in existing Java implementations, or non-Java implementations (e.g., external executables). This interface can be used without OSGi running. Clients may implement this interface. See Also: IConfigurationElement.createExecutableExtension(String) Objects implementing this interface are capable of saving their state in an IMemento. Since: 3.1 extends IWorkbenchPart, IPersistable A view is a visual component within a workbench page. It is typically used to navigate a hierarchy of information (like the workspace), open an editor, or display properties for the active editor. Modifications made in a view are saved immediately (in contrast to an editor part, which conforms to a more elaborate open-save-close lifecycle). Only one instance of a particular view type may exist within a workbench page. This policy is designed to simplify part management for a user. This interface may be implemented directly. For convenience, a base implementation is defined in ViewPart. A view is added to the workbench in two steps: A view extension is contributed to the workbench registry. This extension defines the extension id and extension class. The view is included in the default layout for a perspective. Alternatively, the user may open the view from the Perspective menu. Views implement the IAdaptable interface; extensions are managed by the platform\'s adapter manager. As of 3.4, views may optionally adapt to ISizeProvider if they have a preferred size. The default presentation will make a best effort to allocate the preferred size to a view if it is the only part in a stack. If there is more than one part in the stack, the constraints will be disabled for that stack. The size constraints are adjusted for the size of the tab and border trim. Note that this is considered to be a hint to the presentation, and not all presentations may honor size constraints. See Also: IWorkbenchPage.showView(java.lang.String), ViewPart, ISizeProvider extends IAdaptable A workbench part is a visual component within a workbench page. There are two subtypes: view and editor, as defined by IViewPart and IEditorPart. A view is typically used to navigate a hierarchy of information (like the workspace), open an editor, or display properties for the active editor. Modifications made in a view are saved immediately. An editor is typically used to edit or browse a document or input object. The input is identified using an IEditorInput. Modifications made in an editor part follow an open-save-close lifecycle model. This interface may be implemented directly. For convenience, a base implementation is defined in WorkbenchPart. The lifecycle of a workbench part is as follows: When a part extension is created: instantiate the part create a part site call part.init(site) When a part becomes visible in the workbench: add part to presentation by calling part.createPartControl(parent) to create actual widgets fire partOpened event to all listeners When a part is activated or gets focus: call part.setFocus() fire partActivated event to all listeners When a part is closed: if save is needed, do save; if it fails or is canceled return if part is active, deactivate part fire partClosed event to all listeners remove part from presentation; part controls are disposed as part of the SWT widget tree call part.dispose() After createPartControl has been called, the implementor may safely reference the controls created. When the part is closed these controls will be disposed as part of an SWT composite. This occurs before the IWorkbenchPart.dispose method is called. If there is a need to free SWT resources the part should define a dispose listener for its own control and free those resources from the dispose listener. If the part invokes any method on the disposed SWT controls after this point an SWTError will be thrown. The last method called on IWorkbenchPart is dispose. This signals the end of the part lifecycle. An important point to note about this lifecycle is that following a call to init, createPartControl may never be called. Thus in the dispose method, implementors must not assume controls were created. Workbench parts implement the IAdaptable interface; extensions are managed by the platform\'s adapter manager. See Also: IViewPart, IEditorPart extends IWorkbenchPart Extends IWorkbenchPart, adding the name and status text properties. Prior to 3.0, a view\'s title was often modified to show both the part name and extra status text. With this interface, the distinction is made more explicit. Since: 3.0 extends IWorkbenchPart2 A part can provide arbitrary properties. The properties will be persisted between sessions by the part reference, and will be available from the part reference as well as the part. The properties can only be set on a part, not on the reference. The properties will be available to the IPresentablePart. Setting a property must fire a PropertyChangeEvent. Since: 3.3 The IWorkbenchPartOrientation is the interface that defines the orientation of the part. If a type does not implement this interface an orientation of SWT.NONE will be assumed. Since: 3.1 See Also: SWT.RIGHT_TO_LEFT, SWT.LEFT_TO_RIGHT, SWT.NONE, Window.getDefaultOrientation() extends WorkbenchPart implements IViewPart Abstract base implementation of all workbench views. This class should be subclassed by clients wishing to define new views. The name of the subclass should be given as the \"class\" attribute in a view extension contributed to the workbench\'s view extension point (named \"org.eclipse.ui.views\"). For example, the plug-in\'s XML markup might contain: <extension point=\"org.eclipse.ui.views\"> <view id=\"com.example.myplugin.view\" name=\"My View\" class=\"com.example.myplugin.MyView\" icon=\"images/eview.gif\" /> </extension> where com.example.myplugin.MyView is the name of the ViewPart subclass. Subclasses must implement the following methods: createPartControl - to create the view\'s controls setFocus - to accept focus Subclasses may extend or reimplement the following methods as required: setInitializationData - extend to provide additional initialization when view extension is instantiated init(IWorkbenchPartSite) - extend to provide additional initialization when view is assigned its site dispose - extend to provide additional cleanup getAdapter - reimplement to make their view adaptable '
28, 'org.eclipse.swt.widgets.Label', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/widgets/Label.html', 'Implementers of Drawable can have a graphics context (GC) created for them, and then they can be drawn on by sending messages to their associated GC. SWT images, and device objects such as the Display device and the Printer device, are drawables. IMPORTANT: This interface is not part of the SWT public API. It is marked public only so that it can be shared within the packages provided by SWT. It should never be referenced from application code. See Also: Device, Image, GC extends Control Instances of this class represent a non-selectable user interface object that displays a string or image. When SEPARATOR is specified, displays a single vertical or horizontal line. Shadow styles are hints and may not be honored by the platform. To create a separator label with the default shadow style for the platform, do not specify a shadow style. Styles: SEPARATOR, HORIZONTAL, VERTICAL SHADOW_IN, SHADOW_OUT, SHADOW_NONE CENTER, LEFT, RIGHT, WRAP Events: (none) Note: Only one of SHADOW_IN, SHADOW_OUT and SHADOW_NONE may be specified. SHADOW_NONE is a HINT. Only one of HORIZONTAL and VERTICAL may be specified. Only one of CENTER, LEFT and RIGHT may be specified. IMPORTANT: This class is not intended to be subclassed. See Also: Label snippets, SWT Example: ControlExample, Sample code and further information Restriction: This class is not intended to be subclassed by clients. '
29, 'org.eclipse.ui.IPerspectiveFactory', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/IPerspectiveFactory.html', 'A perspective factory generates the initial page layout and visible action set for a page. When a new page is created in the workbench a perspective is used to define the initial page layout. If this is a predefined perspective (based on an extension to the workbench\'s perspective extension point) an IPerspectiveFactory is used to define the initial page layout. The factory for the perspective is created and passed an IPageLayout where views can be added. The default layout consists of the editor area with no additional views. Additional views are added to the layout using the editor area as the initial point of reference. The factory is used only briefly while a new page is created; then discarded. To define a perspective clients should implement this interface and include the name of their class in an extension to the workbench\'s perspective extension point (named \"org.eclipse.ui.perspectives\"). For example, the plug-in\'s XML markup might contain: <extension point=\"org.eclipse.ui.perspectives\"> <perspective id=\"com.example.javaplugin.perspective\" name=\"Java\" class=\"com.example.javaplugin.JavaPerspective\"> </perspective> </extension> Example of populating a page with standard workbench views: public void createInitialLayout(IPageLayout layout) { // Get the editor area. String editorArea = layout.getEditorArea(); // Top left: Resource Navigator view and Bookmarks view placeholder IFolderLayout topLeft = layout.createFolder(\"topLeft\", IPageLayout.LEFT, 0.25f, editorArea); topLeft.addView(IPageLayout.ID_RES_NAV); topLeft.addPlaceholder(IPageLayout.ID_BOOKMARKS); // Bottom left: Outline view and Property Sheet view IFolderLayout bottomLeft = layout.createFolder(\"bottomLeft\", IPageLayout.BOTTOM, 0.50f, \"topLeft\"); bottomLeft.addView(IPageLayout.ID_OUTLINE); bottomLeft.addView(IPageLayout.ID_PROP_SHEET); // Bottom right: Task List view layout.addView(IPageLayout.ID_TASK_LIST, IPageLayout.BOTTOM, 0.66f, editorArea); } Within the workbench a user may override the visible views, layout and action sets of a predefined perspective to create a custom perspective. In such cases the layout is persisted by the workbench and the factory is not used. '
30, 'org.eclipse.ui.IPageLayout', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/IPageLayout.html', 'A page layout defines the initial layout for a perspective within a page in a workbench window. This interface is not intended to be implemented by clients. When a perspective is opened, it creates a new page layout with a single editor area. This layout is then passed to the perspective factory (implementation of IPerspectiveFactory.createInitialLayout(IPageLayout)) where additional views and other content can be added, using the existing editor area as the initial point of reference. In some cases, multiple instances of a particular view may need to be added to the same layout. These are disambiguated using a secondary id. In layout methods taking a view id, the id can have the compound form: primaryId [\':\' secondaryId]. If a secondary id is given, the view must allow multiple instances by having specified allowMultiple=\"true\" in its extension. View placeholders may also have a secondary id. Wildcards are permitted in placeholder ids (but not regular view ids). \'*\' matches any substring, \'?\' matches any single character. Wildcards can be specified for the primary id, the secondary id, or both. For example, the placeholder \"someView:*\" will match any occurrence of the view that has primary id \"someView\" and that also has some non-null secondary id. Note that this placeholder will not match the view if it has no secondary id, since the compound id in this case is simply \"someView\". Example of populating a layout with standard workbench views: IPageLayout layout = ... // Get the editor area. String editorArea = layout.getEditorArea(); // Top left: Project Explorer view and Bookmarks view placeholder IFolderLayout topLeft = layout.createFolder(\"topLeft\", IPageLayout.LEFT, 0.25f, editorArea); topLeft.addView(IPageLayout.ID_PROJECT_EXPLORER); topLeft.addPlaceholder(IPageLayout.ID_BOOKMARKS); // Bottom left: Outline view and Property Sheet view IFolderLayout bottomLeft = layout.createFolder(\"bottomLeft\", IPageLayout.BOTTOM, 0.50f, \"topLeft\"); bottomLeft.addView(IPageLayout.ID_OUTLINE); bottomLeft.addView(IPageLayout.ID_PROP_SHEET); // Bottom right: Task List view layout.addView(IPageLayout.ID_TASK_LIST, IPageLayout.BOTTOM, 0.66f, editorArea); Restriction: This interface is not intended to be implemented by clients. '
31, 'org.eclipse.e4.core.contexts.IEclipseContext', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/e4/core/contexts/IEclipseContext.html', 'A context is used to isolate application code from its dependencies on an application framework or container. This helps avoid building in dependencies on a specific framework that inhibit reuse of the application code. Fundamentally a context supplies values (either data objects or services), and allows values to be set. Typically a client will be provided values from a context through injection, removing the need for clients to even depend on this interface. While a context appears superficially to be a Map, it may in fact compute values for requested keys dynamically rather than simply retrieving a stored value. Contexts may have a parent context, and may delegate lookup of a value to their parent. Whether a value is computed or stored in this context or a parent context is an implementation detail that clients need not be concerned with. The content of parent contexts cannot be modified by a child context. Contexts may have child contexts. Children inherit context values from their parent as described earlier. At any time, one of the children may be considered the active child. The interpretation of what active means depends on the domain in which the context is used. Like maps, values are stored in the context based on keys. Two types of keys can be used: strings and classes. When classes are used to access objects in the context, keys are calculated based on the class name, so the value stored for the class String can be retrieved using the key value of \"java.lang.String\". Since: 1.3 Restriction: This interface is not intended to be implemented by clients. Restriction: This interface is not intended to be extended by clients. '
32, 'org.eclipse.e4.ui.model.application.ui.basic.MWindow', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/e4/ui/model/application/ui/basic/MWindow.html', ' A representation of the model object \'Element\'. This is the root element for all UI Model elements, defining attribtues common to every element; the element\'s id as well as three general storage elements: Tags: This is a set of strings which can be used to stereotype a particular element. Tags may be specified in element searches and can also be referred to in the CSS styling definition. PersistedState: A string to string map used to store information that nneds to be persisted between sessions. TransientData: A string to object map which can be used to store runtime data relevant to a particular model element. Since: 1.0 The following features are supported: Element Id Persisted State Tags Contributor URI Transient Data A representation of the model object \'Bindings\'. Mixin interface that lists MBindingContexts that should be active when this object is active. Example values: org.eclipse.ui.contexts.dialog, org.eclipse.ui.contexts.window Since: 1.0 The following features are supported: Binding Contexts A representation of the model object \'Context\'. This class is mixed into a UI element when that element is expected to participate in the Dependency Injection context hierarchy. The context life-cycle matches that of the rendered element it belongs to. It\'s automatically created when the element is rendered and disposed when the element is unrendered. Since: 1.0 The following features are supported: Context Variables Properties A representation of the model object \'Handler Container\'. This provides a container in which to store lists of Handlers. Since: 1.0 The following features are supported: Handlers A representation of the model object \'Snippet Container\'. This provides a collection of model fragments that can be subsequently cloned and inserterd into the model using the EModelService. For example saving a customized Perspective will create a clone and store it in this container. Since: 1.0 The following features are supported: Snippets extends MApplicationElement A representation of the model object \'UI Element\'. This is the base mix-in shared by all model elements that can be rendered into the UI presentation of the application. Its main job is to manage the bindings between the concrete element and the UI \'widget\' representing it in the UI. Since: 1.0 The following features are supported: Widget Renderer To Be Rendered On Top Visible Parent Container Data Cur Shared Ref Visible When Accessibility Phrase A representation of the model object \'UI Label\'. This is a mix in that will be used for UI Elements that are capable of showing label information in the GUI (e.g. Parts, Menus / Toolbars, Persepectives...) Since: 1.0 The following features are supported: Label Icon URI Tooltip extends MElementContainer<MWindowElement>, MUILabel, MContext, MHandlerContainer, MBindings, MSnippetContainer A representation of the model object \'Window\'. This is the concrete class representing a bare bones window in the UI Model. Unless specifically desired it\'s likely better to use the TrimmedWindow instead. Since: 1.0 The following features are supported: Main Menu X Y Width Height Windows Shared Elements '
33, 'org.eclipse.e4.ui.model.application.MApplication', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/e4/ui/model/application/MApplication.html', ' A representation of the model object \'Element\'. This is the root element for all UI Model elements, defining attribtues common to every element; the element\'s id as well as three general storage elements: Tags: This is a set of strings which can be used to stereotype a particular element. Tags may be specified in element searches and can also be referred to in the CSS styling definition. PersistedState: A string to string map used to store information that nneds to be persisted between sessions. TransientData: A string to object map which can be used to store runtime data relevant to a particular model element. Since: 1.0 The following features are supported: Element Id Persisted State Tags Contributor URI Transient Data A representation of the model object \'Bindings\'. Mixin interface that lists MBindingContexts that should be active when this object is active. Example values: org.eclipse.ui.contexts.dialog, org.eclipse.ui.contexts.window Since: 1.0 The following features are supported: Binding Contexts A representation of the model object \'Binding Table Container\'. This type contains the list of binding \'tables\', representing the various sets of bindings based on the applicaiton\'s current running \'context\'. Here the \'context\' represents the applicaiton\'s UI state (i.e. whenther a Dialog is open...). Since: 1.0 The following features are supported: Binding Tables Root Context A representation of the model object \'Context\'. This class is mixed into a UI element when that element is expected to participate in the Dependency Injection context hierarchy. The context life-cycle matches that of the rendered element it belongs to. It\'s automatically created when the element is rendered and disposed when the element is unrendered. Since: 1.0 The following features are supported: Context Variables Properties A representation of the model object \'Handler Container\'. This provides a container in which to store lists of Handlers. Since: 1.0 The following features are supported: Handlers A representation of the model object \'Contributions\'. Provisional for 4.3. This is a container aggregating the menu contributions to be applied to menus. Since: 1.0 The following features are supported: Menu Contributions Restriction: This interface is not intended to be referenced by clients. A representation of the model object \'Part Descriptor Container\'. A type specific collection of PartDescriptors. Since: 1.0 The following features are supported: Descriptors A representation of the model object \'Snippet Container\'. This provides a collection of model fragments that can be subsequently cloned and inserterd into the model using the EModelService. For example saving a customized Perspective will create a clone and store it in this container. Since: 1.0 The following features are supported: Snippets A representation of the model object \'Tool Bar Contributions\'. Provisional for 4.3. This is a container aggregating the toolbar contributions to be applied to existing toolbars. Since: 1.0 The following features are supported: Tool Bar Contributions Restriction: This interface is not intended to be referenced by clients. A representation of the model object \'Trim Contributions\'. Provisional for 4.3. This is a container aggregating the trim bar contributions to be applied. Since: 1.0 The following features are supported: Trim Contributions Restriction: This interface is not intended to be referenced by clients. extends MApplicationElement A representation of the model object \'UI Element\'. This is the base mix-in shared by all model elements that can be rendered into the UI presentation of the application. Its main job is to manage the bindings between the concrete element and the UI \'widget\' representing it in the UI. Since: 1.0 The following features are supported: Widget Renderer To Be Rendered On Top Visible Parent Container Data Cur Shared Ref Visible When Accessibility Phrase extends MElementContainer<MWindow>, MContext, MHandlerContainer, MBindingTableContainer, MPartDescriptorContainer, MBindings, MMenuContributions, MToolBarContributions, MTrimContributions, MSnippetContainer A representation of the model object \'Application\'. The MApplication acts as the root of the UI Model. It\'s children are the MWindows representing the UI for this application. It also owns the application\'s context (which is hooked to the OSGI context, allowing access not only to its own runtime information but also to any registered OSGI service. It also owns a number of caches which, while independent of the UI itself are used by the appliecation to populate new windows or to define state that is epected to be the same for all windows: Keybindings, Handlers, Commands Part Descriptors (to support a \'Show View\' dialog...) Snippets of model (such as saved perspectives...) Since: 1.0 The following features are supported: Commands Addons Categories '
34, 'org.eclipse.e4.ui.model.application.ui.basic.MPartSashContainer', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/e4/ui/model/application/ui/basic/MPartSashContainer.html', ' A representation of the model object \'Element\'. This is the root element for all UI Model elements, defining attribtues common to every element; the element\'s id as well as three general storage elements: Tags: This is a set of strings which can be used to stereotype a particular element. Tags may be specified in element searches and can also be referred to in the CSS styling definition. PersistedState: A string to string map used to store information that nneds to be persisted between sessions. TransientData: A string to object map which can be used to store runtime data relevant to a particular model element. Since: 1.0 The following features are supported: Element Id Persisted State Tags Contributor URI Transient Data extends MUIElement A representation of the model object \'Part Sash Container Element\'. A class to be mixed in to any element that should be allowed to be added to a PartSashContainer. Since a PartSashContainer is itself a PartSashContainerElement we can defined nested \'trees\' of sash containment. Since: 1.0 extends MApplicationElement A representation of the model object \'UI Element\'. This is the base mix-in shared by all model elements that can be rendered into the UI presentation of the application. Its main job is to manage the bindings between the concrete element and the UI \'widget\' representing it in the UI. Since: 1.0 The following features are supported: Widget Renderer To Be Rendered On Top Visible Parent Container Data Cur Shared Ref Visible When Accessibility Phrase extends MUIElement A representation of the model object \'Window Element\'. A class to be mixed in to any element that should be allowed to be added to a Window. Since: 1.0 extends MGenericTile<MPartSashContainerElement>, MPartSashContainerElement, MWindowElement A representation of the model object \'Part Sash Container\'. This is the concrete class representing sashed containment in the UI Model. This type is recursive, allowing the creation of a tree of sashes whose leafs are Parts. Since: 1.0 '
35, 'org.eclipse.e4.ui.model.application.ui.basic.MPartStack', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/e4/ui/model/application/ui/basic/MPartStack.html', ' A representation of the model object \'Element\'. This is the root element for all UI Model elements, defining attribtues common to every element; the element\'s id as well as three general storage elements: Tags: This is a set of strings which can be used to stereotype a particular element. Tags may be specified in element searches and can also be referred to in the CSS styling definition. PersistedState: A string to string map used to store information that nneds to be persisted between sessions. TransientData: A string to object map which can be used to store runtime data relevant to a particular model element. Since: 1.0 The following features are supported: Element Id Persisted State Tags Contributor URI Transient Data extends MUIElement A representation of the model object \'Part Sash Container Element\'. A class to be mixed in to any element that should be allowed to be added to a PartSashContainer. Since a PartSashContainer is itself a PartSashContainerElement we can defined nested \'trees\' of sash containment. Since: 1.0 extends MApplicationElement A representation of the model object \'UI Element\'. This is the base mix-in shared by all model elements that can be rendered into the UI presentation of the application. Its main job is to manage the bindings between the concrete element and the UI \'widget\' representing it in the UI. Since: 1.0 The following features are supported: Widget Renderer To Be Rendered On Top Visible Parent Container Data Cur Shared Ref Visible When Accessibility Phrase extends MUIElement A representation of the model object \'Window Element\'. A class to be mixed in to any element that should be allowed to be added to a Window. Since: 1.0 extends MGenericStack<MStackElement>, MPartSashContainerElement, MWindowElement A representation of the model object \'Part Stack\'. This is the concrete class representing a stack of Parts in the UI Model. Since: 1.0 '
36, 'org.eclipse.e4.ui.model.application.ui.basic.MPart', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/e4/ui/model/application/ui/basic/MPart.html', ' A representation of the model object \'Element\'. This is the root element for all UI Model elements, defining attribtues common to every element; the element\'s id as well as three general storage elements: Tags: This is a set of strings which can be used to stereotype a particular element. Tags may be specified in element searches and can also be referred to in the CSS styling definition. PersistedState: A string to string map used to store information that nneds to be persisted between sessions. TransientData: A string to object map which can be used to store runtime data relevant to a particular model element. Since: 1.0 The following features are supported: Element Id Persisted State Tags Contributor URI Transient Data A representation of the model object \'Bindings\'. Mixin interface that lists MBindingContexts that should be active when this object is active. Example values: org.eclipse.ui.contexts.dialog, org.eclipse.ui.contexts.window Since: 1.0 The following features are supported: Binding Contexts A representation of the model object \'Context\'. This class is mixed into a UI element when that element is expected to participate in the Dependency Injection context hierarchy. The context life-cycle matches that of the rendered element it belongs to. It\'s automatically created when the element is rendered and disposed when the element is unrendered. Since: 1.0 The following features are supported: Context Variables Properties extends MApplicationElement A representation of the model object \'Contribution\'. MContribution is a mix-in class used by concrete elements such as Parts to define the location of the client supplied class implementing the specific logic needed. Since: 1.0 The following features are supported: Contribution URI Object A representation of the model object \'Dirtyable\'. This class should be mixed into any UI element that should participate in the dirty / save handling. Parts are the most likely scenario for this but it exists as a mix-in to allow for future model extensions. Since: 1.0 The following features are supported: Dirty A representation of the model object \'Handler Container\'. This provides a container in which to store lists of Handlers. Since: 1.0 The following features are supported: Handlers extends MUIElement A representation of the model object \'Part Sash Container Element\'. A class to be mixed in to any element that should be allowed to be added to a PartSashContainer. Since a PartSashContainer is itself a PartSashContainerElement we can defined nested \'trees\' of sash containment. Since: 1.0 extends MUIElement A representation of the model object \'Stack Element\'. A class to be mixed in to any element that should be allowed to be added to a PartStack. Since: 1.0 extends MApplicationElement A representation of the model object \'UI Element\'. This is the base mix-in shared by all model elements that can be rendered into the UI presentation of the application. Its main job is to manage the bindings between the concrete element and the UI \'widget\' representing it in the UI. Since: 1.0 The following features are supported: Widget Renderer To Be Rendered On Top Visible Parent Container Data Cur Shared Ref Visible When Accessibility Phrase A representation of the model object \'UI Label\'. This is a mix in that will be used for UI Elements that are capable of showing label information in the GUI (e.g. Parts, Menus / Toolbars, Persepectives...) Since: 1.0 The following features are supported: Label Icon URI Tooltip extends MUIElement A representation of the model object \'Window Element\'. A class to be mixed in to any element that should be allowed to be added to a Window. Since: 1.0 extends MUIElement, MPartSashContainerElement, MStackElement, MContribution, MContext, MUILabel, MHandlerContainer, MDirtyable, MBindings, MWindowElement A representation of the model object \'Part\'. This a concrete class representing the core UI functionality within a Window. It\'s what used to be a View / Editor in Eclipse 3. Since: 1.0 The following features are supported: Menus Toolbar Closeable Description '
37, 'org.eclipse.swt.custom.CTabFolder', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/custom/CTabFolder.html', 'Implementers of Drawable can have a graphics context (GC) created for them, and then they can be drawn on by sending messages to their associated GC. SWT images, and device objects such as the Display device and the Printer device, are drawables. IMPORTANT: This interface is not part of the SWT public API. It is marked public only so that it can be shared within the packages provided by SWT. It should never be referenced from application code. See Also: Device, Image, GC extends Composite Instances of this class implement the notebook user interface metaphor. It allows the user to select a notebook page from set of pages. The item children that may be added to instances of this class must be of type CTabItem. Control children are created and then set into a tab item using CTabItem#setControl. Note that although this class is a subclass of Composite, it does not make sense to set a layout on it. Styles: CLOSE, TOP, BOTTOM, FLAT, BORDER, SINGLE, MULTI Events: Selection \"CTabFolder2\" Note: Only one of the styles TOP and BOTTOM may be specified. IMPORTANT: This class is not intended to be subclassed. See Also: CTabFolder, CTabItem snippets, SWT Example: CustomControlExample, Sample code and further information Restriction: This class is not intended to be subclassed by clients. '
38, 'org.eclipse.swt.custom.CTabItem', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/custom/CTabItem.html', 'extends Item Instances of this class represent a selectable user interface object that represent a page in a notebook widget. Styles: SWT.CLOSE Events: (none) IMPORTANT: This class is not intended to be subclassed. See Also: CTabFolder, CTabItem snippets, Sample code and further information Restriction: This class is not intended to be subclassed by clients. '
39, 'org.eclipse.e4.ui.model.application.ui.basic.MTrimmedWindow', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/e4/ui/model/application/ui/basic/MTrimmedWindow.html', ' A representation of the model object \'Element\'. This is the root element for all UI Model elements, defining attribtues common to every element; the element\'s id as well as three general storage elements: Tags: This is a set of strings which can be used to stereotype a particular element. Tags may be specified in element searches and can also be referred to in the CSS styling definition. PersistedState: A string to string map used to store information that nneds to be persisted between sessions. TransientData: A string to object map which can be used to store runtime data relevant to a particular model element. Since: 1.0 The following features are supported: Element Id Persisted State Tags Contributor URI Transient Data A representation of the model object \'Bindings\'. Mixin interface that lists MBindingContexts that should be active when this object is active. Example values: org.eclipse.ui.contexts.dialog, org.eclipse.ui.contexts.window Since: 1.0 The following features are supported: Binding Contexts A representation of the model object \'Context\'. This class is mixed into a UI element when that element is expected to participate in the Dependency Injection context hierarchy. The context life-cycle matches that of the rendered element it belongs to. It\'s automatically created when the element is rendered and disposed when the element is unrendered. Since: 1.0 The following features are supported: Context Variables Properties A representation of the model object \'Handler Container\'. This provides a container in which to store lists of Handlers. Since: 1.0 The following features are supported: Handlers A representation of the model object \'Snippet Container\'. This provides a collection of model fragments that can be subsequently cloned and inserterd into the model using the EModelService. For example saving a customized Perspective will create a clone and store it in this container. Since: 1.0 The following features are supported: Snippets extends MApplicationElement A representation of the model object \'UI Element\'. This is the base mix-in shared by all model elements that can be rendered into the UI presentation of the application. Its main job is to manage the bindings between the concrete element and the UI \'widget\' representing it in the UI. Since: 1.0 The following features are supported: Widget Renderer To Be Rendered On Top Visible Parent Container Data Cur Shared Ref Visible When Accessibility Phrase A representation of the model object \'UI Label\'. This is a mix in that will be used for UI Elements that are capable of showing label information in the GUI (e.g. Parts, Menus / Toolbars, Persepectives...) Since: 1.0 The following features are supported: Label Icon URI Tooltip A representation of the model object \'Element\'. This is the root element for all UI Model elements, defining attribtues common to every element; the element\'s id as well as three general storage elements: Tags: This is a set of strings which can be used to stereotype a particular element. Tags may be specified in element searches and can also be referred to in the CSS styling definition. PersistedState: A string to string map used to store information that nneds to be persisted between sessions. TransientData: A string to object map which can be used to store runtime data relevant to a particular model element. Since: 1.0 The following features are supported: Element Id Persisted State Tags Contributor URI Transient Data A representation of the model object \'Bindings\'. Mixin interface that lists MBindingContexts that should be active when this object is active. Example values: org.eclipse.ui.contexts.dialog, org.eclipse.ui.contexts.window Since: 1.0 The following features are supported: Binding Contexts A representation of the model object \'Context\'. This class is mixed into a UI element when that element is expected to participate in the Dependency Injection context hierarchy. The context life-cycle matches that of the rendered element it belongs to. It\'s automatically created when the element is rendered and disposed when the element is unrendered. Since: 1.0 The following features are supported: Context Variables Properties A representation of the model object \'Handler Container\'. This provides a container in which to store lists of Handlers. Since: 1.0 The following features are supported: Handlers A representation of the model object \'Snippet Container\'. This provides a collection of model fragments that can be subsequently cloned and inserterd into the model using the EModelService. For example saving a customized Perspective will create a clone and store it in this container. Since: 1.0 The following features are supported: Snippets extends MApplicationElement A representation of the model object \'UI Element\'. This is the base mix-in shared by all model elements that can be rendered into the UI presentation of the application. Its main job is to manage the bindings between the concrete element and the UI \'widget\' representing it in the UI. Since: 1.0 The following features are supported: Widget Renderer To Be Rendered On Top Visible Parent Container Data Cur Shared Ref Visible When Accessibility Phrase A representation of the model object \'UI Label\'. This is a mix in that will be used for UI Elements that are capable of showing label information in the GUI (e.g. Parts, Menus / Toolbars, Persepectives...) Since: 1.0 The following features are supported: Label Icon URI Tooltip extends MElementContainer<MWindowElement>, MUILabel, MContext, MHandlerContainer, MBindings, MSnippetContainer A representation of the model object \'Window\'. This is the concrete class representing a bare bones window in the UI Model. Unless specifically desired it\'s likely better to use the TrimmedWindow instead. Since: 1.0 The following features are supported: Main Menu X Y Width Height Windows Shared Elements extends MWindow A representation of the model object \'Trimmed Window\'. A subclass of Window that also supports TrimBars on its edges. Since: 1.0 The following features are supported: Trim Bars '
40, 'org.eclipse.e4.ui.model.application.ui.basic.MTrimBar', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/e4/ui/model/application/ui/basic/MTrimBar.html', ' A representation of the model object \'Element\'. This is the root element for all UI Model elements, defining attribtues common to every element; the element\'s id as well as three general storage elements: Tags: This is a set of strings which can be used to stereotype a particular element. Tags may be specified in element searches and can also be referred to in the CSS styling definition. PersistedState: A string to string map used to store information that nneds to be persisted between sessions. TransientData: A string to object map which can be used to store runtime data relevant to a particular model element. Since: 1.0 The following features are supported: Element Id Persisted State Tags Contributor URI Transient Data extends MApplicationElement A representation of the model object \'UI Element\'. This is the base mix-in shared by all model elements that can be rendered into the UI presentation of the application. Its main job is to manage the bindings between the concrete element and the UI \'widget\' representing it in the UI. Since: 1.0 The following features are supported: Widget Renderer To Be Rendered On Top Visible Parent Container Data Cur Shared Ref Visible When Accessibility Phrase extends MGenericTrimContainer<MTrimElement>, MUIElement A representation of the model object \'Trim Bar\'. This is a concrete class representing the trim along a Window\'s edge. Since: 1.0 The following features are supported: Pending Cleanup '
41, 'org.eclipse.e4.ui.model.application.ui.menu.MToolBar', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/e4/ui/model/application/ui/menu/MToolBar.html', ' A representation of the model object \'Element\'. This is the root element for all UI Model elements, defining attribtues common to every element; the element\'s id as well as three general storage elements: Tags: This is a set of strings which can be used to stereotype a particular element. Tags may be specified in element searches and can also be referred to in the CSS styling definition. PersistedState: A string to string map used to store information that nneds to be persisted between sessions. TransientData: A string to object map which can be used to store runtime data relevant to a particular model element. Since: 1.0 The following features are supported: Element Id Persisted State Tags Contributor URI Transient Data extends MUIElement A representation of the model object \'Trim Element\'. A class to be mixed in to any element that should be allowed to be added to a TrimBar. Since: 1.0 extends MApplicationElement A representation of the model object \'UI Element\'. This is the base mix-in shared by all model elements that can be rendered into the UI presentation of the application. Its main job is to manage the bindings between the concrete element and the UI \'widget\' representing it in the UI. Since: 1.0 The following features are supported: Widget Renderer To Be Rendered On Top Visible Parent Container Data Cur Shared Ref Visible When Accessibility Phrase extends MElementContainer<MToolBarElement>, MTrimElement A representation of the model object \'Tool Bar\'. This is the concrete class representing a Toolbar in the UI Model. Since: 1.0 '
42, 'org.eclipse.e4.ui.model.application.ui.menu.MToolItem', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/e4/ui/model/application/ui/menu/MToolItem.html', ' A representation of the model object \'Element\'. This is the root element for all UI Model elements, defining attribtues common to every element; the element\'s id as well as three general storage elements: Tags: This is a set of strings which can be used to stereotype a particular element. Tags may be specified in element searches and can also be referred to in the CSS styling definition. PersistedState: A string to string map used to store information that nneds to be persisted between sessions. TransientData: A string to object map which can be used to store runtime data relevant to a particular model element. Since: 1.0 The following features are supported: Element Id Persisted State Tags Contributor URI Transient Data extends MUIElement A representation of the model object \'Tool Bar Element\'. This is a placeholder class mixed in to any other type that can be added to a Toolbar. Since: 1.0 extends MApplicationElement A representation of the model object \'UI Element\'. This is the base mix-in shared by all model elements that can be rendered into the UI presentation of the application. Its main job is to manage the bindings between the concrete element and the UI \'widget\' representing it in the UI. Since: 1.0 The following features are supported: Widget Renderer To Be Rendered On Top Visible Parent Container Data Cur Shared Ref Visible When Accessibility Phrase A representation of the model object \'UI Label\'. This is a mix in that will be used for UI Elements that are capable of showing label information in the GUI (e.g. Parts, Menus / Toolbars, Persepectives...) Since: 1.0 The following features are supported: Label Icon URI Tooltip extends MItem, MToolBarElement A representation of the model object \'Tool Item\'. This is the base type for both Direct and Handled tool items. Since: 1.0 The following features are supported: Menu '
43, 'org.eclipse.swt.widgets.ToolItem', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/widgets/ToolItem.html', 'extends Item Instances of this class represent a selectable user interface object that represents a button in a tool bar. Styles: PUSH, CHECK, RADIO, SEPARATOR, DROP_DOWN Events: Selection Note: Only one of the styles CHECK, PUSH, RADIO, SEPARATOR and DROP_DOWN may be specified. IMPORTANT: This class is not intended to be subclassed. See Also: ToolBar, ToolItem snippets, Sample code and further information Restriction: This class is not intended to be subclassed by clients. '
44, 'org.eclipse.swt.widgets.Event', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/widgets/Event.html', 'extends Object Instances of this class provide a description of a particular event which occurred within SWT. The SWT untyped listener API uses these instances for all event dispatching. Note: For a given event, only the fields which are appropriate will be filled in. The contents of the fields which are not used by the event are unspecified. See Also: Listener, TypedEvent, SWT Example: ControlExample, Listeners, Sample code and further information '
45, 'org.eclipse.e4.ui.workbench.modeling.EPartService', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/e4/ui/workbench/modeling/EPartService.html', 'The part service provides clients with the functionalities of showing and hiding parts. Part events can also be tracked via the part service. It is expected that any methods that are exposed by this service that takes an MPart as an argument be a part that is actually being managed by this service. Since: 1.0 Restriction: This interface is not intended to be implemented by clients. '
46, 'org.eclipse.e4.ui.services.ContextServiceAddon', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/e4/ui/services/ContextServiceAddon.html', 'extends Object Since: 1.0 Restriction: This class is not intended to be referenced by clients. Restriction: This class is not intended to be instantiated by clients. '
47, 'org.eclipse.e4.core.contexts.ContextInjectionFactory', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/e4/core/contexts/ContextInjectionFactory.html', 'extends Object An injection factory is used to inject data and services from a context into a domain object. The injection will try to find fields and methods in the user objects that correspond to the names of the services present in the context. Subsequent changes to the context after injection will cause the affected items to be re-injected into the object. Thus the object will remain synchronized with the context once it has been injected. If annotations are supported by the runtime, matching of methods and fields to be injected is also performed using the annotations defined in packages javax.inject and org.eclipse.e4.core.di.annotations. The injection of values is generally done as a number of calls. User objects that want to finalize the injected data (for instance, to perform calculations based on multiple injected values) can place such calculations in a method with the javax.annotation.PostConstruct annotation. When injecting values, all fields are injected prior to injection of methods. When values are removed from the context or the context is disposed, injection of null values occurs in the reverse order: methods and then fields. As a result, injection methods can safely make use of injected field values. The order in which methods are injected is undefined, so injection methods should not rely on other injection methods having been run already. Methods and field on superclasses are injected before methods in fields on the subclasses. When a context is disposed, the injection factory will attempt to notify all injected objects by calling methods with the javax.annotation.PreDestroy annotation. This class is not intended to be extended by clients. Since: 1.3 Restriction: This class is not intended to be instantiated by clients. '
48, 'org.eclipse.e4.ui.services.EContextService', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/e4/ui/services/EContextService.html', ' Since: 1.0 Restriction: This interface is not intended to be implemented by clients. '
49, 'org.eclipse.core.commands.contexts.Context', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/commands/contexts/Context.html', ' An object that is unique identifiable based on the combination of its class and its identifier. Since: 3.2 See Also: HandleObject extends NamedHandleObject implements Comparable A context is an answer to the question \"when\". Other services can listen for the activation and deactivation of contexts, and change their own state in response to these changes. For example, Eclipse\'s key binding service listens to context activation and deactivation to determine which key bindings should be active. An instance of this interface can be obtained from an instance of ContextManager for any identifier, whether or not an context with that identifier is defined in the extension registry. The handle-based nature of this API allows it to work well with runtime plugin activation and deactivation. If a context is defined, that means that its corresponding plug-in is active. If the plug-in is then deactivated, the context will still exist but it will be undefined. An attempts to use an undefined context will result in a NotDefinedException being thrown. This class is not intended to be extended by clients. Since: 3.1 See Also: ContextManager '
50, 'org.eclipse.e4.core.contexts.EclipseContextFactory', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/e4/core/contexts/EclipseContextFactory.html', 'extends Object This factory is used to create new context instances. Since: 1.3 See Also: IEclipseContext '
51, 'org.eclipse.e4.ui.di.UISynchronize', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/e4/ui/di/UISynchronize.html', 'extends Object Widget toolkit abstract to synchronize back into the UI-Thread from other threads Since: 1.0 Restriction: This class is not intended to be subclassed by clients. '
52, 'org.eclipse.core.databinding.observable.Realm', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/databinding/observable/Realm.html', 'extends Object A realm defines a context from which objects implementing IObservable must be accessed, and on which these objects will notify their listeners. To bridge between observables from different realms, subclasses of Binding can be used. A block of code is said to be executing within a realm if calling isCurrent() from that block returns true. Code reached by calling methods from that block will execute within the same realm, with the exception of methods on this class that can be used to execute code within a specific realm. Clients can use syncExec(Runnable), asyncExec(Runnable), or exec(Runnable) to execute a runnable within this realm. Note that using syncExec(Runnable) can lead to deadlocks and should be avoided if the current thread holds any locks. It is instructive to think about possible implementations of Realm: It can be based on executing on a designated thread such as a UI thread, or based on holding a lock. In the former case, calling syncExec on a realm that is not the current realm will execute the given runnable on a different thread (the designated thread). In the latter case, calling syncExec may execute the given runnable on the calling thread, but calling asyncExec(Runnable) will execute the given runnable on a different thread. Therefore, no assumptions can be made about the thread that will execute arguments to asyncExec(Runnable), syncExec(Runnable), or exec(Runnable). It is possible that a block of code is executing within more than one realm. This can happen for implementations of Realm that are based on holding a lock but don\'t use a separate thread to run runnables given to syncExec(Runnable). Realm implementations of this kind should be appropriately documented because it increases the opportunity for deadlock. Some implementations of IObservable provide constructors which do not take a Realm argument and are specified to create the observable instance with the current default realm. The default realm can be set for the currently executing thread by using runWithDefault(Realm, Runnable). Note that the default realm does not have to be the current realm. Subclasses must override at least one of asyncExec()/syncExec(). For realms based on a designated thread, it may be easier to implement asyncExec and keep the default implementation of syncExec. For realms based on holding a lock, it may be easier to implement syncExec and keep the default implementation of asyncExec. Since: 1.0 See Also: IObservable '
53, 'org.eclipse.core.commands.ParameterizedCommand', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/commands/ParameterizedCommand.html', 'extends Object implements Comparable A command that has had one or more of its parameters specified. This class serves as a utility class for developers that need to manipulate commands with parameters. It handles the behaviour of generating a parameter map and a human-readable name. Since: 3.1 '
54, 'org.eclipse.core.commands.Command', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/commands/Command.html', ' An object that is unique identifiable based on the combination of its class and its identifier. Since: 3.2 See Also: HandleObject An object that holds zero or more state objects. This state information can be shared between different instances of IObjectWithState. Clients may implement, but must not extend this interface. Since: 3.2 See Also: AbstractHandlerWithState extends NamedHandleObject implements Comparable A command is an abstract representation for some semantic behaviour. It is not the actual implementation of this behaviour, nor is it the visual appearance of this behaviour in the user interface. Instead, it is a bridge between the two. The concept of a command is based on the command design pattern. The notable difference is how the command delegates responsibility for execution. Rather than allowing concrete subclasses, it uses a handler mechanism (see the handlers extension point). This provides another level of indirection. A command will exist in two states: defined and undefined. A command is defined if it is declared in the XML of a resolved plug-in. If the plug-in is unloaded or the command is simply not declared, then it is undefined. Trying to reference an undefined command will succeed, but trying to access any of its functionality will fail with a NotDefinedException. If you need to know when a command changes from defined to undefined (or vice versa), then attach a command listener. Commands are mutable and will change as their definition changes. Since: 3.1 '
55, 'org.eclipse.core.commands.Category', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/commands/Category.html', ' An object that is unique identifiable based on the combination of its class and its identifier. Since: 3.2 See Also: HandleObject extends NamedHandleObject A logical group for a set of commands. A command belongs to exactly one category. The category has no functional effect, but may be used in graphical tools that want to group the set of commands somehow. Since: 3.1 '
56, 'org.eclipse.e4.ui.services.IStylingEngine', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/e4/ui/services/IStylingEngine.html', ' Since: 1.0 Restriction: This interface is not intended to be implemented by clients. Restriction: This interface is not intended to be referenced by clients. '
57, 'org.eclipse.e4.ui.model.application.ui.basic.MBasicFactory', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/e4/ui/model/application/ui/basic/MBasicFactory.html', ' The Factory for the model. It provides a create method for each non-abstract class of the model. Since: 1.0 '
58, 'org.eclipse.swt.widgets.Button', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/widgets/Button.html', 'Implementers of Drawable can have a graphics context (GC) created for them, and then they can be drawn on by sending messages to their associated GC. SWT images, and device objects such as the Display device and the Printer device, are drawables. IMPORTANT: This interface is not part of the SWT public API. It is marked public only so that it can be shared within the packages provided by SWT. It should never be referenced from application code. See Also: Device, Image, GC extends Control Instances of this class represent a selectable user interface object that issues notification when pressed and released. Styles: ARROW, CHECK, PUSH, RADIO, TOGGLE, FLAT, WRAP UP, DOWN, LEFT, RIGHT, CENTER Events: Selection Note: Only one of the styles ARROW, CHECK, PUSH, RADIO, and TOGGLE may be specified. Note: Only one of the styles LEFT, RIGHT, and CENTER may be specified. Note: Only one of the styles UP, DOWN, LEFT, and RIGHT may be specified when the ARROW style is specified. IMPORTANT: This class is not intended to be subclassed. See Also: Button snippets, SWT Example: ControlExample, Sample code and further information Restriction: This class is not intended to be subclassed by clients. '
59, 'org.eclipse.swt.widgets.Widget', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/widgets/Widget.html', 'extends Object This class is the abstract superclass of all user interface objects. Widgets are created, disposed and issue notification to listeners when events occur which affect them. Styles: (none) Events: Dispose IMPORTANT: This class is intended to be subclassed only within the SWT implementation. However, it has not been marked final to allow those outside of the SWT development team to implement patched versions of the class in order to get around specific limitations in advance of when those limitations can be addressed by the team. Any class built using subclassing to access the internals of this class will likely fail to compile or run between releases and may be strongly platform specific. Subclassing should not be attempted without an intimate and detailed understanding of the workings of the hierarchy. No support is provided for user-written classes which are implemented as subclasses of this class. See Also: checkSubclass(), Sample code and further information '
60, 'org.eclipse.swt.widgets.Tree', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/widgets/Tree.html', 'Implementers of Drawable can have a graphics context (GC) created for them, and then they can be drawn on by sending messages to their associated GC. SWT images, and device objects such as the Display device and the Printer device, are drawables. IMPORTANT: This interface is not part of the SWT public API. It is marked public only so that it can be shared within the packages provided by SWT. It should never be referenced from application code. See Also: Device, Image, GC extends Composite Instances of this class provide a selectable user interface object that displays a hierarchy of items and issues notification when an item in the hierarchy is selected. The item children that may be added to instances of this class must be of type TreeItem. Style VIRTUAL is used to create a Tree whose TreeItems are to be populated by the client on an on-demand basis instead of up-front. This can provide significant performance improvements for trees that are very large or for which TreeItem population is expensive (for example, retrieving values from an external source). Here is an example of using a Tree with style VIRTUAL: final Tree tree = new Tree(parent, SWT.VIRTUAL | SWT.BORDER); tree.setItemCount(20); tree.addListener(SWT.SetData, new Listener() { public void handleEvent(Event event) { TreeItem item = (TreeItem)event.item; TreeItem parentItem = item.getParentItem(); String text = null; if (parentItem == null) { text = \"node \" + tree.indexOf(item); } else { text = parentItem.getText() + \" - \" + parentItem.indexOf(item); } item.setText(text); System.out.println(text); item.setItemCount(10); } }); Note that although this class is a subclass of Composite, it does not normally make sense to add Control children to it, or set a layout on it, unless implementing something like a cell editor. Styles: SINGLE, MULTI, CHECK, FULL_SELECTION, VIRTUAL, NO_SCROLL Events: Selection, DefaultSelection, Collapse, Expand, SetData, MeasureItem, EraseItem, PaintItem Note: Only one of the styles SINGLE and MULTI may be specified. IMPORTANT: This class is not intended to be subclassed. See Also: Tree, TreeItem, TreeColumn snippets, SWT Example: ControlExample, Sample code and further information Restriction: This class is not intended to be subclassed by clients. '
61, 'org.eclipse.jface.action.MenuManager', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/action/MenuManager.html', 'A contribution item represents a contribution to a shared UI resource such as a menu or tool bar. More generally, contribution items are managed by a contribution manager. For instance, in a tool bar a contribution item is a tool bar button or a separator. In a menu bar a contribution item is a menu, and in a menu a contribution item is a menu item or separator. A contribution item can realize itself in different SWT widgets, using the different fill methods. The same type of contribution item can be used with a MenuBarManager, ToolBarManager, CoolBarManager, or a StatusLineManager. This interface is internal to the framework; it should not be implemented outside the framework. See Also: IContributionManager Restriction: This interface is not intended to be implemented by clients. A contribution manager organizes contributions to such UI components as menus, toolbars and status lines. A contribution manager keeps track of a list of contribution items. Each contribution item may has an optional identifier, which can be used to retrieve items from a manager, and for positioning items relative to each other. The list of contribution items can be subdivided into named groups using special contribution items that serve as group markers. The IContributionManager interface provides general protocol for adding, removing, and retrieving contribution items. It also provides convenience methods that make it convenient to contribute actions. This interface should be implemented by all objects that wish to manage contributions. There are several implementions of this interface in this package, including ones for menus (MenuManager), tool bars (ToolBarManager), and status lines (StatusLineManager). A contribution item represents a contribution to a shared UI resource such as a menu or tool bar. More generally, contribution items are managed by a contribution manager. For instance, in a tool bar a contribution item is a tool bar button or a separator. In a menu bar a contribution item is a menu, and in a menu a contribution item is a menu item or separator. A contribution item can realize itself in different SWT widgets, using the different fill methods. The same type of contribution item can be used with a MenuBarManager, ToolBarManager, CoolBarManager, or a StatusLineManager. This interface is internal to the framework; it should not be implemented outside the framework. See Also: IContributionManager Restriction: This interface is not intended to be implemented by clients. A contribution manager organizes contributions to such UI components as menus, toolbars and status lines. A contribution manager keeps track of a list of contribution items. Each contribution item may has an optional identifier, which can be used to retrieve items from a manager, and for positioning items relative to each other. The list of contribution items can be subdivided into named groups using special contribution items that serve as group markers. The IContributionManager interface provides general protocol for adding, removing, and retrieving contribution items. It also provides convenience methods that make it convenient to contribute actions. This interface should be implemented by all objects that wish to manage contributions. There are several implementions of this interface in this package, including ones for menus (MenuManager), tool bars (ToolBarManager), and status lines (StatusLineManager). extends IContributionManager, IContributionItem The IMenuManager interface provides protocol for managing contributions to a menu bar and its sub menus. An IMenuManager is also an IContributionItem, allowing sub-menus to be nested in parent menus. This interface is internal to the framework; it should not be implemented outside the framework. This package provides a concrete menu manager implementation, MenuManager. Restriction: This interface is not intended to be implemented by clients. extends ContributionManager implements IMenuManager A menu manager is a contribution manager which realizes itself and its items in a menu control; either as a menu bar, a sub-menu, or a context menu. This class may be instantiated; it may also be subclassed. '
62, 'org.eclipse.swt.widgets.Menu', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/widgets/Menu.html', 'extends Widget Instances of this class are user interface objects that contain menu items. Styles: BAR, DROP_DOWN, POP_UP, NO_RADIO_GROUP LEFT_TO_RIGHT, RIGHT_TO_LEFT Events: Help, Hide, Show Note: Only one of BAR, DROP_DOWN and POP_UP may be specified. Only one of LEFT_TO_RIGHT or RIGHT_TO_LEFT may be specified. IMPORTANT: This class is not intended to be subclassed. See Also: Menu snippets, SWT Example: ControlExample, Sample code and further information Restriction: This class is not intended to be subclassed by clients. '
63, 'org.eclipse.swt.widgets.MenuItem', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/widgets/MenuItem.html', 'extends Item Instances of this class represent a selectable user interface object that issues notification when pressed and released. Styles: CHECK, CASCADE, PUSH, RADIO, SEPARATOR Events: Arm, Help, Selection Note: Only one of the styles CHECK, CASCADE, PUSH, RADIO and SEPARATOR may be specified. IMPORTANT: This class is not intended to be subclassed. See Also: Sample code and further information Restriction: This class is not intended to be subclassed by clients. '
64, 'org.eclipse.e4.ui.model.application.ui.menu.MMenu', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/e4/ui/model/application/ui/menu/MMenu.html', ' A representation of the model object \'Element\'. This is the root element for all UI Model elements, defining attribtues common to every element; the element\'s id as well as three general storage elements: Tags: This is a set of strings which can be used to stereotype a particular element. Tags may be specified in element searches and can also be referred to in the CSS styling definition. PersistedState: A string to string map used to store information that nneds to be persisted between sessions. TransientData: A string to object map which can be used to store runtime data relevant to a particular model element. Since: 1.0 The following features are supported: Element Id Persisted State Tags Contributor URI Transient Data extends MUIElement, MUILabel A representation of the model object \'Element\'. This is the bsae type for both menu items and Separators. Since: 1.0 The following features are supported: Mnemonics extends MApplicationElement A representation of the model object \'UI Element\'. This is the base mix-in shared by all model elements that can be rendered into the UI presentation of the application. Its main job is to manage the bindings between the concrete element and the UI \'widget\' representing it in the UI. Since: 1.0 The following features are supported: Widget Renderer To Be Rendered On Top Visible Parent Container Data Cur Shared Ref Visible When Accessibility Phrase A representation of the model object \'UI Label\'. This is a mix in that will be used for UI Elements that are capable of showing label information in the GUI (e.g. Parts, Menus / Toolbars, Persepectives...) Since: 1.0 The following features are supported: Label Icon URI Tooltip extends MMenuElement, MElementContainer<MMenuElement> A representation of the model object \'Menu\'. This is a concrete class used to represent a menu in the UI Model. Since: 1.0 The following features are supported: Enabled '
65, 'org.eclipse.e4.ui.model.application.ui.menu.MMenuItem', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/e4/ui/model/application/ui/menu/MMenuItem.html', ' A representation of the model object \'Element\'. This is the root element for all UI Model elements, defining attribtues common to every element; the element\'s id as well as three general storage elements: Tags: This is a set of strings which can be used to stereotype a particular element. Tags may be specified in element searches and can also be referred to in the CSS styling definition. PersistedState: A string to string map used to store information that nneds to be persisted between sessions. TransientData: A string to object map which can be used to store runtime data relevant to a particular model element. Since: 1.0 The following features are supported: Element Id Persisted State Tags Contributor URI Transient Data extends MUIElement, MUILabel A representation of the model object \'Element\'. This is the bsae type for both menu items and Separators. Since: 1.0 The following features are supported: Mnemonics extends MApplicationElement A representation of the model object \'UI Element\'. This is the base mix-in shared by all model elements that can be rendered into the UI presentation of the application. Its main job is to manage the bindings between the concrete element and the UI \'widget\' representing it in the UI. Since: 1.0 The following features are supported: Widget Renderer To Be Rendered On Top Visible Parent Container Data Cur Shared Ref Visible When Accessibility Phrase A representation of the model object \'UI Label\'. This is a mix in that will be used for UI Elements that are capable of showing label information in the GUI (e.g. Parts, Menus / Toolbars, Persepectives...) Since: 1.0 The following features are supported: Label Icon URI Tooltip extends MItem, MMenuElement A representation of the model object \'Item\'. This is the base type for both Handled and direct menu items. Since: 1.0 '
66, 'org.eclipse.e4.ui.workbench.IWorkbench', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/e4/ui/workbench/IWorkbench.html', 'A running instance of the workbench. This instance is published through: the IEclipseContext of the application the OSGi-Service-Registry It is possible that there are multiple active IWorkbench instances in one OSGi-Instance Since: 1.0 Restriction: This interface is not intended to be implemented by clients. '
67, 'org.eclipse.e4.ui.workbench.IPresentationEngine', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/e4/ui/workbench/IPresentationEngine.html', 'The presentation engine is used to translate the generic workbench model into widgets. Implementations of this service are responsible for creating or destroying widgets corresponding to model elements, as well as for running any event loop required for handling user events on those widgets. Since: 1.0 Restriction: This interface is not intended to be implemented by clients. '
68, 'org.eclipse.e4.ui.model.application.descriptor.basic.MPartDescriptor', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/e4/ui/model/application/descriptor/basic/MPartDescriptor.html', ' A representation of the model object \'Element\'. This is the root element for all UI Model elements, defining attribtues common to every element; the element\'s id as well as three general storage elements: Tags: This is a set of strings which can be used to stereotype a particular element. Tags may be specified in element searches and can also be referred to in the CSS styling definition. PersistedState: A string to string map used to store information that nneds to be persisted between sessions. TransientData: A string to object map which can be used to store runtime data relevant to a particular model element. Since: 1.0 The following features are supported: Element Id Persisted State Tags Contributor URI Transient Data A representation of the model object \'Bindings\'. Mixin interface that lists MBindingContexts that should be active when this object is active. Example values: org.eclipse.ui.contexts.dialog, org.eclipse.ui.contexts.window Since: 1.0 The following features are supported: Binding Contexts A representation of the model object \'Handler Container\'. This provides a container in which to store lists of Handlers. Since: 1.0 The following features are supported: Handlers A representation of the model object \'UI Label\'. This is a mix in that will be used for UI Elements that are capable of showing label information in the GUI (e.g. Parts, Menus / Toolbars, Persepectives...) Since: 1.0 The following features are supported: Label Icon URI Tooltip extends MApplicationElement, MUILabel, MHandlerContainer, MBindings A representation of the model object \'Part Descriptor\'. This element represents a template from which an MPart can be created on demand. The collection of PartDescriptors owned by the Application represents the contributed parts and is used in the e4 version of \'Show View\'... Since: 1.0 The following features are supported: Allow Multiple Category Menus Toolbar Closeable Dirtyable Contribution URI Description '
69, 'org.eclipse.e4.ui.model.application.ui.advanced.MPerspectiveStack', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/e4/ui/model/application/ui/advanced/MPerspectiveStack.html', ' A representation of the model object \'Element\'. This is the root element for all UI Model elements, defining attribtues common to every element; the element\'s id as well as three general storage elements: Tags: This is a set of strings which can be used to stereotype a particular element. Tags may be specified in element searches and can also be referred to in the CSS styling definition. PersistedState: A string to string map used to store information that nneds to be persisted between sessions. TransientData: A string to object map which can be used to store runtime data relevant to a particular model element. Since: 1.0 The following features are supported: Element Id Persisted State Tags Contributor URI Transient Data extends MUIElement A representation of the model object \'Part Sash Container Element\'. A class to be mixed in to any element that should be allowed to be added to a PartSashContainer. Since a PartSashContainer is itself a PartSashContainerElement we can defined nested \'trees\' of sash containment. Since: 1.0 extends MApplicationElement A representation of the model object \'UI Element\'. This is the base mix-in shared by all model elements that can be rendered into the UI presentation of the application. Its main job is to manage the bindings between the concrete element and the UI \'widget\' representing it in the UI. Since: 1.0 The following features are supported: Widget Renderer To Be Rendered On Top Visible Parent Container Data Cur Shared Ref Visible When Accessibility Phrase extends MUIElement A representation of the model object \'Window Element\'. A class to be mixed in to any element that should be allowed to be added to a Window. Since: 1.0 extends MUIElement, MGenericStack<MPerspective>, MPartSashContainerElement, MWindowElement A representation of the model object \'Perspective Stack\'. The PerspectiveStack is a collectin of Perspectives. Only one perspective may be visible at a time and is determined by the container\'s \'selectedElement\'. Since: 1.0 '
70, 'org.eclipse.e4.ui.model.application.ui.advanced.MPerspective', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/e4/ui/model/application/ui/advanced/MPerspective.html', ' A representation of the model object \'Element\'. This is the root element for all UI Model elements, defining attribtues common to every element; the element\'s id as well as three general storage elements: Tags: This is a set of strings which can be used to stereotype a particular element. Tags may be specified in element searches and can also be referred to in the CSS styling definition. PersistedState: A string to string map used to store information that nneds to be persisted between sessions. TransientData: A string to object map which can be used to store runtime data relevant to a particular model element. Since: 1.0 The following features are supported: Element Id Persisted State Tags Contributor URI Transient Data A representation of the model object \'Context\'. This class is mixed into a UI element when that element is expected to participate in the Dependency Injection context hierarchy. The context life-cycle matches that of the rendered element it belongs to. It\'s automatically created when the element is rendered and disposed when the element is unrendered. Since: 1.0 The following features are supported: Context Variables Properties extends MApplicationElement A representation of the model object \'UI Element\'. This is the base mix-in shared by all model elements that can be rendered into the UI presentation of the application. Its main job is to manage the bindings between the concrete element and the UI \'widget\' representing it in the UI. Since: 1.0 The following features are supported: Widget Renderer To Be Rendered On Top Visible Parent Container Data Cur Shared Ref Visible When Accessibility Phrase A representation of the model object \'UI Label\'. This is a mix in that will be used for UI Elements that are capable of showing label information in the GUI (e.g. Parts, Menus / Toolbars, Persepectives...) Since: 1.0 The following features are supported: Label Icon URI Tooltip extends MElementContainer<MPartSashContainerElement>, MUILabel, MContext A representation of the model object \'Perspective\'. The Persepctive defines a part of the UI presentation that can be switched independently of the rest of the UI. By using Placeholders it\'s possible to share elements between different perspectives. Since: 1.0 The following features are supported: Windows '
71, 'org.eclipse.e4.ui.model.application.ui.advanced.MPlaceholder', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/e4/ui/model/application/ui/advanced/MPlaceholder.html', ' A representation of the model object \'Element\'. This is the root element for all UI Model elements, defining attribtues common to every element; the element\'s id as well as three general storage elements: Tags: This is a set of strings which can be used to stereotype a particular element. Tags may be specified in element searches and can also be referred to in the CSS styling definition. PersistedState: A string to string map used to store information that nneds to be persisted between sessions. TransientData: A string to object map which can be used to store runtime data relevant to a particular model element. Since: 1.0 The following features are supported: Element Id Persisted State Tags Contributor URI Transient Data extends MUIElement A representation of the model object \'Part Sash Container Element\'. A class to be mixed in to any element that should be allowed to be added to a PartSashContainer. Since a PartSashContainer is itself a PartSashContainerElement we can defined nested \'trees\' of sash containment. Since: 1.0 extends MUIElement A representation of the model object \'Stack Element\'. A class to be mixed in to any element that should be allowed to be added to a PartStack. Since: 1.0 extends MApplicationElement A representation of the model object \'UI Element\'. This is the base mix-in shared by all model elements that can be rendered into the UI presentation of the application. Its main job is to manage the bindings between the concrete element and the UI \'widget\' representing it in the UI. Since: 1.0 The following features are supported: Widget Renderer To Be Rendered On Top Visible Parent Container Data Cur Shared Ref Visible When Accessibility Phrase extends MUIElement, MPartSashContainerElement, MStackElement A representation of the model object \'Placeholder\'. A Placeholder is a concrete class used to share elements between perspectives. The elements referenced by a Placeholder generally exist in the Window\'s \'sharedElements\' list. By convention a placeholder usually shares the same elementId as the element that it\'s referencing. Since: 1.0 The following features are supported: Ref Closeable '
72, 'org.eclipse.e4.ui.workbench.modeling.EModelService', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/e4/ui/workbench/modeling/EModelService.html', 'This service is used to find, create and handle model elements Since: 1.0 Restriction: This interface is not intended to be implemented by clients. '
73, 'org.eclipse.e4.ui.model.application.ui.menu.MToolControl', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/e4/ui/model/application/ui/menu/MToolControl.html', ' A representation of the model object \'Element\'. This is the root element for all UI Model elements, defining attribtues common to every element; the element\'s id as well as three general storage elements: Tags: This is a set of strings which can be used to stereotype a particular element. Tags may be specified in element searches and can also be referred to in the CSS styling definition. PersistedState: A string to string map used to store information that nneds to be persisted between sessions. TransientData: A string to object map which can be used to store runtime data relevant to a particular model element. Since: 1.0 The following features are supported: Element Id Persisted State Tags Contributor URI Transient Data extends MApplicationElement A representation of the model object \'Contribution\'. MContribution is a mix-in class used by concrete elements such as Parts to define the location of the client supplied class implementing the specific logic needed. Since: 1.0 The following features are supported: Contribution URI Object extends MUIElement A representation of the model object \'Tool Bar Element\'. This is a placeholder class mixed in to any other type that can be added to a Toolbar. Since: 1.0 extends MUIElement A representation of the model object \'Trim Element\'. A class to be mixed in to any element that should be allowed to be added to a TrimBar. Since: 1.0 extends MApplicationElement A representation of the model object \'UI Element\'. This is the base mix-in shared by all model elements that can be rendered into the UI presentation of the application. Its main job is to manage the bindings between the concrete element and the UI \'widget\' representing it in the UI. Since: 1.0 The following features are supported: Widget Renderer To Be Rendered On Top Visible Parent Container Data Cur Shared Ref Visible When Accessibility Phrase extends MToolBarElement, MContribution, MTrimElement A representation of the model object \'Tool Control\'. This is a concrete class representing a widget hosted directly in the trim or as an item in a Toolbar. Since: 1.0 '
74, 'org.eclipse.e4.ui.model.application.ui.advanced.MArea', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/e4/ui/model/application/ui/advanced/MArea.html', ' A representation of the model object \'Element\'. This is the root element for all UI Model elements, defining attribtues common to every element; the element\'s id as well as three general storage elements: Tags: This is a set of strings which can be used to stereotype a particular element. Tags may be specified in element searches and can also be referred to in the CSS styling definition. PersistedState: A string to string map used to store information that nneds to be persisted between sessions. TransientData: A string to object map which can be used to store runtime data relevant to a particular model element. Since: 1.0 The following features are supported: Element Id Persisted State Tags Contributor URI Transient Data A representation of the model object \'Element\'. This is the root element for all UI Model elements, defining attribtues common to every element; the element\'s id as well as three general storage elements: Tags: This is a set of strings which can be used to stereotype a particular element. Tags may be specified in element searches and can also be referred to in the CSS styling definition. PersistedState: A string to string map used to store information that nneds to be persisted between sessions. TransientData: A string to object map which can be used to store runtime data relevant to a particular model element. Since: 1.0 The following features are supported: Element Id Persisted State Tags Contributor URI Transient Data extends MUIElement A representation of the model object \'Part Sash Container Element\'. A class to be mixed in to any element that should be allowed to be added to a PartSashContainer. Since a PartSashContainer is itself a PartSashContainerElement we can defined nested \'trees\' of sash containment. Since: 1.0 extends MApplicationElement A representation of the model object \'UI Element\'. This is the base mix-in shared by all model elements that can be rendered into the UI presentation of the application. Its main job is to manage the bindings between the concrete element and the UI \'widget\' representing it in the UI. Since: 1.0 The following features are supported: Widget Renderer To Be Rendered On Top Visible Parent Container Data Cur Shared Ref Visible When Accessibility Phrase extends MUIElement A representation of the model object \'Window Element\'. A class to be mixed in to any element that should be allowed to be added to a Window. Since: 1.0 extends MGenericTile<MPartSashContainerElement>, MPartSashContainerElement, MWindowElement A representation of the model object \'Part Sash Container\'. This is the concrete class representing sashed containment in the UI Model. This type is recursive, allowing the creation of a tree of sashes whose leafs are Parts. Since: 1.0 extends MUIElement A representation of the model object \'Part Sash Container Element\'. A class to be mixed in to any element that should be allowed to be added to a PartSashContainer. Since a PartSashContainer is itself a PartSashContainerElement we can defined nested \'trees\' of sash containment. Since: 1.0 extends MApplicationElement A representation of the model object \'UI Element\'. This is the base mix-in shared by all model elements that can be rendered into the UI presentation of the application. Its main job is to manage the bindings between the concrete element and the UI \'widget\' representing it in the UI. Since: 1.0 The following features are supported: Widget Renderer To Be Rendered On Top Visible Parent Container Data Cur Shared Ref Visible When Accessibility Phrase A representation of the model object \'UI Label\'. This is a mix in that will be used for UI Elements that are capable of showing label information in the GUI (e.g. Parts, Menus / Toolbars, Persepectives...) Since: 1.0 The following features are supported: Label Icon URI Tooltip extends MUIElement A representation of the model object \'Window Element\'. A class to be mixed in to any element that should be allowed to be added to a Window. Since: 1.0 extends MPartSashContainer, MUILabel A representation of the model object \'Area\'. This is a concrete element representing a (possibly sashed) chunk of the UI presentation that will minimize / maximize as one unit. This is used in Eclipse 4 to allow for a split Editor Area. Since: 1.0 '
75, 'org.eclipse.e4.ui.workbench.modeling.IPartListener', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/e4/ui/workbench/modeling/IPartListener.html', ' Since: 1.0 Restriction: This interface is not intended to be referenced by clients. '
76, 'org.eclipse.swt.widgets.Listener', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/widgets/Listener.html', 'Implementers of Listener provide a simple handleEvent() method that is used internally by SWT to dispatch events. After creating an instance of a class that implements this interface it can be added to a widget using the addListener(int eventType, Listener handler) method and removed using the removeListener (int eventType, Listener handler) method. When the specified event occurs, handleEvent(...) will be sent to the instance. Classes which implement this interface are described within SWT as providing the untyped listener API. Typically, widgets will also provide a higher-level typed listener API, that is based on the standard java.util.EventListener pattern. Note that, since all internal SWT event dispatching is based on untyped listeners, it is simple to build subsets of SWT for use on memory constrained, small footprint devices, by removing the classes and methods which implement the typed listener API. See Also: Widget.addListener(int, org.eclipse.swt.widgets.Listener), EventListener, org.eclipse.swt.events '
77, 'org.eclipse.swt.custom.SashForm', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/custom/SashForm.html', 'Implementers of Drawable can have a graphics context (GC) created for them, and then they can be drawn on by sending messages to their associated GC. SWT images, and device objects such as the Display device and the Printer device, are drawables. IMPORTANT: This interface is not part of the SWT public API. It is marked public only so that it can be shared within the packages provided by SWT. It should never be referenced from application code. See Also: Device, Image, GC extends Composite The SashForm is a composite control that lays out its children in a row or column arrangement (as specified by the orientation) and places a Sash between each child. One child may be maximized to occupy the entire size of the SashForm. The relative sizes of the children may be specified using weights. Styles: HORIZONTAL, VERTICAL, SMOOTH See Also: SashForm snippets, SWT Example: CustomControlExample, Sample code and further information '
78, 'org.eclipse.jface.viewers.TreeViewer', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/viewers/TreeViewer.html', 'Interface common to all objects that provide an input. extends IInputProvider, ISelectionProvider Interface common to all objects that provide both an input and a selection. extends ISelectionProvider Selection provider extension interface to allow providers to notify about post selection changed events. A post selection changed event is equivalent to selection changed event if the selection change was triggered by the mouse, but it has a delay if the selection change is triggered by keyboard navigation. Since: 3.0 See Also: ISelectionProvider Interface common to all objects that provide a selection. See Also: ISelection, ISelectionChangedListener, SelectionChangedEvent extends AbstractTreeViewer A concrete viewer based on an SWT Tree control. This class is not intended to be subclassed outside the viewer framework. It is designed to be instantiated with a pre-existing SWT tree control and configured with a domain-specific content provider, label provider, element filter (optional), and element sorter (optional). As of 3.2, TreeViewer supports multiple equal elements (each with a different parent chain) in the tree. This support requires that clients enable the element map by calling setUseHashLookup(true). Content providers for tree viewers must implement either the ITreeContentProvider interface, (as of 3.2) the ILazyTreeContentProvider interface, or (as of 3.3) the ILazyTreePathContentProvider. If the content provider is an ILazyTreeContentProvider or an ILazyTreePathContentProvider, the underlying Tree must be created using the SWT.VIRTUAL style bit, the tree viewer will not support sorting or filtering, and hash lookup must be enabled by calling StructuredViewer.setUseHashlookup(boolean). Users setting up an editable tree with more than 1 column have to pass the SWT.FULL_SELECTION style bit Restriction: This class is not intended to be subclassed by clients. '
79, 'org.eclipse.swt.events.DisposeListener', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/events/DisposeListener.html', 'extends org.eclipse.swt.internal.SWTEventListener Classes which implement this interface provide a method that deals with the event that is generated when a widget is disposed. After creating an instance of a class that implements this interface it can be added to a widget using the addDisposeListener method and removed using the removeDisposeListener method. When a widget is disposed, the widgetDisposed method will be invoked. See Also: DisposeEvent '
80, 'org.eclipse.jface.viewers.ISelectionChangedListener', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/viewers/ISelectionChangedListener.html', 'A listener which is notified when a viewer\'s selection changes. See Also: ISelection, ISelectionProvider, SelectionChangedEvent '
81, 'org.eclipse.jface.viewers.ITreeContentProvider', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/viewers/ITreeContentProvider.html', 'A content provider mediates between the viewer\'s model and the viewer itself. See Also: ContentViewer.setContentProvider(IContentProvider) extends IContentProvider An interface to content providers for structured viewers. See Also: StructuredViewer extends IStructuredContentProvider An interface to content providers for tree-structure-oriented viewers. See Also: AbstractTreeViewer '
82, 'org.eclipse.jface.viewers.LabelProvider', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/viewers/LabelProvider.html', 'A label provider maps an element of the viewer\'s model to an optional image and optional text string used to display the element in the viewer\'s control. Certain label providers may allow multiple labels per element. This is an \"abstract interface\", defining methods common to all label providers, but does not actually define the methods to get the label(s) for an element. This interface should never be directly implemented. Most viewers will take either an ILabelProvider or an ITableLabelProvider. A label provider must not be shared between viewers since a label provider generally manages SWT resources (images), which must be disposed when the viewer is disposed. To simplify life cycle management, the current label provider of a viewer is disposed when the viewer is disposed. Label providers can be used outside the context of viewers wherever images are needed. When label providers are used in this fashion it is the responsibility of the user to ensure dispose is called when the provider is no longer needed. See Also: ILabelProvider, ITableLabelProvider extends IBaseLabelProvider Extends IBaseLabelProvider with the methods to provide the text and/or image for the label of a given element. Used by most structured viewers, except table viewers. extends BaseLabelProvider implements ILabelProvider A label provider implementation which, by default, uses an element\'s toString value for its text and null for its image. This class may be used as is, or subclassed to provide richer labels. Subclasses may override any of the following methods: isLabelProperty getImage getText dispose '
83, 'org.eclipse.core.runtime.IExtensionRegistry', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/runtime/IExtensionRegistry.html', 'The extension registry holds the master list of all discovered namespaces, extension points and extensions. The extension registry can be queried, by name, for extension points and extensions. The various objects that describe the contents of the extension registry (IExtensionPoint, IExtension, and IConfigurationElement) are intended for relatively short-term use. Clients that deal with these objects must be aware that they may become invalid if the declaring plug-in is updated or uninstalled. If this happens, all methods on these object except isValid() will throw InvalidRegistryObjectException. Code in a plug-in that has declared that it is not dynamic aware (or not declared anything) can safely ignore this issue, since the registry would not be modified while it is active. However, code in a plug-in that declares that it is dynamic aware must be careful if it accesses extension registry objects, because it\'s at risk if plug-in are removed. Similarly, tools that analyze or display the extension registry are vulnerable. Client code can pre-test for invalid objects by calling isValid(), which never throws this exception. However, pre-tests are usually not sufficient because of the possibility of the extension registry object becoming invalid as a result of a concurrent activity. At-risk clients must treat InvalidRegistryObjectException as if it were a checked exception. Also, such clients should probably register a listener with the extension registry so that they receive notification of any changes to the registry. Extensions and extension points are declared by generic entities called namespaces. The only fact known about namespaces is that they have unique string-based identifiers. One example of a namespace is a plug-in, for which the namespace id is the plug-in id. This interface can be used without OSGi running. This interface is not intended to be implemented by clients. Since: 3.0 Restriction: This interface is not intended to be implemented by clients. '
84, 'org.eclipse.swt.events.DisposeEvent', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/events/DisposeEvent.html', 'extends TypedEvent Instances of this class are sent as a result of widgets being disposed. See Also: DisposeListener, Sample code and further information, Serialized Form '
85, 'org.eclipse.jface.viewers.SelectionChangedEvent', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/viewers/SelectionChangedEvent.html', 'extends EventObject Event object describing a selection change. The source of these events is a selection provider. See Also: ISelection, ISelectionProvider, ISelectionChangedListener, Serialized Form '
86, 'org.eclipse.core.runtime.IConfigurationElement', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/runtime/IConfigurationElement.html', 'A configuration element, with its attributes and children, directly reflects the content and structure of the extension section within the declaring plug-in\'s manifest (plugin.xml) file. This interface also provides a way to create executable extension objects. These registry objects are intended for relatively short-term use. Clients that deal with these objects must be aware that they may become invalid if the declaring plug-in is updated or uninstalled. If this happens, all methods except isValid() will throw InvalidRegistryObjectException. For configuration element objects, the most common case is code in a plug-in dealing with extensions contributed to one of the extension points it declares. Code in a plug-in that has declared that it is not dynamic aware (or not declared anything) can safely ignore this issue, since the registry would not be modified while it is active. However, code in a plug-in that declares that it is dynamic aware must be careful when accessing the extension and configuration element objects because they become invalid if the contributing plug-in is removed. Similarly, tools that analyze or display the extension registry are vulnerable. Client code can pre-test for invalid objects by calling isValid(), which never throws this exception. However, pre-tests are usually not sufficient because of the possibility of the extension or configuration element object becoming invalid as a result of a concurrent activity. At-risk clients must treat InvalidRegistryObjectException as if it were a checked exception. Also, such clients should probably register a listener with the extension registry so that they receive notification of any changes to the registry. This interface can be used without OSGi running. This interface is not intended to be implemented by clients. Restriction: This interface is not intended to be implemented by clients. '
87, 'org.eclipse.core.runtime.IExtension', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/runtime/IExtension.html', 'An extension declared in a plug-in. All information is obtained from the declaring plug-in\'s manifest (plugin.xml) file. These registry objects are intended for relatively short-term use. Clients that deal with these objects must be aware that they may become invalid if the declaring plug-in is updated or uninstalled. If this happens, all methods except isValid() will throw InvalidRegistryObjectException. For extension objects, the most common case is code in a plug-in dealing with extensions contributed to one of the extension points it declares. Code in a plug-in that has declared that it is not dynamic aware (or not declared anything) can safely ignore this issue, since the registry would not be modified while it is active. However, code in a plug-in that declares that it is dynamic aware must be careful when accessing the extension objects because they become invalid if the contributing plug-in is removed. Similarly, tools that analyze or display the extension registry are vulnerable. Client code can pre-test for invalid objects by calling isValid(), which never throws this exception. However, pre-tests are usually not sufficient because of the possibility of the extension object becoming invalid as a result of a concurrent activity. At-risk clients must treat InvalidRegistryObjectException as if it were a checked exception. Also, such clients should probably register a listener with the extension registry so that they receive notification of any changes to the registry. This interface can be used without OSGi running. This interface is not intended to be implemented by clients. Restriction: This interface is not intended to be implemented by clients. '
88, 'org.eclipse.jface.viewers.Viewer', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/viewers/Viewer.html', 'Interface common to all objects that provide an input. extends IInputProvider, ISelectionProvider Interface common to all objects that provide both an input and a selection. Interface common to all objects that provide a selection. See Also: ISelection, ISelectionChangedListener, SelectionChangedEvent extends Object implements IInputSelectionProvider A viewer is a model-based adapter on a widget. A viewer can be created as an adapter on a pre-existing control (e.g., creating a ListViewer on an existing List control). All viewers also provide a convenience constructor for creating the control. Implementing a concrete viewer typically involves the following steps: create SWT controls for viewer (in constructor) (optional) initialize SWT controls from input (inputChanged) define viewer-specific update methods support selections (setSelection, getSelection) '
89, 'org.eclipse.swt.graphics.Image', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/graphics/Image.html', 'Implementers of Drawable can have a graphics context (GC) created for them, and then they can be drawn on by sending messages to their associated GC. SWT images, and device objects such as the Display device and the Printer device, are drawables. IMPORTANT: This interface is not part of the SWT public API. It is marked public only so that it can be shared within the packages provided by SWT. It should never be referenced from application code. See Also: Device, Image, GC extends Resource implements Drawable Instances of this class are graphics which have been prepared for display on a specific device. That is, they are ready to paint using methods such as GC.drawImage() and display on widgets with, for example, Button.setImage(). If loaded from a file format that supports it, an Image may have transparency, meaning that certain pixels are specified as being transparent when drawn. Examples of file formats that support transparency are GIF and PNG. There are two primary ways to use Images. The first is to load a graphic file from disk and create an Image from it. This is done using an Image constructor, for example: Image i = new Image(device, \"C:\\\\graphic.bmp\"); A graphic file may contain a color table specifying which colors the image was intended to possess. In the above example, these colors will be mapped to the closest available color in SWT. It is possible to get more control over the mapping of colors as the image is being created, using code of the form: ImageData data = new ImageData(\"C:\\\\graphic.bmp\"); RGB[] rgbs = data.getRGBs(); // At this point, rgbs contains specifications of all // the colors contained within this image. You may // allocate as many of these colors as you wish by // using the Color constructor Color(RGB), then // create the image: Image i = new Image(device, data); Applications which require even greater control over the image loading process should use the support provided in class ImageLoader. Application code must explicitly invoke the Image.dispose() method to release the operating system resources managed by each instance when those instances are no longer required. See Also: Color, ImageData, ImageLoader, Image snippets, SWT Examples: GraphicsExample, ImageAnalyzer, Sample code and further information '
90, 'org.eclipse.jface.layout.GridLayoutFactory', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/layout/GridLayoutFactory.html', 'extends Object GridLayoutFactory creates and initializes grid layouts. There are two ways to use GridLayoutFactory. Normally, it is used as a shorthand for writing \"new GridLayout()\" and initializing a bunch of fields. In this case the main benefit is a more concise syntax and the ability to create more than one identical GridLayout from the same factory. Changing a property of the factory will affect future layouts created by the factory, but has no effect on layouts that have already been created. GridLayoutFactory can also generate grid data for all the controls in a layout. This is done with the generateLayout method. To use this feature: Create the composite Create all the controls in the composite Call generateLayout The order here is important. generateLayout must be called after all the child controls have been created. generateLayout will not change any layout data that has already been attached to a child control and it will not recurse into nested composites. Since: 3.2 '
91, 'org.eclipse.e4.ui.model.application.ui.menu.MHandledMenuItem', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/e4/ui/model/application/ui/menu/MHandledMenuItem.html', ' A representation of the model object \'Element\'. This is the root element for all UI Model elements, defining attribtues common to every element; the element\'s id as well as three general storage elements: Tags: This is a set of strings which can be used to stereotype a particular element. Tags may be specified in element searches and can also be referred to in the CSS styling definition. PersistedState: A string to string map used to store information that nneds to be persisted between sessions. TransientData: A string to object map which can be used to store runtime data relevant to a particular model element. Since: 1.0 The following features are supported: Element Id Persisted State Tags Contributor URI Transient Data extends MItem A representation of the model object \'Handled Item\'. This is the base class for menu and tool items associated with Commands. Since: 1.0 The following features are supported: Command Wb Command Parameters extends MUIElement, MUILabel A representation of the model object \'Element\'. This is the bsae type for both menu items and Separators. Since: 1.0 The following features are supported: Mnemonics A representation of the model object \'Element\'. This is the root element for all UI Model elements, defining attribtues common to every element; the element\'s id as well as three general storage elements: Tags: This is a set of strings which can be used to stereotype a particular element. Tags may be specified in element searches and can also be referred to in the CSS styling definition. PersistedState: A string to string map used to store information that nneds to be persisted between sessions. TransientData: A string to object map which can be used to store runtime data relevant to a particular model element. Since: 1.0 The following features are supported: Element Id Persisted State Tags Contributor URI Transient Data extends MUIElement, MUILabel A representation of the model object \'Element\'. This is the bsae type for both menu items and Separators. Since: 1.0 The following features are supported: Mnemonics extends MApplicationElement A representation of the model object \'UI Element\'. This is the base mix-in shared by all model elements that can be rendered into the UI presentation of the application. Its main job is to manage the bindings between the concrete element and the UI \'widget\' representing it in the UI. Since: 1.0 The following features are supported: Widget Renderer To Be Rendered On Top Visible Parent Container Data Cur Shared Ref Visible When Accessibility Phrase A representation of the model object \'UI Label\'. This is a mix in that will be used for UI Elements that are capable of showing label information in the GUI (e.g. Parts, Menus / Toolbars, Persepectives...) Since: 1.0 The following features are supported: Label Icon URI Tooltip extends MItem, MMenuElement A representation of the model object \'Item\'. This is the base type for both Handled and direct menu items. Since: 1.0 extends MApplicationElement A representation of the model object \'UI Element\'. This is the base mix-in shared by all model elements that can be rendered into the UI presentation of the application. Its main job is to manage the bindings between the concrete element and the UI \'widget\' representing it in the UI. Since: 1.0 The following features are supported: Widget Renderer To Be Rendered On Top Visible Parent Container Data Cur Shared Ref Visible When Accessibility Phrase A representation of the model object \'UI Label\'. This is a mix in that will be used for UI Elements that are capable of showing label information in the GUI (e.g. Parts, Menus / Toolbars, Persepectives...) Since: 1.0 The following features are supported: Label Icon URI Tooltip extends MMenuItem, MHandledItem A representation of the model object \'Handled Menu Item\'. This is the concrete UI Model element representing a menu item that is managed through the Commands / Handlers infrastructure. Since: 1.0 '
92, 'org.eclipse.e4.ui.model.application.commands.MCommand', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/e4/ui/model/application/commands/MCommand.html', ' A representation of the model object \'Element\'. This is the root element for all UI Model elements, defining attribtues common to every element; the element\'s id as well as three general storage elements: Tags: This is a set of strings which can be used to stereotype a particular element. Tags may be specified in element searches and can also be referred to in the CSS styling definition. PersistedState: A string to string map used to store information that nneds to be persisted between sessions. TransientData: A string to object map which can be used to store runtime data relevant to a particular model element. Since: 1.0 The following features are supported: Element Id Persisted State Tags Contributor URI Transient Data extends MApplicationElement A representation of the model object \'Command\'. A Command represents a logical operation within the applicaiton. The implementation is provided by an MHandler chosen by examining all the candidate\'s enablement. Since: 1.0 The following features are supported: Command Name Description Parameters Category '
93, 'org.eclipse.e4.ui.model.application.ui.menu.MMenuSeparator', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/e4/ui/model/application/ui/menu/MMenuSeparator.html', ' A representation of the model object \'Element\'. This is the root element for all UI Model elements, defining attribtues common to every element; the element\'s id as well as three general storage elements: Tags: This is a set of strings which can be used to stereotype a particular element. Tags may be specified in element searches and can also be referred to in the CSS styling definition. PersistedState: A string to string map used to store information that nneds to be persisted between sessions. TransientData: A string to object map which can be used to store runtime data relevant to a particular model element. Since: 1.0 The following features are supported: Element Id Persisted State Tags Contributor URI Transient Data extends MUIElement, MUILabel A representation of the model object \'Element\'. This is the bsae type for both menu items and Separators. Since: 1.0 The following features are supported: Mnemonics extends MApplicationElement A representation of the model object \'UI Element\'. This is the base mix-in shared by all model elements that can be rendered into the UI presentation of the application. Its main job is to manage the bindings between the concrete element and the UI \'widget\' representing it in the UI. Since: 1.0 The following features are supported: Widget Renderer To Be Rendered On Top Visible Parent Container Data Cur Shared Ref Visible When Accessibility Phrase A representation of the model object \'UI Label\'. This is a mix in that will be used for UI Elements that are capable of showing label information in the GUI (e.g. Parts, Menus / Toolbars, Persepectives...) Since: 1.0 The following features are supported: Label Icon URI Tooltip extends MMenuElement A representation of the model object \'Separator\'. An element representing a separator in a menu. Since: 1.0 '
94, 'org.eclipse.e4.ui.model.application.ui.menu.MDirectMenuItem', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/e4/ui/model/application/ui/menu/MDirectMenuItem.html', ' A representation of the model object \'Element\'. This is the root element for all UI Model elements, defining attribtues common to every element; the element\'s id as well as three general storage elements: Tags: This is a set of strings which can be used to stereotype a particular element. Tags may be specified in element searches and can also be referred to in the CSS styling definition. PersistedState: A string to string map used to store information that nneds to be persisted between sessions. TransientData: A string to object map which can be used to store runtime data relevant to a particular model element. Since: 1.0 The following features are supported: Element Id Persisted State Tags Contributor URI Transient Data extends MApplicationElement A representation of the model object \'Contribution\'. MContribution is a mix-in class used by concrete elements such as Parts to define the location of the client supplied class implementing the specific logic needed. Since: 1.0 The following features are supported: Contribution URI Object extends MUIElement, MUILabel A representation of the model object \'Element\'. This is the bsae type for both menu items and Separators. Since: 1.0 The following features are supported: Mnemonics A representation of the model object \'Element\'. This is the root element for all UI Model elements, defining attribtues common to every element; the element\'s id as well as three general storage elements: Tags: This is a set of strings which can be used to stereotype a particular element. Tags may be specified in element searches and can also be referred to in the CSS styling definition. PersistedState: A string to string map used to store information that nneds to be persisted between sessions. TransientData: A string to object map which can be used to store runtime data relevant to a particular model element. Since: 1.0 The following features are supported: Element Id Persisted State Tags Contributor URI Transient Data extends MUIElement, MUILabel A representation of the model object \'Element\'. This is the bsae type for both menu items and Separators. Since: 1.0 The following features are supported: Mnemonics extends MApplicationElement A representation of the model object \'UI Element\'. This is the base mix-in shared by all model elements that can be rendered into the UI presentation of the application. Its main job is to manage the bindings between the concrete element and the UI \'widget\' representing it in the UI. Since: 1.0 The following features are supported: Widget Renderer To Be Rendered On Top Visible Parent Container Data Cur Shared Ref Visible When Accessibility Phrase A representation of the model object \'UI Label\'. This is a mix in that will be used for UI Elements that are capable of showing label information in the GUI (e.g. Parts, Menus / Toolbars, Persepectives...) Since: 1.0 The following features are supported: Label Icon URI Tooltip extends MItem, MMenuElement A representation of the model object \'Item\'. This is the base type for both Handled and direct menu items. Since: 1.0 extends MApplicationElement A representation of the model object \'UI Element\'. This is the base mix-in shared by all model elements that can be rendered into the UI presentation of the application. Its main job is to manage the bindings between the concrete element and the UI \'widget\' representing it in the UI. Since: 1.0 The following features are supported: Widget Renderer To Be Rendered On Top Visible Parent Container Data Cur Shared Ref Visible When Accessibility Phrase A representation of the model object \'UI Label\'. This is a mix in that will be used for UI Elements that are capable of showing label information in the GUI (e.g. Parts, Menus / Toolbars, Persepectives...) Since: 1.0 The following features are supported: Label Icon URI Tooltip extends MMenuItem, MContribution A representation of the model object \'Direct Menu Item\'. This is the concrete class use to represent a menu item that is directly invoked when selected. The supplied contribution is asked to execute when selected. Since: 1.0 '
95, 'org.eclipse.e4.ui.model.application.commands.MHandler', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/e4/ui/model/application/commands/MHandler.html', ' A representation of the model object \'Element\'. This is the root element for all UI Model elements, defining attribtues common to every element; the element\'s id as well as three general storage elements: Tags: This is a set of strings which can be used to stereotype a particular element. Tags may be specified in element searches and can also be referred to in the CSS styling definition. PersistedState: A string to string map used to store information that nneds to be persisted between sessions. TransientData: A string to object map which can be used to store runtime data relevant to a particular model element. Since: 1.0 The following features are supported: Element Id Persisted State Tags Contributor URI Transient Data extends MApplicationElement A representation of the model object \'Contribution\'. MContribution is a mix-in class used by concrete elements such as Parts to define the location of the client supplied class implementing the specific logic needed. Since: 1.0 The following features are supported: Contribution URI Object extends MContribution A representation of the model object \'Handler\'. Handlers provide the execution logic that provides the implementation of a particular command. Since: 1.0 The following features are supported: Command '
96, 'org.eclipse.e4.ui.model.application.ui.menu.MMenuContribution', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/e4/ui/model/application/ui/menu/MMenuContribution.html', ' A representation of the model object \'Element\'. This is the root element for all UI Model elements, defining attribtues common to every element; the element\'s id as well as three general storage elements: Tags: This is a set of strings which can be used to stereotype a particular element. Tags may be specified in element searches and can also be referred to in the CSS styling definition. PersistedState: A string to string map used to store information that nneds to be persisted between sessions. TransientData: A string to object map which can be used to store runtime data relevant to a particular model element. Since: 1.0 The following features are supported: Element Id Persisted State Tags Contributor URI Transient Data extends MApplicationElement A representation of the model object \'UI Element\'. This is the base mix-in shared by all model elements that can be rendered into the UI presentation of the application. Its main job is to manage the bindings between the concrete element and the UI \'widget\' representing it in the UI. Since: 1.0 The following features are supported: Widget Renderer To Be Rendered On Top Visible Parent Container Data Cur Shared Ref Visible When Accessibility Phrase extends MElementContainer<MMenuElement> A representation of the model object \'Contribution\'. Provisional for 4.3. This represents a potential extension to some menu already defined in the UI. Since: 1.0 The following features are supported: Position In Parent Parent Id Restriction: This interface is not intended to be referenced by clients. '
97, 'org.eclipse.e4.ui.model.application.ui.MCoreExpression', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/e4/ui/model/application/ui/MCoreExpression.html', ' A representation of the model object \'Element\'. This is the root element for all UI Model elements, defining attribtues common to every element; the element\'s id as well as three general storage elements: Tags: This is a set of strings which can be used to stereotype a particular element. Tags may be specified in element searches and can also be referred to in the CSS styling definition. PersistedState: A string to string map used to store information that nneds to be persisted between sessions. TransientData: A string to object map which can be used to store runtime data relevant to a particular model element. Since: 1.0 The following features are supported: Element Id Persisted State Tags Contributor URI Transient Data extends MApplicationElement A representation of the model object \'Expression\'. A class upon which specific types of expressions are based. These are often used to evaluate visibility and enablement of model elements. Since: 1.0 extends MExpression A representation of the model object \'Core Expression\'. A specific kind of expression used by the Eclipse Workbench. Since: 1.0 The following features are supported: Core Expression Id Core Expression '
98, 'org.eclipse.core.runtime.Plugin', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/runtime/Plugin.html', 'extends Object implements BundleActivator The abstract superclass of all plug-in runtime class implementations. A plug-in subclasses this class and overrides the appropriate life cycle methods in order to react to the life cycle requests automatically issued by the platform. For compatibility reasons, the methods called for those life cycle events vary, please see the \"Constructors and life cycle methods\" section below. Conceptually, the plug-in runtime class represents the entire plug-in rather than an implementation of any one particular extension the plug-in declares. A plug-in is not required to explicitly specify a plug-in runtime class; if none is specified, the plug-in will be given a default plug-in runtime object that ignores all life cycle requests (it still provides access to the corresponding plug-in descriptor). In the case of more complex plug-ins, it may be desirable to define a concrete subclass of Plugin. However, just subclassing Plugin is not sufficient. The name of the class must be explicitly configured in the plug-in\'s manifest (plugin.xml) file with the class attribute of the &ltplugin> element markup. Instances of plug-in runtime classes are automatically created by the platform in the course of plug-in activation. For compatibility reasons, the constructor used to create plug-in instances varies, please see the \"Constructors and life cycle methods\" section below. The concept of bundles underlies plug-ins. However it is safe to regard plug-ins and bundles as synonyms. Clients must never explicitly instantiate a plug-in runtime class. A typical implementation pattern for plug-in runtime classes is to provide a static convenience method to gain access to a plug-in\'s runtime object. This way, code in other parts of the plug-in implementation without direct access to the plug-in runtime object can easily obtain a reference to it, and thence to any plug-in-wide resources recorded on it. An example for Eclipse 3.0 follows: package myplugin; public class MyPluginClass extends Plugin { private static MyPluginClass instance; public static MyPluginClass getInstance() { return instance; } public void MyPluginClass() { super(); instance = this; // ... other initialization } // ... other methods } In the above example, a call to MyPluginClass.getInstance() will always return an initialized instance of MyPluginClass. Constructors and life cycle methods If the plugin.xml of a plug-in indicates <?eclipse version=\"3.0\"?> and its prerequisite list includes org.eclipse.core.runtime, the default constructor of the plug-in class is used and start(BundleContext) and stop(BundleContext) are called as life cycle methods. If the plugin.xml of a plug-in indicates <?eclipse version=\"3.0\"?> and its prerequisite list includes org.eclipse.core.runtime.compatibility, the Plugin(IPluginDescriptor) constructor is used and startup() and shutdown() are called as life cycle methods. Note that in this situation, start() is called before startup() and stop() is called after shutdown. If the plugin.xml of your plug-in does not indicate <?eclipse version=\"3.0\"?> it is therefore not a 3.0 plug-in. Consequently the Plugin(IPluginDescriptor) is used and startup() and shutdown() are called as life cycle methods. Since Eclipse 3.0 APIs of the Plugin class can be called only when the Plugin is in an active state, i.e., after it was started up and before it is shutdown. In particular, it means that Plugin APIs should not be called from overrides of Plugin(). '
99, 'org.eclipse.e4.ui.model.application.commands.MCategory', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/e4/ui/model/application/commands/MCategory.html', ' A representation of the model object \'Element\'. This is the root element for all UI Model elements, defining attribtues common to every element; the element\'s id as well as three general storage elements: Tags: This is a set of strings which can be used to stereotype a particular element. Tags may be specified in element searches and can also be referred to in the CSS styling definition. PersistedState: A string to string map used to store information that nneds to be persisted between sessions. TransientData: A string to object map which can be used to store runtime data relevant to a particular model element. Since: 1.0 The following features are supported: Element Id Persisted State Tags Contributor URI Transient Data extends MApplicationElement A representation of the model object \'Category\'. This defines a logical grouping of Commands in order to facilitate showing the current set of Commands in dialogs, lists etc Since: 1.0 The following features are supported: Name Description '
100, 'org.eclipse.e4.ui.model.application.commands.MCommandParameter', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/e4/ui/model/application/commands/MCommandParameter.html', ' A representation of the model object \'Element\'. This is the root element for all UI Model elements, defining attribtues common to every element; the element\'s id as well as three general storage elements: Tags: This is a set of strings which can be used to stereotype a particular element. Tags may be specified in element searches and can also be referred to in the CSS styling definition. PersistedState: A string to string map used to store information that nneds to be persisted between sessions. TransientData: A string to object map which can be used to store runtime data relevant to a particular model element. Since: 1.0 The following features are supported: Element Id Persisted State Tags Contributor URI Transient Data extends MApplicationElement A representation of the model object \'Command Parameter\'. This represents the format of a parameter to be used in a Command. Since: 1.0 The following features are supported: Name Type Id Optional '
101, 'org.eclipse.e4.ui.model.application.ui.MElementContainer', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/e4/ui/model/application/ui/MElementContainer.html', ' A representation of the model object \'Element\'. This is the root element for all UI Model elements, defining attribtues common to every element; the element\'s id as well as three general storage elements: Tags: This is a set of strings which can be used to stereotype a particular element. Tags may be specified in element searches and can also be referred to in the CSS styling definition. PersistedState: A string to string map used to store information that nneds to be persisted between sessions. TransientData: A string to object map which can be used to store runtime data relevant to a particular model element. Since: 1.0 The following features are supported: Element Id Persisted State Tags Contributor URI Transient Data extends MApplicationElement A representation of the model object \'UI Element\'. This is the base mix-in shared by all model elements that can be rendered into the UI presentation of the application. Its main job is to manage the bindings between the concrete element and the UI \'widget\' representing it in the UI. Since: 1.0 The following features are supported: Widget Renderer To Be Rendered On Top Visible Parent Container Data Cur Shared Ref Visible When Accessibility Phrase T extends MUIElement> extends MUIElement A representation of the model object \'Element Container\'. This is the base for the two different types of containment used in the model; \'Stacks\' (where only one element would be visible at a time) and \'Tiles\' (where all the ele elements are visible at the same time. All containers define the type of element that they are to contain. By design this is always a single type. Where different concrete types are to be contained within the same container they all both mix in a container-specific type. For example both MParts and MPlaceholders are valid children for an MPartStack so they both mix in \'StackElement\' (which is an empty stub used only to constran the stack\'s types. Since: 1.0 The following features are supported: Children Selected Element '
102, 'org.eclipse.e4.ui.model.application.commands.MParameter', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/e4/ui/model/application/commands/MParameter.html', ' A representation of the model object \'Element\'. This is the root element for all UI Model elements, defining attribtues common to every element; the element\'s id as well as three general storage elements: Tags: This is a set of strings which can be used to stereotype a particular element. Tags may be specified in element searches and can also be referred to in the CSS styling definition. PersistedState: A string to string map used to store information that nneds to be persisted between sessions. TransientData: A string to object map which can be used to store runtime data relevant to a particular model element. Since: 1.0 The following features are supported: Element Id Persisted State Tags Contributor URI Transient Data extends MApplicationElement A representation of the model object \'Parameter\'. This defines the value of a Parameter to be used by a Command. Since: 1.0 The following features are supported: Name Value '
103, 'org.eclipse.e4.ui.model.application.ui.MInput', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/e4/ui/model/application/ui/MInput.html', ' A representation of the model object \'Input\'. This class should be mixed into UI elements such as InputParts that need to reference an external resource (files...). Since: 1.0 The following features are supported: Input URI '
104, 'org.eclipse.e4.ui.workbench.modeling.ModelReconciler', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/e4/ui/workbench/modeling/ModelReconciler.html', 'extends Object Since: 1.0 Restriction: This class is not intended to be referenced by clients. '
105, 'org.eclipse.e4.ui.workbench.modeling.ModelDelta', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/e4/ui/workbench/modeling/ModelDelta.html', ' Since: 1.0 Restriction: This interface is not intended to be referenced by clients. extends Object implements IDelta Since: 1.0 Restriction: This class is not intended to be referenced by clients. '
106, 'org.eclipse.e4.ui.workbench.modeling.IModelReconcilingService', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/e4/ui/workbench/modeling/IModelReconcilingService.html', ' Since: 1.0 Restriction: This interface is not intended to be referenced by clients. '
107, 'org.eclipse.e4.ui.model.application.commands.MBindingTable', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/e4/ui/model/application/commands/MBindingTable.html', ' A representation of the model object \'Element\'. This is the root element for all UI Model elements, defining attribtues common to every element; the element\'s id as well as three general storage elements: Tags: This is a set of strings which can be used to stereotype a particular element. Tags may be specified in element searches and can also be referred to in the CSS styling definition. PersistedState: A string to string map used to store information that nneds to be persisted between sessions. TransientData: A string to object map which can be used to store runtime data relevant to a particular model element. Since: 1.0 The following features are supported: Element Id Persisted State Tags Contributor URI Transient Data extends MApplicationElement A representation of the model object \'Binding Table\'. A set of Bindings that will be active if the matching MBindingContext is active. Since: 1.0 The following features are supported: Bindings Binding Context '
108, 'org.eclipse.e4.ui.model.application.commands.MKeyBinding', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/e4/ui/model/application/commands/MKeyBinding.html', ' A representation of the model object \'Element\'. This is the root element for all UI Model elements, defining attribtues common to every element; the element\'s id as well as three general storage elements: Tags: This is a set of strings which can be used to stereotype a particular element. Tags may be specified in element searches and can also be referred to in the CSS styling definition. PersistedState: A string to string map used to store information that nneds to be persisted between sessions. TransientData: A string to object map which can be used to store runtime data relevant to a particular model element. Since: 1.0 The following features are supported: Element Id Persisted State Tags Contributor URI Transient Data A representation of the model object \'Key Sequence\'. This represents the sequence of characters in a KeyBinding whose detection will fire the associated Command. Since: 1.0 The following features are supported: Key Sequence extends MApplicationElement, MKeySequence A representation of the model object \'Key Binding\'. Keybindings map a particular keyboard sequence (i.e. Ctrl + C for Copy...) onto some command. Since: 1.0 The following features are supported: Command Parameters '
109, 'org.eclipse.e4.ui.model.application.MAddon', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/e4/ui/model/application/MAddon.html', ' A representation of the model object \'Element\'. This is the root element for all UI Model elements, defining attribtues common to every element; the element\'s id as well as three general storage elements: Tags: This is a set of strings which can be used to stereotype a particular element. Tags may be specified in element searches and can also be referred to in the CSS styling definition. PersistedState: A string to string map used to store information that nneds to be persisted between sessions. TransientData: A string to object map which can be used to store runtime data relevant to a particular model element. Since: 1.0 The following features are supported: Element Id Persisted State Tags Contributor URI Transient Data extends MApplicationElement A representation of the model object \'Contribution\'. MContribution is a mix-in class used by concrete elements such as Parts to define the location of the client supplied class implementing the specific logic needed. Since: 1.0 The following features are supported: Contribution URI Object extends MContribution A representation of the model object \'Addon\'. An MAddon represents a self-contained application logic. Addons may be used to augment the UI in a variety of ways without requriing that the base application be aware of the extensions. Addons aare expected to be capable of being removed without damage to the original UI. While not yet implemented there will be an uninstall protocol defined ni the future allowing an addon to remove any model elements specific to the addon (i.e. The MinMaxAddon\'s TrimElements. Since: 1.0 '
110, 'org.eclipse.e4.ui.model.application.ui.menu.MToolBarContribution', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/e4/ui/model/application/ui/menu/MToolBarContribution.html', ' A representation of the model object \'Element\'. This is the root element for all UI Model elements, defining attribtues common to every element; the element\'s id as well as three general storage elements: Tags: This is a set of strings which can be used to stereotype a particular element. Tags may be specified in element searches and can also be referred to in the CSS styling definition. PersistedState: A string to string map used to store information that nneds to be persisted between sessions. TransientData: A string to object map which can be used to store runtime data relevant to a particular model element. Since: 1.0 The following features are supported: Element Id Persisted State Tags Contributor URI Transient Data extends MApplicationElement A representation of the model object \'UI Element\'. This is the base mix-in shared by all model elements that can be rendered into the UI presentation of the application. Its main job is to manage the bindings between the concrete element and the UI \'widget\' representing it in the UI. Since: 1.0 The following features are supported: Widget Renderer To Be Rendered On Top Visible Parent Container Data Cur Shared Ref Visible When Accessibility Phrase extends MElementContainer<MToolBarElement> A representation of the model object \'Tool Bar Contribution\'. Provisional for 4.3. This represents a potential extension to some toolbar already defined in the UI. Since: 1.0 The following features are supported: Parent Id Position In Parent Restriction: This interface is not intended to be referenced by clients. '
111, 'org.eclipse.e4.ui.model.application.ui.menu.MHandledToolItem', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/e4/ui/model/application/ui/menu/MHandledToolItem.html', ' A representation of the model object \'Element\'. This is the root element for all UI Model elements, defining attribtues common to every element; the element\'s id as well as three general storage elements: Tags: This is a set of strings which can be used to stereotype a particular element. Tags may be specified in element searches and can also be referred to in the CSS styling definition. PersistedState: A string to string map used to store information that nneds to be persisted between sessions. TransientData: A string to object map which can be used to store runtime data relevant to a particular model element. Since: 1.0 The following features are supported: Element Id Persisted State Tags Contributor URI Transient Data extends MItem A representation of the model object \'Handled Item\'. This is the base class for menu and tool items associated with Commands. Since: 1.0 The following features are supported: Command Wb Command Parameters extends MUIElement A representation of the model object \'Tool Bar Element\'. This is a placeholder class mixed in to any other type that can be added to a Toolbar. Since: 1.0 A representation of the model object \'Element\'. This is the root element for all UI Model elements, defining attribtues common to every element; the element\'s id as well as three general storage elements: Tags: This is a set of strings which can be used to stereotype a particular element. Tags may be specified in element searches and can also be referred to in the CSS styling definition. PersistedState: A string to string map used to store information that nneds to be persisted between sessions. TransientData: A string to object map which can be used to store runtime data relevant to a particular model element. Since: 1.0 The following features are supported: Element Id Persisted State Tags Contributor URI Transient Data extends MUIElement A representation of the model object \'Tool Bar Element\'. This is a placeholder class mixed in to any other type that can be added to a Toolbar. Since: 1.0 extends MApplicationElement A representation of the model object \'UI Element\'. This is the base mix-in shared by all model elements that can be rendered into the UI presentation of the application. Its main job is to manage the bindings between the concrete element and the UI \'widget\' representing it in the UI. Since: 1.0 The following features are supported: Widget Renderer To Be Rendered On Top Visible Parent Container Data Cur Shared Ref Visible When Accessibility Phrase A representation of the model object \'UI Label\'. This is a mix in that will be used for UI Elements that are capable of showing label information in the GUI (e.g. Parts, Menus / Toolbars, Persepectives...) Since: 1.0 The following features are supported: Label Icon URI Tooltip extends MItem, MToolBarElement A representation of the model object \'Tool Item\'. This is the base type for both Direct and Handled tool items. Since: 1.0 The following features are supported: Menu extends MApplicationElement A representation of the model object \'UI Element\'. This is the base mix-in shared by all model elements that can be rendered into the UI presentation of the application. Its main job is to manage the bindings between the concrete element and the UI \'widget\' representing it in the UI. Since: 1.0 The following features are supported: Widget Renderer To Be Rendered On Top Visible Parent Container Data Cur Shared Ref Visible When Accessibility Phrase A representation of the model object \'UI Label\'. This is a mix in that will be used for UI Elements that are capable of showing label information in the GUI (e.g. Parts, Menus / Toolbars, Persepectives...) Since: 1.0 The following features are supported: Label Icon URI Tooltip extends MToolItem, MHandledItem A representation of the model object \'Handled Tool Item\'. This is the concrete UI Model element representing a tool item that is managed through the Commands / Handlers infrastructure. Since: 1.0 '
112, 'org.eclipse.e4.ui.model.application.ui.menu.MTrimContribution', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/e4/ui/model/application/ui/menu/MTrimContribution.html', ' A representation of the model object \'Element\'. This is the root element for all UI Model elements, defining attribtues common to every element; the element\'s id as well as three general storage elements: Tags: This is a set of strings which can be used to stereotype a particular element. Tags may be specified in element searches and can also be referred to in the CSS styling definition. PersistedState: A string to string map used to store information that nneds to be persisted between sessions. TransientData: A string to object map which can be used to store runtime data relevant to a particular model element. Since: 1.0 The following features are supported: Element Id Persisted State Tags Contributor URI Transient Data extends MApplicationElement A representation of the model object \'UI Element\'. This is the base mix-in shared by all model elements that can be rendered into the UI presentation of the application. Its main job is to manage the bindings between the concrete element and the UI \'widget\' representing it in the UI. Since: 1.0 The following features are supported: Widget Renderer To Be Rendered On Top Visible Parent Container Data Cur Shared Ref Visible When Accessibility Phrase extends MElementContainer<MTrimElement> A representation of the model object \'Trim Contribution\'. Provisional for 4.3. This represents a potential extension to some trim bar. Since: 1.0 The following features are supported: Parent Id Position In Parent Restriction: This interface is not intended to be referenced by clients. '
113, 'org.eclipse.e4.ui.model.application.commands.MBindingContext', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/e4/ui/model/application/commands/MBindingContext.html', ' A representation of the model object \'Element\'. This is the root element for all UI Model elements, defining attribtues common to every element; the element\'s id as well as three general storage elements: Tags: This is a set of strings which can be used to stereotype a particular element. Tags may be specified in element searches and can also be referred to in the CSS styling definition. PersistedState: A string to string map used to store information that nneds to be persisted between sessions. TransientData: A string to object map which can be used to store runtime data relevant to a particular model element. Since: 1.0 The following features are supported: Element Id Persisted State Tags Contributor URI Transient Data extends MApplicationElement A representation of the model object \'Binding Context\'. This class describes the hierarchy of contexts that are used by the EBindingService to determine which Bindings are currently available to the user. Since: 1.0 The following features are supported: Name Description Children '
114, 'org.eclipse.e4.ui.model.application.MApplicationFactory', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/e4/ui/model/application/MApplicationFactory.html', ' The Factory for the model. It provides a create method for each non-abstract class of the model. Since: 1.0 '
115, 'org.eclipse.e4.core.services.events.IEventBroker', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/e4/core/services/events/IEventBroker.html', 'To obtain an instance of the event broker service from the IEclipseContext context, use (IEventBroker) context.get(IEventBroker.class.getName()) Since: 1.1 Restriction: This interface is not intended to be implemented by clients. '
116, 'org.eclipse.e4.ui.model.application.ui.menu.MMenuFactory', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/e4/ui/model/application/ui/menu/MMenuFactory.html', ' The Factory for the model. It provides a create method for each non-abstract class of the model. Since: 1.0 '
117, 'org.eclipse.e4.core.contexts.ContextFunction', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/e4/core/contexts/ContextFunction.html', 'A context function encapsulates evaluation of some code within an IEclipseContext. The result of the function must be derived purely from the provided arguments and context objects, and must be free from side-effects other than the function\'s return value. In particular, the function must be idempotent - subsequent invocations of the same function with the same inputs must produce the same result. A common use for context functions is as a place holder for an object that has not yet been created. These place holders can be stored as values in an IEclipseContext, allowing the concrete value they represent to be computed lazily only when requested. Context functions can optionally be registered as OSGi services. Context implementations may use such registered services to seed context instances with initial values. Registering your context function as a service is a signal that contexts are free to add an instance of your function to their context automatically, using the key specified by the SERVICE_CONTEXT_KEY service property. Since: 1.3 See Also: IEclipseContext.set(String, Object) Restriction: This interface is not intended to be implemented by clients. Function implementations must subclass ContextFunction instead. extends Object implements IContextFunction The base class for all computed value implementations. Clients may subclass this class. See the class comment of IContextFunction for specific rules that must be followed by function implementations. This class is intended to be subclassed by clients. Since: 1.3 See Also: IContextFunction '
118, 'org.eclipse.osgi.service.datalocation.Location', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/osgi/service/datalocation/Location.html', 'A Location represents a URL which may have a default value, may be read only, may or may not have a current value and may be cascaded on to a parent location. This interface is not intended to be implemented by clients. Since: 3.0 Restriction: This interface is not intended to be implemented by clients. '
119, 'org.eclipse.e4.ui.workbench.IResourceUtilities', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/e4/ui/workbench/IResourceUtilities.html', 'ImageDesc> This interface describes a utility that is used to load ImageDesc\'s from URIs Since: 1.0 Restriction: This interface is not intended to be implemented by clients. '
120, 'org.eclipse.e4.ui.workbench.modeling.ESelectionService', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/e4/ui/workbench/modeling/ESelectionService.html', 'This interface describes the workbench selection service Since: 1.0 Restriction: This interface is not intended to be implemented by clients. '
121, 'org.eclipse.e4.core.contexts.RunAndTrack', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/e4/core/contexts/RunAndTrack.html', 'extends Object Instances of this class contain behavior that is executed within an IEclipseContext. The context records all values accessed by this object, and will re-evaluate this runnable whenever any accessed value changes. Since: 1.3 See Also: IEclipseContext.runAndTrack(RunAndTrack) '
122, 'org.eclipse.e4.ui.workbench.modeling.ISelectionListener', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/e4/ui/workbench/modeling/ISelectionListener.html', ' Since: 1.0 Restriction: This interface is not intended to be referenced by clients. '
123, 'org.eclipse.e4.ui.model.application.ui.basic.MInputPart', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/e4/ui/model/application/ui/basic/MInputPart.html', ' A representation of the model object \'Element\'. This is the root element for all UI Model elements, defining attribtues common to every element; the element\'s id as well as three general storage elements: Tags: This is a set of strings which can be used to stereotype a particular element. Tags may be specified in element searches and can also be referred to in the CSS styling definition. PersistedState: A string to string map used to store information that nneds to be persisted between sessions. TransientData: A string to object map which can be used to store runtime data relevant to a particular model element. Since: 1.0 The following features are supported: Element Id Persisted State Tags Contributor URI Transient Data A representation of the model object \'Bindings\'. Mixin interface that lists MBindingContexts that should be active when this object is active. Example values: org.eclipse.ui.contexts.dialog, org.eclipse.ui.contexts.window Since: 1.0 The following features are supported: Binding Contexts A representation of the model object \'Context\'. This class is mixed into a UI element when that element is expected to participate in the Dependency Injection context hierarchy. The context life-cycle matches that of the rendered element it belongs to. It\'s automatically created when the element is rendered and disposed when the element is unrendered. Since: 1.0 The following features are supported: Context Variables Properties extends MApplicationElement A representation of the model object \'Contribution\'. MContribution is a mix-in class used by concrete elements such as Parts to define the location of the client supplied class implementing the specific logic needed. Since: 1.0 The following features are supported: Contribution URI Object A representation of the model object \'Dirtyable\'. This class should be mixed into any UI element that should participate in the dirty / save handling. Parts are the most likely scenario for this but it exists as a mix-in to allow for future model extensions. Since: 1.0 The following features are supported: Dirty A representation of the model object \'Handler Container\'. This provides a container in which to store lists of Handlers. Since: 1.0 The following features are supported: Handlers A representation of the model object \'Input\'. This class should be mixed into UI elements such as InputParts that need to reference an external resource (files...). Since: 1.0 The following features are supported: Input URI extends MUIElement A representation of the model object \'Part Sash Container Element\'. A class to be mixed in to any element that should be allowed to be added to a PartSashContainer. Since a PartSashContainer is itself a PartSashContainerElement we can defined nested \'trees\' of sash containment. Since: 1.0 extends MUIElement A representation of the model object \'Stack Element\'. A class to be mixed in to any element that should be allowed to be added to a PartStack. Since: 1.0 extends MApplicationElement A representation of the model object \'UI Element\'. This is the base mix-in shared by all model elements that can be rendered into the UI presentation of the application. Its main job is to manage the bindings between the concrete element and the UI \'widget\' representing it in the UI. Since: 1.0 The following features are supported: Widget Renderer To Be Rendered On Top Visible Parent Container Data Cur Shared Ref Visible When Accessibility Phrase A representation of the model object \'UI Label\'. This is a mix in that will be used for UI Elements that are capable of showing label information in the GUI (e.g. Parts, Menus / Toolbars, Persepectives...) Since: 1.0 The following features are supported: Label Icon URI Tooltip extends MUIElement A representation of the model object \'Window Element\'. A class to be mixed in to any element that should be allowed to be added to a Window. Since: 1.0 extends MPart, MInput A representation of the model object \'Input Part\'. This is a subclass of Part that allows tracking of an \'input\'. While originally defined as a type of \'editor\' it turns out that it may well be better to just use a regular Part and to store what would be the input as an entry on the Part\'s \'persistentData\' map. Since: 1.0 '
124, 'org.eclipse.e4.ui.workbench.modeling.ISaveHandler', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/e4/ui/workbench/modeling/ISaveHandler.html', ' Since: 1.0 Restriction: This interface is not intended to be referenced by clients. '
125, 'org.eclipse.e4.ui.model.application.ui.MGenericStack', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/e4/ui/model/application/ui/MGenericStack.html', ' A representation of the model object \'Element\'. This is the root element for all UI Model elements, defining attribtues common to every element; the element\'s id as well as three general storage elements: Tags: This is a set of strings which can be used to stereotype a particular element. Tags may be specified in element searches and can also be referred to in the CSS styling definition. PersistedState: A string to string map used to store information that nneds to be persisted between sessions. TransientData: A string to object map which can be used to store runtime data relevant to a particular model element. Since: 1.0 The following features are supported: Element Id Persisted State Tags Contributor URI Transient Data extends MApplicationElement A representation of the model object \'UI Element\'. This is the base mix-in shared by all model elements that can be rendered into the UI presentation of the application. Its main job is to manage the bindings between the concrete element and the UI \'widget\' representing it in the UI. Since: 1.0 The following features are supported: Widget Renderer To Be Rendered On Top Visible Parent Container Data Cur Shared Ref Visible When Accessibility Phrase T extends MUIElement> extends MElementContainer<T> A representation of the model object \'Generic Stack\'. This type defines the base type for \'stack\' type containers. These containers are expected to only show their currently \'selected\' element. Since: 1.0 '
126, 'org.eclipse.e4.ui.workbench.UIEvents', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/e4/ui/workbench/UIEvents.html', 'extends Object E4 UI events and event topic definitions. This file contains generated and hand crafted event topic constants. There are also hand crafted utility methods for constructing topic strings and publishing events. When the UI model changes org.eclipse.e4.ui.internal.workbench.swt.GenTopic should be run as an Eclipse application and the console results should be pasted into this file replacing the code below the \"Place Generated Code Here\" comment Since: 1.0 Restriction: This class is not intended to be subclassed by clients. Restriction: This class is not intended to be instantiated by clients. '
127, 'org.eclipse.core.runtime.Assert', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/runtime/Assert.html', 'extends Object Assert is useful for for embedding runtime sanity checks in code. The predicate methods all test a condition and throw some type of unchecked exception if the condition does not hold. Assertion failure exceptions, like most runtime exceptions, are thrown when something is misbehaving. Assertion failures are invariably unspecified behavior; consequently, clients should never rely on these being thrown (and certainly should not be catching them specifically). This class can be used without OSGi running. This class is not intended to be instantiated or sub-classed by clients. Since: org.eclipse.equinox.common 3.2 Restriction: This class is not intended to be instantiated by clients. '
128, 'org.eclipse.e4.ui.model.application.commands.MCommandsFactory', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/e4/ui/model/application/commands/MCommandsFactory.html', ' The Factory for the model. It provides a create method for each non-abstract class of the model. Since: 1.0 '
129, 'org.eclipse.e4.ui.model.application.descriptor.basic.MBasicFactory', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/e4/ui/model/application/descriptor/basic/MBasicFactory.html', ' The Factory for the model. It provides a create method for each non-abstract class of the model. Since: 1.0 '
130, 'org.eclipse.swt.graphics.Resource', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/graphics/Resource.html', 'extends Object This class is the abstract superclass of all graphics resource objects. Resources created by the application must be disposed. IMPORTANT: This class is intended to be subclassed only within the SWT implementation. However, it has not been marked final to allow those outside of the SWT development team to implement patched versions of the class in order to get around specific limitations in advance of when those limitations can be addressed by the team. Any class built using subclassing to access the internals of this class will likely fail to compile or run between releases and may be strongly platform specific. Subclassing should not be attempted without an intimate and detailed understanding of the workings of the hierarchy. No support is provided for user-written classes which are implemented as subclasses of this class. Since: 3.1 See Also: dispose(), isDisposed(), Sample code and further information '
131, 'org.eclipse.swt.graphics.Font', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/graphics/Font.html', 'extends Resource Instances of this class manage operating system resources that define how text looks when it is displayed. Fonts may be constructed by providing a device and either name, size and style information or a FontData object which encapsulates this data. Application code must explicitly invoke the Font.dispose() method to release the operating system resources managed by each instance when those instances are no longer required. See Also: FontData, Font snippets, SWT Examples: GraphicsExample, PaintExample, Sample code and further information '
132, 'org.eclipse.swt.graphics.Color', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/graphics/Color.html', 'extends Resource Instances of this class manage the operating system resources that implement SWT\'s RGB color model. To create a color you can either specify the individual color components as integers in the range 0 to 255 or provide an instance of an RGB. Application code must explicitly invoke the Color.dispose() method to release the operating system resources managed by each instance when those instances are no longer required. See Also: RGB, Device.getSystemColor(int), Color and RGB snippets, SWT Example: PaintExample, Sample code and further information '
133, 'org.eclipse.core.commands.CommandManager', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/commands/CommandManager.html', 'An instance of this interface can be used by clients to receive notification of changes to one or more instances of Category. This interface may be implemented by clients. Since: 3.1 See Also: Category.addCategoryListener(ICategoryListener), Category.removeCategoryListener(ICategoryListener) An instance of this interface can be used by clients to receive notification of changes to one or more instances of Command. This interface may be implemented by clients. Since: 3.1 See Also: Command.addCommandListener(ICommandListener), Command.removeCommandListener(ICommandListener) An instance of this interface can be used by clients to receive notification of changes to one or more instances of ParameterType. This interface may be implemented by clients. Since: 3.2 See Also: ParameterType.addListener(IParameterTypeListener), ParameterType.removeListener(IParameterTypeListener) extends HandleObjectManager implements ICategoryListener, ICommandListener, IParameterTypeListener A central repository for commands -- both in the defined and undefined states. Commands can be created and retrieved using this manager. It is possible to listen to changes in the collection of commands by attaching a listener to the manager. Since: 3.1 See Also: getCommand(String) '
134, 'org.eclipse.core.commands.contexts.ContextManager', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/commands/contexts/ContextManager.html', 'An instance of this interface can be used by clients to receive notification of changes to one or more instances of IContext. This interface may be implemented by clients. Since: 3.1 See Also: Context.addContextListener(IContextListener), Context.removeContextListener(IContextListener) extends HandleObjectManager implements IContextListener A context manager tracks the sets of defined and enabled contexts within the application. The manager sends notification events to listeners when these sets change. It is also possible to retrieve any given context with its identifier. This class is not intended to be extended by clients. Since: 3.1 '
135, 'org.eclipse.jface.bindings.keys.KeyBinding', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/bindings/keys/KeyBinding.html', 'extends Binding A keyboard shortcut. This is a binding between some keyboard input and the triggering of a command. This object is immutable. Since: 3.1 '
136, 'org.eclipse.jface.bindings.Binding', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/bindings/Binding.html', 'extends Object A binding is a link between user input and the triggering of a particular command. The most common example of a binding is a keyboard shortcut, but there are also mouse and gesture bindings. Bindings are linked to particular conditions within the application. Some of these conditions change infrequently (e.g., locale, scheme), while some will tend to change quite frequently (e.g., context). This allows the bindings to be tailored to particular situations. For example, a set of bindings may be appropriate only inside a text editor. Or, perhaps, a set of bindings might be appropriate only for a given locale, such as bindings that coexist with the Input Method Editor (IME) on Chinese locales. It is also possible to remove a particular binding. This is typically done as part of user configuration (e.g., user changing keyboard shortcuts). However, it can also be helpful when trying to change a binding on a particular locale or platform. An \"unbinding\" is really just a binding with no command identifier. For it to unbind a particular binding, it must match that binding in its context identifier and scheme identifier. Subclasses (e.g., KeyBinding) may require other properties to match (e.g., keySequence). If these properties match, then this is an unbinding. Note: the locale and platform can be different. For example, imagine you have a key binding that looks like this: KeyBinding(command, scheme, context, \"Ctrl+Shift+F\") On GTK+, the \"Ctrl+Shift+F\" interferes with some native behaviour. To change the binding, we first unbind the \"Ctrl+Shift+F\" key sequence by assigning it a null command on the gtk platform. We then create a new binding that maps the command to the \"Esc Ctrl+F\" key sequence. KeyBinding(\"Ctrl+Shift+F\",null,scheme,context,null,gtk,null,SYSTEM) KeyBinding(\"Esc Ctrl+F\",parameterizedCommand,scheme,context,null,gtk,SYSTEM) Bindings are intended to be immutable objects. Since: 3.1 '
137, 'org.eclipse.jface.bindings.keys.KeySequence', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/bindings/keys/KeySequence.html', 'extends TriggerSequence implements Comparable A KeySequence is defined as a list of zero or more KeyStrokes, with the stipulation that all KeyStroke objects must be complete, save for the last one, whose completeness is optional. A KeySequence is said to be complete if all of its KeyStroke objects are complete. All KeySequence objects have a formal string representation available via the toString() method. There are a number of methods to get instances of KeySequence objects, including one which can parse this formal string representation. All KeySequence objects, via the format() method, provide a version of their formal string representation translated by platform and locale, suitable for display to a user. KeySequence objects are immutable. Clients are not permitted to extend this class. Since: 3.1 '
138, 'org.eclipse.ui.plugin.AbstractUIPlugin', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/plugin/AbstractUIPlugin.html', 'extends Plugin Abstract base class for plug-ins that integrate with the Eclipse platform UI. Subclasses obtain the following capabilities: Preferences The platform core runtime contains general support for plug-in preferences (org.eclipse.core.runtime.Preferences). This class provides appropriate conversion to the older JFace preference API (org.eclipse.jface.preference.IPreferenceStore). The method getPreferenceStore returns the JFace preference store (cf. Plugin.getPluginPreferences which returns a core runtime preferences object. Subclasses may reimplement initializeDefaultPreferences to set up any default values for preferences using JFace API. In this case, initializeDefaultPluginPreferences should not be overridden. Subclasses may reimplement initializeDefaultPluginPreferences to set up any default values for preferences using core runtime API. In this case, initializeDefaultPreferences should not be overridden. Preferences are also saved automatically on plug-in shutdown. However, saving preferences immediately after changing them is strongly recommended, since that ensures that preference settings are not lost even in the event of a platform crash. Dialogs The dialog store is read the first time getDialogSettings is called. The dialog store allows the plug-in to \"record\" important choices made by the user in a wizard or dialog, so that the next time the wizard/dialog is used the widgets can be defaulted to better values. A wizard could also use it to record the last 5 values a user entered into an editable combo - to show \"recent values\". The dialog store is found in the file whose name is given by the constant FN_DIALOG_STORE. A dialog store file is first looked for in the plug-in\'s read/write state area; if not found there, the plug-in\'s install directory is checked. This allows a plug-in to ship with a read-only copy of a dialog store file containing initial values for certain settings. Plug-in code can call saveDialogSettings to cause settings to be saved in the plug-in\'s read/write state area. A plug-in may opt to do this each time a wizard or dialog is closed to ensure the latest information is always safe on disk. Dialog settings are also saved automatically on plug-in shutdown. Images A typical UI plug-in will have some images that are used very frequently and so need to be cached and shared. The plug-in\'s image registry provides a central place for a plug-in to store its common images. Images managed by the registry are created lazily as needed, and will be automatically disposed of when the plug-in shuts down. Note that the number of registry images should be kept to a minimum since many OSs have severe limits on the number of images that can be in memory at once. For easy access to your plug-in object, use the singleton pattern. Declare a static variable in your plug-in class for the singleton. Store the first (and only) instance of the plug-in class in the singleton when it is created. Then access the singleton when needed through a static getDefault method. See the description on Plugin. '
139, 'org.eclipse.swt.widgets.Text', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/widgets/Text.html', 'Implementers of Drawable can have a graphics context (GC) created for them, and then they can be drawn on by sending messages to their associated GC. SWT images, and device objects such as the Display device and the Printer device, are drawables. IMPORTANT: This interface is not part of the SWT public API. It is marked public only so that it can be shared within the packages provided by SWT. It should never be referenced from application code. See Also: Device, Image, GC extends Scrollable Instances of this class are selectable user interface objects that allow the user to enter and modify text. Text controls can be either single or multi-line. When a text control is created with a border, the operating system includes a platform specific inset around the contents of the control. When created without a border, an effort is made to remove the inset such that the preferred size of the control is the same size as the contents. Styles: CENTER, ICON_CANCEL, ICON_SEARCH, LEFT, MULTI, PASSWORD, SEARCH, SINGLE, RIGHT, READ_ONLY, WRAP Events: DefaultSelection, Modify, Verify, OrientationChange Note: Only one of the styles MULTI and SINGLE may be specified, and only one of the styles LEFT, CENTER, and RIGHT may be specified. Note: The styles ICON_CANCEL and ICON_SEARCH are hints used in combination with SEARCH. When the platform supports the hint, the text control shows these icons. When an icon is selected, a default selection event is sent with the detail field set to one of ICON_CANCEL or ICON_SEARCH. Normally, application code does not need to check the detail. In the case of ICON_CANCEL, the text is cleared before the default selection event is sent causing the application to search for an empty string. IMPORTANT: This class is not intended to be subclassed. See Also: Text snippets, SWT Example: ControlExample, Sample code and further information Restriction: This class is not intended to be subclassed by clients. '
140, 'org.eclipse.jface.action.ToolBarManager', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/action/ToolBarManager.html', 'A contribution manager organizes contributions to such UI components as menus, toolbars and status lines. A contribution manager keeps track of a list of contribution items. Each contribution item may has an optional identifier, which can be used to retrieve items from a manager, and for positioning items relative to each other. The list of contribution items can be subdivided into named groups using special contribution items that serve as group markers. The IContributionManager interface provides general protocol for adding, removing, and retrieving contribution items. It also provides convenience methods that make it convenient to contribute actions. This interface should be implemented by all objects that wish to manage contributions. There are several implementions of this interface in this package, including ones for menus (MenuManager), tool bars (ToolBarManager), and status lines (StatusLineManager). extends IContributionManager The IToolBarManager interface provides protocol for managing contributions to a tool bar. It extends IContributionManager but does not declare any new members; it exists only to increase the readability of code using tool bars. This package also provides a concrete tool bar manager implementation, ToolBarManager. extends ContributionManager implements IToolBarManager A tool bar manager is a contribution manager which realizes itself and its items in a tool bar control. This class may be instantiated; it may also be subclassed if a more sophisticated layout is required. '
141, 'org.eclipse.ui.dialogs.PatternFilter', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/dialogs/PatternFilter.html', 'extends ViewerFilter A filter used in conjunction with FilteredTree. In order to determine if a node should be filtered it uses the content and label provider of the tree to do pattern matching on its children. This causes the entire tree structure to be realized. Note that the label provider must implement ILabelProvider. Since: 3.2 See Also: FilteredTree '
142, 'org.eclipse.core.runtime.jobs.Job', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/runtime/jobs/Job.html', 'An interface for an adaptable object. Adaptable objects can be dynamically extended to provide different interfaces (or \"adapters\"). Adapters are created by adapter factories, which are in turn managed by type by adapter managers. For example, IAdaptable a = [some adaptable]; IFoo x = (IFoo)a.getAdapter(IFoo.class); if (x != null) [do IFoo things with x] This interface can be used without OSGi running. Clients may implement this interface, or obtain a default implementation of this interface by subclassing PlatformObject. See Also: IAdapterFactory, IAdapterManager, PlatformObject extends org.eclipse.core.internal.jobs.InternalJob implements IAdaptable Jobs are units of runnable work that can be scheduled to be run with the job manager. Once a job has completed, it can be scheduled to run again (jobs are reusable). Jobs have a state that indicates what they are currently doing. When constructed, jobs start with a state value of NONE. When a job is scheduled to be run, it moves into the WAITING state. When a job starts running, it moves into the RUNNING state. When execution finishes (either normally or through cancelation), the state changes back to NONE. A job can also be in the SLEEPING state. This happens if a user calls Job.sleep() on a waiting job, or if a job is scheduled to run after a specified delay. Only jobs in the WAITING state can be put to sleep. Sleeping jobs can be woken at any time using Job.wakeUp(), which will put the job back into the WAITING state. Jobs can be assigned a priority that is used as a hint about how the job should be scheduled. There is no guarantee that jobs of one priority will be run before all jobs of lower priority. The javadoc for the various priority constants provide more detail about what each priority means. By default, jobs start in the LONG priority class. Since: 3.0 See Also: IJobManager '
143, 'org.eclipse.swt.layout.GridLayout', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/layout/GridLayout.html', 'extends Layout Instances of this class lay out the control children of a Composite in a grid. GridLayout has a number of configuration fields, and the controls it lays out can have an associated layout data object, called GridData. The power of GridLayout lies in the ability to configure GridData for each control in the layout. The following code creates a shell managed by a GridLayout with 3 columns: Display display = new Display(); Shell shell = new Shell(display); GridLayout gridLayout = new GridLayout(); gridLayout.numColumns = 3; shell.setLayout(gridLayout); The numColumns field is the most important field in a GridLayout. Widgets are laid out in columns from left to right, and a new row is created when numColumns + 1 controls are added to the Composite. See Also: GridData, GridLayout snippets, SWT Example: LayoutExample, Sample code and further information '
144, 'org.eclipse.swt.layout.GridData', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/layout/GridData.html', 'extends Object GridData is the layout data object associated with GridLayout. To set a GridData object into a control, you use the Control.setLayoutData(Object) method. There are two ways to create a GridData object with certain fields set. The first is to set the fields directly, like this: GridData gridData = new GridData(); gridData.horizontalAlignment = GridData.FILL; gridData.grabExcessHorizontalSpace = true; button1.setLayoutData(gridData); gridData = new GridData(); gridData.horizontalAlignment = GridData.FILL; gridData.verticalAlignment = GridData.FILL; gridData.grabExcessHorizontalSpace = true; gridData.grabExcessVerticalSpace = true; gridData.horizontalSpan = 2; button2.setLayoutData(gridData); The second is to take advantage of GridData convenience constructors, for example: button1.setLayoutData(new GridData (SWT.FILL, SWT.CENTER, true, false)); button2.setLayoutData(new GridData (SWT.FILL, SWT.FILL, true, true, 2, 1)); NOTE: Do not reuse GridData objects. Every control in a Composite that is managed by a GridLayout must have a unique GridData object. If the layout data for a control in a GridLayout is null at layout time, a unique GridData object is created for it. See Also: GridLayout, Control.setLayoutData(java.lang.Object), Sample code and further information '
145, 'org.eclipse.swt.widgets.TreeItem', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/widgets/TreeItem.html', 'extends Item Instances of this class represent a selectable user interface object that represents a hierarchy of tree items in a tree widget. Styles: (none) Events: (none) IMPORTANT: This class is not intended to be subclassed. See Also: Tree, TreeItem, TreeColumn snippets, Sample code and further information Restriction: This class is not intended to be subclassed by clients. '
146, 'org.eclipse.ui.progress.WorkbenchJob', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/progress/WorkbenchJob.html', 'An interface for an adaptable object. Adaptable objects can be dynamically extended to provide different interfaces (or \"adapters\"). Adapters are created by adapter factories, which are in turn managed by type by adapter managers. For example, IAdaptable a = [some adaptable]; IFoo x = (IFoo)a.getAdapter(IFoo.class); if (x != null) [do IFoo things with x] This interface can be used without OSGi running. Clients may implement this interface, or obtain a default implementation of this interface by subclassing PlatformObject. See Also: IAdapterFactory, IAdapterManager, PlatformObject extends UIJob WorkbenchJob is a type of job that implements a done listener and does the shutdown checks before scheduling. This is used if a job is not meant to run when the Workbench is shutdown. Since: 3.0 '
147, 'org.eclipse.core.runtime.IProgressMonitor', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/runtime/IProgressMonitor.html', 'The IProgressMonitor interface is implemented by objects that monitor the progress of an activity; the methods in this interface are invoked by code that performs the activity. All activity is broken down into a linear sequence of tasks against which progress is reported. When a task begins, a beginTask(String, int) notification is reported, followed by any number and mixture of progress reports (worked()) and subtask notifications (subTask(String)). When the task is eventually completed, a done() notification is reported. After the done() notification, the progress monitor cannot be reused; i.e., beginTask(String, int) cannot be called again after the call to done(). A request to cancel an operation can be signaled using the setCanceled method. Operations taking a progress monitor are expected to poll the monitor (using isCanceled) periodically and abort at their earliest convenience. Operation can however choose to ignore cancelation requests. Since notification is synchronous with the activity itself, the listener should provide a fast and robust implementation. If the handling of notifications would involve blocking operations, or operations which might throw uncaught exceptions, the notifications should be queued, and the actual processing deferred (or perhaps delegated to a separate thread). This interface can be used without OSGi running. Clients may implement this interface. '
148, 'org.eclipse.swt.accessibility.AccessibleAdapter', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/accessibility/AccessibleAdapter.html', 'extends org.eclipse.swt.internal.SWTEventListener Classes that implement this interface provide methods that deal with the events that are generated when an accessibility client sends a message to a control. After creating an instance of a class that implements this interface it can be added to a control using the addAccessibleListener method and removed using the removeAccessibleListener method. When a client requests information, the appropriate method will be invoked. Note: Accessibility clients use child identifiers to specify whether they want information about a control or one of its children. Child identifiers are increasing integers beginning with 0. The identifier CHILDID_SELF represents the control itself. Since: 2.0 See Also: AccessibleAdapter, AccessibleEvent extends Object implements AccessibleListener This adapter class provides default implementations for the methods described by the AccessibleListener interface. Classes that wish to deal with AccessibleEvents can extend this class and override only the methods that they are interested in. Note: Accessibility clients use child identifiers to specify whether they want information about a control or one of its children. Child identifiers are increasing integers beginning with 0. The identifier CHILDID_SELF represents the control itself. Since: 2.0 See Also: AccessibleListener, AccessibleEvent, Sample code and further information '
149, 'org.eclipse.swt.events.FocusAdapter', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/events/FocusAdapter.html', 'extends org.eclipse.swt.internal.SWTEventListener Classes which implement this interface provide methods that deal with the events that are generated as controls gain and lose focus. After creating an instance of a class that implements this interface it can be added to a control using the addFocusListener method and removed using the removeFocusListener method. When a control gains or loses focus, the appropriate method will be invoked. See Also: FocusAdapter, FocusEvent extends Object implements FocusListener This adapter class provides default implementations for the methods described by the FocusListener interface. Classes that wish to deal with FocusEvents can extend this class and override only the methods which they are interested in. See Also: FocusListener, FocusEvent, Sample code and further information '
150, 'org.eclipse.swt.events.MouseAdapter', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/events/MouseAdapter.html', 'extends org.eclipse.swt.internal.SWTEventListener Classes which implement this interface provide methods that deal with the events that are generated as mouse buttons are pressed. After creating an instance of a class that implements this interface it can be added to a control using the addMouseListener method and removed using the removeMouseListener method. When a mouse button is pressed or released, the appropriate method will be invoked. See Also: MouseAdapter, MouseEvent extends Object implements MouseListener This adapter class provides default implementations for the methods described by the MouseListener interface. Classes that wish to deal with MouseEvents which occur as mouse buttons are pressed and released can extend this class and override only the methods which they are interested in. See Also: MouseListener, MouseEvent, Sample code and further information '
151, 'org.eclipse.swt.events.KeyAdapter', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/events/KeyAdapter.html', 'extends org.eclipse.swt.internal.SWTEventListener Classes which implement this interface provide methods that deal with the events that are generated as keys are pressed on the system keyboard. After creating an instance of a class that implements this interface it can be added to a control using the addKeyListener method and removed using the removeKeyListener method. When a key is pressed or released, the appropriate method will be invoked. See Also: KeyAdapter, KeyEvent extends Object implements KeyListener This adapter class provides default implementations for the methods described by the KeyListener interface. Classes that wish to deal with KeyEvents can extend this class and override only the methods which they are interested in. See Also: KeyListener, KeyEvent, Sample code and further information '
152, 'org.eclipse.swt.events.TraverseListener', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/events/TraverseListener.html', 'extends org.eclipse.swt.internal.SWTEventListener Classes which implement this interface provide a method that deals with the events that are generated when a traverse event occurs in a control. After creating an instance of a class that implements this interface it can be added to a control using the addTraverseListener method and removed using the removeTraverseListener method. When a traverse event occurs in a control, the keyTraversed method will be invoked. See Also: TraverseEvent '
153, 'org.eclipse.swt.events.ModifyListener', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/events/ModifyListener.html', 'extends org.eclipse.swt.internal.SWTEventListener Classes which implement this interface provide a method that deals with the events that are generated when text is modified. After creating an instance of a class that implements this interface it can be added to a text widget using the addModifyListener method and removed using the removeModifyListener method. When the text is modified, the modifyText method will be invoked. See Also: ModifyEvent '
154, 'org.eclipse.swt.events.SelectionAdapter', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/events/SelectionAdapter.html', 'extends org.eclipse.swt.internal.SWTEventListener Classes which implement this interface provide methods that deal with the events that are generated when selection occurs in a control. After creating an instance of a class that implements this interface it can be added to a control using the addSelectionListener method and removed using the removeSelectionListener method. When selection occurs in a control the appropriate method will be invoked. See Also: SelectionAdapter, SelectionEvent extends Object implements SelectionListener This adapter class provides default implementations for the methods described by the SelectionListener interface. Classes that wish to deal with SelectionEvents can extend this class and override only the methods which they are interested in. See Also: SelectionListener, SelectionEvent, Sample code and further information '
155, 'org.eclipse.swt.accessibility.AccessibleEvent', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/accessibility/AccessibleEvent.html', 'extends org.eclipse.swt.internal.SWTEventObject Instances of this class are sent as a result of accessibility clients sending messages to controls asking for information about the control instance. Note: The meaning of the result field depends on the message that was sent. Since: 2.0 See Also: AccessibleListener, AccessibleAdapter, Sample code and further information, Serialized Form '
156, 'org.eclipse.swt.events.FocusEvent', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/events/FocusEvent.html', 'extends TypedEvent Instances of this class are sent as a result of widgets gaining and losing focus. See Also: FocusListener, Sample code and further information, Serialized Form '
157, 'org.eclipse.swt.events.MouseEvent', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/events/MouseEvent.html', 'extends TypedEvent Instances of this class are sent whenever mouse related actions occur. This includes mouse buttons being pressed and released, the mouse pointer being moved and the mouse pointer crossing widget boundaries. Note: The button field is an integer that represents the mouse button number. This is not the same as the SWT mask constants BUTTONx. See Also: MouseListener, MouseMoveListener, MouseTrackListener, Sample code and further information, Serialized Form '
158, 'org.eclipse.swt.events.KeyEvent', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/events/KeyEvent.html', 'extends TypedEvent Instances of this class are sent as a result of keys being pressed and released on the keyboard. When a key listener is added to a control, the control will take part in widget traversal. By default, all traversal keys (such as the tab key and so on) are delivered to the control. In order for a control to take part in traversal, it should listen for traversal events. Otherwise, the user can traverse into a control but not out. Note that native controls such as table and tree implement key traversal in the operating system. It is not necessary to add traversal listeners for these controls, unless you want to override the default traversal. See Also: KeyListener, TraverseListener, Sample code and further information, Serialized Form '
159, 'org.eclipse.swt.events.TraverseEvent', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/events/TraverseEvent.html', 'extends KeyEvent Instances of this class are sent as a result of widget traversal actions. The traversal event allows fine control over keyboard traversal in a control both to implement traversal and override the default traversal behavior defined by the system. This is achieved using two fields, detail and doit. When a control is traversed, a traverse event is sent. The detail describes the type of traversal and the doit field indicates the default behavior of the system. For example, when a right arrow key is pressed in a text control, the detail field is TRAVERSE_ARROW_NEXT and the doit field is false, indicating that the system will not traverse to the next tab item and the arrow key will be delivered to the text control. If the same key is pressed in a radio button, the doit field will be true, indicating that traversal is to proceed to the next tab item, possibly another radio button in the group and that the arrow key is not to be delivered to the radio button. How can the traversal event be used to implement traversal? When a tab key is pressed in a canvas, the detail field will be TRAVERSE_TAB_NEXT and the doit field will be false. The default behavior of the system is to provide no traversal for canvas controls. This means that by default in a canvas, a key listener will see every key that the user types, including traversal keys. To understand why this is so, it is important to understand that only the widget implementor can decide which traversal is appropriate for the widget. Returning to the TRAVERSE_TAB_NEXT example, a text widget implemented by a canvas would typically want to use the tab key to insert a tab character into the widget. A list widget implementation, on the other hand, would like the system default traversal behavior. Using only the doit flag, both implementations are possible. The text widget implementor sets doit to false, ensuring that the system will not traverse and that the tab key will be delivered to key listeners. The list widget implementor sets doit to true, indicating that the system should perform tab traversal and that the key should not be delivered to the list widget. How can the traversal event be used to override system traversal? When the return key is pressed in a single line text control, the detail field is TRAVERSE_RETURN and the doit field is true. This means that the return key will be processed by the default button, not the text widget. If the text widget has a default selection listener, it will not run because the return key will be processed by the default button. Imagine that the text control is being used as an in-place editor and return is used to dispose the widget. Setting doit to false will stop the system from activating the default button but the key will be delivered to the text control, running the key and selection listeners for the text. How can TRAVERSE_RETURN be implemented so that the default button will not be activated and the text widget will not see the return key? This is achieved by setting doit to true, and the detail to TRAVERSE_NONE. Note: A widget implementor will typically implement traversal using only the doit flag to either enable or disable system traversal. See Also: TraverseListener, Sample code and further information, Serialized Form '
160, 'org.eclipse.swt.events.ModifyEvent', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/events/ModifyEvent.html', 'extends TypedEvent Instances of this class are sent as a result of text being modified. See Also: ModifyListener, Sample code and further information, Serialized Form '
161, 'org.eclipse.swt.events.SelectionEvent', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/events/SelectionEvent.html', 'extends TypedEvent Instances of this class are sent as a result of widgets being selected. Note: The fields that are filled in depend on the widget. See Also: SelectionListener, Sample code and further information, Serialized Form '
162, 'org.eclipse.jface.viewers.ISelection', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/viewers/ISelection.html', 'Interface for a selection. See Also: ISelectionProvider, ISelectionChangedListener, SelectionChangedEvent '
163, 'org.eclipse.jface.action.Action', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/action/Action.html', 'An action represents the non-UI side of a command which can be triggered by the end user. Actions are typically associated with buttons, menu items, and items in tool bars. The controls for a command are built by some container, which furnished the context where these controls appear and configures them with data from properties declared by the action. When the end user triggers the command via its control, the action\'s run method is invoked to do the real work. Actions support a predefined set of properties (and possibly others as well). Clients of an action may register property change listeners so that they get notified whenever the value of a property changes. Clients should subclass the abstract base class Action to define concrete actions rather than implementing IAction from scratch. This interface exists only to define the API for actions. It is not intended to be implemented by clients. See Also: Action Restriction: This interface is not intended to be implemented by clients. extends AbstractAction implements IAction The standard abstract implementation of an action. Subclasses must implement the IAction.run method to carry out the action\'s semantics. '
164, 'org.eclipse.swt.events.MouseTrackListener', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/events/MouseTrackListener.html', 'extends org.eclipse.swt.internal.SWTEventListener Classes which implement this interface provide methods that deal with the events that are generated as the mouse pointer passes (or hovers) over controls. After creating an instance of a class that implements this interface it can be added to a control using the addMouseTrackListener method and removed using the removeMouseTrackListener method. When the mouse pointer passes into or out of the area of the screen covered by a control or pauses while over a control, the appropriate method will be invoked. See Also: MouseTrackAdapter, MouseEvent '
165, 'org.eclipse.swt.accessibility.AccessibleControlAdapter', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/accessibility/AccessibleControlAdapter.html', 'extends org.eclipse.swt.internal.SWTEventListener Classes that implement this interface provide methods that deal with the events that are generated when an accessibility client sends a message to a control. After creating an instance of a class that implements this interface it can be added to a control using the addAccessibleControlListener method and removed using the removeAccessibleControlListener method. When a client requests information the appropriate method will be invoked. Note: Accessibility clients use child identifiers to specify whether they want information about a control or one of its children. Child identifiers are increasing integers beginning with 0. The identifier CHILDID_SELF represents the control itself. Note: This interface is typically used by implementors of a custom control to provide very detailed information about the control instance to accessibility clients. Since: 2.0 See Also: AccessibleControlAdapter, AccessibleControlEvent extends Object implements AccessibleControlListener This adapter class provides default implementations for the methods described by the AccessibleControlListener interface. Classes that wish to deal with AccessibleControlEvents can extend this class and override only the methods that they are interested in. Note: Accessibility clients use child identifiers to specify whether they want information about a control or one of its children. Child identifiers are increasing integers beginning with 0. The identifier CHILDID_SELF represents the control itself. When returning a child identifier to a client, you may use CHILDID_NONE to indicate that no child or control has the required information. Note: This adapter is typically used by implementors of a custom control to provide very detailed information about the control instance to accessibility clients. Since: 2.0 See Also: AccessibleControlListener, AccessibleControlEvent, Sample code and further information '
166, 'org.eclipse.swt.events.MouseMoveListener', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/events/MouseMoveListener.html', 'extends org.eclipse.swt.internal.SWTEventListener Classes which implement this interface provide a method that deals with the events that are generated as the mouse pointer moves. After creating an instance of a class that implements this interface it can be added to a control using the addMouseMoveListener method and removed using the removeMouseMoveListener method. As the mouse moves, the mouseMove method will be invoked. See Also: MouseEvent '
167, 'org.eclipse.swt.graphics.Point', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/graphics/Point.html', 'extends Object implements org.eclipse.swt.internal.SerializableCompatibility Instances of this class represent places on the (x, y) coordinate plane. The coordinate space for rectangles and points is considered to have increasing values downward and to the right from its origin making this the normal, computer graphics oriented notion of (x, y) coordinates rather than the strict mathematical one. The hashCode() method in this class uses the values of the public fields to compute the hash value. When storing instances of the class in hashed collections, do not modify these fields after the object has been inserted. Application code does not need to explicitly release the resources managed by each instance when those instances are no longer required, and thus no dispose() method is provided. See Also: Rectangle, Sample code and further information, Serialized Form '
168, 'org.eclipse.swt.accessibility.AccessibleControlEvent', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/accessibility/AccessibleControlEvent.html', 'extends org.eclipse.swt.internal.SWTEventObject Instances of this class are sent as a result of accessibility clients sending messages to controls asking for detailed information about the implementation of the control instance. Typically, only implementors of custom controls need to listen for this event. Note: The meaning of each field depends on the message that was sent. Since: 2.0 See Also: AccessibleControlListener, AccessibleControlAdapter, Sample code and further information, Serialized Form '
169, 'org.eclipse.jface.resource.JFaceResources', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/resource/JFaceResources.html', 'extends Object Utility methods to access JFace-specific resources. All methods declared on this class are static. This class cannot be instantiated. The following global state is also maintained by this class: a font registry a color registry an image registry a resource bundle Restriction: This class is not intended to be subclassed by clients. Restriction: This class is not intended to be instantiated by clients. '
170, 'org.eclipse.ui.dialogs.FilteredTree', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/dialogs/FilteredTree.html', 'Implementers of Drawable can have a graphics context (GC) created for them, and then they can be drawn on by sending messages to their associated GC. SWT images, and device objects such as the Display device and the Printer device, are drawables. IMPORTANT: This interface is not part of the SWT public API. It is marked public only so that it can be shared within the packages provided by SWT. It should never be referenced from application code. See Also: Device, Image, GC extends Composite A simple control that provides a text widget and a tree viewer. The contents of the text widget are used to drive a PatternFilter that is on the viewer. Since: 3.2 See Also: PatternFilter '
171, 'org.eclipse.jface.dialogs.TrayDialog', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/dialogs/TrayDialog.html', 'Interface for objects that can return a shell. This is normally used for opening child windows. An object that wants to open child shells can take an IShellProvider in its constructor, and the object that implements IShellProvider can dynamically choose where child shells should be opened. Since: 3.1 extends Dialog A TrayDialog is a specialized Dialog that can contain a tray on its side. The tray\'s content is provided as a DialogTray. It is recommended to subclass this class instead of Dialog in all cases except where the dialog should never show a tray. For example, dialogs which are very short, simple, and quick to dismiss (e.g. a message dialog with an OK button) should subclass Dialog. Note: Trays are not supported on dialogs that use a custom layout on the Shell by overriding Window#getLayout(). Since: 3.2 See Also: DialogTray, Window.getLayout() '
172, 'org.eclipse.swt.widgets.TabFolder', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/widgets/TabFolder.html', 'Implementers of Drawable can have a graphics context (GC) created for them, and then they can be drawn on by sending messages to their associated GC. SWT images, and device objects such as the Display device and the Printer device, are drawables. IMPORTANT: This interface is not part of the SWT public API. It is marked public only so that it can be shared within the packages provided by SWT. It should never be referenced from application code. See Also: Device, Image, GC extends Composite Instances of this class implement the notebook user interface metaphor. It allows the user to select a notebook page from set of pages. The item children that may be added to instances of this class must be of type TabItem. Control children are created and then set into a tab item using TabItem#setControl. Note that although this class is a subclass of Composite, it does not make sense to set a layout on it. Styles: TOP, BOTTOM Events: Selection Note: Only one of the styles TOP and BOTTOM may be specified. IMPORTANT: This class is not intended to be subclassed. See Also: TabFolder, TabItem snippets, SWT Example: ControlExample, Sample code and further information Restriction: This class is not intended to be subclassed by clients. '
173, 'org.eclipse.jface.resource.ImageDescriptor', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/resource/ImageDescriptor.html', 'extends DeviceResourceDescriptor An image descriptor is an object that knows how to create an SWT image. It does not hold onto images or cache them, but rather just creates them on demand. An image descriptor is intended to be a lightweight representation of an image that can be manipulated even when no SWT display exists. This package defines a concrete image descriptor implementation which reads an image from a file (FileImageDescriptor). It also provides abstract framework classes (this one and CompositeImageDescriptor) which may be subclassed to define news kinds of image descriptors. Using this abstract class involves defining a concrete subclass and providing an implementation for the getImageData method. There are two ways to get an Image from an ImageDescriptor. The method createImage will always return a new Image which must be disposed by the caller. Alternatively, createResource() returns a shared Image. When the caller is done with an image obtained from createResource, they must call destroyResource() rather than disposing the Image directly. The result of createResource() can be safely cast to an Image. See Also: Image '
174, 'org.eclipse.swt.widgets.TabItem', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/widgets/TabItem.html', 'extends Item Instances of this class represent a selectable user interface object corresponding to a tab for a page in a tab folder. Styles: (none) Events: (none) IMPORTANT: This class is not intended to be subclassed. See Also: TabFolder, TabItem snippets, Sample code and further information Restriction: This class is not intended to be subclassed by clients. '
175, 'org.eclipse.jface.viewers.CheckboxTableViewer', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/viewers/CheckboxTableViewer.html', 'Interface for objects that support elements with a checked state. See Also: ICheckStateListener, CheckStateChangedEvent Interface common to all objects that provide an input. extends IInputProvider, ISelectionProvider Interface common to all objects that provide both an input and a selection. extends ISelectionProvider Selection provider extension interface to allow providers to notify about post selection changed events. A post selection changed event is equivalent to selection changed event if the selection change was triggered by the mouse, but it has a delay if the selection change is triggered by keyboard navigation. Since: 3.0 See Also: ISelectionProvider Interface common to all objects that provide a selection. See Also: ISelection, ISelectionChangedListener, SelectionChangedEvent extends TableViewer implements ICheckable A concrete viewer based on an SWT Table control with checkboxes on each node. This class supports setting an ICheckStateProvider to set the checkbox states. To see standard SWT behavior, view SWT Snippet274. This class is not intended to be subclassed outside the viewer framework. It is designed to be instantiated with a pre-existing SWT table control and configured with a domain-specific content provider, label provider, element filter (optional), and element sorter (optional). Restriction: This class is not intended to be subclassed by clients. '
176, 'org.eclipse.jface.viewers.CheckboxTreeViewer', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/viewers/CheckboxTreeViewer.html', 'Interface for objects that support elements with a checked state. See Also: ICheckStateListener, CheckStateChangedEvent Interface common to all objects that provide an input. extends IInputProvider, ISelectionProvider Interface common to all objects that provide both an input and a selection. extends ISelectionProvider Selection provider extension interface to allow providers to notify about post selection changed events. A post selection changed event is equivalent to selection changed event if the selection change was triggered by the mouse, but it has a delay if the selection change is triggered by keyboard navigation. Since: 3.0 See Also: ISelectionProvider Interface common to all objects that provide a selection. See Also: ISelection, ISelectionChangedListener, SelectionChangedEvent extends TreeViewer implements ICheckable A concrete tree-structured viewer based on an SWT Tree control with checkboxes on each node. This class supports setting an ICheckStateProvider to set the checkbox states. To see standard SWT behavior, view SWT Snippet274. This class is not intended to be subclassed outside the viewer framework. It is designed to be instantiated with a pre-existing SWT tree control and configured with a domain-specific content provider, label provider, element filter (optional), and element sorter (optional). Restriction: This class is not intended to be subclassed by clients. '
177, 'org.eclipse.jface.action.ActionContributionItem', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/action/ActionContributionItem.html', 'A contribution item represents a contribution to a shared UI resource such as a menu or tool bar. More generally, contribution items are managed by a contribution manager. For instance, in a tool bar a contribution item is a tool bar button or a separator. In a menu bar a contribution item is a menu, and in a menu a contribution item is a menu item or separator. A contribution item can realize itself in different SWT widgets, using the different fill methods. The same type of contribution item can be used with a MenuBarManager, ToolBarManager, CoolBarManager, or a StatusLineManager. This interface is internal to the framework; it should not be implemented outside the framework. See Also: IContributionManager Restriction: This interface is not intended to be implemented by clients. extends ContributionItem A contribution item which delegates to an action. This class may be instantiated; it is not intended to be subclassed. Restriction: This class is not intended to be subclassed by clients. '
178, 'org.eclipse.ui.wizards.IWizardDescriptor', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/wizards/IWizardDescriptor.html', 'An interface for an adaptable object. Adaptable objects can be dynamically extended to provide different interfaces (or \"adapters\"). Adapters are created by adapter factories, which are in turn managed by type by adapter managers. For example, IAdaptable a = [some adaptable]; IFoo x = (IFoo)a.getAdapter(IFoo.class); if (x != null) [do IFoo things with x] This interface can be used without OSGi running. Clients may implement this interface, or obtain a default implementation of this interface by subclassing PlatformObject. See Also: IAdapterFactory, IAdapterManager, PlatformObject Description of a workbench part. The part descriptor contains the information needed to create part instances. This interface is not intended to be implemented by clients. Restriction: This interface is not intended to be implemented by clients. extends IWorkbenchPartDescriptor, IAdaptable Base interface for all wizards defined via workbench extension points. This interface is not intended to be implemented by clients. Since: 3.1 Restriction: This interface is not intended to be implemented by clients. '
179, 'org.eclipse.ui.actions.OpenPerspectiveAction', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/actions/OpenPerspectiveAction.html', 'An action represents the non-UI side of a command which can be triggered by the end user. Actions are typically associated with buttons, menu items, and items in tool bars. The controls for a command are built by some container, which furnished the context where these controls appear and configures them with data from properties declared by the action. When the end user triggers the command via its control, the action\'s run method is invoked to do the real work. Actions support a predefined set of properties (and possibly others as well). Clients of an action may register property change listeners so that they get notified whenever the value of a property changes. Clients should subclass the abstract base class Action to define concrete actions rather than implementing IAction from scratch. This interface exists only to define the API for actions. It is not intended to be implemented by clients. See Also: Action Restriction: This interface is not intended to be implemented by clients. An interface that descriptor classes may implement in addition to their descriptor interface. This indicates that they may or may not originate from a plugin contribution. This is useful in various activity filtering scenarios. Since: 3.0 extends Action implements IPluginContribution Opens a perspective. Since: 3.1 '
180, 'org.eclipse.ui.IPerspectiveDescriptor', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/IPerspectiveDescriptor.html', 'A perspective descriptor describes a perspective in an IPerspectiveRegistry. A perspective is a template for view visibility, layout, and action visibility within a workbench page. There are two types of perspective: a predefined perspective and a custom perspective. A predefined perspective is defined by an extension to the workbench\'s perspective extension point (\"org.eclipse.ui.perspectives\"). The extension defines a id, label, and IPerspectiveFactory. A perspective factory is used to define the initial layout for a page. A custom perspective is defined by the user. In this case a predefined perspective is modified to suit a particular task and saved as a new perspective. The attributes for the perspective are stored in a separate file in the workbench\'s metadata directory. Within a page the user can open any of the perspectives known to the workbench\'s perspective registry, typically by selecting one from the workbench\'s Open Perspective menu. When selected, the views and actions within the active page rearrange to reflect the perspective. This interface is not intended to be implemented by clients. See Also: IPerspectiveRegistry Restriction: This interface is not intended to be implemented by clients. '
181, 'org.eclipse.ui.actions.ActionFactory', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/actions/ActionFactory.html', 'extends Object Access to standard actions provided by the workbench. Most of the functionality of this class is provided by static methods and fields. Example usage: MenuManager menu = ...; ActionFactory.IWorkbenchAction closeEditorAction = ActionFactory.CLOSE.create(window); menu.add(closeEditorAction); Clients may declare other classes that provide additional application-specific action factories. Since: 3.0 '
182, 'org.eclipse.osgi.util.NLS', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/osgi/util/NLS.html', 'extends Object Common superclass for all message bundle classes. Provides convenience methods for manipulating messages. The #bind methods perform string substitution and should be considered a convenience and not a full substitute replacement for MessageFormat#format method calls. Text appearing within curly braces in the given message, will be interpreted as a numeric index to the corresponding substitution object in the given array. Calling the #bind methods with text that does not map to an integer will result in an IllegalArgumentException. Text appearing within single quotes is treated as a literal. A single quote is escaped by a preceeding single quote. Clients who wish to use the full substitution power of the MessageFormat class should call that class directly and not use these #bind methods. Clients may subclass this type. Since: 3.1 '
183, 'org.eclipse.swt.graphics.FontData', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/graphics/FontData.html', 'extends Object Instances of this class describe operating system fonts. For platform-independent behaviour, use the get and set methods corresponding to the following properties: height the height of the font in points name the face name of the font, which may include the foundry style A bitwise combination of NORMAL, ITALIC and BOLD If extra, platform-dependent functionality is required: On Windows, the data member of the FontData corresponds to a Windows LOGFONT structure whose fields may be retrieved and modified. On X, the fields of the FontData correspond to the entries in the font\'s XLFD name and may be retrieved and modified. Application code does not need to explicitly release the resources managed by each instance when those instances are no longer required, and thus no dispose() method is provided. See Also: Font, Sample code and further information '
184, 'org.eclipse.swt.widgets.Combo', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/widgets/Combo.html', 'Implementers of Drawable can have a graphics context (GC) created for them, and then they can be drawn on by sending messages to their associated GC. SWT images, and device objects such as the Display device and the Printer device, are drawables. IMPORTANT: This interface is not part of the SWT public API. It is marked public only so that it can be shared within the packages provided by SWT. It should never be referenced from application code. See Also: Device, Image, GC extends Composite Instances of this class are controls that allow the user to choose an item from a list of items, or optionally enter a new value by typing it into an editable text field. Often, Combos are used in the same place where a single selection List widget could be used but space is limited. A Combo takes less space than a List widget and shows similar information. Note: Since Combos can contain both a list and an editable text field, it is possible to confuse methods which access one versus the other (compare for example, clearSelection() and deselectAll()). The API documentation is careful to indicate either \"the receiver\'s list\" or the \"the receiver\'s text field\" to distinguish between the two cases. Note that although this class is a subclass of Composite, it does not make sense to add children to it, or set a layout on it. Styles: DROP_DOWN, READ_ONLY, SIMPLE Events: DefaultSelection, Modify, Selection, Verify, OrientationChange Note: Only one of the styles DROP_DOWN and SIMPLE may be specified. IMPORTANT: This class is not intended to be subclassed. See Also: List, Combo snippets, SWT Example: ControlExample, Sample code and further information Restriction: This class is not intended to be subclassed by clients. '
185, 'org.eclipse.jface.viewers.ComboViewer', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/viewers/ComboViewer.html', 'Interface common to all objects that provide an input. extends IInputProvider, ISelectionProvider Interface common to all objects that provide both an input and a selection. extends ISelectionProvider Selection provider extension interface to allow providers to notify about post selection changed events. A post selection changed event is equivalent to selection changed event if the selection change was triggered by the mouse, but it has a delay if the selection change is triggered by keyboard navigation. Since: 3.0 See Also: ISelectionProvider Interface common to all objects that provide a selection. See Also: ISelection, ISelectionChangedListener, SelectionChangedEvent extends AbstractListViewer A concrete viewer based either on an SWT Combo control or CCombo control. This class is intended as an alternative to the JFace ListViewer, which displays its content in a combo box rather than a list. Wherever possible, this class attempts to behave like ListViewer. This class is designed to be instantiated with a pre-existing SWT combo control and configured with a domain-specific content provider, label provider, element filter (optional), and element sorter (optional). Since: 3.0 (made non-final in 3.4) See Also: ListViewer '
186, 'org.eclipse.ui.model.WorkbenchViewerComparator', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/model/WorkbenchViewerComparator.html', 'extends ViewerComparator A viewer comparator that sorts elements with registered workbench adapters by their text property. Note that capitalization differences are not considered by this sorter, so a > B > c Since: 3.3 See Also: IWorkbenchAdapter '
187, 'org.eclipse.jface.viewers.ICheckStateListener', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/viewers/ICheckStateListener.html', 'A listener which is notified of changes to the checked state of items in checkbox viewers. See Also: CheckStateChangedEvent '
188, 'org.eclipse.swt.widgets.TableColumn', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/widgets/TableColumn.html', 'extends Item Instances of this class represent a column in a table widget. Styles: LEFT, RIGHT, CENTER Events: Move, Resize, Selection Note: Only one of the styles LEFT, RIGHT and CENTER may be specified. IMPORTANT: This class is not intended to be subclassed. See Also: Table, TableItem, TableColumn snippets, Sample code and further information Restriction: This class is not intended to be subclassed by clients. '
189, 'org.eclipse.jface.viewers.CheckStateChangedEvent', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/viewers/CheckStateChangedEvent.html', 'extends EventObject Event object describing a change to the checked state of a viewer element. See Also: ICheckStateListener, Serialized Form '
190, 'org.eclipse.swt.widgets.Table', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/widgets/Table.html', 'Implementers of Drawable can have a graphics context (GC) created for them, and then they can be drawn on by sending messages to their associated GC. SWT images, and device objects such as the Display device and the Printer device, are drawables. IMPORTANT: This interface is not part of the SWT public API. It is marked public only so that it can be shared within the packages provided by SWT. It should never be referenced from application code. See Also: Device, Image, GC extends Composite Instances of this class implement a selectable user interface object that displays a list of images and strings and issues notification when selected. The item children that may be added to instances of this class must be of type TableItem. Style VIRTUAL is used to create a Table whose TableItems are to be populated by the client on an on-demand basis instead of up-front. This can provide significant performance improvements for tables that are very large or for which TableItem population is expensive (for example, retrieving values from an external source). Here is an example of using a Table with style VIRTUAL: final Table table = new Table (parent, SWT.VIRTUAL | SWT.BORDER); table.setItemCount (1000000); table.addListener (SWT.SetData, new Listener () { public void handleEvent (Event event) { TableItem item = (TableItem) event.item; int index = table.indexOf (item); item.setText (\"Item \" + index); System.out.println (item.getText ()); } }); Note that although this class is a subclass of Composite, it does not normally make sense to add Control children to it, or set a layout on it, unless implementing something like a cell editor. Styles: SINGLE, MULTI, CHECK, FULL_SELECTION, HIDE_SELECTION, VIRTUAL, NO_SCROLL Events: Selection, DefaultSelection, SetData, MeasureItem, EraseItem, PaintItem Note: Only one of the styles SINGLE, and MULTI may be specified. IMPORTANT: This class is not intended to be subclassed. See Also: Table, TableItem, TableColumn snippets, SWT Example: ControlExample, Sample code and further information Restriction: This class is not intended to be subclassed by clients. '
191, 'org.eclipse.jface.viewers.IStructuredSelection', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/viewers/IStructuredSelection.html', 'Interface for a selection. See Also: ISelectionProvider, ISelectionChangedListener, SelectionChangedEvent extends ISelection A selection containing elements. '
192, 'org.eclipse.jface.viewers.ArrayContentProvider', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/viewers/ArrayContentProvider.html', 'A content provider mediates between the viewer\'s model and the viewer itself. See Also: ContentViewer.setContentProvider(IContentProvider) extends IContentProvider An interface to content providers for structured viewers. See Also: StructuredViewer extends Object implements IStructuredContentProvider This implementation of IStructuredContentProvider handles the case where the viewer input is an unchanging array or collection of elements. This class is not intended to be subclassed outside the viewer framework. Since: 2.1 Restriction: This class is not intended to be subclassed by clients. '
193, 'org.eclipse.jface.viewers.ICheckStateProvider', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/viewers/ICheckStateProvider.html', 'Interface to provide checked and grayed state information about data in trees or tables. The following chart determines the checkbox state: isGrayed() false true isChecked() false unchecked true checked grayed Since: 3.5 '
194, 'org.eclipse.jface.viewers.ViewerFilter', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/viewers/ViewerFilter.html', 'extends Object A viewer filter is used by a structured viewer to extract a subset of elements provided by its content provider. Subclasses must implement the select method and may implement the isFilterProperty method. See Also: IStructuredContentProvider, StructuredViewer '
195, 'org.eclipse.ui.part.PageBook', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/part/PageBook.html', 'Implementers of Drawable can have a graphics context (GC) created for them, and then they can be drawn on by sending messages to their associated GC. SWT images, and device objects such as the Display device and the Printer device, are drawables. IMPORTANT: This interface is not part of the SWT public API. It is marked public only so that it can be shared within the packages provided by SWT. It should never be referenced from application code. See Also: Device, Image, GC extends Composite A pagebook is a composite control where only a single control is visible at a time. It is similar to a notebook, but without tabs. This class may be instantiated; it is not intended to be subclassed. Note that although this class is a subclass of Composite, it does not make sense to set a layout on it. See Also: PageBookView Restriction: This class is not intended to be subclassed by clients. '
196, 'org.eclipse.jface.viewers.TableViewer', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/viewers/TableViewer.html', 'Interface common to all objects that provide an input. extends IInputProvider, ISelectionProvider Interface common to all objects that provide both an input and a selection. extends ISelectionProvider Selection provider extension interface to allow providers to notify about post selection changed events. A post selection changed event is equivalent to selection changed event if the selection change was triggered by the mouse, but it has a delay if the selection change is triggered by keyboard navigation. Since: 3.0 See Also: ISelectionProvider Interface common to all objects that provide a selection. See Also: ISelection, ISelectionChangedListener, SelectionChangedEvent extends AbstractTableViewer A concrete viewer based on a SWT Table control. This class is not intended to be subclassed outside the viewer framework. It is designed to be instantiated with a pre-existing SWT table control and configured with a domain-specific content provider, table label provider, element filter (optional), and element sorter (optional). Label providers for table viewers must implement either the ITableLabelProvider or the ILabelProvider interface (see TableViewer.setLabelProvider for more details). As of 3.1 the TableViewer now supports the SWT.VIRTUAL flag. If the underlying table is SWT.VIRTUAL, the content provider may implement ILazyContentProvider instead of IStructuredContentProvider . Note that in this case, the viewer does not support sorting or filtering. Also note that in this case, the Widget based APIs may return null if the element is not specified or not created yet. Users of SWT.VIRTUAL should also avoid using getItems() from the Table within the TreeViewer as this does not necessarily generate a callback for the TreeViewer to populate the items. It also has the side effect of creating all of the items thereby eliminating the performance improvements of SWT.VIRTUAL. Users setting up an editable table with more than 1 column have to pass the SWT.FULL_SELECTION style bit See Also: SWT.VIRTUAL, doFindItem(Object), AbstractTableViewer.internalRefresh(Object, boolean) Restriction: This class is not intended to be subclassed by clients. '
197, 'org.eclipse.jface.viewers.StructuredSelection', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/viewers/StructuredSelection.html', 'Interface for a selection. See Also: ISelectionProvider, ISelectionChangedListener, SelectionChangedEvent Interface for a selection. See Also: ISelectionProvider, ISelectionChangedListener, SelectionChangedEvent extends ISelection A selection containing elements. extends Object implements IStructuredSelection A concrete implementation of the IStructuredSelection interface, suitable for instantiating. This class is not intended to be subclassed. Restriction: This class is not intended to be subclassed by clients. '
198, 'org.eclipse.ui.keys.IBindingService', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/keys/IBindingService.html', ' The interface that should be implemented by services that make themselves available through the IAdaptable mechanism. This is the interface that drives the majority of services provided at the workbench level. A service has life-cycle. When the constructor completes, the service must be fully functional. When it comes time for the service to go away, then the service will receive a dispose() call. At this point, the service must release all resources and detach all listeners. A service can only be disposed once; it cannot be reused. This interface has nothing to do with OSGi services. This interface can be extended or implemented by clients. Since: 3.2 extends IDisposable Provides services related to the binding architecture (e.g., keyboard shortcuts) within the workbench. This service can be used to access the currently active bindings, as well as the current state of the binding architecture. This service can be acquired from your service locator: IBindingService service = (IBindingService) getSite().getService(IBindingService.class); This service is available globally. Since: 3.1 Restriction: This interface is not intended to be implemented by clients. Restriction: This interface is not intended to be extended by clients. '
199, 'org.eclipse.jface.bindings.BindingManager', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/bindings/BindingManager.html', 'An instance of this interface can be used by clients to receive notification of changes to one or more instances of IContextManager. This interface may be implemented by clients. Since: 3.1 See Also: ContextManager.addContextManagerListener(IContextManagerListener), ContextManager.removeContextManagerListener(IContextManagerListener) An instance of ISchemeListener can be used by clients to receive notification of changes to one or more instances of IScheme. This interface may be implemented by clients. Since: 3.1 See Also: Scheme.addSchemeListener(ISchemeListener), Scheme.removeSchemeListener(ISchemeListener), SchemeEvent extends HandleObjectManager implements IContextManagerListener, ISchemeListener A central repository for bindings -- both in the defined and undefined states. Schemes and bindings can be created and retrieved using this manager. It is possible to listen to changes in the collection of schemes and bindings by adding a listener to the manager. The binding manager is very sensitive to performance. Misusing the manager can render an application unenjoyable to use. As such, each of the public methods states the current run-time performance. In future releases, it is guaranteed that the method will run in at least the stated time constraint -- though it might get faster. Where possible, we have also tried to be memory efficient. Since: 3.1 '
200, 'org.eclipse.ui.activities.WorkbenchActivityHelper', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/activities/WorkbenchActivityHelper.html', 'extends Object A utility class that contains helpful methods for interacting with the activities API. Since: 3.0 '
201, 'org.eclipse.ui.IWorkbenchActionConstants', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/IWorkbenchActionConstants.html', 'Action ids for standard actions, groups in the workbench menu bar, and global actions. This interface contains constants only; it is not intended to be implemented or extended. Standard menus File menu (M_FILE) Edit menu (M_EDIT) Window menu (M_WINDOW) Help menu (M_HELP) Standard group for adding top level menus Extra top level menu group (MB_ADDITIONS) Global actions Undo (UNDO) Redo (REDO) Cut (CUT) Copy (COPY) Paste (PASTE) Delete (DELETE) Find (FIND) Select All (SELECT_ALL) Add Bookmark (BOOKMARK) Standard File menu actions Start group (FILE_START) End group (FILE_END) New action (NEW) Extra New-like action group (NEW_EXT) Close action (CLOSE) Close All action (CLOSE_ALL) Extra Close-like action group (CLOSE_EXT) Save action (SAVE) Save As action (SAVE_AS) Save All action (SAVE_ALL) Extra Save-like action group (SAVE_EXT) Import action (IMPORT) Export action (EXPORT) Extra Import-like action group (IMPORT_EXT) Quit action (QUIT) Standard Edit menu actions Start group (EDIT_START) End group (EDIT_END) Undo global action (UNDO) Redo global action (REDO) Extra Undo-like action group (UNDO_EXT) Cut global action (CUT) Copy global action (COPY) Paste global action (PASTE) Extra Cut-like action group (CUT_EXT) Delete global action (DELETE) Find global action (FIND) Select All global action (SELECT_ALL) Bookmark global action (BOOKMARK) Standard Perspective menu actions Extra Perspective-like action group (VIEW_EXT) Standard Workbench menu actions Start group (WB_START) End group (WB_END) Extra Build-like action group (BUILD_EXT) Build action (BUILD) Rebuild All action (REBUILD_ALL) Standard Window menu actions Extra Window-like action group (WINDOW_EXT) Standard Help menu actions Start group (HELP_START) End group (HELP_END) About action (ABOUT) Standard pop-up menu groups Managing group (GROUP_MANAGING) Reorganize group (GROUP_REORGANIZE) Add group (GROUP_ADD) File group (GROUP_FILE) To hook a global action handler, a view should use the following code: IAction copyHandler = ...; view.getSite().getActionBars().setGlobalActionHandler( IWorkbenchActionConstants.COPY, copyHandler); For editors, this should be done in the IEditorActionBarContributor. See Also: Note: many of the remaining non-deprecated constants here are IDE-specific and should be deprecated and moved to a constant pool at the IDE layer (e.g. IIDEActionConstants). Restriction: This interface is not intended to be implemented by clients. Restriction: This interface is not intended to be extended by clients. '
202, 'org.eclipse.ui.wizards.IWizardCategory', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/wizards/IWizardCategory.html', 'A wizard category may contain other categories or wizard elements. This interface is not intended to be implemented by clients. Since: 3.1 Restriction: This interface is not intended to be implemented by clients. '
203, 'org.eclipse.ui.IPerspectiveRegistry', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/IPerspectiveRegistry.html', 'The workbench\'s global registry of perspectives. This registry contains a descriptor for each perspectives in the workbench. It is initially populated with stock perspectives from the workbench\'s perspective extension point (\"org.eclipse.ui.perspectives\") and with custom perspectives defined by the user. This interface is not intended to be implemented by clients. See Also: IWorkbench.getPerspectiveRegistry() Restriction: This interface is not intended to be implemented by clients. '
204, 'org.eclipse.ui.views.IViewRegistry', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/views/IViewRegistry.html', 'The view registry maintains a list of views explicitly registered against the view extension point.. The description of a given view is kept in a IViewDescriptor. This interface is not intended to be implemented by clients. Since: 3.1 See Also: IViewDescriptor, IStickyViewDescriptor Restriction: This interface is not intended to be implemented by clients. '
205, 'org.eclipse.ui.views.IViewCategory', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/views/IViewCategory.html', 'Represents a categorization of views. This interface is not intended to be implemented by clients. Since: 3.1 '
206, 'org.eclipse.ui.views.IViewDescriptor', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/views/IViewDescriptor.html', 'An interface for an adaptable object. Adaptable objects can be dynamically extended to provide different interfaces (or \"adapters\"). Adapters are created by adapter factories, which are in turn managed by type by adapter managers. For example, IAdaptable a = [some adaptable]; IFoo x = (IFoo)a.getAdapter(IFoo.class); if (x != null) [do IFoo things with x] This interface can be used without OSGi running. Clients may implement this interface, or obtain a default implementation of this interface by subclassing PlatformObject. See Also: IAdapterFactory, IAdapterManager, PlatformObject Description of a workbench part. The part descriptor contains the information needed to create part instances. This interface is not intended to be implemented by clients. Restriction: This interface is not intended to be implemented by clients. extends IWorkbenchPartDescriptor, IAdaptable This is a view descriptor. It provides a \"description\" of a given given view so that the view can later be constructed. The view registry provides facilities to map from an extension to a IViewDescriptor. This interface is not intended to be implemented by clients. Since: 3.1 See Also: IViewRegistry Restriction: This interface is not intended to be implemented by clients. '
207, 'org.eclipse.swt.widgets.Decorations', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/widgets/Decorations.html', 'Implementers of Drawable can have a graphics context (GC) created for them, and then they can be drawn on by sending messages to their associated GC. SWT images, and device objects such as the Display device and the Printer device, are drawables. IMPORTANT: This interface is not part of the SWT public API. It is marked public only so that it can be shared within the packages provided by SWT. It should never be referenced from application code. See Also: Device, Image, GC extends Canvas Instances of this class provide the appearance and behavior of Shells, but are not top level shells or dialogs. Class Shell shares a significant amount of code with this class, and is a subclass. IMPORTANT: This class was intended to be abstract and should never be referenced or instantiated. Instead, the class Shell should be used. Instances are always displayed in one of the maximized, minimized or normal states: When an instance is marked as maximized, the window manager will typically resize it to fill the entire visible area of the display, and the instance is usually put in a state where it can not be resized (even if it has style RESIZE) until it is no longer maximized. When an instance is in the normal state (neither maximized or minimized), its appearance is controlled by the style constants which were specified when it was created and the restrictions of the window manager (see below). When an instance has been marked as minimized, its contents (client area) will usually not be visible, and depending on the window manager, it may be \"iconified\" (that is, replaced on the desktop by a small simplified representation of itself), relocated to a distinguished area of the screen, or hidden. Combinations of these changes are also possible. Note: The styles supported by this class must be treated as HINTs, since the window manager for the desktop on which the instance is visible has ultimate control over the appearance and behavior of decorations. For example, some window managers only support resizable windows and will always assume the RESIZE style, even if it is not set. Styles: BORDER, CLOSE, MIN, MAX, NO_TRIM, RESIZE, TITLE, ON_TOP, TOOL Events: (none) Class SWT provides two \"convenience constants\" for the most commonly required style combinations: SHELL_TRIM the result of combining the constants which are required to produce a typical application top level shell: (that is, CLOSE | TITLE | MIN | MAX | RESIZE) DIALOG_TRIM the result of combining the constants which are required to produce a typical application dialog shell: (that is, TITLE | CLOSE | BORDER) IMPORTANT: This class is intended to be subclassed only within the SWT implementation. See Also: getMinimized(), getMaximized(), Shell, SWT, Sample code and further information Restriction: This class is not intended to be subclassed by clients. '
208, 'org.eclipse.swt.widgets.CoolBar', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/widgets/CoolBar.html', 'Implementers of Drawable can have a graphics context (GC) created for them, and then they can be drawn on by sending messages to their associated GC. SWT images, and device objects such as the Display device and the Printer device, are drawables. IMPORTANT: This interface is not part of the SWT public API. It is marked public only so that it can be shared within the packages provided by SWT. It should never be referenced from application code. See Also: Device, Image, GC extends Composite Instances of this class provide an area for dynamically positioning the items they contain. The item children that may be added to instances of this class must be of type CoolItem. Note that although this class is a subclass of Composite, it does not make sense to add Control children to it, or set a layout on it. Styles: FLAT, HORIZONTAL, VERTICAL Events: (none) Note: Only one of the styles HORIZONTAL and VERTICAL may be specified. IMPORTANT: This class is not intended to be subclassed. See Also: CoolBar snippets, SWT Example: ControlExample, Sample code and further information Restriction: This class is not intended to be subclassed by clients. '
209, 'org.eclipse.ui.menus.CommandContributionItem', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/menus/CommandContributionItem.html', 'A contribution item represents a contribution to a shared UI resource such as a menu or tool bar. More generally, contribution items are managed by a contribution manager. For instance, in a tool bar a contribution item is a tool bar button or a separator. In a menu bar a contribution item is a menu, and in a menu a contribution item is a menu item or separator. A contribution item can realize itself in different SWT widgets, using the different fill methods. The same type of contribution item can be used with a MenuBarManager, ToolBarManager, CoolBarManager, or a StatusLineManager. This interface is internal to the framework; it should not be implemented outside the framework. See Also: IContributionManager Restriction: This interface is not intended to be implemented by clients. extends ContributionItem A contribution item which delegates to a command. It can be used in AbstractContributionFactory.createContributionItems(IServiceLocator, IContributionRoot). It currently supports placement in menus and toolbars. This class may be instantiated; it is not intended to be subclassed. Since: 3.3 Restriction: This class is not intended to be subclassed by clients. '
210, 'org.eclipse.e4.ui.model.application.ui.MUIElement', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/e4/ui/model/application/ui/MUIElement.html', ' A representation of the model object \'Element\'. This is the root element for all UI Model elements, defining attribtues common to every element; the element\'s id as well as three general storage elements: Tags: This is a set of strings which can be used to stereotype a particular element. Tags may be specified in element searches and can also be referred to in the CSS styling definition. PersistedState: A string to string map used to store information that nneds to be persisted between sessions. TransientData: A string to object map which can be used to store runtime data relevant to a particular model element. Since: 1.0 The following features are supported: Element Id Persisted State Tags Contributor URI Transient Data extends MApplicationElement A representation of the model object \'UI Element\'. This is the base mix-in shared by all model elements that can be rendered into the UI presentation of the application. Its main job is to manage the bindings between the concrete element and the UI \'widget\' representing it in the UI. Since: 1.0 The following features are supported: Widget Renderer To Be Rendered On Top Visible Parent Container Data Cur Shared Ref Visible When Accessibility Phrase '
211, 'org.eclipse.jface.action.SubContributionItem', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/action/SubContributionItem.html', 'A contribution item represents a contribution to a shared UI resource such as a menu or tool bar. More generally, contribution items are managed by a contribution manager. For instance, in a tool bar a contribution item is a tool bar button or a separator. In a menu bar a contribution item is a menu, and in a menu a contribution item is a menu item or separator. A contribution item can realize itself in different SWT widgets, using the different fill methods. The same type of contribution item can be used with a MenuBarManager, ToolBarManager, CoolBarManager, or a StatusLineManager. This interface is internal to the framework; it should not be implemented outside the framework. See Also: IContributionManager Restriction: This interface is not intended to be implemented by clients. extends Object implements IContributionItem A SubContributionItem is a wrapper for an IContributionItem. It is used within a SubContributionManager to control the visibility of items. This class is not intended to be subclassed. Restriction: This class is not intended to be subclassed by clients. '
212, 'org.eclipse.e4.ui.model.application.ui.menu.MMenuElement', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/e4/ui/model/application/ui/menu/MMenuElement.html', ' A representation of the model object \'Element\'. This is the root element for all UI Model elements, defining attribtues common to every element; the element\'s id as well as three general storage elements: Tags: This is a set of strings which can be used to stereotype a particular element. Tags may be specified in element searches and can also be referred to in the CSS styling definition. PersistedState: A string to string map used to store information that nneds to be persisted between sessions. TransientData: A string to object map which can be used to store runtime data relevant to a particular model element. Since: 1.0 The following features are supported: Element Id Persisted State Tags Contributor URI Transient Data A representation of the model object \'Element\'. This is the root element for all UI Model elements, defining attribtues common to every element; the element\'s id as well as three general storage elements: Tags: This is a set of strings which can be used to stereotype a particular element. Tags may be specified in element searches and can also be referred to in the CSS styling definition. PersistedState: A string to string map used to store information that nneds to be persisted between sessions. TransientData: A string to object map which can be used to store runtime data relevant to a particular model element. Since: 1.0 The following features are supported: Element Id Persisted State Tags Contributor URI Transient Data extends MApplicationElement A representation of the model object \'UI Element\'. This is the base mix-in shared by all model elements that can be rendered into the UI presentation of the application. Its main job is to manage the bindings between the concrete element and the UI \'widget\' representing it in the UI. Since: 1.0 The following features are supported: Widget Renderer To Be Rendered On Top Visible Parent Container Data Cur Shared Ref Visible When Accessibility Phrase A representation of the model object \'UI Label\'. This is a mix in that will be used for UI Elements that are capable of showing label information in the GUI (e.g. Parts, Menus / Toolbars, Persepectives...) Since: 1.0 The following features are supported: Label Icon URI Tooltip extends MUIElement, MUILabel A representation of the model object \'Element\'. This is the bsae type for both menu items and Separators. Since: 1.0 The following features are supported: Mnemonics '
213, 'org.eclipse.e4.ui.model.application.ui.menu.MOpaqueMenuItem', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/e4/ui/model/application/ui/menu/MOpaqueMenuItem.html', ' A representation of the model object \'Element\'. This is the root element for all UI Model elements, defining attribtues common to every element; the element\'s id as well as three general storage elements: Tags: This is a set of strings which can be used to stereotype a particular element. Tags may be specified in element searches and can also be referred to in the CSS styling definition. PersistedState: A string to string map used to store information that nneds to be persisted between sessions. TransientData: A string to object map which can be used to store runtime data relevant to a particular model element. Since: 1.0 The following features are supported: Element Id Persisted State Tags Contributor URI Transient Data A representation of the model object \'Element\'. This is the root element for all UI Model elements, defining attribtues common to every element; the element\'s id as well as three general storage elements: Tags: This is a set of strings which can be used to stereotype a particular element. Tags may be specified in element searches and can also be referred to in the CSS styling definition. PersistedState: A string to string map used to store information that nneds to be persisted between sessions. TransientData: A string to object map which can be used to store runtime data relevant to a particular model element. Since: 1.0 The following features are supported: Element Id Persisted State Tags Contributor URI Transient Data A representation of the model object \'Element\'. This is the root element for all UI Model elements, defining attribtues common to every element; the element\'s id as well as three general storage elements: Tags: This is a set of strings which can be used to stereotype a particular element. Tags may be specified in element searches and can also be referred to in the CSS styling definition. PersistedState: A string to string map used to store information that nneds to be persisted between sessions. TransientData: A string to object map which can be used to store runtime data relevant to a particular model element. Since: 1.0 The following features are supported: Element Id Persisted State Tags Contributor URI Transient Data extends MApplicationElement A representation of the model object \'UI Element\'. This is the base mix-in shared by all model elements that can be rendered into the UI presentation of the application. Its main job is to manage the bindings between the concrete element and the UI \'widget\' representing it in the UI. Since: 1.0 The following features are supported: Widget Renderer To Be Rendered On Top Visible Parent Container Data Cur Shared Ref Visible When Accessibility Phrase A representation of the model object \'UI Label\'. This is a mix in that will be used for UI Elements that are capable of showing label information in the GUI (e.g. Parts, Menus / Toolbars, Persepectives...) Since: 1.0 The following features are supported: Label Icon URI Tooltip extends MUIElement, MUILabel A representation of the model object \'Element\'. This is the bsae type for both menu items and Separators. Since: 1.0 The following features are supported: Mnemonics A representation of the model object \'Element\'. This is the root element for all UI Model elements, defining attribtues common to every element; the element\'s id as well as three general storage elements: Tags: This is a set of strings which can be used to stereotype a particular element. Tags may be specified in element searches and can also be referred to in the CSS styling definition. PersistedState: A string to string map used to store information that nneds to be persisted between sessions. TransientData: A string to object map which can be used to store runtime data relevant to a particular model element. Since: 1.0 The following features are supported: Element Id Persisted State Tags Contributor URI Transient Data extends MUIElement, MUILabel A representation of the model object \'Element\'. This is the bsae type for both menu items and Separators. Since: 1.0 The following features are supported: Mnemonics extends MApplicationElement A representation of the model object \'UI Element\'. This is the base mix-in shared by all model elements that can be rendered into the UI presentation of the application. Its main job is to manage the bindings between the concrete element and the UI \'widget\' representing it in the UI. Since: 1.0 The following features are supported: Widget Renderer To Be Rendered On Top Visible Parent Container Data Cur Shared Ref Visible When Accessibility Phrase A representation of the model object \'UI Label\'. This is a mix in that will be used for UI Elements that are capable of showing label information in the GUI (e.g. Parts, Menus / Toolbars, Persepectives...) Since: 1.0 The following features are supported: Label Icon URI Tooltip extends MItem, MMenuElement A representation of the model object \'Item\'. This is the base type for both Handled and direct menu items. Since: 1.0 A representation of the model object \'Element\'. This is the root element for all UI Model elements, defining attribtues common to every element; the element\'s id as well as three general storage elements: Tags: This is a set of strings which can be used to stereotype a particular element. Tags may be specified in element searches and can also be referred to in the CSS styling definition. PersistedState: A string to string map used to store information that nneds to be persisted between sessions. TransientData: A string to object map which can be used to store runtime data relevant to a particular model element. Since: 1.0 The following features are supported: Element Id Persisted State Tags Contributor URI Transient Data extends MApplicationElement A representation of the model object \'UI Element\'. This is the base mix-in shared by all model elements that can be rendered into the UI presentation of the application. Its main job is to manage the bindings between the concrete element and the UI \'widget\' representing it in the UI. Since: 1.0 The following features are supported: Widget Renderer To Be Rendered On Top Visible Parent Container Data Cur Shared Ref Visible When Accessibility Phrase extends MMenuItem A representation of the model object \'Opaque Menu Item\'. Do no use! This class will be removed at the beginning of Luna (4.4) development. Since: 1.0 The following features are supported: Opaque Item Restriction: This interface is not intended to be referenced by clients. '
214, 'org.eclipse.jface.viewers.StructuredViewer', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/viewers/StructuredViewer.html', 'Interface common to all objects that provide an input. extends IInputProvider, ISelectionProvider Interface common to all objects that provide both an input and a selection. extends ISelectionProvider Selection provider extension interface to allow providers to notify about post selection changed events. A post selection changed event is equivalent to selection changed event if the selection change was triggered by the mouse, but it has a delay if the selection change is triggered by keyboard navigation. Since: 3.0 See Also: ISelectionProvider Interface common to all objects that provide a selection. See Also: ISelection, ISelectionChangedListener, SelectionChangedEvent extends ContentViewer implements IPostSelectionProvider Abstract base implementation for structure-oriented viewers (trees, lists, tables). Supports custom sorting, filtering, and rendering. Any number of viewer filters can be added to this viewer (using addFilter). When the viewer receives an update, it asks each of its filters if it is out of date, and refilters elements as required. See Also: ViewerFilter, ViewerComparator '
215, 'org.eclipse.e4.ui.model.application.ui.menu.MToolBarElement', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/e4/ui/model/application/ui/menu/MToolBarElement.html', ' A representation of the model object \'Element\'. This is the root element for all UI Model elements, defining attribtues common to every element; the element\'s id as well as three general storage elements: Tags: This is a set of strings which can be used to stereotype a particular element. Tags may be specified in element searches and can also be referred to in the CSS styling definition. PersistedState: A string to string map used to store information that nneds to be persisted between sessions. TransientData: A string to object map which can be used to store runtime data relevant to a particular model element. Since: 1.0 The following features are supported: Element Id Persisted State Tags Contributor URI Transient Data A representation of the model object \'Element\'. This is the root element for all UI Model elements, defining attribtues common to every element; the element\'s id as well as three general storage elements: Tags: This is a set of strings which can be used to stereotype a particular element. Tags may be specified in element searches and can also be referred to in the CSS styling definition. PersistedState: A string to string map used to store information that nneds to be persisted between sessions. TransientData: A string to object map which can be used to store runtime data relevant to a particular model element. Since: 1.0 The following features are supported: Element Id Persisted State Tags Contributor URI Transient Data extends MApplicationElement A representation of the model object \'UI Element\'. This is the base mix-in shared by all model elements that can be rendered into the UI presentation of the application. Its main job is to manage the bindings between the concrete element and the UI \'widget\' representing it in the UI. Since: 1.0 The following features are supported: Widget Renderer To Be Rendered On Top Visible Parent Container Data Cur Shared Ref Visible When Accessibility Phrase extends MUIElement A representation of the model object \'Tool Bar Element\'. This is a placeholder class mixed in to any other type that can be added to a Toolbar. Since: 1.0 '
216, 'org.eclipse.e4.ui.model.application.ui.menu.MToolBarSeparator', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/e4/ui/model/application/ui/menu/MToolBarSeparator.html', ' A representation of the model object \'Element\'. This is the root element for all UI Model elements, defining attribtues common to every element; the element\'s id as well as three general storage elements: Tags: This is a set of strings which can be used to stereotype a particular element. Tags may be specified in element searches and can also be referred to in the CSS styling definition. PersistedState: A string to string map used to store information that nneds to be persisted between sessions. TransientData: A string to object map which can be used to store runtime data relevant to a particular model element. Since: 1.0 The following features are supported: Element Id Persisted State Tags Contributor URI Transient Data A representation of the model object \'Element\'. This is the root element for all UI Model elements, defining attribtues common to every element; the element\'s id as well as three general storage elements: Tags: This is a set of strings which can be used to stereotype a particular element. Tags may be specified in element searches and can also be referred to in the CSS styling definition. PersistedState: A string to string map used to store information that nneds to be persisted between sessions. TransientData: A string to object map which can be used to store runtime data relevant to a particular model element. Since: 1.0 The following features are supported: Element Id Persisted State Tags Contributor URI Transient Data A representation of the model object \'Element\'. This is the root element for all UI Model elements, defining attribtues common to every element; the element\'s id as well as three general storage elements: Tags: This is a set of strings which can be used to stereotype a particular element. Tags may be specified in element searches and can also be referred to in the CSS styling definition. PersistedState: A string to string map used to store information that nneds to be persisted between sessions. TransientData: A string to object map which can be used to store runtime data relevant to a particular model element. Since: 1.0 The following features are supported: Element Id Persisted State Tags Contributor URI Transient Data extends MApplicationElement A representation of the model object \'UI Element\'. This is the base mix-in shared by all model elements that can be rendered into the UI presentation of the application. Its main job is to manage the bindings between the concrete element and the UI \'widget\' representing it in the UI. Since: 1.0 The following features are supported: Widget Renderer To Be Rendered On Top Visible Parent Container Data Cur Shared Ref Visible When Accessibility Phrase extends MUIElement A representation of the model object \'Tool Bar Element\'. This is a placeholder class mixed in to any other type that can be added to a Toolbar. Since: 1.0 A representation of the model object \'Element\'. This is the root element for all UI Model elements, defining attribtues common to every element; the element\'s id as well as three general storage elements: Tags: This is a set of strings which can be used to stereotype a particular element. Tags may be specified in element searches and can also be referred to in the CSS styling definition. PersistedState: A string to string map used to store information that nneds to be persisted between sessions. TransientData: A string to object map which can be used to store runtime data relevant to a particular model element. Since: 1.0 The following features are supported: Element Id Persisted State Tags Contributor URI Transient Data extends MApplicationElement A representation of the model object \'UI Element\'. This is the base mix-in shared by all model elements that can be rendered into the UI presentation of the application. Its main job is to manage the bindings between the concrete element and the UI \'widget\' representing it in the UI. Since: 1.0 The following features are supported: Widget Renderer To Be Rendered On Top Visible Parent Container Data Cur Shared Ref Visible When Accessibility Phrase extends MToolBarElement A representation of the model object \'Tool Bar Separator\'. This is the concrete class used to represent a separator in a Toolbar. Since: 1.0 '
217, 'org.eclipse.e4.ui.model.application.ui.basic.MTrimElement', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/e4/ui/model/application/ui/basic/MTrimElement.html', ' A representation of the model object \'Element\'. This is the root element for all UI Model elements, defining attribtues common to every element; the element\'s id as well as three general storage elements: Tags: This is a set of strings which can be used to stereotype a particular element. Tags may be specified in element searches and can also be referred to in the CSS styling definition. PersistedState: A string to string map used to store information that nneds to be persisted between sessions. TransientData: A string to object map which can be used to store runtime data relevant to a particular model element. Since: 1.0 The following features are supported: Element Id Persisted State Tags Contributor URI Transient Data A representation of the model object \'Element\'. This is the root element for all UI Model elements, defining attribtues common to every element; the element\'s id as well as three general storage elements: Tags: This is a set of strings which can be used to stereotype a particular element. Tags may be specified in element searches and can also be referred to in the CSS styling definition. PersistedState: A string to string map used to store information that nneds to be persisted between sessions. TransientData: A string to object map which can be used to store runtime data relevant to a particular model element. Since: 1.0 The following features are supported: Element Id Persisted State Tags Contributor URI Transient Data extends MApplicationElement A representation of the model object \'UI Element\'. This is the base mix-in shared by all model elements that can be rendered into the UI presentation of the application. Its main job is to manage the bindings between the concrete element and the UI \'widget\' representing it in the UI. Since: 1.0 The following features are supported: Widget Renderer To Be Rendered On Top Visible Parent Container Data Cur Shared Ref Visible When Accessibility Phrase extends MUIElement A representation of the model object \'Trim Element\'. A class to be mixed in to any element that should be allowed to be added to a TrimBar. Since: 1.0 '
218, 'org.eclipse.e4.ui.model.application.ui.menu.MOpaqueToolItem', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/e4/ui/model/application/ui/menu/MOpaqueToolItem.html', ' A representation of the model object \'Element\'. This is the root element for all UI Model elements, defining attribtues common to every element; the element\'s id as well as three general storage elements: Tags: This is a set of strings which can be used to stereotype a particular element. Tags may be specified in element searches and can also be referred to in the CSS styling definition. PersistedState: A string to string map used to store information that nneds to be persisted between sessions. TransientData: A string to object map which can be used to store runtime data relevant to a particular model element. Since: 1.0 The following features are supported: Element Id Persisted State Tags Contributor URI Transient Data A representation of the model object \'Element\'. This is the root element for all UI Model elements, defining attribtues common to every element; the element\'s id as well as three general storage elements: Tags: This is a set of strings which can be used to stereotype a particular element. Tags may be specified in element searches and can also be referred to in the CSS styling definition. PersistedState: A string to string map used to store information that nneds to be persisted between sessions. TransientData: A string to object map which can be used to store runtime data relevant to a particular model element. Since: 1.0 The following features are supported: Element Id Persisted State Tags Contributor URI Transient Data A representation of the model object \'Element\'. This is the root element for all UI Model elements, defining attribtues common to every element; the element\'s id as well as three general storage elements: Tags: This is a set of strings which can be used to stereotype a particular element. Tags may be specified in element searches and can also be referred to in the CSS styling definition. PersistedState: A string to string map used to store information that nneds to be persisted between sessions. TransientData: A string to object map which can be used to store runtime data relevant to a particular model element. Since: 1.0 The following features are supported: Element Id Persisted State Tags Contributor URI Transient Data extends MApplicationElement A representation of the model object \'UI Element\'. This is the base mix-in shared by all model elements that can be rendered into the UI presentation of the application. Its main job is to manage the bindings between the concrete element and the UI \'widget\' representing it in the UI. Since: 1.0 The following features are supported: Widget Renderer To Be Rendered On Top Visible Parent Container Data Cur Shared Ref Visible When Accessibility Phrase extends MUIElement A representation of the model object \'Tool Bar Element\'. This is a placeholder class mixed in to any other type that can be added to a Toolbar. Since: 1.0 A representation of the model object \'Element\'. This is the root element for all UI Model elements, defining attribtues common to every element; the element\'s id as well as three general storage elements: Tags: This is a set of strings which can be used to stereotype a particular element. Tags may be specified in element searches and can also be referred to in the CSS styling definition. PersistedState: A string to string map used to store information that nneds to be persisted between sessions. TransientData: A string to object map which can be used to store runtime data relevant to a particular model element. Since: 1.0 The following features are supported: Element Id Persisted State Tags Contributor URI Transient Data extends MUIElement A representation of the model object \'Tool Bar Element\'. This is a placeholder class mixed in to any other type that can be added to a Toolbar. Since: 1.0 extends MApplicationElement A representation of the model object \'UI Element\'. This is the base mix-in shared by all model elements that can be rendered into the UI presentation of the application. Its main job is to manage the bindings between the concrete element and the UI \'widget\' representing it in the UI. Since: 1.0 The following features are supported: Widget Renderer To Be Rendered On Top Visible Parent Container Data Cur Shared Ref Visible When Accessibility Phrase A representation of the model object \'UI Label\'. This is a mix in that will be used for UI Elements that are capable of showing label information in the GUI (e.g. Parts, Menus / Toolbars, Persepectives...) Since: 1.0 The following features are supported: Label Icon URI Tooltip extends MItem, MToolBarElement A representation of the model object \'Tool Item\'. This is the base type for both Direct and Handled tool items. Since: 1.0 The following features are supported: Menu A representation of the model object \'Element\'. This is the root element for all UI Model elements, defining attribtues common to every element; the element\'s id as well as three general storage elements: Tags: This is a set of strings which can be used to stereotype a particular element. Tags may be specified in element searches and can also be referred to in the CSS styling definition. PersistedState: A string to string map used to store information that nneds to be persisted between sessions. TransientData: A string to object map which can be used to store runtime data relevant to a particular model element. Since: 1.0 The following features are supported: Element Id Persisted State Tags Contributor URI Transient Data extends MApplicationElement A representation of the model object \'UI Element\'. This is the base mix-in shared by all model elements that can be rendered into the UI presentation of the application. Its main job is to manage the bindings between the concrete element and the UI \'widget\' representing it in the UI. Since: 1.0 The following features are supported: Widget Renderer To Be Rendered On Top Visible Parent Container Data Cur Shared Ref Visible When Accessibility Phrase extends MToolItem A representation of the model object \'Opaque Tool Item\'. Do no use! This class will be removed at the beginning of Luna (4.4) development. Since: 1.0 The following features are supported: Opaque Item Restriction: This interface is not intended to be referenced by clients. '
219, 'org.eclipse.e4.ui.model.application.ui.menu.MItem', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/e4/ui/model/application/ui/menu/MItem.html', ' A representation of the model object \'Element\'. This is the root element for all UI Model elements, defining attribtues common to every element; the element\'s id as well as three general storage elements: Tags: This is a set of strings which can be used to stereotype a particular element. Tags may be specified in element searches and can also be referred to in the CSS styling definition. PersistedState: A string to string map used to store information that nneds to be persisted between sessions. TransientData: A string to object map which can be used to store runtime data relevant to a particular model element. Since: 1.0 The following features are supported: Element Id Persisted State Tags Contributor URI Transient Data A representation of the model object \'Element\'. This is the root element for all UI Model elements, defining attribtues common to every element; the element\'s id as well as three general storage elements: Tags: This is a set of strings which can be used to stereotype a particular element. Tags may be specified in element searches and can also be referred to in the CSS styling definition. PersistedState: A string to string map used to store information that nneds to be persisted between sessions. TransientData: A string to object map which can be used to store runtime data relevant to a particular model element. Since: 1.0 The following features are supported: Element Id Persisted State Tags Contributor URI Transient Data extends MApplicationElement A representation of the model object \'UI Element\'. This is the base mix-in shared by all model elements that can be rendered into the UI presentation of the application. Its main job is to manage the bindings between the concrete element and the UI \'widget\' representing it in the UI. Since: 1.0 The following features are supported: Widget Renderer To Be Rendered On Top Visible Parent Container Data Cur Shared Ref Visible When Accessibility Phrase A representation of the model object \'UI Label\'. This is a mix in that will be used for UI Elements that are capable of showing label information in the GUI (e.g. Parts, Menus / Toolbars, Persepectives...) Since: 1.0 The following features are supported: Label Icon URI Tooltip extends MUIElement, MUILabel A representation of the model object \'Item\'. This is the base type for various menu and toolbar items. Since: 1.0 The following features are supported: Enabled Selected Type '
220, 'org.eclipse.e4.ui.model.application.ui.menu.MHandledItem', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/e4/ui/model/application/ui/menu/MHandledItem.html', ' A representation of the model object \'Element\'. This is the root element for all UI Model elements, defining attribtues common to every element; the element\'s id as well as three general storage elements: Tags: This is a set of strings which can be used to stereotype a particular element. Tags may be specified in element searches and can also be referred to in the CSS styling definition. PersistedState: A string to string map used to store information that nneds to be persisted between sessions. TransientData: A string to object map which can be used to store runtime data relevant to a particular model element. Since: 1.0 The following features are supported: Element Id Persisted State Tags Contributor URI Transient Data A representation of the model object \'Element\'. This is the root element for all UI Model elements, defining attribtues common to every element; the element\'s id as well as three general storage elements: Tags: This is a set of strings which can be used to stereotype a particular element. Tags may be specified in element searches and can also be referred to in the CSS styling definition. PersistedState: A string to string map used to store information that nneds to be persisted between sessions. TransientData: A string to object map which can be used to store runtime data relevant to a particular model element. Since: 1.0 The following features are supported: Element Id Persisted State Tags Contributor URI Transient Data extends MApplicationElement A representation of the model object \'UI Element\'. This is the base mix-in shared by all model elements that can be rendered into the UI presentation of the application. Its main job is to manage the bindings between the concrete element and the UI \'widget\' representing it in the UI. Since: 1.0 The following features are supported: Widget Renderer To Be Rendered On Top Visible Parent Container Data Cur Shared Ref Visible When Accessibility Phrase A representation of the model object \'UI Label\'. This is a mix in that will be used for UI Elements that are capable of showing label information in the GUI (e.g. Parts, Menus / Toolbars, Persepectives...) Since: 1.0 The following features are supported: Label Icon URI Tooltip extends MItem A representation of the model object \'Handled Item\'. This is the base class for menu and tool items associated with Commands. Since: 1.0 The following features are supported: Command Wb Command Parameters '
221, 'org.eclipse.jface.bindings.TriggerSequence', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/bindings/TriggerSequence.html', 'extends Object A sequence of one or more triggers. None of these triggers may be null. Since: 3.1 '
222, 'org.eclipse.swt.widgets.Canvas', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/widgets/Canvas.html', 'Implementers of Drawable can have a graphics context (GC) created for them, and then they can be drawn on by sending messages to their associated GC. SWT images, and device objects such as the Display device and the Printer device, are drawables. IMPORTANT: This interface is not part of the SWT public API. It is marked public only so that it can be shared within the packages provided by SWT. It should never be referenced from application code. See Also: Device, Image, GC extends Composite Instances of this class provide a surface for drawing arbitrary graphics. Styles: (none) Events: (none) This class may be subclassed by custom control implementors who are building controls that are not constructed from aggregates of other controls. That is, they are either painted using SWT graphics calls or are handled by native methods. See Also: Composite, Canvas snippets, SWT Example: ControlExample, Sample code and further information '
223, 'org.eclipse.jface.preference.IPreferenceStore', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/preference/IPreferenceStore.html', 'The IPreferenceStore interface represents a table mapping named preferences to values. If there is no value for a given name, then that preferences\'s default value is returned; and if there is no default value for that preference, then a default-default value is returned. The default-default values for the primitive types are as follows: boolean = false double = 0.0 float = 0.0f int = 0 long = 0 String = \"\" (the empty string) Thus a preference store maintains two values for each of a set of names: a current value and a default value. The typical usage is to establish the defaults for all known preferences and then restore previously stored values for preferences whose values were different from their defaults. After the current values of the preferences have been modified, it is a simple matter to write out only those preferences whose values are different from their defaults. This two-tiered approach to saving and restoring preference setting minimized the number of preferences that need to be persisted; indeed, the normal starting state does not require storing any preferences at all. A property change event is reported whenever a preferences current value actually changes (whether through setValue, setToDefault, or other unspecified means). Note, however, that manipulating default values (with setDefault) does not cause such events to be reported. Clients who need a preference store may implement this interface or instantiate the standard implementation PreferenceStore. See Also: PreferenceStore '
224, 'org.eclipse.jface.util.IPropertyChangeListener', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/util/IPropertyChangeListener.html', 'extends EventListener Listener for property changes. Usage: IPropertyChangeListener listener = new IPropertyChangeListener() { public void propertyChange(PropertyChangeEvent event) { ... // code to deal with occurrence of property change } }; emitter.addPropertyChangeListener(listener); ... emitter.removePropertyChangeListener(listener); '
225, 'org.eclipse.swt.graphics.GC', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/graphics/GC.html', 'extends Resource Class GC is where all of the drawing capabilities that are supported by SWT are located. Instances are used to draw on either an Image, a Control, or directly on a Display. Styles: LEFT_TO_RIGHT, RIGHT_TO_LEFT The SWT drawing coordinate system is the two-dimensional space with the origin (0,0) at the top left corner of the drawing area and with (x,y) values increasing to the right and downward respectively. The result of drawing on an image that was created with an indexed palette using a color that is not in the palette is platform specific. Some platforms will match to the nearest color while other will draw the color itself. This happens because the allocated image might use a direct palette on platforms that do not support indexed palette. Application code must explicitly invoke the GC.dispose() method to release the operating system resources managed by each instance when those instances are no longer required. This is particularly important on Windows95 and Windows98 where the operating system has a limited number of device contexts available. Note: Only one of LEFT_TO_RIGHT and RIGHT_TO_LEFT may be specified. See Also: PaintEvent, GC snippets, SWT Examples: GraphicsExample, PaintExample, Sample code and further information '
226, 'org.eclipse.jface.action.IMenuListener', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/action/IMenuListener.html', 'A menu listener that gets informed when a menu is about to show. See Also: MenuManager.addMenuListener(org.eclipse.jface.action.IMenuListener) '
227, 'org.eclipse.swt.custom.BusyIndicator', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/custom/BusyIndicator.html', 'extends Object Support for showing a Busy Cursor during a long running process. See Also: BusyIndicator snippets, Sample code and further information '
228, 'org.eclipse.core.runtime.ListenerList', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/runtime/ListenerList.html', 'extends Object This class is a thread safe list that is designed for storing lists of listeners. The implementation is optimized for minimal memory footprint, frequent reads and infrequent writes. Modification of the list is synchronized and relatively expensive, while accessing the listeners is very fast. Readers are given access to the underlying array data structure for reading, with the trust that they will not modify the underlying array. A listener list handles the same listener being added multiple times, and tolerates removal of listeners that are the same as other listeners in the list. For this purpose, listeners can be compared with each other using either equality or identity, as specified in the list constructor. Use the getListeners method when notifying listeners. The recommended code sequence for notifying all registered listeners of say, FooListener.eventHappened, is: Object[] listeners = myListenerList.getListeners(); for (int i = 0; i < listeners.length; ++i) { ((FooListener) listeners[i]).eventHappened(event); } This class can be used without OSGi running. Since: org.eclipse.equinox.common 3.2 '
229, 'org.eclipse.core.runtime.dynamichelpers.IExtensionTracker', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/runtime/dynamichelpers/IExtensionTracker.html', 'An extension tracker keeps associations between extensions and their derived objects on an extension basis. All extensions being added in a tracker will automatically be removed when the extension is uninstalled from the registry. Users interested in extension removal can register a handler that will let them know when an object is being removed. This interface can be used without OSGi running. This interface is not intended to be implemented by clients. Since: 3.1 Restriction: This interface is not intended to be implemented by clients. '
230, 'org.eclipse.ui.ISelectionService', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/ISelectionService.html', 'A selection service tracks the selection within an object. A listener that wants to be notified when the selection becomes null must implement the INullSelectionListener interface. This service can be acquired from your service locator: ISelectionService service = (ISelectionService) getSite().getService(ISelectionService.class); This service is not available globally, only from the workbench window level down. See Also: ISelectionListener, INullSelectionListener, IServiceLocator.getService(Class) Restriction: This interface is not intended to be implemented by clients. '
231, 'org.eclipse.jface.action.StatusLineManager', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/action/StatusLineManager.html', 'A contribution manager organizes contributions to such UI components as menus, toolbars and status lines. A contribution manager keeps track of a list of contribution items. Each contribution item may has an optional identifier, which can be used to retrieve items from a manager, and for positioning items relative to each other. The list of contribution items can be subdivided into named groups using special contribution items that serve as group markers. The IContributionManager interface provides general protocol for adding, removing, and retrieving contribution items. It also provides convenience methods that make it convenient to contribute actions. This interface should be implemented by all objects that wish to manage contributions. There are several implementions of this interface in this package, including ones for menus (MenuManager), tool bars (ToolBarManager), and status lines (StatusLineManager). A contribution manager organizes contributions to such UI components as menus, toolbars and status lines. A contribution manager keeps track of a list of contribution items. Each contribution item may has an optional identifier, which can be used to retrieve items from a manager, and for positioning items relative to each other. The list of contribution items can be subdivided into named groups using special contribution items that serve as group markers. The IContributionManager interface provides general protocol for adding, removing, and retrieving contribution items. It also provides convenience methods that make it convenient to contribute actions. This interface should be implemented by all objects that wish to manage contributions. There are several implementions of this interface in this package, including ones for menus (MenuManager), tool bars (ToolBarManager), and status lines (StatusLineManager). extends IContributionManager The IStatusLineManager interface provides protocol for displaying messages on a status line, for monitoring progress, and for managing contributions to the status line. Note: An error message overrides the current message until the error message is cleared. This package also provides a concrete status line manager implementation, StatusLineManager. extends ContributionManager implements IStatusLineManager A status line manager is a contribution manager which realizes itself and its items in a status line control. This class may be instantiated; it may also be subclassed if a more sophisticated layout is required. '
232, 'org.eclipse.jface.action.IContributionManagerOverrides', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/action/IContributionManagerOverrides.html', 'This interface is used by instances of IContributionItem to determine if the values for certain properties have been overriden by their manager. This interface is internal to the framework; it should not be implemented outside the framework. Since: 2.0 Restriction: This interface is not intended to be implemented by clients. '
233, 'org.eclipse.e4.ui.workbench.modeling.IWindowCloseHandler', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/e4/ui/workbench/modeling/IWindowCloseHandler.html', 'A handler that can be inserted into the context of the application or a particular window to determine whether the window should be closed or not. Since: 1.0 Restriction: This interface is not intended to be referenced by clients. '
234, 'org.eclipse.ui.IWorkbenchPart', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/IWorkbenchPart.html', 'An interface for an adaptable object. Adaptable objects can be dynamically extended to provide different interfaces (or \"adapters\"). Adapters are created by adapter factories, which are in turn managed by type by adapter managers. For example, IAdaptable a = [some adaptable]; IFoo x = (IFoo)a.getAdapter(IFoo.class); if (x != null) [do IFoo things with x] This interface can be used without OSGi running. Clients may implement this interface, or obtain a default implementation of this interface by subclassing PlatformObject. See Also: IAdapterFactory, IAdapterManager, PlatformObject extends IAdaptable A workbench part is a visual component within a workbench page. There are two subtypes: view and editor, as defined by IViewPart and IEditorPart. A view is typically used to navigate a hierarchy of information (like the workspace), open an editor, or display properties for the active editor. Modifications made in a view are saved immediately. An editor is typically used to edit or browse a document or input object. The input is identified using an IEditorInput. Modifications made in an editor part follow an open-save-close lifecycle model. This interface may be implemented directly. For convenience, a base implementation is defined in WorkbenchPart. The lifecycle of a workbench part is as follows: When a part extension is created: instantiate the part create a part site call part.init(site) When a part becomes visible in the workbench: add part to presentation by calling part.createPartControl(parent) to create actual widgets fire partOpened event to all listeners When a part is activated or gets focus: call part.setFocus() fire partActivated event to all listeners When a part is closed: if save is needed, do save; if it fails or is canceled return if part is active, deactivate part fire partClosed event to all listeners remove part from presentation; part controls are disposed as part of the SWT widget tree call part.dispose() After createPartControl has been called, the implementor may safely reference the controls created. When the part is closed these controls will be disposed as part of an SWT composite. This occurs before the IWorkbenchPart.dispose method is called. If there is a need to free SWT resources the part should define a dispose listener for its own control and free those resources from the dispose listener. If the part invokes any method on the disposed SWT controls after this point an SWTError will be thrown. The last method called on IWorkbenchPart is dispose. This signals the end of the part lifecycle. An important point to note about this lifecycle is that following a call to init, createPartControl may never be called. Thus in the dispose method, implementors must not assume controls were created. Workbench parts implement the IAdaptable interface; extensions are managed by the platform\'s adapter manager. See Also: IViewPart, IEditorPart '
235, 'org.eclipse.ui.ISaveablePart', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/ISaveablePart.html', 'Workbench parts implement or adapt to this interface to participate in the enablement and execution of the Save and Save As actions. Since: 2.1 See Also: IEditorPart '
236, 'org.eclipse.ui.dialogs.ListSelectionDialog', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/dialogs/ListSelectionDialog.html', 'Interface for objects that can return a shell. This is normally used for opening child windows. An object that wants to open child shells can take an IShellProvider in its constructor, and the object that implements IShellProvider can dynamically choose where child shells should be opened. Since: 3.1 extends SelectionDialog A standard dialog which solicits a list of selections from the user. This class is configured with an arbitrary data model represented by content and label provider objects. The getResult method returns the selected elements. This class may be instantiated; it is not intended to be subclassed. Example: ListSelectionDialog dlg = new ListSelectionDialog( getShell(), input, new BaseWorkbenchContentProvider(), new WorkbenchLabelProvider(), \"Select the resources to save:\"); dlg.setInitialSelections(dirtyEditors); dlg.setTitle(\"Save Resources\"); dlg.open(); Restriction: This class is not intended to be subclassed by clients. '
237, 'org.eclipse.ui.IPageService', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/IPageService.html', 'A page service tracks the page and perspective lifecycle events within a workbench window. This service can be acquired from your service locator: IPageService service = (IPageService) getSite().getService(IPageService.class); This service is not available globally, only from the workbench window level down. See Also: IWorkbenchWindow, IPageListener, IPerspectiveListener, IServiceLocator.getService(Class) Restriction: This interface is not intended to be implemented by clients. '
238, 'org.eclipse.ui.IPartService', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/IPartService.html', 'A part service tracks the creation and activation of parts within a workbench page. This service can be acquired from your service locator: IPartService service = (IPartService) getSite().getService(IPartService.class); This service is not available globally, only from the workbench window level down. See Also: IWorkbenchPage, IServiceLocator.getService(Class) Restriction: This interface is not intended to be implemented by clients. '
239, 'org.eclipse.core.expressions.ExpressionInfo', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/expressions/ExpressionInfo.html', 'extends Object A status object describing information about an expression tree. This information can for example be used to decide whether an expression tree has to be reevaluated if the value of some variables changes. This class is not intended to be extended by clients. Since: 3.2 Restriction: This class is not intended to be subclassed by clients. '
240, 'org.eclipse.ui.contexts.IContextService', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/contexts/IContextService.html', ' The interface that should be implemented by services that make themselves available through the IAdaptable mechanism. This is the interface that drives the majority of services provided at the workbench level. A service has life-cycle. When the constructor completes, the service must be fully functional. When it comes time for the service to go away, then the service will receive a dispose() call. At this point, the service must release all resources and detach all listeners. A service can only be disposed once; it cannot be reused. This interface has nothing to do with OSGi services. This interface can be extended or implemented by clients. Since: 3.2 extends IDisposable A service that responds to changes in one or more sources. These sources can be plugged into the service. Sources represent a common event framework for services. Clients must not extend or implement. Since: 3.2 extends IServiceWithSources Provides services related to contexts in the Eclipse workbench. This provides access to contexts. This service can be acquired from your service locator: IContextService service = (IContextService) getSite().getService(IContextService.class); This service is available globally. Since: 3.1 Restriction: This interface is not intended to be implemented by clients. Restriction: This interface is not intended to be extended by clients. '
241, 'org.eclipse.jface.action.AbstractGroupMarker', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/action/AbstractGroupMarker.html', 'A contribution item represents a contribution to a shared UI resource such as a menu or tool bar. More generally, contribution items are managed by a contribution manager. For instance, in a tool bar a contribution item is a tool bar button or a separator. In a menu bar a contribution item is a menu, and in a menu a contribution item is a menu item or separator. A contribution item can realize itself in different SWT widgets, using the different fill methods. The same type of contribution item can be used with a MenuBarManager, ToolBarManager, CoolBarManager, or a StatusLineManager. This interface is internal to the framework; it should not be implemented outside the framework. See Also: IContributionManager Restriction: This interface is not intended to be implemented by clients. extends ContributionItem Abstract superclass for group marker classes. This class is not intended to be subclassed outside the framework. Restriction: This class is not intended to be subclassed by clients. '
242, 'org.eclipse.jface.action.GroupMarker', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/action/GroupMarker.html', 'A contribution item represents a contribution to a shared UI resource such as a menu or tool bar. More generally, contribution items are managed by a contribution manager. For instance, in a tool bar a contribution item is a tool bar button or a separator. In a menu bar a contribution item is a menu, and in a menu a contribution item is a menu item or separator. A contribution item can realize itself in different SWT widgets, using the different fill methods. The same type of contribution item can be used with a MenuBarManager, ToolBarManager, CoolBarManager, or a StatusLineManager. This interface is internal to the framework; it should not be implemented outside the framework. See Also: IContributionManager Restriction: This interface is not intended to be implemented by clients. extends AbstractGroupMarker A group marker is a special kind of contribution item denoting the beginning of a group. These groups are used to structure the list of items. Unlike regular contribution items and separators, group markers have no visual representation. The name of the group is synonymous with the contribution item id. This class may be instantiated; it is not intended to be subclassed outside the framework. Restriction: This class is not intended to be subclassed by clients. '
243, 'org.eclipse.jface.commands.ActionHandler', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/commands/ActionHandler.html', 'A handler is the pluggable piece of a command that handles execution. Each command can have zero or more handlers associated with it (in general), of which only one will be active at any given moment in time. When the command is asked to execute, it will simply pass that request on to its active handler, if any. Since: 3.1 See Also: AbstractHandler extends IHandler Extend the IHandler interface to provide some context for isEnabled() requests. Clients should use AbstractHandler unless they need to provide their own listener mechanism. Since: 3.4 See Also: AbstractHandler extends AbstractHandler This class adapts instances of IAction to IHandler. Since: 3.1 '
244, 'org.eclipse.ui.ActiveShellExpression', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/ActiveShellExpression.html', 'extends Expression An expression that checks the active shell variable. The variable name is ISources.ACTIVE_SHELL_NAME and falls back to ISources.ACTIVE_WORKBENCH_WINDOW. That is, if the active shell doesn\'t match, then it will be allowed to match the active workbench window. Since: 3.1 '
245, 'org.eclipse.ui.handlers.IHandlerService', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/handlers/IHandlerService.html', ' The interface that should be implemented by services that make themselves available through the IAdaptable mechanism. This is the interface that drives the majority of services provided at the workbench level. A service has life-cycle. When the constructor completes, the service must be fully functional. When it comes time for the service to go away, then the service will receive a dispose() call. At this point, the service must release all resources and detach all listeners. A service can only be disposed once; it cannot be reused. This interface has nothing to do with OSGi services. This interface can be extended or implemented by clients. Since: 3.2 extends IDisposable A service that responds to changes in one or more sources. These sources can be plugged into the service. Sources represent a common event framework for services. Clients must not extend or implement. Since: 3.2 extends IServiceWithSources Provides services related to activating and deactivating handlers within the workbench. This service can be acquired from your service locator: IHandlerService service = (IHandlerService) getSite().getService(IHandlerService.class); This service is available globally. Since: 3.1 Restriction: This interface is not intended to be implemented by clients. Restriction: This interface is not intended to be extended by clients. '
246, 'org.eclipse.ui.handlers.IHandlerActivation', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/handlers/IHandlerActivation.html', 'extends org.eclipse.ui.internal.services.IEvaluationResultCache, Comparable A token representing the activation of a handler. This token can later be used to cancel that activation. Without this token, then handler will only become inactive if the component in which the handler was activated is destroyed. This interface is not intended to be implemented or extended by clients. Since: 3.1 See Also: ISources, ISourceProvider '
247, 'org.eclipse.core.expressions.Expression', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/expressions/Expression.html', 'extends Object Abstract base class for all expressions provided by the common expression language. An expression is evaluated by calling evaluate(IEvaluationContext). This class may be subclassed to provide specific expressions. Since: 3.0 '
248, 'org.eclipse.jface.util.PropertyChangeEvent', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/util/PropertyChangeEvent.html', 'extends EventObject An event object describing a change to a named property. This concrete class was designed to be instantiated, but may also be subclassed if required. The JFace frameworks contain classes that report property change events for internal state changes that may be of interest to external parties. A special listener interface (IPropertyChangeListener) is defined for this purpose, and a typical class allow listeners to be registered via an addPropertyChangeListener method. See Also: IPropertyChangeListener, Serialized Form '
249, 'org.eclipse.ui.IPageListener', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/IPageListener.html', 'Interface for listening to page lifecycle events. This interface may be implemented by clients. See Also: IPageService.addPageListener(org.eclipse.ui.IPageListener) '
250, 'org.eclipse.ui.IWorkbenchPartReference', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/IWorkbenchPartReference.html', 'Implements a reference to a IWorkbenchPart. The IWorkbenchPart will not be instantiated until the part becomes visible or the API getPart is sent with true; This interface is not intended to be implemented by clients. Restriction: This interface is not intended to be implemented by clients. '
251, 'org.eclipse.swt.widgets.Layout', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/widgets/Layout.html', 'extends Object A layout controls the position and size of the children of a composite widget. This class is the abstract base class for layouts. See Also: Composite.setLayout(Layout), Sample code and further information '
252, 'org.eclipse.core.runtime.NullProgressMonitor', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/runtime/NullProgressMonitor.html', 'The IProgressMonitor interface is implemented by objects that monitor the progress of an activity; the methods in this interface are invoked by code that performs the activity. All activity is broken down into a linear sequence of tasks against which progress is reported. When a task begins, a beginTask(String, int) notification is reported, followed by any number and mixture of progress reports (worked()) and subtask notifications (subTask(String)). When the task is eventually completed, a done() notification is reported. After the done() notification, the progress monitor cannot be reused; i.e., beginTask(String, int) cannot be called again after the call to done(). A request to cancel an operation can be signaled using the setCanceled method. Operations taking a progress monitor are expected to poll the monitor (using isCanceled) periodically and abort at their earliest convenience. Operation can however choose to ignore cancelation requests. Since notification is synchronous with the activity itself, the listener should provide a fast and robust implementation. If the handling of notifications would involve blocking operations, or operations which might throw uncaught exceptions, the notifications should be queued, and the actual processing deferred (or perhaps delegated to a separate thread). This interface can be used without OSGi running. Clients may implement this interface. extends Object implements IProgressMonitor A default progress monitor implementation suitable for subclassing. This implementation supports cancelation. The default implementations of the other methods do nothing. This class can be used without OSGi running. '
253, 'org.eclipse.jface.operation.IRunnableWithProgress', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/operation/IRunnableWithProgress.html', 'The IRunnableWithProgress interface should be implemented by any class whose instances are intended to be executed as a long-running operation. Long-running operations are typically presented at the UI via a modal dialog showing a progress indicator and a Cancel button. The class must define a run method that takes a progress monitor. The run method is usually not invoked directly, but rather by passing the IRunnableWithProgress to the run method of an IRunnableContext, which provides the UI for the progress monitor and Cancel button. See Also: IRunnableContext '
254, 'org.eclipse.ui.services.IEvaluationService', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/services/IEvaluationService.html', ' The interface that should be implemented by services that make themselves available through the IAdaptable mechanism. This is the interface that drives the majority of services provided at the workbench level. A service has life-cycle. When the constructor completes, the service must be fully functional. When it comes time for the service to go away, then the service will receive a dispose() call. At this point, the service must release all resources and detach all listeners. A service can only be disposed once; it cannot be reused. This interface has nothing to do with OSGi services. This interface can be extended or implemented by clients. Since: 3.2 extends IDisposable A service that responds to changes in one or more sources. These sources can be plugged into the service. Sources represent a common event framework for services. Clients must not extend or implement. Since: 3.2 extends IServiceWithSources Evaluate a core expression against the workbench application context and report updates using a Boolean property. Clients supply an IPropertyChangeListener that will be notified as changes occur. This can be used to implement core expressions in client extension points similar to the <enabledWhen> of org.eclipse.ui.handlers/handler elements. The service will fire Boolean.TRUE and Boolean.FALSE for the oldValue and newValue in the property change events. Adding the evaluation listener will fire one change with oldValue=null and newValue=\"evaluated expression\". Remove the IEvaluationReference will fire one change with oldValue=\"last evaluated value\" and newValue=null. Adding a service listener will fire the PROP_NOTIFYING property change event with newValue=Boolean.TRUE when a source change causes expression evaluations to update and another PROP_NOTIFYING property change event with newValue=Boolean.FALSE when the changes that started with a specific source change have finished. The PROP_NOTIFYING change events will not be fired for source changes caused by the outer most recalculations. Variable sources can be provided to this service using the org.eclipse.ui.services Extension Point. This makes the available to <with/> expressions. This service can be acquired from your service locator: IEvaluationService service = (IEvaluationService) getSite().getService(IEvaluationService.class); This service is available globally. Since: 3.4 Restriction: This interface is not intended to be implemented by clients. Restriction: This interface is not intended to be extended by clients. '
255, 'org.eclipse.core.expressions.IEvaluationContext', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/expressions/IEvaluationContext.html', 'An evaluation context is used to manage a set of objects needed during XML expression evaluation. A context has a parent context, can manage a set of named variables and has a default variable. The default variable is used during XML expression evaluation if no explicit variable is referenced. This interface is not intended to be implemented by clients. Clients are allowed to instantiate EvaluationContext. Since: 3.0 Restriction: This interface is not intended to be implemented by clients. Restriction: This interface is not intended to be extended by clients. '
256, 'org.eclipse.ui.menus.IMenuService', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/menus/IMenuService.html', ' The interface that should be implemented by services that make themselves available through the IAdaptable mechanism. This is the interface that drives the majority of services provided at the workbench level. A service has life-cycle. When the constructor completes, the service must be fully functional. When it comes time for the service to go away, then the service will receive a dispose() call. At this point, the service must release all resources and detach all listeners. A service can only be disposed once; it cannot be reused. This interface has nothing to do with OSGi services. This interface can be extended or implemented by clients. Since: 3.2 extends IDisposable A service that responds to changes in one or more sources. These sources can be plugged into the service. Sources represent a common event framework for services. Clients must not extend or implement. Since: 3.2 extends IServiceWithSources Provides services related to the menu architecture within the workbench. It can be used to contribute additional items to the menu, tool bar and status line. This service can be acquired from your service locator: IMenuService service = (IMenuService) getSite().getService(IMenuService.class); This service is available globally. Since: 3.3 Restriction: This interface is not intended to be implemented by clients. Restriction: This interface is not intended to be extended by clients. '
257, 'org.eclipse.swt.events.ShellAdapter', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/events/ShellAdapter.html', 'extends org.eclipse.swt.internal.SWTEventListener Classes which implement this interface provide methods that deal with changes in state of Shells. After creating an instance of a class that implements this interface it can be added to a shell using the addShellListener method and removed using the removeShellListener method. When the state of the shell changes, the appropriate method will be invoked. See Also: ShellAdapter, ShellEvent extends Object implements ShellListener This adapter class provides default implementations for the methods described by the ShellListener interface. Classes that wish to deal with ShellEvents can extend this class and override only the methods which they are interested in. See Also: ShellListener, ShellEvent, Sample code and further information '
258, 'org.eclipse.swt.events.ShellEvent', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/events/ShellEvent.html', 'extends TypedEvent Instances of this class are sent as a result of operations being performed on shells. See Also: ShellListener, Sample code and further information, Serialized Form '
259, 'org.eclipse.ui.presentations.AbstractPresentationFactory', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/presentations/AbstractPresentationFactory.html', 'extends Object This is a factory for presentation objects that control the appearance of editors, views and other components in the workbench. Since: 3.0 '
260, 'org.eclipse.ui.commands.ICommandService', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/commands/ICommandService.html', ' The interface that should be implemented by services that make themselves available through the IAdaptable mechanism. This is the interface that drives the majority of services provided at the workbench level. A service has life-cycle. When the constructor completes, the service must be fully functional. When it comes time for the service to go away, then the service will receive a dispose() call. At this point, the service must release all resources and detach all listeners. A service can only be disposed once; it cannot be reused. This interface has nothing to do with OSGi services. This interface can be extended or implemented by clients. Since: 3.2 extends IDisposable Provides services related to the command architecture within the workbench. This service can be used to access the set of commands and command categories. This service can be acquired from your service locator: ICommandService service = (ICommandService) getSite().getService(ICommandService.class); This service is available globally. Since: 3.1 Restriction: This interface is not intended to be implemented by clients. Restriction: This interface is not intended to be extended by clients. '
261, 'org.eclipse.jface.action.CoolBarManager', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/action/CoolBarManager.html', 'A contribution manager organizes contributions to such UI components as menus, toolbars and status lines. A contribution manager keeps track of a list of contribution items. Each contribution item may has an optional identifier, which can be used to retrieve items from a manager, and for positioning items relative to each other. The list of contribution items can be subdivided into named groups using special contribution items that serve as group markers. The IContributionManager interface provides general protocol for adding, removing, and retrieving contribution items. It also provides convenience methods that make it convenient to contribute actions. This interface should be implemented by all objects that wish to manage contributions. There are several implementions of this interface in this package, including ones for menus (MenuManager), tool bars (ToolBarManager), and status lines (StatusLineManager). A contribution manager organizes contributions to such UI components as menus, toolbars and status lines. A contribution manager keeps track of a list of contribution items. Each contribution item may has an optional identifier, which can be used to retrieve items from a manager, and for positioning items relative to each other. The list of contribution items can be subdivided into named groups using special contribution items that serve as group markers. The IContributionManager interface provides general protocol for adding, removing, and retrieving contribution items. It also provides convenience methods that make it convenient to contribute actions. This interface should be implemented by all objects that wish to manage contributions. There are several implementions of this interface in this package, including ones for menus (MenuManager), tool bars (ToolBarManager), and status lines (StatusLineManager). extends IContributionManager The ICoolBarManager interface provides protocol for managing contributions to a cool bar. A cool bar manager delegates responsibility for creating child controls to its contribution items by calling IContributionItem.fill(CoolBar, int). This interface is internal to the framework; it should not be implemented outside the framework. This package provides a concrete cool bar manager implementation, CoolBarManager, which clients may instantiate or subclass. Since: 3.0 See Also: ToolBarContributionItem extends ContributionManager implements ICoolBarManager A cool bar manager is a contribution manager which realizes itself and its items in a cool bar control. This class may be instantiated; it may also be subclassed. Since: 3.0 '
262, 'org.eclipse.ui.IViewPart', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/IViewPart.html', 'An interface for an adaptable object. Adaptable objects can be dynamically extended to provide different interfaces (or \"adapters\"). Adapters are created by adapter factories, which are in turn managed by type by adapter managers. For example, IAdaptable a = [some adaptable]; IFoo x = (IFoo)a.getAdapter(IFoo.class); if (x != null) [do IFoo things with x] This interface can be used without OSGi running. Clients may implement this interface, or obtain a default implementation of this interface by subclassing PlatformObject. See Also: IAdapterFactory, IAdapterManager, PlatformObject Objects implementing this interface are capable of saving their state in an IMemento. Since: 3.1 An interface for an adaptable object. Adaptable objects can be dynamically extended to provide different interfaces (or \"adapters\"). Adapters are created by adapter factories, which are in turn managed by type by adapter managers. For example, IAdaptable a = [some adaptable]; IFoo x = (IFoo)a.getAdapter(IFoo.class); if (x != null) [do IFoo things with x] This interface can be used without OSGi running. Clients may implement this interface, or obtain a default implementation of this interface by subclassing PlatformObject. See Also: IAdapterFactory, IAdapterManager, PlatformObject extends IAdaptable A workbench part is a visual component within a workbench page. There are two subtypes: view and editor, as defined by IViewPart and IEditorPart. A view is typically used to navigate a hierarchy of information (like the workspace), open an editor, or display properties for the active editor. Modifications made in a view are saved immediately. An editor is typically used to edit or browse a document or input object. The input is identified using an IEditorInput. Modifications made in an editor part follow an open-save-close lifecycle model. This interface may be implemented directly. For convenience, a base implementation is defined in WorkbenchPart. The lifecycle of a workbench part is as follows: When a part extension is created: instantiate the part create a part site call part.init(site) When a part becomes visible in the workbench: add part to presentation by calling part.createPartControl(parent) to create actual widgets fire partOpened event to all listeners When a part is activated or gets focus: call part.setFocus() fire partActivated event to all listeners When a part is closed: if save is needed, do save; if it fails or is canceled return if part is active, deactivate part fire partClosed event to all listeners remove part from presentation; part controls are disposed as part of the SWT widget tree call part.dispose() After createPartControl has been called, the implementor may safely reference the controls created. When the part is closed these controls will be disposed as part of an SWT composite. This occurs before the IWorkbenchPart.dispose method is called. If there is a need to free SWT resources the part should define a dispose listener for its own control and free those resources from the dispose listener. If the part invokes any method on the disposed SWT controls after this point an SWTError will be thrown. The last method called on IWorkbenchPart is dispose. This signals the end of the part lifecycle. An important point to note about this lifecycle is that following a call to init, createPartControl may never be called. Thus in the dispose method, implementors must not assume controls were created. Workbench parts implement the IAdaptable interface; extensions are managed by the platform\'s adapter manager. See Also: IViewPart, IEditorPart extends IWorkbenchPart, IPersistable A view is a visual component within a workbench page. It is typically used to navigate a hierarchy of information (like the workspace), open an editor, or display properties for the active editor. Modifications made in a view are saved immediately (in contrast to an editor part, which conforms to a more elaborate open-save-close lifecycle). Only one instance of a particular view type may exist within a workbench page. This policy is designed to simplify part management for a user. This interface may be implemented directly. For convenience, a base implementation is defined in ViewPart. A view is added to the workbench in two steps: A view extension is contributed to the workbench registry. This extension defines the extension id and extension class. The view is included in the default layout for a perspective. Alternatively, the user may open the view from the Perspective menu. Views implement the IAdaptable interface; extensions are managed by the platform\'s adapter manager. As of 3.4, views may optionally adapt to ISizeProvider if they have a preferred size. The default presentation will make a best effort to allocate the preferred size to a view if it is the only part in a stack. If there is more than one part in the stack, the constraints will be disabled for that stack. The size constraints are adjusted for the size of the tab and border trim. Note that this is considered to be a hint to the presentation, and not all presentations may honor size constraints. See Also: IWorkbenchPage.showView(java.lang.String), ViewPart, ISizeProvider '
263, 'org.eclipse.jface.action.Separator', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/action/Separator.html', 'A contribution item represents a contribution to a shared UI resource such as a menu or tool bar. More generally, contribution items are managed by a contribution manager. For instance, in a tool bar a contribution item is a tool bar button or a separator. In a menu bar a contribution item is a menu, and in a menu a contribution item is a menu item or separator. A contribution item can realize itself in different SWT widgets, using the different fill methods. The same type of contribution item can be used with a MenuBarManager, ToolBarManager, CoolBarManager, or a StatusLineManager. This interface is internal to the framework; it should not be implemented outside the framework. See Also: IContributionManager Restriction: This interface is not intended to be implemented by clients. extends AbstractGroupMarker A separator is a special kind of contribution item which acts as a visual separator and, optionally, acts as a group marker. Unlike group markers, separators do have a visual representation for menus and toolbars. This class may be instantiated; it is not intended to be subclassed outside the framework. Restriction: This class is not intended to be subclassed by clients. '
264, 'org.eclipse.ui.preferences.ViewPreferencesAction', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/preferences/ViewPreferencesAction.html', 'An action represents the non-UI side of a command which can be triggered by the end user. Actions are typically associated with buttons, menu items, and items in tool bars. The controls for a command are built by some container, which furnished the context where these controls appear and configures them with data from properties declared by the action. When the end user triggers the command via its control, the action\'s run method is invoked to do the real work. Actions support a predefined set of properties (and possibly others as well). Clients of an action may register property change listeners so that they get notified whenever the value of a property changes. Clients should subclass the abstract base class Action to define concrete actions rather than implementing IAction from scratch. This interface exists only to define the API for actions. It is not intended to be implemented by clients. See Also: Action Restriction: This interface is not intended to be implemented by clients. extends Action The ViewPreferencesAction is the action for opening a view preferences dialog on a class. Since: 3.1 '
265, 'org.eclipse.ui.IActionBars', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/IActionBars.html', 'Used by a part to access its menu, toolbar, and status line managers. Within the workbench each part, editor or view, has a private set of action bars. This set, which contains a menu, toolbar, and status line, appears in the local toolbar for a view and in the window for an editor. The view may provide an implementation for pre-existing actions or add new actions to the action bars. In a workbench window there are a number of actions which are applicable to all parts. Some common examples are CUT, COPY and PASTE. These actions, known as \"global actions\", are contributed to the workbench window by the window itself and shared by all parts. The presentation is owned by the window. The implementation is delegated to the active part. To participate in the global action design an IWorkbenchPart should register a handler for each global action which is implemented by the part. This can be done by calling setGlobalActionHandler. For convenience, the standard global actions are defined in org.eclipse.ui.IWorkbenchActionConstants. Additional work is required for the Delete global action. In this case the accelerator is defined in the menu item text but is not hooked on the window. This is to support text editors where the Delete key is functional even when the Delete action is disabled (no text is selected). An implementation for this accelerator must be defined locally, in each part, by listening for Delete key events. A part may also contribute new actions to the action bars as required. To do this, call getMenuManager, getToolBarManager, or getStatusLineManager as appropriate to get the action target. Add the action(s) to the target and call update to commit any changes to the underlying widgets. This interface is not intended to be implemented by clients. Restriction: This interface is not intended to be implemented by clients. '
266, 'org.eclipse.core.runtime.jobs.ProgressProvider', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/runtime/jobs/ProgressProvider.html', 'extends Object The progress provider supplies the job manager with progress monitors for running jobs. There can only be one progress provider at any given time. This class is intended for use by the currently executing Eclipse application. Plug-ins outside the currently running application should not reference or subclass this class. Since: 3.0 See Also: IJobManager.setProgressProvider(ProgressProvider) '
267, 'org.eclipse.ui.progress.IProgressService', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/progress/IProgressService.html', 'Interface for UI components which can execute a long-running operation in the form of an IRunnableWithProgress. The context is responsible for displaying a progress indicator and Cancel button to the end user while the operation is in progress; the context supplies a progress monitor to be used from code running inside the operation. Note that an IRunnableContext is not a runnable itself. For examples of UI components which implement this interface, see ApplicationWindow, ProgressMonitorDialog, and WizardDialog. See Also: IRunnableWithProgress, ApplicationWindow, ProgressMonitorDialog, WizardDialog extends IRunnableContext The progress service is the primary interface to the workbench progress support. It can be obtained from the workbench and then used to show progress for both background operations and operations that run in the UI thread. All methods on the progress service must be called from the UI thread. This service can be acquired from your service locator: IProgressService service = (IProgressService) getSite().getService(IProgressService.class); This service is available globally. NOTE The progress service must be referenced at least once before it will become the progress provider for the IJobManager in the workbench. This connection is done lazily so that RCP applications will not have to use the IProgressService as the ProgressProvider to the jobs framework if they do not wish to reference it. Since: 3.0 See Also: IWorkbench.getProgressService(), IJobManager.setProgressProvider(org.eclipse.core.runtime.jobs.ProgressProvider), IServiceLocator.getService(Class) Restriction: This interface is not intended to be implemented by clients. '
268, 'org.eclipse.core.runtime.QualifiedName', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/runtime/QualifiedName.html', 'extends Object Qualified names are two-part names: qualifier and local name. The qualifier must be in URI form (see RFC2396). Note however that the qualifier may be null if the default name space is being used. The empty string is not a valid local name. This class can be used without OSGi running. This class is not intended to be subclassed by clients. '
269, 'org.eclipse.core.runtime.jobs.IJobChangeListener', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/runtime/jobs/IJobChangeListener.html', 'Callback interface for clients interested in being notified when jobs change state. A single job listener instance can be added either to the job manager, for notification of all scheduled jobs, or to any set of individual jobs. A single listener instance should not be added to both the job manager, and to individual jobs (such a listener may receive duplicate notifications). Clients should not rely on the result of the Job#getState() method on jobs for which notification is occurring. Listeners are notified of all job state changes, but whether the state change occurs before, during, or after listeners are notified is unspecified. Clients may implement this interface. Since: 3.0 See Also: JobChangeAdapter, IJobManager.addJobChangeListener(IJobChangeListener), IJobManager.removeJobChangeListener(IJobChangeListener), Job.addJobChangeListener(IJobChangeListener), Job.getState(), Job.removeJobChangeListener(IJobChangeListener) '
270, 'org.eclipse.ui.statushandlers.StatusManager', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/statushandlers/StatusManager.html', 'extends Object StatusManager is the entry point for all statuses to be reported in the user interface. Handlers shoudn\'t be used directly but through the StatusManager singleton which keeps the status handling policy and chooses handlers. StatusManager.getManager().handle(IStatus) and handle(IStatus status, int style) are the methods are the primary access points to the StatusManager. Acceptable styles (can be combined with logical OR) NONE - a style indicating that the status should not be acted on. This is used by objects such as log listeners that do not want to report a status twice LOG - a style indicating that the status should be logged only SHOW - a style indicating that handlers should show a problem to an user without blocking the calling method while awaiting user response. This is generally done using a non modal Dialog BLOCK - a style indicating that the handling should block the calling method until the user has responded. This is generally done using a modal window such as a Dialog Handlers are intended to be accessed via the status manager. The StatusManager chooses which handler should be used for a particular error. There are two ways for adding handlers to the handling flow. First using extension point org.eclipse.ui.statusHandlers, second by the workbench advisor and its method WorkbenchAdvisor.getWorkbenchErrorHandler(). If a handler is associated with a product, it is used instead of this defined in advisor. Since: 3.3 See Also: AbstractStatusHandler '
271, 'org.eclipse.jface.dialogs.Dialog', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/dialogs/Dialog.html', 'Interface for objects that can return a shell. This is normally used for opening child windows. An object that wants to open child shells can take an IShellProvider in its constructor, and the object that implements IShellProvider can dynamically choose where child shells should be opened. Since: 3.1 extends Window A dialog is a specialized window used for narrow-focused communication with the user. Dialogs are usually modal. Consequently, it is generally bad practice to open a dialog without a parent. A modal dialog without a parent is not prevented from disappearing behind the application\'s other windows, making it very confusing for the user. If more than one modal dialog is open, the second one should be parented off of the shell of the first one. Otherwise, it is possible that the OS will give focus to the first dialog, potentially blocking the UI. This class also moves the default button to the right if required, see initializeBounds(). '
272, 'org.eclipse.ui.statushandlers.StatusAdapter', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/statushandlers/StatusAdapter.html', 'An interface for an adaptable object. Adaptable objects can be dynamically extended to provide different interfaces (or \"adapters\"). Adapters are created by adapter factories, which are in turn managed by type by adapter managers. For example, IAdaptable a = [some adaptable]; IFoo x = (IFoo)a.getAdapter(IFoo.class); if (x != null) [do IFoo things with x] This interface can be used without OSGi running. Clients may implement this interface, or obtain a default implementation of this interface by subclassing PlatformObject. See Also: IAdapterFactory, IAdapterManager, PlatformObject extends Object implements IAdaptable The StatusAdapter wraps an instance of IStatus subclass and can hold additional information either by using properties or by adding a new adapter. Used during status handling process. Since: 3.3 '
273, 'org.eclipse.core.runtime.jobs.JobChangeAdapter', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/runtime/jobs/JobChangeAdapter.html', 'Callback interface for clients interested in being notified when jobs change state. A single job listener instance can be added either to the job manager, for notification of all scheduled jobs, or to any set of individual jobs. A single listener instance should not be added to both the job manager, and to individual jobs (such a listener may receive duplicate notifications). Clients should not rely on the result of the Job#getState() method on jobs for which notification is occurring. Listeners are notified of all job state changes, but whether the state change occurs before, during, or after listeners are notified is unspecified. Clients may implement this interface. Since: 3.0 See Also: JobChangeAdapter, IJobManager.addJobChangeListener(IJobChangeListener), IJobManager.removeJobChangeListener(IJobChangeListener), Job.addJobChangeListener(IJobChangeListener), Job.getState(), Job.removeJobChangeListener(IJobChangeListener) extends Object implements IJobChangeListener This adapter class provides default implementations for the methods described by the IJobChangeListener interface. Classes that wish to listen to the progress of scheduled jobs can extend this class and override only the methods which they are interested in. Since: 3.0 See Also: IJobChangeListener '
274, 'org.eclipse.core.runtime.jobs.IJobChangeEvent', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/runtime/jobs/IJobChangeEvent.html', 'An event describing a change to the state of a job. Since: 3.0 See Also: IJobChangeListener Restriction: This interface is not intended to be implemented by clients. Restriction: This interface is not intended to be extended by clients. '
275, 'org.eclipse.swt.graphics.ImageData', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/graphics/ImageData.html', 'extends Object implements org.eclipse.swt.internal.CloneableCompatibility Instances of this class are device-independent descriptions of images. They are typically used as an intermediate format between loading from or writing to streams and creating an Image. Note that the public fields x, y, disposalMethod and delayTime are typically only used when the image is in a set of images used for animation. See Also: Image, ImageLoader, ImageData snippets, SWT Example: ImageAnalyzer, Sample code and further information '
276, 'org.eclipse.swt.graphics.ImageLoader', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/graphics/ImageLoader.html', 'extends Object Instances of this class are used to load images from, and save images to, a file or stream. Currently supported image formats are: BMP (Windows or OS/2 Bitmap) ICO (Windows Icon) JPEG GIF PNG TIFF ImageLoaders can be used to: load/save single images in all formats load/save multiple images (GIF/ICO/TIFF) load/save animated GIF images load interlaced GIF/PNG images load progressive JPEG images See Also: SWT Example: ImageAnalyzer, Sample code and further information '
277, 'org.eclipse.core.runtime.jobs.ISchedulingRule', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/runtime/jobs/ISchedulingRule.html', 'Scheduling rules are used by jobs to indicate when they need exclusive access to a resource. Scheduling rules can also be applied synchronously to a thread using IJobManager.beginRule(ISchedulingRule) and IJobManager.endRule(ISchedulingRule). The job manager guarantees that no two jobs with conflicting scheduling rules will run concurrently. Multiple rules can be applied to a given thread only if the outer rule explicitly allows the nesting as specified by the contains method. Clients may implement this interface. Since: 3.0 See Also: Job.getRule(), Job.setRule(ISchedulingRule), Job.schedule(long), IJobManager.beginRule(ISchedulingRule, org.eclipse.core.runtime.IProgressMonitor), IJobManager.endRule(ISchedulingRule) '
278, 'org.eclipse.jface.resource.ImageRegistry', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/resource/ImageRegistry.html', 'extends Object An image registry maintains a mapping between symbolic image names and SWT image objects or special image descriptor objects which defer the creation of SWT image objects until they are needed. An image registry owns all of the image objects registered with it, and automatically disposes of them when the SWT Display that creates the images is disposed. Because of this, clients do not need to (indeed, must not attempt to) dispose of these images themselves. Clients may instantiate this class (it was not designed to be subclassed). Unlike the FontRegistry, it is an error to replace images. As a result there are no events that fire when values are changed in the registry Restriction: This class is not intended to be subclassed by clients. '
279, 'org.eclipse.jface.viewers.ViewerComparator', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/viewers/ViewerComparator.html', 'extends Object A viewer comparator is used by a StructuredViewer to reorder the elements provided by its content provider. The default compare method compares elements using two steps. The first step uses the values returned from category. By default, all elements are in the same category. The second level is based on a case insensitive compare of the strings obtained from the content viewer\'s label provider via ILabelProvider.getText. Subclasses may implement the isSorterProperty method; they may reimplement the category method to provide categorization; and they may override the compare methods to provide a totally different way of sorting elements. Since: 3.2 See Also: IStructuredContentProvider, StructuredViewer '
280, 'org.eclipse.swt.widgets.ToolBar', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/widgets/ToolBar.html', 'Implementers of Drawable can have a graphics context (GC) created for them, and then they can be drawn on by sending messages to their associated GC. SWT images, and device objects such as the Display device and the Printer device, are drawables. IMPORTANT: This interface is not part of the SWT public API. It is marked public only so that it can be shared within the packages provided by SWT. It should never be referenced from application code. See Also: Device, Image, GC extends Composite Instances of this class support the layout of selectable tool bar items. The item children that may be added to instances of this class must be of type ToolItem. Note that although this class is a subclass of Composite, it does not make sense to add Control children to it, or set a layout on it. Styles: FLAT, WRAP, RIGHT, HORIZONTAL, VERTICAL, SHADOW_OUT Events: (none) Note: Only one of the styles HORIZONTAL and VERTICAL may be specified. IMPORTANT: This class is not intended to be subclassed. See Also: ToolBar, ToolItem snippets, SWT Example: ControlExample, Sample code and further information Restriction: This class is not intended to be subclassed by clients. '
281, 'org.eclipse.swt.widgets.ProgressBar', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/widgets/ProgressBar.html', 'Implementers of Drawable can have a graphics context (GC) created for them, and then they can be drawn on by sending messages to their associated GC. SWT images, and device objects such as the Display device and the Printer device, are drawables. IMPORTANT: This interface is not part of the SWT public API. It is marked public only so that it can be shared within the packages provided by SWT. It should never be referenced from application code. See Also: Device, Image, GC extends Control Instances of the receiver represent an unselectable user interface object that is used to display progress, typically in the form of a bar. Styles: SMOOTH, HORIZONTAL, VERTICAL, INDETERMINATE Events: (none) Note: Only one of the styles HORIZONTAL and VERTICAL may be specified. IMPORTANT: This class is not intended to be subclassed. See Also: ProgressBar snippets, SWT Example: ControlExample, Sample code and further information Restriction: This class is not intended to be subclassed by clients. '
282, 'org.eclipse.jface.resource.ResourceManager', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/resource/ResourceManager.html', 'extends Object This class manages SWT resources. It manages reference-counted instances of resources such as Fonts, Images, and Colors, and allows them to be accessed using descriptors. Everything allocated through the registry should also be disposed through the registry. Since the resources are shared and reference counted, they should never be disposed directly. ResourceManager handles correct allocation and disposal of resources. It differs from the various JFace *Registry classes, which also map symbolic IDs onto resources. In general, you should use a *Registry class to map IDs onto descriptors, and use a ResourceManager to convert the descriptors into real Images/Fonts/etc. Since: 3.1 '
283, 'org.eclipse.swt.widgets.Link', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/widgets/Link.html', 'Implementers of Drawable can have a graphics context (GC) created for them, and then they can be drawn on by sending messages to their associated GC. SWT images, and device objects such as the Display device and the Printer device, are drawables. IMPORTANT: This interface is not part of the SWT public API. It is marked public only so that it can be shared within the packages provided by SWT. It should never be referenced from application code. See Also: Device, Image, GC extends Control Instances of this class represent a selectable user interface object that displays a text with links. Styles: (none) Events: Selection IMPORTANT: This class is not intended to be subclassed. Since: 3.1 See Also: Link snippets, SWT Example: ControlExample, Sample code and further information Restriction: This class is not intended to be subclassed by clients. '
284, 'org.eclipse.jface.viewers.ILabelDecorator', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/viewers/ILabelDecorator.html', 'A label provider maps an element of the viewer\'s model to an optional image and optional text string used to display the element in the viewer\'s control. Certain label providers may allow multiple labels per element. This is an \"abstract interface\", defining methods common to all label providers, but does not actually define the methods to get the label(s) for an element. This interface should never be directly implemented. Most viewers will take either an ILabelProvider or an ITableLabelProvider. A label provider must not be shared between viewers since a label provider generally manages SWT resources (images), which must be disposed when the viewer is disposed. To simplify life cycle management, the current label provider of a viewer is disposed when the viewer is disposed. Label providers can be used outside the context of viewers wherever images are needed. When label providers are used in this fashion it is the responsibility of the user to ensure dispose is called when the provider is no longer needed. See Also: ILabelProvider, ITableLabelProvider extends IBaseLabelProvider A label decorator decorates the label text and image for some element. The original label text and image are obtained by some other means, for example by a label provider. See Also: ILabelProvider '
285, 'org.eclipse.swt.layout.FormLayout', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/layout/FormLayout.html', 'extends Layout Instances of this class control the position and size of the children of a composite control by using FormAttachments to optionally configure the left, top, right and bottom edges of each child. The following example code creates a FormLayout and then sets it into a Shell: Display display = new Display (); Shell shell = new Shell(display); FormLayout layout = new FormLayout(); layout.marginWidth = 3; layout.marginHeight = 3; shell.setLayout(layout); To use a FormLayout, create a FormData with FormAttachment for each child of Composite. The following example code attaches button1 to the top and left edge of the composite and button2 to the right edge of button1 and the top and right edges of the composite: FormData data1 = new FormData(); data1.left = new FormAttachment(0, 0); data1.top = new FormAttachment(0, 0); button1.setLayoutData(data1); FormData data2 = new FormData(); data2.left = new FormAttachment(button1); data2.top = new FormAttachment(0, 0); data2.right = new FormAttachment(100, 0); button2.setLayoutData(data2); Each side of a child control can be attached to a position in the parent composite, or to other controls within the Composite by creating instances of FormAttachment and setting them into the top, bottom, left, and right fields of the child\'s FormData. If a side is not given an attachment, it is defined as not being attached to anything, causing the child to remain at its preferred size. If a child is given no attachment on either the left or the right or top or bottom, it is automatically attached to the left and top of the composite respectively. The following code positions button1 and button2 but relies on default attachments: FormData data2 = new FormData(); data2.left = new FormAttachment(button1); data2.right = new FormAttachment(100, 0); button2.setLayoutData(data2); IMPORTANT: Do not define circular attachments. For example, do not attach the right edge of button1 to the left edge of button2 and then attach the left edge of button2 to the right edge of button1. This will over constrain the layout, causing undefined behavior. The algorithm will terminate, but the results are undefined. Since: 2.0 See Also: FormData, FormAttachment, FormLayout snippets, SWT Example: LayoutExample, Sample code and further information '
286, 'org.eclipse.swt.layout.FormData', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/layout/FormData.html', 'extends Object Instances of this class are used to define the attachments of a control in a FormLayout. To set a FormData object into a control, you use the setLayoutData () method. To define attachments for the FormData, set the fields directly, like this: FormData data = new FormData(); data.left = new FormAttachment(0,5); data.right = new FormAttachment(100,-5); button.setLayoutData(formData); FormData contains the FormAttachments for each edge of the control that the FormLayout uses to determine the size and position of the control. FormData objects also allow you to set the width and height of controls within a FormLayout. Since: 2.0 See Also: FormLayout, FormAttachment, Sample code and further information '
287, 'org.eclipse.swt.layout.FormAttachment', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/layout/FormAttachment.html', 'extends Object Instances of this class are used to define the edges of a control within a FormLayout. FormAttachments are set into the top, bottom, left, and right fields of the FormData for a control. For example: FormData data = new FormData(); data.top = new FormAttachment(0,5); data.bottom = new FormAttachment(100,-5); data.left = new FormAttachment(0,5); data.right = new FormAttachment(100,-5); button.setLayoutData(data); A FormAttachment defines where to attach the side of a control by using the equation, y = ax + b. The \"a\" term represents a fraction of the parent composite\'s width (from the left) or height (from the top). It can be defined using a numerator and denominator, or just a percentage value. If a percentage is used, the denominator is set to 100. The \"b\" term in the equation represents an offset, in pixels, from the attachment position. For example: FormAttachment attach = new FormAttachment (20, -5); specifies that the side to which the FormAttachment object belongs will lie at 20% of the parent composite, minus 5 pixels. Control sides can also be attached to another control. For example: FormAttachment attach = new FormAttachment (button, 10); specifies that the side to which the FormAttachment object belongs will lie in the same position as the adjacent side of the button control, plus 10 pixels. The control side can also be attached to the opposite side of the specified control. For example: FormData data = new FormData (); data.left = new FormAttachment (button, 0, SWT.LEFT); specifies that the left side of the control will lie in the same position as the left side of the button control. The control can also be attached in a position that will center the control on the specified control. For example: data.left = new FormAttachment (button, 0, SWT.CENTER); specifies that the left side of the control will be positioned so that it is centered between the left and right sides of the button control. If the alignment is not specified, the default is to attach to the adjacent side. Since: 2.0 See Also: FormLayout, FormData, Sample code and further information '
288, 'org.eclipse.jface.resource.LocalResourceManager', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/resource/LocalResourceManager.html', 'extends ResourceManager A local registry that shares its resources with some global registry. LocalResourceManager is typically used to safeguard against leaks. Clients can use a nested registry to allocate and deallocate resources in the global registry. Calling dispose() on the nested registry will deallocate everything allocated for the nested registry without affecting the rest of the global registry. A nested registry can be used to manage the resources for, say, a dialog box. Since: 3.1 '
289, 'org.eclipse.core.runtime.Status', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/runtime/Status.html', 'A status object represents the outcome of an operation. All CoreExceptions carry a status object to indicate what went wrong. Status objects are also returned by methods needing to provide details of failures (e.g., validation methods). A status carries the following information: plug-in identifier (required) severity (required) status code (required) message (required) - localized to current locale exception (optional) - for problems stemming from a failure at a lower level Some status objects, known as multi-statuses, have other status objects as children. The class Status is the standard public implementation of status objects; the subclass MultiStatus is the implements multi-status objects. This interface can be used without OSGi running. See Also: MultiStatus, Status extends Object implements IStatus A concrete status implementation, suitable either for instantiating or subclassing. This class can be used without OSGi running. '
290, 'org.eclipse.jface.util.Util', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/util/Util.html', 'extends Object A static class providing utility methods to all of JFace. Since: 3.1 '
291, 'org.eclipse.ui.ISizeProvider', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/ISizeProvider.html', 'Interface implemented by objects that are capable of computing a preferred size. Since: 3.1 '
292, 'org.eclipse.ui.IPropertyListener', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/IPropertyListener.html', 'Interface for listening for property changes on an object. This interface may be implemented by clients. See Also: IWorkbenchPart.addPropertyListener(org.eclipse.ui.IPropertyListener) '
293, 'org.eclipse.ui.ISaveablesLifecycleListener', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/ISaveablesLifecycleListener.html', 'Listener for events fired by implementers of ISaveablesSource. This service can be acquired from a part\'s service locator: ISaveablesLifecycleListener listener = (ISaveablesLifecycleListener) getSite() .getService(ISaveablesLifecycleListener.class); or, in the case of implementers of ISaveablesSource that are not a part, from the workbench: ISaveablesLifecycleListener listener = (ISaveablesLifecycleListener) workbench .getService(ISaveablesLifecycleListener.class); This service is available globally. Since: 3.2 '
294, 'org.eclipse.ui.IWorkbenchPart3', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/IWorkbenchPart3.html', 'An interface for an adaptable object. Adaptable objects can be dynamically extended to provide different interfaces (or \"adapters\"). Adapters are created by adapter factories, which are in turn managed by type by adapter managers. For example, IAdaptable a = [some adaptable]; IFoo x = (IFoo)a.getAdapter(IFoo.class); if (x != null) [do IFoo things with x] This interface can be used without OSGi running. Clients may implement this interface, or obtain a default implementation of this interface by subclassing PlatformObject. See Also: IAdapterFactory, IAdapterManager, PlatformObject An interface for an adaptable object. Adaptable objects can be dynamically extended to provide different interfaces (or \"adapters\"). Adapters are created by adapter factories, which are in turn managed by type by adapter managers. For example, IAdaptable a = [some adaptable]; IFoo x = (IFoo)a.getAdapter(IFoo.class); if (x != null) [do IFoo things with x] This interface can be used without OSGi running. Clients may implement this interface, or obtain a default implementation of this interface by subclassing PlatformObject. See Also: IAdapterFactory, IAdapterManager, PlatformObject extends IAdaptable A workbench part is a visual component within a workbench page. There are two subtypes: view and editor, as defined by IViewPart and IEditorPart. A view is typically used to navigate a hierarchy of information (like the workspace), open an editor, or display properties for the active editor. Modifications made in a view are saved immediately. An editor is typically used to edit or browse a document or input object. The input is identified using an IEditorInput. Modifications made in an editor part follow an open-save-close lifecycle model. This interface may be implemented directly. For convenience, a base implementation is defined in WorkbenchPart. The lifecycle of a workbench part is as follows: When a part extension is created: instantiate the part create a part site call part.init(site) When a part becomes visible in the workbench: add part to presentation by calling part.createPartControl(parent) to create actual widgets fire partOpened event to all listeners When a part is activated or gets focus: call part.setFocus() fire partActivated event to all listeners When a part is closed: if save is needed, do save; if it fails or is canceled return if part is active, deactivate part fire partClosed event to all listeners remove part from presentation; part controls are disposed as part of the SWT widget tree call part.dispose() After createPartControl has been called, the implementor may safely reference the controls created. When the part is closed these controls will be disposed as part of an SWT composite. This occurs before the IWorkbenchPart.dispose method is called. If there is a need to free SWT resources the part should define a dispose listener for its own control and free those resources from the dispose listener. If the part invokes any method on the disposed SWT controls after this point an SWTError will be thrown. The last method called on IWorkbenchPart is dispose. This signals the end of the part lifecycle. An important point to note about this lifecycle is that following a call to init, createPartControl may never be called. Thus in the dispose method, implementors must not assume controls were created. Workbench parts implement the IAdaptable interface; extensions are managed by the platform\'s adapter manager. See Also: IViewPart, IEditorPart extends IWorkbenchPart Extends IWorkbenchPart, adding the name and status text properties. Prior to 3.0, a view\'s title was often modified to show both the part name and extra status text. With this interface, the distinction is made more explicit. Since: 3.0 extends IWorkbenchPart2 A part can provide arbitrary properties. The properties will be persisted between sessions by the part reference, and will be available from the part reference as well as the part. The properties can only be set on a part, not on the reference. The properties will be available to the IPresentablePart. Setting a property must fire a PropertyChangeEvent. Since: 3.3 '
295, 'org.eclipse.swt.events.PaintListener', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/events/PaintListener.html', 'extends org.eclipse.swt.internal.SWTEventListener Classes which implement this interface provide methods that deal with the events that are generated when the control needs to be painted. After creating an instance of a class that implements this interface it can be added to a control using the addPaintListener method and removed using the removePaintListener method. When a paint event occurs, the paintControl method will be invoked. See Also: PaintEvent '
296, 'org.eclipse.swt.graphics.Cursor', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/graphics/Cursor.html', 'extends Resource Instances of this class manage operating system resources that specify the appearance of the on-screen pointer. To create a cursor you specify the device and either a simple cursor style describing one of the standard operating system provided cursors or the image and mask data for the desired appearance. Application code must explicitly invoke the Cursor.dispose() method to release the operating system resources managed by each instance when those instances are no longer required. Styles: CURSOR_ARROW, CURSOR_WAIT, CURSOR_CROSS, CURSOR_APPSTARTING, CURSOR_HELP, CURSOR_SIZEALL, CURSOR_SIZENESW, CURSOR_SIZENS, CURSOR_SIZENWSE, CURSOR_SIZEWE, CURSOR_SIZEN, CURSOR_SIZES, CURSOR_SIZEE, CURSOR_SIZEW, CURSOR_SIZENE, CURSOR_SIZESE, CURSOR_SIZESW, CURSOR_SIZENW, CURSOR_UPARROW, CURSOR_IBEAM, CURSOR_NO, CURSOR_HAND Note: Only one of the above styles may be specified. See Also: Cursor snippets, Sample code and further information '
297, 'org.eclipse.swt.events.PaintEvent', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/events/PaintEvent.html', 'extends TypedEvent Instances of this class are sent as a result of visible areas of controls requiring re-painting. See Also: PaintListener, Sample code and further information, Serialized Form '
298, 'org.eclipse.ui.ISourceProviderListener', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/ISourceProviderListener.html', ' A listener to changes in a particular source of information. This listener is notified as the source changes. Typically, workbench services will implement this interface, and register themselves as listeners to the ISourceProvider instances that are registered with them. Since: 3.1 See Also: ISources, ISourceProvider '
299, 'org.eclipse.ui.ISourceProvider', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/ISourceProvider.html', ' A provider of notifications for when a change has occurred to a particular type of source. These providers can be given to the appropriate service, and this service will then re-evaluate the appropriate pieces of its internal state in response to these changes. It is recommended that clients subclass AbstractSourceProvider instead, as this provides some common support for listeners. Since: 3.1 See Also: IHandlerService, ISources '
300, 'org.eclipse.ui.ISources', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/ISources.html', ' A source is type of event change that can occur within the workbench. For example, the active workbench window can change, so it is considered a source. Workbench services can track changes to these sources, and thereby try to resolve conflicts between a variety of possible options. This is most commonly used for things like handlers and contexts. This interface defines the source that are known to the workbench at compile-time. These sources can be combined in a bit-wise fashion. So, for example, a ACTIVE_PART | ACTIVE_CONTEXT source includes change to both the active context and the active part. The values assigned to each source indicates its relative priority. The higher the value, the more priority the source is given in resolving conflicts. Another way to look at this is that the higher the value, the more \"local\" the source is to what the user is currently doing. This is similar to, but distinct from the concept of components. The nesting support provided by components represent only one source (ACTIVE_SITE) that the workbench understands. Note that for backward compatibility, we must reserve the lowest three bits for Priority instances using the old HandlerSubmission mechanism. This mechanism was used in Eclipse 3.0. Note in 3.3: Currently, source variables are not extensible by user plugins, and the number of bits available for resolving conflicts is limited. When the variable sources become user extensible a new conflict resolution mechanism will be implemented. Since: 3.1 See Also: ISourceProvider Restriction: This interface is not intended to be implemented by clients. Restriction: This interface is not intended to be extended by clients. '
301, 'org.eclipse.ui.services.IEvaluationReference', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/services/IEvaluationReference.html', 'extends org.eclipse.ui.internal.services.IEvaluationResultCache A token representing a core expression and property change listener currently working in the IEvaluationService. Since: 3.4 Restriction: This interface is not intended to be implemented by clients. Restriction: This interface is not intended to be extended by clients. '
302, 'org.eclipse.core.runtime.ISafeRunnable', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/runtime/ISafeRunnable.html', 'Safe runnables represent blocks of code and associated exception handlers. They are typically used when a plug-in needs to call some untrusted code (e.g., code contributed by another plug-in via an extension). This interface can be used without OSGi running. Clients may implement this interface. See Also: SafeRunner.run(ISafeRunnable) '
303, 'org.eclipse.core.runtime.SafeRunner', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/runtime/SafeRunner.html', 'extends Object Runs the given ISafeRunnable in a protected mode: exceptions and certain errors thrown in the runnable are logged and passed to the runnable\'s exception handler. Such exceptions are not rethrown by this method. This class can be used without OSGi running. Since: org.eclipse.equinox.common 3.2 '
304, 'org.eclipse.ui.IEditorReference', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/IEditorReference.html', 'Implements a reference to a IWorkbenchPart. The IWorkbenchPart will not be instantiated until the part becomes visible or the API getPart is sent with true; This interface is not intended to be implemented by clients. Restriction: This interface is not intended to be implemented by clients. extends IWorkbenchPartReference Implements a reference to an editor. The IEditorPart will not be instantiated until the editor becomes visible or the API getEditor(boolean) is called with true. This interface is not intended to be implemented by clients. Restriction: This interface is not intended to be implemented by clients. '
305, 'org.eclipse.ui.IEditorInput', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/IEditorInput.html', 'An interface for an adaptable object. Adaptable objects can be dynamically extended to provide different interfaces (or \"adapters\"). Adapters are created by adapter factories, which are in turn managed by type by adapter managers. For example, IAdaptable a = [some adaptable]; IFoo x = (IFoo)a.getAdapter(IFoo.class); if (x != null) [do IFoo things with x] This interface can be used without OSGi running. Clients may implement this interface, or obtain a default implementation of this interface by subclassing PlatformObject. See Also: IAdapterFactory, IAdapterManager, PlatformObject extends IAdaptable IEditorInput is a light weight descriptor of editor input, like a file name but more abstract. It is not a model. It is a description of the model source for an IEditorPart. Clients implementing this editor input interface should override Object.equals(Object) to answer true for two inputs that are the same. The IWorbenchPage.openEditor APIs are dependent on this to find an editor with the same input. Clients should extend this interface to declare new types of editor inputs. An editor input is passed to an editor via the IEditorPart.init method. Due to the wide range of valid editor inputs, it is not possible to define generic methods for getting and setting bytes. Editor input must implement the IAdaptable interface; extensions are managed by the platform\'s adapter manager. Please note that it is important that the editor input be light weight. Within the workbench, the navigation history tends to hold on to editor inputs as a means of reconstructing the editor at a later time. The navigation history can hold on to quite a few inputs (i.e., the default is fifty). The actual data model should probably not be held in the input. See Also: IEditorPart, IWorkbenchPage.openEditor(IEditorInput, String), IWorkbenchPage.openEditor(IEditorInput, String, boolean) '
306, 'org.eclipse.ui.IEditorRegistry', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/IEditorRegistry.html', 'Registry of editors known to the workbench. An editor can be created in one of two ways: An editor can be defined by an extension to the workbench. The user manually associates an editor with a given resource extension type. This will override any default workbench or platform association. The registry does not keep track of editors that are \"implicitly\" determined. For example a bitmap (.bmp) file will typically not have a registered editor. Instead, when no registered editor is found, the underlying OS is consulted. This interface is not intended to be implemented by clients. See Also: IWorkbench.getEditorRegistry() Restriction: This interface is not intended to be implemented by clients. '
307, 'org.eclipse.ui.IEditorPart', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/IEditorPart.html', 'An interface for an adaptable object. Adaptable objects can be dynamically extended to provide different interfaces (or \"adapters\"). Adapters are created by adapter factories, which are in turn managed by type by adapter managers. For example, IAdaptable a = [some adaptable]; IFoo x = (IFoo)a.getAdapter(IFoo.class); if (x != null) [do IFoo things with x] This interface can be used without OSGi running. Clients may implement this interface, or obtain a default implementation of this interface by subclassing PlatformObject. See Also: IAdapterFactory, IAdapterManager, PlatformObject Workbench parts implement or adapt to this interface to participate in the enablement and execution of the Save and Save As actions. Since: 2.1 See Also: IEditorPart An interface for an adaptable object. Adaptable objects can be dynamically extended to provide different interfaces (or \"adapters\"). Adapters are created by adapter factories, which are in turn managed by type by adapter managers. For example, IAdaptable a = [some adaptable]; IFoo x = (IFoo)a.getAdapter(IFoo.class); if (x != null) [do IFoo things with x] This interface can be used without OSGi running. Clients may implement this interface, or obtain a default implementation of this interface by subclassing PlatformObject. See Also: IAdapterFactory, IAdapterManager, PlatformObject extends IAdaptable A workbench part is a visual component within a workbench page. There are two subtypes: view and editor, as defined by IViewPart and IEditorPart. A view is typically used to navigate a hierarchy of information (like the workspace), open an editor, or display properties for the active editor. Modifications made in a view are saved immediately. An editor is typically used to edit or browse a document or input object. The input is identified using an IEditorInput. Modifications made in an editor part follow an open-save-close lifecycle model. This interface may be implemented directly. For convenience, a base implementation is defined in WorkbenchPart. The lifecycle of a workbench part is as follows: When a part extension is created: instantiate the part create a part site call part.init(site) When a part becomes visible in the workbench: add part to presentation by calling part.createPartControl(parent) to create actual widgets fire partOpened event to all listeners When a part is activated or gets focus: call part.setFocus() fire partActivated event to all listeners When a part is closed: if save is needed, do save; if it fails or is canceled return if part is active, deactivate part fire partClosed event to all listeners remove part from presentation; part controls are disposed as part of the SWT widget tree call part.dispose() After createPartControl has been called, the implementor may safely reference the controls created. When the part is closed these controls will be disposed as part of an SWT composite. This occurs before the IWorkbenchPart.dispose method is called. If there is a need to free SWT resources the part should define a dispose listener for its own control and free those resources from the dispose listener. If the part invokes any method on the disposed SWT controls after this point an SWTError will be thrown. The last method called on IWorkbenchPart is dispose. This signals the end of the part lifecycle. An important point to note about this lifecycle is that following a call to init, createPartControl may never be called. Thus in the dispose method, implementors must not assume controls were created. Workbench parts implement the IAdaptable interface; extensions are managed by the platform\'s adapter manager. See Also: IViewPart, IEditorPart extends IWorkbenchPart, ISaveablePart An editor is a visual component within a workbench page. It is typically used to edit or browse a document or input object. The input is identified using an IEditorInput. Modifications made in an editor part follow an open-save-close lifecycle model (in contrast to a view part, where modifications are saved to the workbench immediately). An editor is document or input-centric. Each editor has an input, and only one editor can exist for each editor input within a page. This policy has been designed to simplify part management. An editor should be used in place of a view whenever more than one instance of a document type can exist. This interface may be implemented directly. For convenience, a base implementation is defined in EditorPart. An editor part is added to the workbench in two stages: An editor extension is contributed to the workbench registry. This extension defines the extension id, extension class, and the file extensions which are supported by the editor. An editor part based upon the extension is created and added to the workbench when the user opens a file with one of the supported file extensions (or some other suitable form of editor input). All editor parts implement the IAdaptable interface; extensions are managed by the platform\'s adapter manager. See Also: IWorkbenchPage.openEditor(IEditorInput, String), EditorPart '
308, 'org.eclipse.ui.IPersistableElement', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/IPersistableElement.html', 'Objects implementing this interface are capable of saving their state in an IMemento. Since: 3.1 extends IPersistable Interface for asking an object to store its state in a memento. This interface is typically included in interfaces where persistance is required. When the workbench is shutdown objects which implement this interface will be persisted. At this time the getFactoryId method is invoked to discover the id of the element factory that will be used to re-create the object from a memento. Then the saveState method is invoked to store the element data into a newly created memento. The resulting mementos are collected up and written out to a single file. During workbench startup these mementos are read from the file. The factory Id for each is retrieved and mapped to an IElementFactory which has been registered in the element factory extension point. If a factory exists for the Id it will be engaged to re-create the original object. See Also: IAdaptable, IMemento, IElementFactory '
309, 'org.eclipse.ui.IPersistableEditor', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/IPersistableEditor.html', 'Objects implementing this interface are capable of saving their state in an IMemento. Since: 3.1 extends IPersistable An editor can implement this interface and participate in the workbench session save/restore cycle using IMemento, similar to how IViewPart currently works. Refer to IWorkbenchPart for the part lifecycle. If a memento is available, restoreState(*) will be inserted into the editor startup. editor.init(site, input) editor.restoreState(memento) editor.createPartControl(parent) ... On workbench shutdown, the editor state will be persisted when the editor references are saved. Since: 3.3 '
310, 'org.eclipse.ui.IElementFactory', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/IElementFactory.html', 'A factory for re-creating objects from a previously saved memento. Clients should implement this interface and include the name of their class in an extension to the platform extension point named \"org.eclipse.ui.elementFactories\". For example, the plug-in\'s XML markup might contain: <extension point=\"org.eclipse.ui.elementFactories\"> <factory id=\"com.example.myplugin.MyFactory\" class=\"com.example.myplugin.MyFactory\" /> </extension> See Also: IPersistableElement, IMemento, IWorkbench.getElementFactory(java.lang.String) '
311, 'org.eclipse.ui.IEditorSite', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/IEditorSite.html', 'An interface for an adaptable object. Adaptable objects can be dynamically extended to provide different interfaces (or \"adapters\"). Adapters are created by adapter factories, which are in turn managed by type by adapter managers. For example, IAdaptable a = [some adaptable]; IFoo x = (IFoo)a.getAdapter(IFoo.class); if (x != null) [do IFoo things with x] This interface can be used without OSGi running. Clients may implement this interface, or obtain a default implementation of this interface by subclassing PlatformObject. See Also: IAdapterFactory, IAdapterManager, PlatformObject A component with which one or more services are registered. The services can be retrieved from this locator using some key -- typically the class representing the interface the service must implement. For example: IHandlerService service = (IHandlerService) workbenchWindow .getService(IHandlerService.class); This interface is not to be implemented or extended by clients. Since: 3.2 Interface for objects that can return a shell. This is normally used for opening child windows. An object that wants to open child shells can take an IShellProvider in its constructor, and the object that implements IShellProvider can dynamically choose where child shells should be opened. Since: 3.1 extends IWorkbenchSite The primary interface between a workbench part and the workbench. This interface is not intended to be implemented or extended by clients. Restriction: This interface is not intended to be implemented by clients. extends IAdaptable, IShellProvider, IServiceLocator The common interface between the workbench and its parts, including pages within parts. The workbench site supports a few services by default. If these services are used to allocate resources, it is important to remember to clean up those resources after you are done with them. Otherwise, the resources will exist until the workbench site is disposed. The supported services are: ICommandService IContextService IHandlerService IBindingService. Resources allocated through this service will not be cleaned up until the workbench shuts down. This interface is not intended to be implemented or extended by clients. Since: 2.0 See Also: IWorkbenchPartSite, IPageSite Restriction: This interface is not intended to be implemented by clients. extends IWorkbenchPartSite The primary interface between an editor part and the workbench. The workbench exposes its implemention of editor part sites via this interface, which is not intended to be implemented or extended by clients. Restriction: This interface is not intended to be implemented by clients. '
312, 'org.eclipse.ui.IEditorActionBarContributor', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/IEditorActionBarContributor.html', 'A editor action bar contributor defines the actions for one or more editors. Within the workbench there may be more than one open editor of a particular type. For instance, there may be 1 or more open Java Editors. To avoid the creation of duplicate actions and action images the editor concept has been split into two. An action contributor is responsible for the creation of actions. The editor is responsible for action implementation. Furthermore, the contributor is shared by each open editor. As a result of this design there is only 1 set of actions for 1 or more open editors. The relationship between editor and contributor is defined by the org.eclipse.ui.editors extension point in the plugin registry. This interface should not be implemented directly. An implementation of this interface has been created in EditorActionBarContributor. Implementors should subclass this and specialize as required. See Also: IEditorActionBarContributor '
313, 'org.eclipse.jface.preference.PreferencePage', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/preference/PreferencePage.html', 'Interface for a page in a multi-page dialog. Minimal interface to a message provider. Used for dialog pages which can provide a message with an icon. Since: 2.0 extends IDialogPage An interface for a preference page. This interface is used primarily by the page\'s container extends DialogPage implements IPreferencePage Abstract base implementation for all preference page implementations. Subclasses must implement the createContents framework method to supply the page\'s main control. Subclasses should extend the doComputeSize framework method to compute the size of the page\'s control. Subclasses may override the performOk, performApply, performDefaults, performCancel, and performHelp framework methods to react to the standard button events. Subclasses may call the noDefaultAndApplyButton framework method before the page\'s control has been created to suppress the standard Apply and Defaults buttons. '
314, 'org.eclipse.ui.IWorkbenchPreferencePage', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/IWorkbenchPreferencePage.html', 'Interface for a page in a multi-page dialog. extends IDialogPage An interface for a preference page. This interface is used primarily by the page\'s container extends IPreferencePage Interface for workbench preference pages. Clients should implement this interface and include the name of their class in an extension contributed to the workbench\'s preference extension point (named \"org.eclipse.ui.preferencePages\"). For example, the plug-in\'s XML markup might contain: <extension point=\"org.eclipse.ui.preferencePages\"> <page id=\"com.example.myplugin.prefs\" name=\"Knobs\" class=\"com.example.myplugin.MyPreferencePage\" /> </extension> '
315, 'org.eclipse.core.runtime.IExecutableExtension', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/runtime/IExecutableExtension.html', 'Interface for executable extension classes that require access to their configuration element, or implement an extension adapter. Extension adapters are typically required in cases where the extension implementation does not follow the interface rules specified by the provider of the extension point. In these cases, the role of the adapter is to map between the extension point interface, and the actual extension implementation. In general, adapters are used when attempting to plug-in existing Java implementations, or non-Java implementations (e.g., external executables). This interface can be used without OSGi running. Clients may implement this interface. See Also: IConfigurationElement.createExecutableExtension(String) '
316, 'org.eclipse.ui.activities.IMutableActivityManager', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/activities/IMutableActivityManager.html', 'An instance of this interface allows clients to manage activities, as defined by the extension point org.eclipse.ui.activities. This interface is not intended to be extended or implemented by clients. Since: 3.0 Restriction: This interface is not intended to be implemented by clients. extends IActivityManager An instance of this interface allows clients to manage activities, as defined by the extension point org.eclipse.ui.activities. This interface extends IActivityManager by granting the ability to alter the set of currently enabled activities. This interface is not intended to be extended or implemented by clients. Since: 3.0 Restriction: This interface is not intended to be implemented by clients. '
317, 'org.eclipse.swt.widgets.TableItem', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/widgets/TableItem.html', 'extends Item Instances of this class represent a selectable user interface object that represents an item in a table. Styles: (none) Events: (none) IMPORTANT: This class is not intended to be subclassed. See Also: Table, TableItem, TableColumn snippets, Sample code and further information Restriction: This class is not intended to be subclassed by clients. '
318, 'org.eclipse.ui.activities.ICategory', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/activities/ICategory.html', 'extends Comparable An instance of this interface is a category as defined by the extension point org.eclipse.ui.activities. An instance of this interface can be obtained from an instance of IActivityManager for any identifier, whether or not a category with that identifier is defined in the extension registry. The handle-based nature of this API allows it to work well with runtime plugin activation and deactivation, which can cause dynamic changes to the extension registry. This interface is not intended to be extended or implemented by clients. Since: 3.0 See Also: IActivityManager Restriction: This interface is not intended to be implemented by clients. '
319, 'org.eclipse.ui.activities.IActivity', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/activities/IActivity.html', 'extends Comparable An instance of this interface is an activity as defined by the extension point org.eclipse.ui.activities. An instance of this interface can be obtained from an instance of IActivityManager for any identifier, whether or not an activity with that identifier is defined in the extension registry. The handle-based nature of this API allows it to work well with runtime plugin activation and deactivation, which can cause dynamic changes to the extension registry. A client may get an IActivity handle that is currently undefined (isDefined() equals false) and listen for it to become defined. This interface is not intended to be extended or implemented by clients. Since: 3.0 See Also: IActivityManager Restriction: This interface is not intended to be implemented by clients. '
320, 'org.eclipse.e4.core.contexts.IContextFunction', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/e4/core/contexts/IContextFunction.html', 'A context function encapsulates evaluation of some code within an IEclipseContext. The result of the function must be derived purely from the provided arguments and context objects, and must be free from side-effects other than the function\'s return value. In particular, the function must be idempotent - subsequent invocations of the same function with the same inputs must produce the same result. A common use for context functions is as a place holder for an object that has not yet been created. These place holders can be stored as values in an IEclipseContext, allowing the concrete value they represent to be computed lazily only when requested. Context functions can optionally be registered as OSGi services. Context implementations may use such registered services to seed context instances with initial values. Registering your context function as a service is a signal that contexts are free to add an instance of your function to their context automatically, using the key specified by the SERVICE_CONTEXT_KEY service property. Since: 1.3 See Also: IEclipseContext.set(String, Object) Restriction: This interface is not intended to be implemented by clients. Function implementations must subclass ContextFunction instead. '
321, 'org.eclipse.jface.action.ContributionItem', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/action/ContributionItem.html', 'A contribution item represents a contribution to a shared UI resource such as a menu or tool bar. More generally, contribution items are managed by a contribution manager. For instance, in a tool bar a contribution item is a tool bar button or a separator. In a menu bar a contribution item is a menu, and in a menu a contribution item is a menu item or separator. A contribution item can realize itself in different SWT widgets, using the different fill methods. The same type of contribution item can be used with a MenuBarManager, ToolBarManager, CoolBarManager, or a StatusLineManager. This interface is internal to the framework; it should not be implemented outside the framework. See Also: IContributionManager Restriction: This interface is not intended to be implemented by clients. extends Object implements IContributionItem An abstract base implementation for contribution items. '
322, 'org.eclipse.core.commands.IStateListener', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/commands/IStateListener.html', ' A listener to changes in some state. Clients may implement, but must not extend this interface. Since: 3.2 '
323, 'org.eclipse.core.commands.State', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/commands/State.html', 'extends EventManager A piece of state information that can be shared between objects, and might be persisted between sessions. This can be used for commands that toggle between two states and wish to pass this state information between different handlers. This state object can either be used as a single state object shared between several commands, or one state object per command -- depending on the needs of the application. Clients may instantiate or extend this class. Since: 3.2 '
324, 'org.eclipse.swt.widgets.Item', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/widgets/Item.html', 'extends Widget This class is the abstract superclass of all non-windowed user interface objects that occur within specific controls. For example, a tree will contain tree items. Styles: (none) Events: (none) See Also: Sample code and further information '
325, 'org.eclipse.e4.ui.model.application.ui.menu.MRenderedMenu', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/e4/ui/model/application/ui/menu/MRenderedMenu.html', ' A representation of the model object \'Element\'. This is the root element for all UI Model elements, defining attribtues common to every element; the element\'s id as well as three general storage elements: Tags: This is a set of strings which can be used to stereotype a particular element. Tags may be specified in element searches and can also be referred to in the CSS styling definition. PersistedState: A string to string map used to store information that nneds to be persisted between sessions. TransientData: A string to object map which can be used to store runtime data relevant to a particular model element. Since: 1.0 The following features are supported: Element Id Persisted State Tags Contributor URI Transient Data A representation of the model object \'Element\'. This is the root element for all UI Model elements, defining attribtues common to every element; the element\'s id as well as three general storage elements: Tags: This is a set of strings which can be used to stereotype a particular element. Tags may be specified in element searches and can also be referred to in the CSS styling definition. PersistedState: A string to string map used to store information that nneds to be persisted between sessions. TransientData: A string to object map which can be used to store runtime data relevant to a particular model element. Since: 1.0 The following features are supported: Element Id Persisted State Tags Contributor URI Transient Data A representation of the model object \'Element\'. This is the root element for all UI Model elements, defining attribtues common to every element; the element\'s id as well as three general storage elements: Tags: This is a set of strings which can be used to stereotype a particular element. Tags may be specified in element searches and can also be referred to in the CSS styling definition. PersistedState: A string to string map used to store information that nneds to be persisted between sessions. TransientData: A string to object map which can be used to store runtime data relevant to a particular model element. Since: 1.0 The following features are supported: Element Id Persisted State Tags Contributor URI Transient Data extends MApplicationElement A representation of the model object \'UI Element\'. This is the base mix-in shared by all model elements that can be rendered into the UI presentation of the application. Its main job is to manage the bindings between the concrete element and the UI \'widget\' representing it in the UI. Since: 1.0 The following features are supported: Widget Renderer To Be Rendered On Top Visible Parent Container Data Cur Shared Ref Visible When Accessibility Phrase A representation of the model object \'UI Label\'. This is a mix in that will be used for UI Elements that are capable of showing label information in the GUI (e.g. Parts, Menus / Toolbars, Persepectives...) Since: 1.0 The following features are supported: Label Icon URI Tooltip extends MUIElement, MUILabel A representation of the model object \'Element\'. This is the bsae type for both menu items and Separators. Since: 1.0 The following features are supported: Mnemonics A representation of the model object \'Element\'. This is the root element for all UI Model elements, defining attribtues common to every element; the element\'s id as well as three general storage elements: Tags: This is a set of strings which can be used to stereotype a particular element. Tags may be specified in element searches and can also be referred to in the CSS styling definition. PersistedState: A string to string map used to store information that nneds to be persisted between sessions. TransientData: A string to object map which can be used to store runtime data relevant to a particular model element. Since: 1.0 The following features are supported: Element Id Persisted State Tags Contributor URI Transient Data extends MApplicationElement A representation of the model object \'UI Element\'. This is the base mix-in shared by all model elements that can be rendered into the UI presentation of the application. Its main job is to manage the bindings between the concrete element and the UI \'widget\' representing it in the UI. Since: 1.0 The following features are supported: Widget Renderer To Be Rendered On Top Visible Parent Container Data Cur Shared Ref Visible When Accessibility Phrase extends MMenu A representation of the model object \'Rendered Menu\'. Do no use! This class will be removed at the beginning of Luna (4.4) development. Since: 1.0 The following features are supported: Contribution Manager Restriction: '
326, 'org.eclipse.jface.action.IMenuCreator', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/action/IMenuCreator.html', 'Interface for something that creates and disposes of SWT menus. Note that it is the responsibility of the implementor to dispose of SWT menus it creates. '
327, 'org.eclipse.e4.ui.model.application.ui.MContext', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/e4/ui/model/application/ui/MContext.html', ' A representation of the model object \'Context\'. This class is mixed into a UI element when that element is expected to participate in the Dependency Injection context hierarchy. The context life-cycle matches that of the rendered element it belongs to. It\'s automatically created when the element is rendered and disposed when the element is unrendered. Since: 1.0 The following features are supported: Context Variables Properties '
328, 'org.eclipse.e4.ui.model.application.ui.menu.MDirectToolItem', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/e4/ui/model/application/ui/menu/MDirectToolItem.html', ' A representation of the model object \'Element\'. This is the root element for all UI Model elements, defining attribtues common to every element; the element\'s id as well as three general storage elements: Tags: This is a set of strings which can be used to stereotype a particular element. Tags may be specified in element searches and can also be referred to in the CSS styling definition. PersistedState: A string to string map used to store information that nneds to be persisted between sessions. TransientData: A string to object map which can be used to store runtime data relevant to a particular model element. Since: 1.0 The following features are supported: Element Id Persisted State Tags Contributor URI Transient Data extends MApplicationElement A representation of the model object \'Contribution\'. MContribution is a mix-in class used by concrete elements such as Parts to define the location of the client supplied class implementing the specific logic needed. Since: 1.0 The following features are supported: Contribution URI Object A representation of the model object \'Element\'. This is the root element for all UI Model elements, defining attribtues common to every element; the element\'s id as well as three general storage elements: Tags: This is a set of strings which can be used to stereotype a particular element. Tags may be specified in element searches and can also be referred to in the CSS styling definition. PersistedState: A string to string map used to store information that nneds to be persisted between sessions. TransientData: A string to object map which can be used to store runtime data relevant to a particular model element. Since: 1.0 The following features are supported: Element Id Persisted State Tags Contributor URI Transient Data A representation of the model object \'Element\'. This is the root element for all UI Model elements, defining attribtues common to every element; the element\'s id as well as three general storage elements: Tags: This is a set of strings which can be used to stereotype a particular element. Tags may be specified in element searches and can also be referred to in the CSS styling definition. PersistedState: A string to string map used to store information that nneds to be persisted between sessions. TransientData: A string to object map which can be used to store runtime data relevant to a particular model element. Since: 1.0 The following features are supported: Element Id Persisted State Tags Contributor URI Transient Data extends MApplicationElement A representation of the model object \'UI Element\'. This is the base mix-in shared by all model elements that can be rendered into the UI presentation of the application. Its main job is to manage the bindings between the concrete element and the UI \'widget\' representing it in the UI. Since: 1.0 The following features are supported: Widget Renderer To Be Rendered On Top Visible Parent Container Data Cur Shared Ref Visible When Accessibility Phrase extends MUIElement A representation of the model object \'Tool Bar Element\'. This is a placeholder class mixed in to any other type that can be added to a Toolbar. Since: 1.0 A representation of the model object \'Element\'. This is the root element for all UI Model elements, defining attribtues common to every element; the element\'s id as well as three general storage elements: Tags: This is a set of strings which can be used to stereotype a particular element. Tags may be specified in element searches and can also be referred to in the CSS styling definition. PersistedState: A string to string map used to store information that nneds to be persisted between sessions. TransientData: A string to object map which can be used to store runtime data relevant to a particular model element. Since: 1.0 The following features are supported: Element Id Persisted State Tags Contributor URI Transient Data extends MUIElement A representation of the model object \'Tool Bar Element\'. This is a placeholder class mixed in to any other type that can be added to a Toolbar. Since: 1.0 extends MApplicationElement A representation of the model object \'UI Element\'. This is the base mix-in shared by all model elements that can be rendered into the UI presentation of the application. Its main job is to manage the bindings between the concrete element and the UI \'widget\' representing it in the UI. Since: 1.0 The following features are supported: Widget Renderer To Be Rendered On Top Visible Parent Container Data Cur Shared Ref Visible When Accessibility Phrase A representation of the model object \'UI Label\'. This is a mix in that will be used for UI Elements that are capable of showing label information in the GUI (e.g. Parts, Menus / Toolbars, Persepectives...) Since: 1.0 The following features are supported: Label Icon URI Tooltip extends MItem, MToolBarElement A representation of the model object \'Tool Item\'. This is the base type for both Direct and Handled tool items. Since: 1.0 The following features are supported: Menu A representation of the model object \'Element\'. This is the root element for all UI Model elements, defining attribtues common to every element; the element\'s id as well as three general storage elements: Tags: This is a set of strings which can be used to stereotype a particular element. Tags may be specified in element searches and can also be referred to in the CSS styling definition. PersistedState: A string to string map used to store information that nneds to be persisted between sessions. TransientData: A string to object map which can be used to store runtime data relevant to a particular model element. Since: 1.0 The following features are supported: Element Id Persisted State Tags Contributor URI Transient Data extends MApplicationElement A representation of the model object \'UI Element\'. This is the base mix-in shared by all model elements that can be rendered into the UI presentation of the application. Its main job is to manage the bindings between the concrete element and the UI \'widget\' representing it in the UI. Since: 1.0 The following features are supported: Widget Renderer To Be Rendered On Top Visible Parent Container Data Cur Shared Ref Visible When Accessibility Phrase A representation of the model object \'UI Label\'. This is a mix in that will be used for UI Elements that are capable of showing label information in the GUI (e.g. Parts, Menus / Toolbars, Persepectives...) Since: 1.0 The following features are supported: Label Icon URI Tooltip extends MToolItem, MContribution A representation of the model object \'Direct Tool Item\'. This is the concrete class use to represent a tool item that is directly invoked when selected. The supplied contribution is asked to execute when selected. Since: 1.0 '
329, 'org.eclipse.e4.ui.model.application.ui.menu.MPopupMenu', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/e4/ui/model/application/ui/menu/MPopupMenu.html', ' A representation of the model object \'Element\'. This is the root element for all UI Model elements, defining attribtues common to every element; the element\'s id as well as three general storage elements: Tags: This is a set of strings which can be used to stereotype a particular element. Tags may be specified in element searches and can also be referred to in the CSS styling definition. PersistedState: A string to string map used to store information that nneds to be persisted between sessions. TransientData: A string to object map which can be used to store runtime data relevant to a particular model element. Since: 1.0 The following features are supported: Element Id Persisted State Tags Contributor URI Transient Data A representation of the model object \'Context\'. This class is mixed into a UI element when that element is expected to participate in the Dependency Injection context hierarchy. The context life-cycle matches that of the rendered element it belongs to. It\'s automatically created when the element is rendered and disposed when the element is unrendered. Since: 1.0 The following features are supported: Context Variables Properties A representation of the model object \'Element\'. This is the root element for all UI Model elements, defining attribtues common to every element; the element\'s id as well as three general storage elements: Tags: This is a set of strings which can be used to stereotype a particular element. Tags may be specified in element searches and can also be referred to in the CSS styling definition. PersistedState: A string to string map used to store information that nneds to be persisted between sessions. TransientData: A string to object map which can be used to store runtime data relevant to a particular model element. Since: 1.0 The following features are supported: Element Id Persisted State Tags Contributor URI Transient Data A representation of the model object \'Element\'. This is the root element for all UI Model elements, defining attribtues common to every element; the element\'s id as well as three general storage elements: Tags: This is a set of strings which can be used to stereotype a particular element. Tags may be specified in element searches and can also be referred to in the CSS styling definition. PersistedState: A string to string map used to store information that nneds to be persisted between sessions. TransientData: A string to object map which can be used to store runtime data relevant to a particular model element. Since: 1.0 The following features are supported: Element Id Persisted State Tags Contributor URI Transient Data extends MApplicationElement A representation of the model object \'UI Element\'. This is the base mix-in shared by all model elements that can be rendered into the UI presentation of the application. Its main job is to manage the bindings between the concrete element and the UI \'widget\' representing it in the UI. Since: 1.0 The following features are supported: Widget Renderer To Be Rendered On Top Visible Parent Container Data Cur Shared Ref Visible When Accessibility Phrase A representation of the model object \'UI Label\'. This is a mix in that will be used for UI Elements that are capable of showing label information in the GUI (e.g. Parts, Menus / Toolbars, Persepectives...) Since: 1.0 The following features are supported: Label Icon URI Tooltip extends MUIElement, MUILabel A representation of the model object \'Element\'. This is the bsae type for both menu items and Separators. Since: 1.0 The following features are supported: Mnemonics A representation of the model object \'Element\'. This is the root element for all UI Model elements, defining attribtues common to every element; the element\'s id as well as three general storage elements: Tags: This is a set of strings which can be used to stereotype a particular element. Tags may be specified in element searches and can also be referred to in the CSS styling definition. PersistedState: A string to string map used to store information that nneds to be persisted between sessions. TransientData: A string to object map which can be used to store runtime data relevant to a particular model element. Since: 1.0 The following features are supported: Element Id Persisted State Tags Contributor URI Transient Data extends MApplicationElement A representation of the model object \'UI Element\'. This is the base mix-in shared by all model elements that can be rendered into the UI presentation of the application. Its main job is to manage the bindings between the concrete element and the UI \'widget\' representing it in the UI. Since: 1.0 The following features are supported: Widget Renderer To Be Rendered On Top Visible Parent Container Data Cur Shared Ref Visible When Accessibility Phrase A representation of the model object \'UI Label\'. This is a mix in that will be used for UI Elements that are capable of showing label information in the GUI (e.g. Parts, Menus / Toolbars, Persepectives...) Since: 1.0 The following features are supported: Label Icon URI Tooltip extends MMenu, MContext A representation of the model object \'Popup Menu\'. This is a concrete class representing context menus. Menus of this type are generally managed by code within the running application since they\'re not visible in the UI. Since: 1.0 '
330, 'org.eclipse.e4.ui.model.application.ui.menu.MRenderedMenuItem', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/e4/ui/model/application/ui/menu/MRenderedMenuItem.html', ' A representation of the model object \'Element\'. This is the root element for all UI Model elements, defining attribtues common to every element; the element\'s id as well as three general storage elements: Tags: This is a set of strings which can be used to stereotype a particular element. Tags may be specified in element searches and can also be referred to in the CSS styling definition. PersistedState: A string to string map used to store information that nneds to be persisted between sessions. TransientData: A string to object map which can be used to store runtime data relevant to a particular model element. Since: 1.0 The following features are supported: Element Id Persisted State Tags Contributor URI Transient Data A representation of the model object \'Element\'. This is the root element for all UI Model elements, defining attribtues common to every element; the element\'s id as well as three general storage elements: Tags: This is a set of strings which can be used to stereotype a particular element. Tags may be specified in element searches and can also be referred to in the CSS styling definition. PersistedState: A string to string map used to store information that nneds to be persisted between sessions. TransientData: A string to object map which can be used to store runtime data relevant to a particular model element. Since: 1.0 The following features are supported: Element Id Persisted State Tags Contributor URI Transient Data A representation of the model object \'Element\'. This is the root element for all UI Model elements, defining attribtues common to every element; the element\'s id as well as three general storage elements: Tags: This is a set of strings which can be used to stereotype a particular element. Tags may be specified in element searches and can also be referred to in the CSS styling definition. PersistedState: A string to string map used to store information that nneds to be persisted between sessions. TransientData: A string to object map which can be used to store runtime data relevant to a particular model element. Since: 1.0 The following features are supported: Element Id Persisted State Tags Contributor URI Transient Data extends MApplicationElement A representation of the model object \'UI Element\'. This is the base mix-in shared by all model elements that can be rendered into the UI presentation of the application. Its main job is to manage the bindings between the concrete element and the UI \'widget\' representing it in the UI. Since: 1.0 The following features are supported: Widget Renderer To Be Rendered On Top Visible Parent Container Data Cur Shared Ref Visible When Accessibility Phrase A representation of the model object \'UI Label\'. This is a mix in that will be used for UI Elements that are capable of showing label information in the GUI (e.g. Parts, Menus / Toolbars, Persepectives...) Since: 1.0 The following features are supported: Label Icon URI Tooltip extends MUIElement, MUILabel A representation of the model object \'Element\'. This is the bsae type for both menu items and Separators. Since: 1.0 The following features are supported: Mnemonics A representation of the model object \'Element\'. This is the root element for all UI Model elements, defining attribtues common to every element; the element\'s id as well as three general storage elements: Tags: This is a set of strings which can be used to stereotype a particular element. Tags may be specified in element searches and can also be referred to in the CSS styling definition. PersistedState: A string to string map used to store information that nneds to be persisted between sessions. TransientData: A string to object map which can be used to store runtime data relevant to a particular model element. Since: 1.0 The following features are supported: Element Id Persisted State Tags Contributor URI Transient Data extends MUIElement, MUILabel A representation of the model object \'Element\'. This is the bsae type for both menu items and Separators. Since: 1.0 The following features are supported: Mnemonics extends MApplicationElement A representation of the model object \'UI Element\'. This is the base mix-in shared by all model elements that can be rendered into the UI presentation of the application. Its main job is to manage the bindings between the concrete element and the UI \'widget\' representing it in the UI. Since: 1.0 The following features are supported: Widget Renderer To Be Rendered On Top Visible Parent Container Data Cur Shared Ref Visible When Accessibility Phrase A representation of the model object \'UI Label\'. This is a mix in that will be used for UI Elements that are capable of showing label information in the GUI (e.g. Parts, Menus / Toolbars, Persepectives...) Since: 1.0 The following features are supported: Label Icon URI Tooltip extends MItem, MMenuElement A representation of the model object \'Item\'. This is the base type for both Handled and direct menu items. Since: 1.0 A representation of the model object \'Element\'. This is the root element for all UI Model elements, defining attribtues common to every element; the element\'s id as well as three general storage elements: Tags: This is a set of strings which can be used to stereotype a particular element. Tags may be specified in element searches and can also be referred to in the CSS styling definition. PersistedState: A string to string map used to store information that nneds to be persisted between sessions. TransientData: A string to object map which can be used to store runtime data relevant to a particular model element. Since: 1.0 The following features are supported: Element Id Persisted State Tags Contributor URI Transient Data extends MApplicationElement A representation of the model object \'UI Element\'. This is the base mix-in shared by all model elements that can be rendered into the UI presentation of the application. Its main job is to manage the bindings between the concrete element and the UI \'widget\' representing it in the UI. Since: 1.0 The following features are supported: Widget Renderer To Be Rendered On Top Visible Parent Container Data Cur Shared Ref Visible When Accessibility Phrase extends MMenuItem A representation of the model object \'Rendered Menu Item\'. Do no use! This class will be removed at the beginning of Luna (4.4) development. Since: 1.0 The following features are supported: Contribution Item Restriction: This interface is not intended to be referenced by clients. '
331, 'org.eclipse.e4.ui.model.application.ui.menu.MDynamicMenuContribution', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/e4/ui/model/application/ui/menu/MDynamicMenuContribution.html', ' A representation of the model object \'Element\'. This is the root element for all UI Model elements, defining attribtues common to every element; the element\'s id as well as three general storage elements: Tags: This is a set of strings which can be used to stereotype a particular element. Tags may be specified in element searches and can also be referred to in the CSS styling definition. PersistedState: A string to string map used to store information that nneds to be persisted between sessions. TransientData: A string to object map which can be used to store runtime data relevant to a particular model element. Since: 1.0 The following features are supported: Element Id Persisted State Tags Contributor URI Transient Data extends MApplicationElement A representation of the model object \'Contribution\'. MContribution is a mix-in class used by concrete elements such as Parts to define the location of the client supplied class implementing the specific logic needed. Since: 1.0 The following features are supported: Contribution URI Object A representation of the model object \'Element\'. This is the root element for all UI Model elements, defining attribtues common to every element; the element\'s id as well as three general storage elements: Tags: This is a set of strings which can be used to stereotype a particular element. Tags may be specified in element searches and can also be referred to in the CSS styling definition. PersistedState: A string to string map used to store information that nneds to be persisted between sessions. TransientData: A string to object map which can be used to store runtime data relevant to a particular model element. Since: 1.0 The following features are supported: Element Id Persisted State Tags Contributor URI Transient Data A representation of the model object \'Element\'. This is the root element for all UI Model elements, defining attribtues common to every element; the element\'s id as well as three general storage elements: Tags: This is a set of strings which can be used to stereotype a particular element. Tags may be specified in element searches and can also be referred to in the CSS styling definition. PersistedState: A string to string map used to store information that nneds to be persisted between sessions. TransientData: A string to object map which can be used to store runtime data relevant to a particular model element. Since: 1.0 The following features are supported: Element Id Persisted State Tags Contributor URI Transient Data extends MApplicationElement A representation of the model object \'UI Element\'. This is the base mix-in shared by all model elements that can be rendered into the UI presentation of the application. Its main job is to manage the bindings between the concrete element and the UI \'widget\' representing it in the UI. Since: 1.0 The following features are supported: Widget Renderer To Be Rendered On Top Visible Parent Container Data Cur Shared Ref Visible When Accessibility Phrase A representation of the model object \'UI Label\'. This is a mix in that will be used for UI Elements that are capable of showing label information in the GUI (e.g. Parts, Menus / Toolbars, Persepectives...) Since: 1.0 The following features are supported: Label Icon URI Tooltip extends MUIElement, MUILabel A representation of the model object \'Element\'. This is the bsae type for both menu items and Separators. Since: 1.0 The following features are supported: Mnemonics A representation of the model object \'Element\'. This is the root element for all UI Model elements, defining attribtues common to every element; the element\'s id as well as three general storage elements: Tags: This is a set of strings which can be used to stereotype a particular element. Tags may be specified in element searches and can also be referred to in the CSS styling definition. PersistedState: A string to string map used to store information that nneds to be persisted between sessions. TransientData: A string to object map which can be used to store runtime data relevant to a particular model element. Since: 1.0 The following features are supported: Element Id Persisted State Tags Contributor URI Transient Data extends MUIElement, MUILabel A representation of the model object \'Element\'. This is the bsae type for both menu items and Separators. Since: 1.0 The following features are supported: Mnemonics extends MApplicationElement A representation of the model object \'UI Element\'. This is the base mix-in shared by all model elements that can be rendered into the UI presentation of the application. Its main job is to manage the bindings between the concrete element and the UI \'widget\' representing it in the UI. Since: 1.0 The following features are supported: Widget Renderer To Be Rendered On Top Visible Parent Container Data Cur Shared Ref Visible When Accessibility Phrase A representation of the model object \'UI Label\'. This is a mix in that will be used for UI Elements that are capable of showing label information in the GUI (e.g. Parts, Menus / Toolbars, Persepectives...) Since: 1.0 The following features are supported: Label Icon URI Tooltip extends MItem, MMenuElement A representation of the model object \'Item\'. This is the base type for both Handled and direct menu items. Since: 1.0 A representation of the model object \'Element\'. This is the root element for all UI Model elements, defining attribtues common to every element; the element\'s id as well as three general storage elements: Tags: This is a set of strings which can be used to stereotype a particular element. Tags may be specified in element searches and can also be referred to in the CSS styling definition. PersistedState: A string to string map used to store information that nneds to be persisted between sessions. TransientData: A string to object map which can be used to store runtime data relevant to a particular model element. Since: 1.0 The following features are supported: Element Id Persisted State Tags Contributor URI Transient Data extends MApplicationElement A representation of the model object \'UI Element\'. This is the base mix-in shared by all model elements that can be rendered into the UI presentation of the application. Its main job is to manage the bindings between the concrete element and the UI \'widget\' representing it in the UI. Since: 1.0 The following features are supported: Widget Renderer To Be Rendered On Top Visible Parent Container Data Cur Shared Ref Visible When Accessibility Phrase A representation of the model object \'UI Label\'. This is a mix in that will be used for UI Elements that are capable of showing label information in the GUI (e.g. Parts, Menus / Toolbars, Persepectives...) Since: 1.0 The following features are supported: Label Icon URI Tooltip extends MMenuItem, MContribution A representation of the model object \'Dynamic Menu Contribution\'. This is a concrete class used to represent a menu item that replaces itself through the execution of the associated client code. The supplied contribution will provide the appropriate MMenuElement model elements when queried. Since: 1.0 '
332, 'org.eclipse.e4.ui.model.application.ui.menu.MOpaqueMenu', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/e4/ui/model/application/ui/menu/MOpaqueMenu.html', ' A representation of the model object \'Element\'. This is the root element for all UI Model elements, defining attribtues common to every element; the element\'s id as well as three general storage elements: Tags: This is a set of strings which can be used to stereotype a particular element. Tags may be specified in element searches and can also be referred to in the CSS styling definition. PersistedState: A string to string map used to store information that nneds to be persisted between sessions. TransientData: A string to object map which can be used to store runtime data relevant to a particular model element. Since: 1.0 The following features are supported: Element Id Persisted State Tags Contributor URI Transient Data A representation of the model object \'Element\'. This is the root element for all UI Model elements, defining attribtues common to every element; the element\'s id as well as three general storage elements: Tags: This is a set of strings which can be used to stereotype a particular element. Tags may be specified in element searches and can also be referred to in the CSS styling definition. PersistedState: A string to string map used to store information that nneds to be persisted between sessions. TransientData: A string to object map which can be used to store runtime data relevant to a particular model element. Since: 1.0 The following features are supported: Element Id Persisted State Tags Contributor URI Transient Data A representation of the model object \'Element\'. This is the root element for all UI Model elements, defining attribtues common to every element; the element\'s id as well as three general storage elements: Tags: This is a set of strings which can be used to stereotype a particular element. Tags may be specified in element searches and can also be referred to in the CSS styling definition. PersistedState: A string to string map used to store information that nneds to be persisted between sessions. TransientData: A string to object map which can be used to store runtime data relevant to a particular model element. Since: 1.0 The following features are supported: Element Id Persisted State Tags Contributor URI Transient Data extends MApplicationElement A representation of the model object \'UI Element\'. This is the base mix-in shared by all model elements that can be rendered into the UI presentation of the application. Its main job is to manage the bindings between the concrete element and the UI \'widget\' representing it in the UI. Since: 1.0 The following features are supported: Widget Renderer To Be Rendered On Top Visible Parent Container Data Cur Shared Ref Visible When Accessibility Phrase A representation of the model object \'UI Label\'. This is a mix in that will be used for UI Elements that are capable of showing label information in the GUI (e.g. Parts, Menus / Toolbars, Persepectives...) Since: 1.0 The following features are supported: Label Icon URI Tooltip extends MUIElement, MUILabel A representation of the model object \'Element\'. This is the bsae type for both menu items and Separators. Since: 1.0 The following features are supported: Mnemonics A representation of the model object \'Element\'. This is the root element for all UI Model elements, defining attribtues common to every element; the element\'s id as well as three general storage elements: Tags: This is a set of strings which can be used to stereotype a particular element. Tags may be specified in element searches and can also be referred to in the CSS styling definition. PersistedState: A string to string map used to store information that nneds to be persisted between sessions. TransientData: A string to object map which can be used to store runtime data relevant to a particular model element. Since: 1.0 The following features are supported: Element Id Persisted State Tags Contributor URI Transient Data extends MApplicationElement A representation of the model object \'UI Element\'. This is the base mix-in shared by all model elements that can be rendered into the UI presentation of the application. Its main job is to manage the bindings between the concrete element and the UI \'widget\' representing it in the UI. Since: 1.0 The following features are supported: Widget Renderer To Be Rendered On Top Visible Parent Container Data Cur Shared Ref Visible When Accessibility Phrase extends MMenu A representation of the model object \'Opaque Menu\'. Do no use! This class will be removed at the beginning of Luna (4.4) development. Since: 1.0 Restriction: This interface is not intended to be referenced by clients. '
333, 'org.eclipse.e4.ui.model.application.ui.menu.MOpaqueMenuSeparator', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/e4/ui/model/application/ui/menu/MOpaqueMenuSeparator.html', ' A representation of the model object \'Element\'. This is the root element for all UI Model elements, defining attribtues common to every element; the element\'s id as well as three general storage elements: Tags: This is a set of strings which can be used to stereotype a particular element. Tags may be specified in element searches and can also be referred to in the CSS styling definition. PersistedState: A string to string map used to store information that nneds to be persisted between sessions. TransientData: A string to object map which can be used to store runtime data relevant to a particular model element. Since: 1.0 The following features are supported: Element Id Persisted State Tags Contributor URI Transient Data A representation of the model object \'Element\'. This is the root element for all UI Model elements, defining attribtues common to every element; the element\'s id as well as three general storage elements: Tags: This is a set of strings which can be used to stereotype a particular element. Tags may be specified in element searches and can also be referred to in the CSS styling definition. PersistedState: A string to string map used to store information that nneds to be persisted between sessions. TransientData: A string to object map which can be used to store runtime data relevant to a particular model element. Since: 1.0 The following features are supported: Element Id Persisted State Tags Contributor URI Transient Data A representation of the model object \'Element\'. This is the root element for all UI Model elements, defining attribtues common to every element; the element\'s id as well as three general storage elements: Tags: This is a set of strings which can be used to stereotype a particular element. Tags may be specified in element searches and can also be referred to in the CSS styling definition. PersistedState: A string to string map used to store information that nneds to be persisted between sessions. TransientData: A string to object map which can be used to store runtime data relevant to a particular model element. Since: 1.0 The following features are supported: Element Id Persisted State Tags Contributor URI Transient Data extends MApplicationElement A representation of the model object \'UI Element\'. This is the base mix-in shared by all model elements that can be rendered into the UI presentation of the application. Its main job is to manage the bindings between the concrete element and the UI \'widget\' representing it in the UI. Since: 1.0 The following features are supported: Widget Renderer To Be Rendered On Top Visible Parent Container Data Cur Shared Ref Visible When Accessibility Phrase A representation of the model object \'UI Label\'. This is a mix in that will be used for UI Elements that are capable of showing label information in the GUI (e.g. Parts, Menus / Toolbars, Persepectives...) Since: 1.0 The following features are supported: Label Icon URI Tooltip extends MUIElement, MUILabel A representation of the model object \'Element\'. This is the bsae type for both menu items and Separators. Since: 1.0 The following features are supported: Mnemonics A representation of the model object \'Element\'. This is the root element for all UI Model elements, defining attribtues common to every element; the element\'s id as well as three general storage elements: Tags: This is a set of strings which can be used to stereotype a particular element. Tags may be specified in element searches and can also be referred to in the CSS styling definition. PersistedState: A string to string map used to store information that nneds to be persisted between sessions. TransientData: A string to object map which can be used to store runtime data relevant to a particular model element. Since: 1.0 The following features are supported: Element Id Persisted State Tags Contributor URI Transient Data extends MUIElement, MUILabel A representation of the model object \'Element\'. This is the bsae type for both menu items and Separators. Since: 1.0 The following features are supported: Mnemonics extends MApplicationElement A representation of the model object \'UI Element\'. This is the base mix-in shared by all model elements that can be rendered into the UI presentation of the application. Its main job is to manage the bindings between the concrete element and the UI \'widget\' representing it in the UI. Since: 1.0 The following features are supported: Widget Renderer To Be Rendered On Top Visible Parent Container Data Cur Shared Ref Visible When Accessibility Phrase A representation of the model object \'UI Label\'. This is a mix in that will be used for UI Elements that are capable of showing label information in the GUI (e.g. Parts, Menus / Toolbars, Persepectives...) Since: 1.0 The following features are supported: Label Icon URI Tooltip extends MMenuElement A representation of the model object \'Separator\'. An element representing a separator in a menu. Since: 1.0 A representation of the model object \'Element\'. This is the root element for all UI Model elements, defining attribtues common to every element; the element\'s id as well as three general storage elements: Tags: This is a set of strings which can be used to stereotype a particular element. Tags may be specified in element searches and can also be referred to in the CSS styling definition. PersistedState: A string to string map used to store information that nneds to be persisted between sessions. TransientData: A string to object map which can be used to store runtime data relevant to a particular model element. Since: 1.0 The following features are supported: Element Id Persisted State Tags Contributor URI Transient Data extends MApplicationElement A representation of the model object \'UI Element\'. This is the base mix-in shared by all model elements that can be rendered into the UI presentation of the application. Its main job is to manage the bindings between the concrete element and the UI \'widget\' representing it in the UI. Since: 1.0 The following features are supported: Widget Renderer To Be Rendered On Top Visible Parent Container Data Cur Shared Ref Visible When Accessibility Phrase extends MMenuSeparator A representation of the model object \'Opaque Menu Separator\'. Do no use! This class will be removed at the beginning of Luna (4.4) development. Since: 1.0 The following features are supported: Opaque Item Restriction: This interface is not intended to be referenced by clients. '
334, 'org.eclipse.swt.graphics.Device', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/graphics/Device.html', 'Implementers of Drawable can have a graphics context (GC) created for them, and then they can be drawn on by sending messages to their associated GC. SWT images, and device objects such as the Display device and the Printer device, are drawables. IMPORTANT: This interface is not part of the SWT public API. It is marked public only so that it can be shared within the packages provided by SWT. It should never be referenced from application code. See Also: Device, Image, GC extends Object implements Drawable This class is the abstract superclass of all device objects, such as the Display device and the Printer device. Devices can have a graphics context (GC) created for them, and they can be drawn on by sending messages to the associated GC. See Also: Sample code and further information '
335, 'org.eclipse.ui.IWorkbenchPart2', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/IWorkbenchPart2.html', 'An interface for an adaptable object. Adaptable objects can be dynamically extended to provide different interfaces (or \"adapters\"). Adapters are created by adapter factories, which are in turn managed by type by adapter managers. For example, IAdaptable a = [some adaptable]; IFoo x = (IFoo)a.getAdapter(IFoo.class); if (x != null) [do IFoo things with x] This interface can be used without OSGi running. Clients may implement this interface, or obtain a default implementation of this interface by subclassing PlatformObject. See Also: IAdapterFactory, IAdapterManager, PlatformObject An interface for an adaptable object. Adaptable objects can be dynamically extended to provide different interfaces (or \"adapters\"). Adapters are created by adapter factories, which are in turn managed by type by adapter managers. For example, IAdaptable a = [some adaptable]; IFoo x = (IFoo)a.getAdapter(IFoo.class); if (x != null) [do IFoo things with x] This interface can be used without OSGi running. Clients may implement this interface, or obtain a default implementation of this interface by subclassing PlatformObject. See Also: IAdapterFactory, IAdapterManager, PlatformObject extends IAdaptable A workbench part is a visual component within a workbench page. There are two subtypes: view and editor, as defined by IViewPart and IEditorPart. A view is typically used to navigate a hierarchy of information (like the workspace), open an editor, or display properties for the active editor. Modifications made in a view are saved immediately. An editor is typically used to edit or browse a document or input object. The input is identified using an IEditorInput. Modifications made in an editor part follow an open-save-close lifecycle model. This interface may be implemented directly. For convenience, a base implementation is defined in WorkbenchPart. The lifecycle of a workbench part is as follows: When a part extension is created: instantiate the part create a part site call part.init(site) When a part becomes visible in the workbench: add part to presentation by calling part.createPartControl(parent) to create actual widgets fire partOpened event to all listeners When a part is activated or gets focus: call part.setFocus() fire partActivated event to all listeners When a part is closed: if save is needed, do save; if it fails or is canceled return if part is active, deactivate part fire partClosed event to all listeners remove part from presentation; part controls are disposed as part of the SWT widget tree call part.dispose() After createPartControl has been called, the implementor may safely reference the controls created. When the part is closed these controls will be disposed as part of an SWT composite. This occurs before the IWorkbenchPart.dispose method is called. If there is a need to free SWT resources the part should define a dispose listener for its own control and free those resources from the dispose listener. If the part invokes any method on the disposed SWT controls after this point an SWTError will be thrown. The last method called on IWorkbenchPart is dispose. This signals the end of the part lifecycle. An important point to note about this lifecycle is that following a call to init, createPartControl may never be called. Thus in the dispose method, implementors must not assume controls were created. Workbench parts implement the IAdaptable interface; extensions are managed by the platform\'s adapter manager. See Also: IViewPart, IEditorPart extends IWorkbenchPart Extends IWorkbenchPart, adding the name and status text properties. Prior to 3.0, a view\'s title was often modified to show both the part name and extra status text. With this interface, the distinction is made more explicit. Since: 3.0 '
336, 'org.eclipse.swt.custom.CTabFolderRenderer', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/custom/CTabFolderRenderer.html', 'extends Object Instances of this class provide all of the measuring and drawing functionality required by CTabFolder. This class can be subclassed in order to customize the look of a CTabFolder. Since: 3.6 See Also: Sample code and further information '
337, 'org.eclipse.swt.graphics.Region', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/graphics/Region.html', 'extends Resource Instances of this class represent areas of an x-y coordinate system that are aggregates of the areas covered by a number of polygons. Application code must explicitly invoke the Region.dispose() method to release the operating system resources managed by each instance when those instances are no longer required. See Also: SWT Example: GraphicsExample, Sample code and further information '
338, 'org.eclipse.swt.graphics.Pattern', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/graphics/Pattern.html', 'extends Resource Instances of this class represent patterns to use while drawing. Patterns can be specified either as bitmaps or gradients. Application code must explicitly invoke the Pattern.dispose() method to release the operating system resources managed by each instance when those instances are no longer required. This class requires the operating system\'s advanced graphics subsystem which may not be available on some platforms. Since: 3.1 See Also: Path, Pattern snippets, SWT Example: GraphicsExample, Sample code and further information '
339, 'org.eclipse.swt.graphics.RGB', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/graphics/RGB.html', 'extends Object implements org.eclipse.swt.internal.SerializableCompatibility Instances of this class are descriptions of colors in terms of the primary additive color model (red, green and blue). A color may be described in terms of the relative intensities of these three primary colors. The brightness of each color is specified by a value in the range 0 to 255, where 0 indicates no color (blackness) and 255 indicates maximum intensity. The hashCode() method in this class uses the values of the public fields to compute the hash value. When storing instances of the class in hashed collections, do not modify these fields after the object has been inserted. Application code does not need to explicitly release the resources managed by each instance when those instances are no longer required, and thus no dispose() method is provided. See Also: Color, Color and RGB snippets, Sample code and further information, Serialized Form '
340, 'org.eclipse.swt.graphics.PaletteData', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/graphics/PaletteData.html', 'extends Object Instances of this class describe the color data used by an image. Depending on the depth of the image, the PaletteData can take one of two forms, indicated by the isDirect field: isDirect is false If isDirect is false, this palette is an indexed palette which maps pixel values to RGBs. The actual RGB values may be retrieved by using the getRGBs() method. isDirect is true If isDirect is true, this palette is a direct color palette. Instead of containing RGB values, it contains red, green and blue mask and shift information which indicates how the color components may be extracted from a given pixel. This means that the RGB value is actually encoded in the pixel value. In this case, the shift data is the number of bits required to shift the RGB value to the left in order to align the high bit of the corresponding mask with the high bit of the first byte. This number may be negative, so care must be taken when shifting. For example, with a red mask of 0xFF0000, the red shift would be -16. With a red mask of 0x1F, the red shift would be 3. See Also: Image, RGB, Sample code and further information '
341, 'org.eclipse.ui.model.AdaptableList', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/model/AdaptableList.html', 'An interface for an adaptable object. Adaptable objects can be dynamically extended to provide different interfaces (or \"adapters\"). Adapters are created by adapter factories, which are in turn managed by type by adapter managers. For example, IAdaptable a = [some adaptable]; IFoo x = (IFoo)a.getAdapter(IFoo.class); if (x != null) [do IFoo things with x] This interface can be used without OSGi running. Clients may implement this interface, or obtain a default implementation of this interface by subclassing PlatformObject. See Also: IAdapterFactory, IAdapterManager, PlatformObject This adapter interface provides visual presentation and hierarchical structure for workbench elements, allowing them to be displayed in the UI without having to know the concrete type of the element. There is an associate label provider and content provider for showing elements with a registered workbench adapter in JFace structured viewers. See Also: WorkbenchLabelProvider, BaseWorkbenchContentProvider Extension interface for IWorkbenchAdapter that allows for color and font support. There is an associate label provider and content provider for showing elements with a registered workbench adapter in JFace structured viewers. Since: 3.0 See Also: IWorkbenchAdapter, WorkbenchLabelProvider, BaseWorkbenchContentProvider Extension interface for IWorkbenchAdapter that allows for StyledString support. Since: 3.7 See Also: IWorkbenchAdapter, WorkbenchLabelProvider, BaseWorkbenchContentProvider, DelegatingStyledCellLabelProvider.IStyledLabelProvider extends WorkbenchAdapter implements IAdaptable A modifiable list of IAdaptable objects. The list is adaptable to IWorkbenchAdapter, and can be used to display an arbitrary set of adaptable objects in a viewer. This class is not intended to be subclassed. Since: 3.0 See Also: IWorkbenchAdapter Restriction: This class is not intended to be subclassed by clients. '
342, 'org.eclipse.ui.IPluginContribution', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/IPluginContribution.html', 'An interface that descriptor classes may implement in addition to their descriptor interface. This indicates that they may or may not originate from a plugin contribution. This is useful in various activity filtering scenarios. Since: 3.0 '
343, 'org.eclipse.core.runtime.Platform', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/runtime/Platform.html', 'extends Object The central class of the Eclipse Platform Runtime. This class cannot be instantiated or subclassed by clients; all functionality is provided by static methods. Features include: the platform registry of installed plug-ins the platform adapter manager the platform log the authorization info management Most users don\'t have to worry about Platform\'s lifecycle. However, if your code can call methods of this class when Platform is not running, it becomes necessary to check isRunning() before making the call. A runtime exception might be thrown or incorrect result might be returned if a method from this class is called while Platform is not running. '
344, 'org.eclipse.core.runtime.Path', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/runtime/Path.html', 'extends Object implements IPath, Cloneable The standard implementation of the IPath interface. Paths are always maintained in canonicalized form. That is, parent references (i.e., ../../) and duplicate separators are resolved. For example, new Path(\"/a/b\").append(\"../foo/bar\") will yield the path /a/foo/bar This class can be used without OSGi running. This class is not intended to be subclassed by clients but may be instantiated. See Also: IPath Restriction: This class is not intended to be subclassed by clients. '
345, 'org.eclipse.ui.dialogs.SelectionStatusDialog', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/dialogs/SelectionStatusDialog.html', 'Interface for objects that can return a shell. This is normally used for opening child windows. An object that wants to open child shells can take an IShellProvider in its constructor, and the object that implements IShellProvider can dynamically choose where child shells should be opened. Since: 3.1 extends SelectionDialog An abstract base class for dialogs with a status bar and ok/cancel buttons. The status message must be passed over as StatusInfo object and can be an error, warning or ok. The OK button is enabled or disabled depending on the status. Since: 2.0 '
346, 'org.eclipse.jface.viewers.ILabelProvider', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/viewers/ILabelProvider.html', 'A label provider maps an element of the viewer\'s model to an optional image and optional text string used to display the element in the viewer\'s control. Certain label providers may allow multiple labels per element. This is an \"abstract interface\", defining methods common to all label providers, but does not actually define the methods to get the label(s) for an element. This interface should never be directly implemented. Most viewers will take either an ILabelProvider or an ITableLabelProvider. A label provider must not be shared between viewers since a label provider generally manages SWT resources (images), which must be disposed when the viewer is disposed. To simplify life cycle management, the current label provider of a viewer is disposed when the viewer is disposed. Label providers can be used outside the context of viewers wherever images are needed. When label providers are used in this fashion it is the responsibility of the user to ensure dispose is called when the provider is no longer needed. See Also: ILabelProvider, ITableLabelProvider extends IBaseLabelProvider Extends IBaseLabelProvider with the methods to provide the text and/or image for the label of a given element. Used by most structured viewers, except table viewers. '
347, 'org.eclipse.ui.dialogs.ISelectionStatusValidator', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/dialogs/ISelectionStatusValidator.html', 'Used in selection dialogs to validate selections Since: 2.0 '
348, 'org.eclipse.jface.viewers.ViewerSorter', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/viewers/ViewerSorter.html', 'extends ViewerComparator A viewer sorter is used by a StructuredViewer to reorder the elements provided by its content provider. The default compare method compares elements using two steps. The first step uses the values returned from category. By default, all elements are in the same category. The second level is based on a case insensitive compare of the strings obtained from the content viewer\'s label provider via ILabelProvider.getText. Subclasses may implement the isSorterProperty method; they may reimplement the category method to provide categorization; and they may override the compare methods to provide a totally different way of sorting elements. It is recommended to use ViewerComparator instead. See Also: IStructuredContentProvider, StructuredViewer '
349, 'org.eclipse.jface.viewers.IDoubleClickListener', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/viewers/IDoubleClickListener.html', 'A listener which is notified of double-click events on viewers. '
350, 'org.eclipse.jface.viewers.DoubleClickEvent', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/viewers/DoubleClickEvent.html', 'extends EventObject Event object describing a double-click. The source of these events is a viewer. See Also: IDoubleClickListener, Serialized Form '
351, 'org.eclipse.swt.layout.RowLayout', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/layout/RowLayout.html', 'extends Layout Instances of this class determine the size and position of the children of a Composite by placing them either in horizontal rows or vertical columns within the parent Composite. RowLayout aligns all controls in one row if the type is set to horizontal, and one column if it is set to vertical. It has the ability to wrap, and provides configurable margins and spacing. RowLayout has a number of configuration fields. In addition, the height and width of each control in a RowLayout can be specified by setting a RowData object into the control using setLayoutData (). The following example code creates a RowLayout, sets all of its fields to non-default values, and then sets it into a Shell. RowLayout rowLayout = new RowLayout(); rowLayout.wrap = false; rowLayout.pack = false; rowLayout.justify = true; rowLayout.type = SWT.VERTICAL; rowLayout.marginLeft = 5; rowLayout.marginTop = 5; rowLayout.marginRight = 5; rowLayout.marginBottom = 5; rowLayout.spacing = 0; shell.setLayout(rowLayout); If you are using the default field values, you only need one line of code: shell.setLayout(new RowLayout()); See Also: RowData, RowLayout snippets, SWT Example: LayoutExample, Sample code and further information '
352, 'org.eclipse.swt.events.MenuDetectListener', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/events/MenuDetectListener.html', 'extends org.eclipse.swt.internal.SWTEventListener Classes which implement this interface provide methods that deal with the events that are generated when the platform-specific trigger for showing a context menu is detected. After creating an instance of a class that implements this interface it can be added to a control or TrayItem using the addMenuDetectListener method and removed using the removeMenuDetectListener method. When the context menu trigger occurs, the menuDetected method will be invoked. Since: 3.3 See Also: MenuDetectEvent '
353, 'org.eclipse.swt.events.SelectionListener', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/events/SelectionListener.html', 'extends org.eclipse.swt.internal.SWTEventListener Classes which implement this interface provide methods that deal with the events that are generated when selection occurs in a control. After creating an instance of a class that implements this interface it can be added to a control using the addSelectionListener method and removed using the removeSelectionListener method. When selection occurs in a control the appropriate method will be invoked. See Also: SelectionAdapter, SelectionEvent '
354, 'org.eclipse.swt.events.MenuDetectEvent', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/events/MenuDetectEvent.html', 'extends TypedEvent Instances of this class are sent whenever the platform- specific trigger for showing a context menu is detected. Since: 3.3 See Also: MenuDetectListener, Sample code and further information, Serialized Form '
355, 'org.eclipse.swt.events.MouseListener', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/events/MouseListener.html', 'extends org.eclipse.swt.internal.SWTEventListener Classes which implement this interface provide methods that deal with the events that are generated as mouse buttons are pressed. After creating an instance of a class that implements this interface it can be added to a control using the addMouseListener method and removed using the removeMouseListener method. When a mouse button is pressed or released, the appropriate method will be invoked. See Also: MouseAdapter, MouseEvent '
356, 'org.eclipse.swt.events.DragDetectListener', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/events/DragDetectListener.html', 'extends org.eclipse.swt.internal.SWTEventListener Classes which implement this interface provide methods that deal with the events that are generated when a drag gesture is detected. After creating an instance of a class that implements this interface it can be added to a control using the addDragDetectListener method and removed using the removeDragDetectListener method. When the drag is detected, the drageDetected method will be invoked. Since: 3.3 See Also: DragDetectEvent '
357, 'org.eclipse.swt.events.DragDetectEvent', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/events/DragDetectEvent.html', 'extends MouseEvent Instances of this class are sent as a result of a drag gesture. Since: 3.3 See Also: DragDetectListener, Sample code and further information, Serialized Form '
358, 'org.eclipse.swt.events.MenuListener', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/events/MenuListener.html', 'extends org.eclipse.swt.internal.SWTEventListener Classes which implement this interface provide methods that deal with the hiding and showing of menus. After creating an instance of a class that implements this interface it can be added to a menu using the addMenuListener method and removed using the removeMenuListener method. When the menu is hidden or shown, the appropriate method will be invoked. See Also: MenuAdapter, MenuEvent '
359, 'org.eclipse.swt.events.MenuEvent', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/events/MenuEvent.html', 'extends TypedEvent Instances of this class are sent as a result of menus being shown and hidden. See Also: MenuListener, Sample code and further information, Serialized Form '
360, 'org.eclipse.ui.IWorkbenchPreferenceConstants', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/IWorkbenchPreferenceConstants.html', 'Preference ids exposed by the Eclipse Platform User Interface. These preference settings can be obtained from the UI plug-in\'s preference store. Note:This interface should not be implemented or extended. See Also: PlatformUI.PLUGIN_ID, PlatformUI.getPreferenceStore() Restriction: This interface is not intended to be implemented by clients. Restriction: This interface is not intended to be extended by clients. '
361, 'org.eclipse.ui.services.IDisposable', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/services/IDisposable.html', ' The interface that should be implemented by services that make themselves available through the IAdaptable mechanism. This is the interface that drives the majority of services provided at the workbench level. A service has life-cycle. When the constructor completes, the service must be fully functional. When it comes time for the service to go away, then the service will receive a dispose() call. At this point, the service must release all resources and detach all listeners. A service can only be disposed once; it cannot be reused. This interface has nothing to do with OSGi services. This interface can be extended or implemented by clients. Since: 3.2 '
362, 'org.eclipse.jface.action.IContributionItem', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/action/IContributionItem.html', 'A contribution item represents a contribution to a shared UI resource such as a menu or tool bar. More generally, contribution items are managed by a contribution manager. For instance, in a tool bar a contribution item is a tool bar button or a separator. In a menu bar a contribution item is a menu, and in a menu a contribution item is a menu item or separator. A contribution item can realize itself in different SWT widgets, using the different fill methods. The same type of contribution item can be used with a MenuBarManager, ToolBarManager, CoolBarManager, or a StatusLineManager. This interface is internal to the framework; it should not be implemented outside the framework. See Also: IContributionManager Restriction: This interface is not intended to be implemented by clients. '
363, 'org.eclipse.core.commands.IHandler', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/commands/IHandler.html', 'A handler is the pluggable piece of a command that handles execution. Each command can have zero or more handlers associated with it (in general), of which only one will be active at any given moment in time. When the command is asked to execute, it will simply pass that request on to its active handler, if any. Since: 3.1 See Also: AbstractHandler '
364, 'org.eclipse.jface.action.IToolBarManager', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/action/IToolBarManager.html', 'A contribution manager organizes contributions to such UI components as menus, toolbars and status lines. A contribution manager keeps track of a list of contribution items. Each contribution item may has an optional identifier, which can be used to retrieve items from a manager, and for positioning items relative to each other. The list of contribution items can be subdivided into named groups using special contribution items that serve as group markers. The IContributionManager interface provides general protocol for adding, removing, and retrieving contribution items. It also provides convenience methods that make it convenient to contribute actions. This interface should be implemented by all objects that wish to manage contributions. There are several implementions of this interface in this package, including ones for menus (MenuManager), tool bars (ToolBarManager), and status lines (StatusLineManager). extends IContributionManager The IToolBarManager interface provides protocol for managing contributions to a tool bar. It extends IContributionManager but does not declare any new members; it exists only to increase the readability of code using tool bars. This package also provides a concrete tool bar manager implementation, ToolBarManager. '
365, 'org.eclipse.jface.viewers.ILightweightLabelDecorator', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/viewers/ILightweightLabelDecorator.html', 'A label provider maps an element of the viewer\'s model to an optional image and optional text string used to display the element in the viewer\'s control. Certain label providers may allow multiple labels per element. This is an \"abstract interface\", defining methods common to all label providers, but does not actually define the methods to get the label(s) for an element. This interface should never be directly implemented. Most viewers will take either an ILabelProvider or an ITableLabelProvider. A label provider must not be shared between viewers since a label provider generally manages SWT resources (images), which must be disposed when the viewer is disposed. To simplify life cycle management, the current label provider of a viewer is disposed when the viewer is disposed. Label providers can be used outside the context of viewers wherever images are needed. When label providers are used in this fashion it is the responsibility of the user to ensure dispose is called when the provider is no longer needed. See Also: ILabelProvider, ITableLabelProvider extends IBaseLabelProvider The ILightweightLabelDecorator is a decorator that decorates using a prefix, suffix and overlay image rather than doing all of the image and text management itself like an ILabelDecorator. '
366, 'org.eclipse.jface.viewers.ILabelProviderListener', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/viewers/ILabelProviderListener.html', 'A listener which is notified when a label provider\'s state changes. See Also: IBaseLabelProvider.addListener(org.eclipse.jface.viewers.ILabelProviderListener), IBaseLabelProvider.removeListener(org.eclipse.jface.viewers.ILabelProviderListener) '
367, 'org.eclipse.jface.viewers.IDecoration', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/viewers/IDecoration.html', 'Defines the result of decorating an element. This interface is not meant to be implemented and will be provided to instances of ILightweightLabelDecorator. Restriction: This interface is not intended to be implemented by clients. '
368, 'org.eclipse.core.commands.common.EventManager', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/commands/common/EventManager.html', 'extends Object A manager to which listeners can be attached. This handles the management of a list of listeners -- optimizing memory and performance. All the methods on this class are guaranteed to be thread-safe. Clients may extend. Since: 3.2 '
369, 'org.eclipse.ui.themes.IThemeManager', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/themes/IThemeManager.html', 'A theme manager is an object that contains references to usable ITheme objects and maintains a reference to the currently active theme. This theme will be used by the workbench to decorate tab folders and other controls where possible. The workbench implementation of this interface will push the values of the current theme into the underlying jface registries (ColorRegistry and FontRegistry whenever the current theme changes. Clients who do not need access to specific themes may instead attach listeners to these registries directly. This interface is not intended to be implemented or extended by clients. Since: 3.0 See Also: IWorkbench.getThemeManager() Restriction: This interface is not intended to be implemented by clients. '
370, 'org.eclipse.ui.themes.ITheme', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/themes/ITheme.html', 'A theme is a collection of colors, fonts and supporting data that may be used by plugins to help provide uniform look and feel to their components. The workbench has a default theme (one whos id has the value IThemeManager.DEFAULT_THEME) that defines the initial values for a collection of fonts and colors. Other themes may extend and override the default theme to provide new values. Clients may obtain themes via IThemeManager.getTheme(String). This interface is not intended to be implemented or extended by clients. Since: 3.0 See Also: IWorkbench.getThemeManager() Restriction: This interface is not intended to be implemented by clients. '
371, 'org.eclipse.jface.resource.ColorRegistry', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/resource/ColorRegistry.html', 'extends ResourceRegistry A color registry maintains a mapping between symbolic color names and SWT Colors. A color registry owns all of the Color objects registered with it, and automatically disposes of them when the SWT Display that creates the Colors is disposed. Because of this, clients do not need to (indeed, must not attempt to) dispose of Color objects themselves. Methods are provided for registering listeners that will be kept apprised of changes to list of registed colors. Clients may instantiate this class (it was not designed to be subclassed). Since: 3.0 Restriction: This class is not intended to be subclassed by clients. '
372, 'org.eclipse.jface.resource.FontRegistry', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/resource/FontRegistry.html', 'extends ResourceRegistry A font registry maintains a mapping between symbolic font names and SWT fonts. A font registry owns all of the font objects registered with it, and automatically disposes of them when the SWT Display that creates the fonts is disposed. Because of this, clients do not need to (indeed, must not attempt to) dispose of font objects themselves. A special constructor is provided for populating a font registry from a property files using the standard Java resource bundle mechanism. Methods are provided for registering listeners that will be kept apprised of changes to list of registered fonts. Clients may instantiate this class (it was not designed to be subclassed). Since 3.0 this class extends ResourceRegistry. Restriction: This class is not intended to be subclassed by clients. '
373, 'org.eclipse.ui.themes.ColorUtil', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/themes/ColorUtil.html', 'extends Object Useful color utilities. Since: 3.0 - initial release, 3.2 - public API '
374, 'org.eclipse.swt.custom.StackLayout', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/custom/StackLayout.html', 'extends Layout This Layout stacks all the controls one on top of the other and resizes all controls to have the same size and location. The control specified in topControl is visible and all other controls are not visible. Users must set the topControl value to flip between the visible items and then call layout() on the composite which has the StackLayout. Here is an example which places ten buttons in a stack layout and flips between them: public static void main(String[] args) { Display display = new Display(); Shell shell = new Shell(display); shell.setLayout(new GridLayout()); final Composite parent = new Composite(shell, SWT.NONE); parent.setLayoutData(new GridData(GridData.FILL_BOTH)); final StackLayout layout = new StackLayout(); parent.setLayout(layout); final Button[] bArray = new Button[10]; for (int i = 0; i < 10; i++) { bArray[i] = new Button(parent, SWT.PUSH); bArray[i].setText(\"Button \"+i); } layout.topControl = bArray[0]; Button b = new Button(shell, SWT.PUSH); b.setText(\"Show Next Button\"); final int[] index = new int[1]; b.addListener(SWT.Selection, new Listener(){ public void handleEvent(Event e) { index[0] = (index[0] + 1) % 10; layout.topControl = bArray[index[0]]; parent.layout(); } }); shell.open(); while (shell != null && !shell.isDisposed()) { if (!display.readAndDispatch()) display.sleep(); } } See Also: StackLayout snippets, SWT Example: LayoutExample, Sample code and further information '
375, 'org.eclipse.ui.themes.IThemePreview', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/themes/IThemePreview.html', 'Interface used by theme element developers to preview the usage of their elements within the colors and fonts preference page. Since: 3.0 '
376, 'org.eclipse.jface.preference.PreferenceConverter', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/preference/PreferenceConverter.html', 'extends Object A utility class for dealing with preferences whose values are common SWT objects (color, points, rectangles, and font data). The static methods on this class handle the conversion between the SWT objects and their string representations. Usage: IPreferenceStore store = ...; PreferenceConverter.setValue(store, \"bg\", new RGB(127,127,127)); ... RBG bgColor = PreferenceConverter.getValue(store, \"bg\"); This class contains static methods and fields only and cannot be instantiated. Note: touching this class has the side effect of creating a display (static initializer). Restriction: This class is not intended to be instantiated by clients. '
377, 'org.eclipse.jface.resource.StringConverter', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/resource/StringConverter.html', 'extends Object Helper class for converting various data types to and from strings. Supported types include: boolean int long float double org.eclipse.swt.graphics.Point org.eclipse.swt.graphics.Rectangle org.eclipse.swt.graphics.RGB org.eclipse.swt.graphics.FontData All methods declared on this class are static. This class cannot be instantiated. Restriction: This class is not intended to be subclassed by clients. Restriction: This class is not intended to be instantiated by clients. '
378, 'org.eclipse.swt.layout.FillLayout', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/layout/FillLayout.html', 'extends Layout FillLayout is the simplest layout class. It lays out controls in a single row or column, forcing them to be the same size. Initially, the controls will all be as tall as the tallest control, and as wide as the widest. FillLayout does not wrap, but you can specify margins and spacing. You might use it to lay out buttons in a task bar or tool bar, or to stack checkboxes in a Group. FillLayout can also be used when a Composite only has one child. For example, if a Shell has a single Group child, FillLayout will cause the Group to completely fill the Shell (if margins are 0). Example code: first a FillLayout is created and its type field is set, and then the layout is set into the Composite. Note that in a FillLayout, children are always the same size, and they fill all available space. FillLayout fillLayout = new FillLayout(); fillLayout.type = SWT.VERTICAL; shell.setLayout(fillLayout); See Also: SWT Example: LayoutExample, Sample code and further information '
379, 'org.eclipse.swt.widgets.FontDialog', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/widgets/FontDialog.html', 'extends Dialog Instances of this class allow the user to select a font from all available fonts in the system. Styles: (none) Events: (none) IMPORTANT: This class is not intended to be subclassed. See Also: SWT Example: ControlExample, Dialog tab, Sample code and further information Restriction: This class is not intended to be subclassed by clients. '
380, 'org.eclipse.swt.widgets.ColorDialog', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/widgets/ColorDialog.html', 'extends Dialog Instances of this class allow the user to select a color from a predefined set of available colors. Styles: (none) Events: (none) IMPORTANT: This class is not intended to be subclassed. See Also: SWT Example: ControlExample, Dialog tab, Sample code and further information Restriction: This class is not intended to be subclassed by clients. '
381, 'org.eclipse.swt.graphics.FontMetrics', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/graphics/FontMetrics.html', 'extends Object Instances of this class provide measurement information about fonts including ascent, descent, height, leading space between rows, and average character width. FontMetrics are obtained from GCs using the getFontMetrics() method. See Also: GC.getFontMetrics(), Sample code and further information '
382, 'org.eclipse.jface.viewers.BaseLabelProvider', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/viewers/BaseLabelProvider.html', 'A label provider maps an element of the viewer\'s model to an optional image and optional text string used to display the element in the viewer\'s control. Certain label providers may allow multiple labels per element. This is an \"abstract interface\", defining methods common to all label providers, but does not actually define the methods to get the label(s) for an element. This interface should never be directly implemented. Most viewers will take either an ILabelProvider or an ITableLabelProvider. A label provider must not be shared between viewers since a label provider generally manages SWT resources (images), which must be disposed when the viewer is disposed. To simplify life cycle management, the current label provider of a viewer is disposed when the viewer is disposed. Label providers can be used outside the context of viewers wherever images are needed. When label providers are used in this fashion it is the responsibility of the user to ensure dispose is called when the provider is no longer needed. See Also: ILabelProvider, ITableLabelProvider extends EventManager implements IBaseLabelProvider BaseLabelProvider is a default concrete implementation of IBaseLabelProvider Since: 3.3 '
383, 'org.eclipse.jface.viewers.CellLabelProvider', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/viewers/CellLabelProvider.html', 'A label provider maps an element of the viewer\'s model to an optional image and optional text string used to display the element in the viewer\'s control. Certain label providers may allow multiple labels per element. This is an \"abstract interface\", defining methods common to all label providers, but does not actually define the methods to get the label(s) for an element. This interface should never be directly implemented. Most viewers will take either an ILabelProvider or an ITableLabelProvider. A label provider must not be shared between viewers since a label provider generally manages SWT resources (images), which must be disposed when the viewer is disposed. To simplify life cycle management, the current label provider of a viewer is disposed when the viewer is disposed. Label providers can be used outside the context of viewers wherever images are needed. When label providers are used in this fashion it is the responsibility of the user to ensure dispose is called when the provider is no longer needed. See Also: ILabelProvider, ITableLabelProvider extends BaseLabelProvider The CellLabelProvider is an abstract implementation of a label provider for structured viewers. This class is intended to be subclassed Since: 3.3 See Also: as a concrete implementation '
384, 'org.eclipse.jface.viewers.ColumnViewer', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/viewers/ColumnViewer.html', 'Interface common to all objects that provide an input. extends IInputProvider, ISelectionProvider Interface common to all objects that provide both an input and a selection. extends ISelectionProvider Selection provider extension interface to allow providers to notify about post selection changed events. A post selection changed event is equivalent to selection changed event if the selection change was triggered by the mouse, but it has a delay if the selection change is triggered by keyboard navigation. Since: 3.0 See Also: ISelectionProvider Interface common to all objects that provide a selection. See Also: ISelection, ISelectionChangedListener, SelectionChangedEvent extends StructuredViewer The ColumnViewer is the abstract superclass of viewers that have columns (e.g., AbstractTreeViewer and AbstractTableViewer). Concrete subclasses of ColumnViewer should implement a matching concrete subclass of ViewerColumn. This class is not intended to be subclassed outside of the JFace viewers framework. Since: 3.3 '
385, 'org.eclipse.jface.viewers.AbstractTreeViewer', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/viewers/AbstractTreeViewer.html', 'Interface common to all objects that provide an input. extends IInputProvider, ISelectionProvider Interface common to all objects that provide both an input and a selection. extends ISelectionProvider Selection provider extension interface to allow providers to notify about post selection changed events. A post selection changed event is equivalent to selection changed event if the selection change was triggered by the mouse, but it has a delay if the selection change is triggered by keyboard navigation. Since: 3.0 See Also: ISelectionProvider Interface common to all objects that provide a selection. See Also: ISelection, ISelectionChangedListener, SelectionChangedEvent extends ColumnViewer Abstract base implementation for tree-structure-oriented viewers (trees and table trees). Nodes in the tree can be in either an expanded or a collapsed state, depending on whether the children on a node are visible. This class introduces public methods for controlling the expanding and collapsing of nodes. As of 3.2, AbstractTreeViewer supports multiple equal elements (each with a different parent chain) in the tree. This support requires that clients enable the element map by calling setUseHashLookup(true). Content providers for abstract tree viewers must implement one of the interfaces ITreeContentProvider or (as of 3.2, to support multiple equal elements) ITreePathContentProvider. See Also: TreeViewer '
386, 'org.eclipse.jface.viewers.ITableLabelProvider', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/viewers/ITableLabelProvider.html', 'A label provider maps an element of the viewer\'s model to an optional image and optional text string used to display the element in the viewer\'s control. Certain label providers may allow multiple labels per element. This is an \"abstract interface\", defining methods common to all label providers, but does not actually define the methods to get the label(s) for an element. This interface should never be directly implemented. Most viewers will take either an ILabelProvider or an ITableLabelProvider. A label provider must not be shared between viewers since a label provider generally manages SWT resources (images), which must be disposed when the viewer is disposed. To simplify life cycle management, the current label provider of a viewer is disposed when the viewer is disposed. Label providers can be used outside the context of viewers wherever images are needed. When label providers are used in this fashion it is the responsibility of the user to ensure dispose is called when the provider is no longer needed. See Also: ILabelProvider, ITableLabelProvider extends IBaseLabelProvider Extends IBaseLabelProvider with the methods to provide the text and/or image for each column of a given element. Used by table viewers. See Also: TableViewer '
387, 'org.eclipse.jface.viewers.ITableColorProvider', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/viewers/ITableColorProvider.html', 'Interface to provide color representation for a given cell within the row for an element in a table. Since: 3.1 '
388, 'org.eclipse.jface.viewers.ITableFontProvider', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/viewers/ITableFontProvider.html', 'The ITableFontProvider is a font provider that provides fonts to individual cells within tables. Since: 3.1 '
389, 'org.eclipse.jface.viewers.ViewerCell', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/viewers/ViewerCell.html', 'extends Object The ViewerCell is the JFace representation of a cell entry in a ViewerRow. Since: 3.3 '
390, 'org.eclipse.jface.viewers.ViewerColumn', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/viewers/ViewerColumn.html', 'extends Object Instances of this class represent a column of a ColumnViewer. Label providers and editing support can be configured for each column separately. Concrete subclasses of ColumnViewer should implement a matching concrete subclass of ViewerColumn. Since: 3.3 '
391, 'org.eclipse.jface.viewers.StyledCellLabelProvider', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/viewers/StyledCellLabelProvider.html', 'A label provider maps an element of the viewer\'s model to an optional image and optional text string used to display the element in the viewer\'s control. Certain label providers may allow multiple labels per element. This is an \"abstract interface\", defining methods common to all label providers, but does not actually define the methods to get the label(s) for an element. This interface should never be directly implemented. Most viewers will take either an ILabelProvider or an ITableLabelProvider. A label provider must not be shared between viewers since a label provider generally manages SWT resources (images), which must be disposed when the viewer is disposed. To simplify life cycle management, the current label provider of a viewer is disposed when the viewer is disposed. Label providers can be used outside the context of viewers wherever images are needed. When label providers are used in this fashion it is the responsibility of the user to ensure dispose is called when the provider is no longer needed. See Also: ILabelProvider, ITableLabelProvider extends OwnerDrawLabelProvider A StyledCellLabelProvider supports styled labels by using owner draw. Besides the styles in labels, the label provider preserves native viewer behavior: similar image and label positioning native drawing of focus and selection For providing the label\'s styles, create a subclass and overwrite update(ViewerCell) to return set all information needed to render a element. Use ViewerCell.setStyleRanges(StyleRange[]) to set style ranges on the label. Since: 3.4 '
392, 'org.eclipse.jface.viewers.StyledString', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/viewers/StyledString.html', 'extends Object A mutable string with styled ranges. All ranges mark substrings of the string and do not overlap. Styles are applied using instances of StyledString.Styler to compute the result of getStyleRanges(). The styled string can be built in the following two ways: new strings with stylers can be appended stylers can by applied to ranges of the existing string This class may be instantiated; it is not intended to be subclassed. Since: 3.4 '
393, 'org.eclipse.swt.custom.StyleRange', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/custom/StyleRange.html', 'extends TextStyle implements org.eclipse.swt.internal.CloneableCompatibility StyleRange defines a set of styles for a specified range of text. The hashCode() method in this class uses the values of the public fields to compute the hash value. When storing instances of the class in hashed collections, do not modify these fields after the object has been inserted. See Also: Sample code and further information '
394, 'org.eclipse.jface.viewers.IColorProvider', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/viewers/IColorProvider.html', 'Interface to provide color representation for a given element. See Also: IColorDecorator '
395, 'org.eclipse.jface.viewers.IFontProvider', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/viewers/IFontProvider.html', 'Interface to provide font representation for a given element. Since: 3.0 See Also: IFontDecorator '
396, 'org.eclipse.core.runtime.IExtensionPoint', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/runtime/IExtensionPoint.html', 'An extension point declared in a plug-in. Except for the list of extensions plugged in to it, the information available for an extension point is obtained from the declaring plug-in\'s manifest (plugin.xml) file. These registry objects are intended for relatively short-term use. Clients that deal with these objects must be aware that they may become invalid if the declaring plug-in is updated or uninstalled. If this happens, all methods except isValid() will throw InvalidRegistryObjectException. For extension point objects, the most common case is code in a plug-in dealing with one of the extension points it declares. These extension point objects are guaranteed to be valid while the plug-in is active. Code in a plug-in that has declared that it is not dynamic aware (or not declared anything) can also safely ignore this issue, since the registry would not be modified while it is active. However, code in a plug-in that declares that it is dynamic aware must be careful if it access the extension point object of a different plug-in, because it\'s at risk if that other plug-in is removed. Similarly, tools that analyze or display the extension registry are vulnerable. Client code can pre-test for invalid objects by calling isValid(), which never throws this exception. However, pre-tests are usually not sufficient because of the possibility of the extension point object becoming invalid as a result of a concurrent activity. At-risk clients must treat InvalidRegistryObjectException as if it were a checked exception. Also, such clients should probably register a listener with the extension registry so that they receive notification of any changes to the registry. This interface can be used without OSGi running. This interface is not intended to be implemented by clients. Restriction: This interface is not intended to be implemented by clients. '
397, 'org.eclipse.core.runtime.RegistryFactory', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/runtime/RegistryFactory.html', 'extends Object Use this class to create or obtain an extension registry. The following methods can be used without OSGi running: createRegistry(RegistryStrategy, Object, Object) getRegistry() setDefaultRegistryProvider(IRegistryProvider) This class is not intended to be subclassed or instantiated. Since: org.eclipse.equinox.registry 3.2 Restriction: This class is not intended to be instantiated by clients. '
398, 'org.eclipse.core.runtime.preferences.IEclipsePreferences', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/runtime/preferences/IEclipsePreferences.html', 'extends org.osgi.service.prefs.Preferences This interface describes Eclipse extensions to the preference story. It provides means for both preference and node change listeners. Clients may implement this interface. Since: 3.0 See Also: Preferences '
399, 'org.eclipse.core.runtime.FileLocator', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/runtime/FileLocator.html', 'extends Object This class contains a collection of helper methods for finding files in bundles. This class can only be used if the OSGi plugin is available. Since: org.eclipse.equinox.common 3.2 Restriction: This class is not intended to be instantiated by clients. '
400, 'org.eclipse.core.runtime.preferences.InstanceScope', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/runtime/preferences/InstanceScope.html', 'Clients implement this interface to provide context to a particular scope. Instances of implementations of this interface are passed to the IPreferencesService for use in preference searching. Clients may implement this interface. Since: 3.0 See Also: IPreferencesService extends org.eclipse.core.internal.preferences.AbstractScope Object representing the instance scope in the Eclipse preferences hierarchy. Can be used as a context for searching for preference values (in the IPreferencesService APIs) or for determining the correct preference node to set values in the store. Instance preferences are stored on a per instance basis in the platform\'s instance area as specified by the Location class and the Location.INSTANCE_FILTER filter. The path for preferences defined in the instance scope hierarchy is as follows: /instance/<qualifier> This class is not intended to be subclassed. This class may be instantiated. Since: 3.0 See Also: Location.INSTANCE_FILTER '
401, 'org.eclipse.swt.events.ControlListener', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/events/ControlListener.html', 'extends org.eclipse.swt.internal.SWTEventListener Classes which implement this interface provide methods that deal with the events that are generated by moving and resizing controls. After creating an instance of a class that implements this interface it can be added to a control using the addControlListener method and removed using the removeControlListener method. When a control is moved or resized, the appropriate method will be invoked. See Also: ControlAdapter, ControlEvent '
402, 'org.eclipse.swt.events.ControlEvent', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/events/ControlEvent.html', 'extends TypedEvent Instances of this class are sent as a result of controls being moved or resized. See Also: ControlListener, Sample code and further information, Serialized Form '
403, 'org.eclipse.e4.ui.model.application.MApplicationElement', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/e4/ui/model/application/MApplicationElement.html', ' A representation of the model object \'Element\'. This is the root element for all UI Model elements, defining attribtues common to every element; the element\'s id as well as three general storage elements: Tags: This is a set of strings which can be used to stereotype a particular element. Tags may be specified in element searches and can also be referred to in the CSS styling definition. PersistedState: A string to string map used to store information that nneds to be persisted between sessions. TransientData: A string to object map which can be used to store runtime data relevant to a particular model element. Since: 1.0 The following features are supported: Element Id Persisted State Tags Contributor URI Transient Data '
404, 'org.eclipse.swt.SWT', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/SWT.html', 'extends Object This class provides access to a small number of SWT system-wide methods, and in addition defines the public constants provided by SWT. By defining constants like UP and DOWN in a single class, SWT can share common names and concepts at the same time minimizing the number of classes, names and constants for the application programmer. Note that some of the constants provided by this class represent optional, appearance related aspects of widgets which are available either only on some window systems, or for a differing set of widgets on each window system. These constants are marked as HINTs. The set of widgets which support a particular HINT may change from release to release, although we typically will not withdraw support for a HINT once it is made available. See Also: Sample code and further information '
405, 'org.eclipse.swt.events.FocusListener', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/events/FocusListener.html', 'extends org.eclipse.swt.internal.SWTEventListener Classes which implement this interface provide methods that deal with the events that are generated as controls gain and lose focus. After creating an instance of a class that implements this interface it can be added to a control using the addFocusListener method and removed using the removeFocusListener method. When a control gains or loses focus, the appropriate method will be invoked. See Also: FocusAdapter, FocusEvent '
406, 'org.eclipse.swt.events.ShellListener', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/events/ShellListener.html', 'extends org.eclipse.swt.internal.SWTEventListener Classes which implement this interface provide methods that deal with changes in state of Shells. After creating an instance of a class that implements this interface it can be added to a shell using the addShellListener method and removed using the removeShellListener method. When the state of the shell changes, the appropriate method will be invoked. See Also: ShellAdapter, ShellEvent '
407, 'org.eclipse.ui.actions.NewWizardMenu', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/actions/NewWizardMenu.html', 'A contribution item represents a contribution to a shared UI resource such as a menu or tool bar. More generally, contribution items are managed by a contribution manager. For instance, in a tool bar a contribution item is a tool bar button or a separator. In a menu bar a contribution item is a menu, and in a menu a contribution item is a menu item or separator. A contribution item can realize itself in different SWT widgets, using the different fill methods. The same type of contribution item can be used with a MenuBarManager, ToolBarManager, CoolBarManager, or a StatusLineManager. This interface is internal to the framework; it should not be implemented outside the framework. See Also: IContributionManager Restriction: This interface is not intended to be implemented by clients. extends BaseNewWizardMenu A NewWizardMenu augments BaseNewWizardMenu with IDE-specific actions: New Project... (always shown) and New Example... (shown only if there are example wizards installed). Note: Clients must dispose this menu when it is no longer required. '
408, 'org.eclipse.jface.action.StatusLineContributionItem', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/action/StatusLineContributionItem.html', 'A contribution item represents a contribution to a shared UI resource such as a menu or tool bar. More generally, contribution items are managed by a contribution manager. For instance, in a tool bar a contribution item is a tool bar button or a separator. In a menu bar a contribution item is a menu, and in a menu a contribution item is a menu item or separator. A contribution item can realize itself in different SWT widgets, using the different fill methods. The same type of contribution item can be used with a MenuBarManager, ToolBarManager, CoolBarManager, or a StatusLineManager. This interface is internal to the framework; it should not be implemented outside the framework. See Also: IContributionManager Restriction: This interface is not intended to be implemented by clients. extends ContributionItem A contribution item to be used with status line managers. This class may be instantiated; it is not intended to be subclassed. Since: 3.4 '
409, 'org.eclipse.core.resources.IResourceChangeListener', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/resources/IResourceChangeListener.html', 'extends EventListener A resource change listener is notified of changes to resources in the workspace. These changes arise from direct manipulation of resources, or indirectly through re-synchronization with the local file system. Clients may implement this interface. See Also: IResourceDelta, IWorkspace.addResourceChangeListener(IResourceChangeListener, int) '
410, 'org.eclipse.ui.actions.BuildAction', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/actions/BuildAction.html', 'An action represents the non-UI side of a command which can be triggered by the end user. Actions are typically associated with buttons, menu items, and items in tool bars. The controls for a command are built by some container, which furnished the context where these controls appear and configures them with data from properties declared by the action. When the end user triggers the command via its control, the action\'s run method is invoked to do the real work. Actions support a predefined set of properties (and possibly others as well). Clients of an action may register property change listeners so that they get notified whenever the value of a property changes. Clients should subclass the abstract base class Action to define concrete actions rather than implementing IAction from scratch. This interface exists only to define the API for actions. It is not intended to be implemented by clients. See Also: Action Restriction: This interface is not intended to be implemented by clients. A listener which is notified when a viewer\'s selection changes. See Also: ISelection, ISelectionProvider, SelectionChangedEvent extends WorkspaceAction Standard actions for full and incremental builds of the selected project(s) and their references project build configurations. This class may be instantiated; it is not intended to be subclassed. Restriction: This class is not intended to be subclassed by clients. '
411, 'org.eclipse.core.resources.IResourceChangeEvent', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/resources/IResourceChangeEvent.html', 'Resource change events describe changes to resources. There are currently five different types of resource change events: Before-the-fact batch reports of arbitrary creations, deletions and modifications to one or more resources expressed as a hierarchical resource delta. Event type is PRE_BUILD, and getDelta returns the hierarchical delta rooted at the workspace root. The getBuildKind method returns the kind of build that is about to occur, and the getSource method returns the scope of the build (either the workspace or a single project). These events are broadcast to interested parties immediately before each build operation. If autobuilding is not enabled, these events still occur at times when autobuild would have occurred. The workspace is open for change during notification of these events. The delta reported in this event cycle is identical across all listeners registered for this type of event. Resource changes attempted during a PRE_BUILD callback must be done in the thread doing the notification. After-the-fact batch reports of arbitrary creations, deletions and modifications to one or more resources expressed as a hierarchical resource delta. Event type is POST_BUILD, and getDelta returns the hierarchical delta rooted at the workspace root. The getBuildKind method returns the kind of build that occurred, and the getSource method returns the scope of the build (either the workspace or a single project). These events are broadcast to interested parties at the end of every build operation. If autobuilding is not enabled, these events still occur at times when autobuild would have occurred. The workspace is open for change during notification of these events. The delta reported in this event cycle is identical across all listeners registered for this type of event. Resource changes attempted during a POST_BUILD callback must be done in the thread doing the notification. After-the-fact batch reports of arbitrary creations, deletions and modifications to one or more resources expressed as a hierarchical resource delta. Event type is POST_CHANGE, and getDelta returns the hierarchical delta. The resource delta is rooted at the workspace root. These events are broadcast to interested parties after a set of resource changes and happen whether or not autobuilding is enabled. The workspace is closed for change during notification of these events. The delta reported in this event cycle is identical across all listeners registered for this type of event. Before-the-fact reports of the impending closure of a single project. Event type is PRE_CLOSE, and getResource returns the project being closed. The workspace is closed for change during notification of these events. Before-the-fact reports of the impending deletion of a single project. Event type is PRE_DELETE, and getResource returns the project being deleted. The workspace is closed for change during notification of these events. Before-the-fact reports of the impending refresh of a single project or the workspace. Event type is PRE_REFRESH and the getSource method returns the scope of the refresh (either the workspace or a single project). If the event is fired by a project refresh the getResource method returns the project being refreshed. The workspace is closed for changes during notification of these events. In order to handle additional event types that may be introduced in future releases of the platform, clients should do not write code that presumes the set of event types is closed. Restriction: This interface is not intended to be implemented by clients. Restriction: This interface is not intended to be extended by clients. '
412, 'org.eclipse.core.resources.IResourceDelta', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/resources/IResourceDelta.html', 'An interface for an adaptable object. Adaptable objects can be dynamically extended to provide different interfaces (or \"adapters\"). Adapters are created by adapter factories, which are in turn managed by type by adapter managers. For example, IAdaptable a = [some adaptable]; IFoo x = (IFoo)a.getAdapter(IFoo.class); if (x != null) [do IFoo things with x] This interface can be used without OSGi running. Clients may implement this interface, or obtain a default implementation of this interface by subclassing PlatformObject. See Also: IAdapterFactory, IAdapterManager, PlatformObject extends IAdaptable A resource delta represents changes in the state of a resource tree between two discrete points in time. Resource deltas implement the IAdaptable interface; extensions are managed by the platform\'s adapter manager. See Also: IResource, Platform.getAdapterManager() Restriction: This interface is not intended to be implemented by clients. Restriction: This interface is not intended to be extended by clients. '
413, 'org.eclipse.core.resources.ResourcesPlugin', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/resources/ResourcesPlugin.html', 'extends Plugin The plug-in runtime class for the Resources plug-in. This is the starting point for all workspace and resource manipulation. A typical sequence of events would be for a dependent plug-in to call ResourcesPlugin.getWorkspace(). Doing so would cause this plug-in to be activated and the workspace (if any) to be loaded from disk and initialized. Restriction: This class is not intended to be instantiated by clients. '
414, 'org.eclipse.ui.actions.ContributionItemFactory', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/actions/ContributionItemFactory.html', 'extends Object Access to standard contribution items provided by the workbench. Most of the functionality of this class is provided by static methods and fields. Example usage: MenuManager menu = ...; IContributionItem reEdit = ContributionItemFactory.REOPEN_EDITORS.create(window); menu.add(reEdit); Clients may declare subclasses that provide additional application-specific contribution item factories. Since: 3.0 '
415, 'org.eclipse.ui.menus.CommandContributionItemParameter', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/menus/CommandContributionItemParameter.html', 'extends Object A help class for the various parameters that can be used with command contributions. Mandatory parameters are in the constructor, and public fields can be set to fill in other parameters. Since: 3.4 '
416, 'org.eclipse.ui.ide.IDEActionFactory', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/ide/IDEActionFactory.html', 'extends Object Access to standard actions provided by the IDE workbench (including those of the generic workbench). The functionality of this class is provided by static fields. Example usage: MenuManager menu = ...; ActionFactory.IWorkbenchAction closeProjectAction = IDEActionFactory.CLOSE_PROJECT.create(window); menu.add(closeProjectAction); Since: 3.0 '
417, 'org.eclipse.core.resources.IWorkspace', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/resources/IWorkspace.html', 'An interface for an adaptable object. Adaptable objects can be dynamically extended to provide different interfaces (or \"adapters\"). Adapters are created by adapter factories, which are in turn managed by type by adapter managers. For example, IAdaptable a = [some adaptable]; IFoo x = (IFoo)a.getAdapter(IFoo.class); if (x != null) [do IFoo things with x] This interface can be used without OSGi running. Clients may implement this interface, or obtain a default implementation of this interface by subclassing PlatformObject. See Also: IAdapterFactory, IAdapterManager, PlatformObject extends IAdaptable Workspaces are the basis for Eclipse Platform resource management. There is only one workspace per running platform. All resources exist in the context of this workspace. A workspace corresponds closely to discreet areas in the local file system. Each project in a workspace maps onto a specific area of the file system. The folders and files within a project map directly onto the corresponding directories and files in the file system. One sub-directory, the workspace metadata area, contains internal information about the workspace and its resources. This metadata area should be accessed only by the Platform or via Platform API calls. Workspaces add value over using the file system directly in that they allow for comprehensive change tracking (through IResourceDelta s), various forms of resource metadata (e.g., markers and properties) as well as support for managing application/tool state (e.g., saving and restoring). The workspace as a whole is thread safe and allows one writer concurrent with multiple readers. It also supports mechanisms for saving and snapshotting the current resource state. The workspace is provided by the Resources plug-in and is automatically created when that plug-in is activated. The default workspace data area (i.e., where its resources are stored) overlap exactly with the platform\'s data area. That is, by default, the workspace\'s projects are found directly in the platform\'s data area. Individual project locations can be specified explicitly. The workspace resource namespace is always case-sensitive and case-preserving. Thus the workspace allows multiple sibling resources to exist with names that differ only in case. The workspace also imposes no restrictions on valid characters in resource names, the length of resource names, or the size of resources on disk. In situations where one or more resources are stored in a file system that is not case-sensitive, or that imposes restrictions on resource names, any failure to store or retrieve those resources will be propagated back to the caller of workspace API. Workspaces implement the IAdaptable interface; extensions are managed by the platform\'s adapter manager. Restriction: This interface is not intended to be implemented by clients. Restriction: This interface is not intended to be extended by clients. '
418, 'org.eclipse.core.resources.IProject', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/resources/IProject.html', 'An interface for an adaptable object. Adaptable objects can be dynamically extended to provide different interfaces (or \"adapters\"). Adapters are created by adapter factories, which are in turn managed by type by adapter managers. For example, IAdaptable a = [some adaptable]; IFoo x = (IFoo)a.getAdapter(IFoo.class); if (x != null) [do IFoo things with x] This interface can be used without OSGi running. Clients may implement this interface, or obtain a default implementation of this interface by subclassing PlatformObject. See Also: IAdapterFactory, IAdapterManager, PlatformObject extends IResource, IAdaptable Interface for resources which may contain other resources (termed its members). While the workspace itself is not considered a container in this sense, the workspace root resource is a container. Containers implement the IAdaptable interface; extensions are managed by the platform\'s adapter manager. See Also: Platform.getAdapterManager(), IProject, IFolder, IWorkspaceRoot Restriction: This interface is not intended to be implemented by clients. Restriction: This interface is not intended to be extended by clients. extends IAdaptable, ISchedulingRule The workspace analog of file system files and directories. There are exactly four types of resource: files, folders, projects and the workspace root. File resources are similar to files in that they hold data directly. Folder resources are analogous to directories in that they hold other resources but cannot directly hold data. Project resources group files and folders into reusable clusters. The workspace root is the top level resource under which all others reside. Features of resources: IResource objects are handles to state maintained by a workspace. That is, resource objects do not actually contain data themselves but rather represent resource state and give it behavior. Programmers are free to manipulate handles for resources that do not exist in a workspace but must keep in mind that some methods and operations require that an actual resource be available. Resources have two different kinds of properties as detailed below. All properties are keyed by qualified names. Session properties: Session properties live for the lifetime of one execution of the workspace. They are not stored on disk. They can carry arbitrary object values. Clients should be aware that these values are kept in memory at all times and, as such, the values should not be large. Persistent properties: Persistent properties have string values which are stored on disk across platform sessions. The value of a persistent property is a string which should be short (i.e., under 2KB). Resources are identified by type and by their path, which is similar to a file system path. The name of a resource is the last segment of its path. A resource\'s parent is located by removing the last segment (the resource\'s name) from the resource\'s full path. Resources can be local or non-local. A non-local resource is one whose contents and properties have not been fetched from a repository. Phantom resources represent incoming additions or outgoing deletions which have yet to be reconciled with a synchronization partner. Resources implement the IAdaptable interface; extensions are managed by the platform\'s adapter manager. See Also: IWorkspace, Platform.getAdapterManager() Restriction: This interface is not intended to be implemented by clients. Restriction: This interface is not intended to be extended by clients. Scheduling rules are used by jobs to indicate when they need exclusive access to a resource. Scheduling rules can also be applied synchronously to a thread using IJobManager.beginRule(ISchedulingRule) and IJobManager.endRule(ISchedulingRule). The job manager guarantees that no two jobs with conflicting scheduling rules will run concurrently. Multiple rules can be applied to a given thread only if the outer rule explicitly allows the nesting as specified by the contains method. Clients may implement this interface. Since: 3.0 See Also: Job.getRule(), Job.setRule(ISchedulingRule), Job.schedule(long), IJobManager.beginRule(ISchedulingRule, org.eclipse.core.runtime.IProgressMonitor), IJobManager.endRule(ISchedulingRule) extends IContainer, IAdaptable A project is a type of resource which groups resources into buildable, reusable units. Features of projects include: A project collects together a set of files and folders. A project\'s location controls where the project\'s resources are stored in the local file system. A project\'s build spec controls how building is done on the project. A project can carry session and persistent properties. A project can be open or closed; a closed project is passive and has a minimal in-memory footprint. A project can have one or more project build configurations. A project can carry references to other project build configurations. A project can have one or more project natures. Projects implement the IAdaptable interface; extensions are managed by the platform\'s adapter manager. See Also: Platform.getAdapterManager() Restriction: This interface is not intended to be implemented by clients. Restriction: This interface is not intended to be extended by clients. '
419, 'org.eclipse.ui.ISharedImages', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/ISharedImages.html', 'A registry for common images used by the workbench which may be useful to other plug-ins. This class provides Image and ImageDescriptors for each named image in the interface. All Image objects provided by this class are managed by this class and must never be disposed by other clients. This interface is not intended to be implemented by clients. Restriction: This interface is not intended to be implemented by clients. Restriction: This interface is not intended to be extended by clients. '
420, 'org.eclipse.core.commands.AbstractHandler', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/commands/AbstractHandler.html', 'A handler is the pluggable piece of a command that handles execution. Each command can have zero or more handlers associated with it (in general), of which only one will be active at any given moment in time. When the command is asked to execute, it will simply pass that request on to its active handler, if any. Since: 3.1 See Also: AbstractHandler extends IHandler Extend the IHandler interface to provide some context for isEnabled() requests. Clients should use AbstractHandler unless they need to provide their own listener mechanism. Since: 3.4 See Also: AbstractHandler extends EventManager implements IHandler2 This class is a partial implementation of IHandler. This abstract implementation provides support for handler listeners. You should subclass from this method unless you want to implement your own listener support. Subclasses should call fireHandlerChanged(HandlerEvent)when the handler changes. Subclasses can also override isEnabled() and isHandled(). Since: 3.1 '
421, 'org.eclipse.core.commands.ExecutionEvent', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/commands/ExecutionEvent.html', 'extends Object The data object to pass to the command (and its handler) as it executes. This carries information about the current state of the application, and the application context in which the command was executed. An execution event carries three blocks of data: the parameters, the trigger, and the application context. How these blocks are used is application dependent. In the Eclipse workbench, the trigger is an SWT event, and the application context contains information about the selection and active part. Since: 3.1 '
422, 'org.eclipse.e4.ui.model.application.ui.basic.MStackElement', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/e4/ui/model/application/ui/basic/MStackElement.html', ' A representation of the model object \'Element\'. This is the root element for all UI Model elements, defining attribtues common to every element; the element\'s id as well as three general storage elements: Tags: This is a set of strings which can be used to stereotype a particular element. Tags may be specified in element searches and can also be referred to in the CSS styling definition. PersistedState: A string to string map used to store information that nneds to be persisted between sessions. TransientData: A string to object map which can be used to store runtime data relevant to a particular model element. Since: 1.0 The following features are supported: Element Id Persisted State Tags Contributor URI Transient Data A representation of the model object \'Element\'. This is the root element for all UI Model elements, defining attribtues common to every element; the element\'s id as well as three general storage elements: Tags: This is a set of strings which can be used to stereotype a particular element. Tags may be specified in element searches and can also be referred to in the CSS styling definition. PersistedState: A string to string map used to store information that nneds to be persisted between sessions. TransientData: A string to object map which can be used to store runtime data relevant to a particular model element. Since: 1.0 The following features are supported: Element Id Persisted State Tags Contributor URI Transient Data extends MApplicationElement A representation of the model object \'UI Element\'. This is the base mix-in shared by all model elements that can be rendered into the UI presentation of the application. Its main job is to manage the bindings between the concrete element and the UI \'widget\' representing it in the UI. Since: 1.0 The following features are supported: Widget Renderer To Be Rendered On Top Visible Parent Container Data Cur Shared Ref Visible When Accessibility Phrase extends MUIElement A representation of the model object \'Stack Element\'. A class to be mixed in to any element that should be allowed to be added to a PartStack. Since: 1.0 '
423, 'org.eclipse.ui.handlers.HandlerUtil', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/handlers/HandlerUtil.html', 'extends Object Some common utilities for working with handlers in Platform UI. Note: this class should not be instantiated or extended by clients. Since: 3.3 '
424, 'org.eclipse.e4.ui.model.application.ui.MExpression', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/e4/ui/model/application/ui/MExpression.html', ' A representation of the model object \'Element\'. This is the root element for all UI Model elements, defining attribtues common to every element; the element\'s id as well as three general storage elements: Tags: This is a set of strings which can be used to stereotype a particular element. Tags may be specified in element searches and can also be referred to in the CSS styling definition. PersistedState: A string to string map used to store information that nneds to be persisted between sessions. TransientData: A string to object map which can be used to store runtime data relevant to a particular model element. Since: 1.0 The following features are supported: Element Id Persisted State Tags Contributor URI Transient Data extends MApplicationElement A representation of the model object \'Expression\'. A class upon which specific types of expressions are based. These are often used to evaluate visibility and enablement of model elements. Since: 1.0 '
425, 'org.eclipse.e4.ui.model.application.ui.MDirtyable', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/e4/ui/model/application/ui/MDirtyable.html', ' A representation of the model object \'Dirtyable\'. This class should be mixed into any UI element that should participate in the dirty / save handling. Parts are the most likely scenario for this but it exists as a mix-in to allow for future model extensions. Since: 1.0 The following features are supported: Dirty '
426, 'org.eclipse.ui.views.properties.IPropertySheetEntry', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/views/properties/IPropertySheetEntry.html', 'IPropertySheetEntry describes the model interface for the property sheet. May be implemented when supplying a custom root entry to a property page. '
427, 'org.eclipse.ui.views.properties.PropertySheetEntry', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/views/properties/PropertySheetEntry.html', 'IPropertySheetEntry describes the model interface for the property sheet. May be implemented when supplying a custom root entry to a property page. extends EventManager implements IPropertySheetEntry PropertySheetEntry is an implementation of IPropertySheetEntry which uses IPropertySource and IPropertyDescriptor to interact with domain model objects. Every property sheet entry has a single descriptor (except the root entry which has none). This descriptor determines what property of its objects it will display/edit. Entries do not listen for changes in their objects. Since there is no restriction on properties being independent, a change in one property may affect other properties. The value of a parent\'s property may also change. As a result we are forced to refresh the entire entry tree when a property changes value. Since: 3.0 (was previously internal) '
428, 'org.eclipse.ui.views.properties.IPropertySourceProvider', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/views/properties/IPropertySourceProvider.html', 'Interface used by PropertySheetEntry to obtain an IPropertySource for a given object. This interface may be implemented by clients. '
429, 'org.eclipse.ui.views.properties.IPropertyDescriptor', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/views/properties/IPropertyDescriptor.html', 'A descriptor for a property to be presented by a standard property sheet page (PropertySheetPage). These descriptors originate with property sources (IPropertySource). A property descriptor carries the following information: property id (required) display name (required) brief description of the property (optional) category for grouping related properties (optional) label provider used to display the property value (optional) cell editor for changing the property value (optional) help context id (optional) Clients may implement this interface to provide specialized property descriptors; however, there are standard implementations declared in this package that take care of the most common cases: PropertyDescriptor - read-only property TextPropertyDescriptor - edits with a TextCellEditor CheckboxPropertyDescriptor - edits with a CheckboxCellEditor ComboBoxPropertyDescriptor - edits with a ComboBoxCellEditor ColorPropertyDescriptor - edits with a ColorCellEditor See Also: IPropertySource.getPropertyDescriptors() '
430, 'org.eclipse.jface.viewers.CellEditor', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/viewers/CellEditor.html', 'extends Object Abstract base class for cell editors. Implements property change listener handling, and SWT window management. Subclasses implement particular kinds of cell editors. This package contains various specialized cell editors: TextCellEditor - for simple text strings ColorCellEditor - for colors ComboBoxCellEditor - value selected from drop-down combo box CheckboxCellEditor - boolean valued checkbox DialogCellEditor - value from arbitrary dialog '
431, 'org.eclipse.jface.viewers.ICellEditorListener', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/viewers/ICellEditorListener.html', 'A listener which is notified of significant events in the life of a cell editor. This interface should be implemented by classes that wish to react to cell editor activity. Note: the cell editor is not passed as a parameter to any of these methods; so the assumption is that the listener knows which cell editor is talking to it. '
432, 'org.eclipse.ui.views.properties.IPropertySheetEntryListener', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/views/properties/IPropertySheetEntryListener.html', 'Listener for changes in objects of type IPropertySheetEntry. This interface is public since it appears in the api of IPropertySheetEntry. It is not intended to be implemented outside of this package. Restriction: This interface is not intended to be implemented by clients. '
433, 'org.eclipse.ui.views.properties.IPropertySource', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/views/properties/IPropertySource.html', 'Interface to an object which is capable of supplying properties for display by the standard property sheet page implementation (PropertySheetPage). This interface should be implemented by clients. PropertySheetPage discovers the properties to display from currently selected elements. Elements that implement IPropertySource directly are included, as are elements that implement IAdaptable and have an IPropertySource adapter. Clients should implement this interface for any newly-defined elements that are to have properties displayable by PropertySheetPage. Note that in the latter case, the client will also need to register a suitable adapter factory with the platform\'s adapter manager (Platform.getAdapterManager). See Also: IAdaptable, Platform.getAdapterManager(), PropertySheetPage, IPropertySource2 '
434, 'org.eclipse.ui.views.properties.IPropertySource2', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/views/properties/IPropertySource2.html', 'Interface to an object which is capable of supplying properties for display by the standard property sheet page implementation (PropertySheetPage). This interface should be implemented by clients. PropertySheetPage discovers the properties to display from currently selected elements. Elements that implement IPropertySource directly are included, as are elements that implement IAdaptable and have an IPropertySource adapter. Clients should implement this interface for any newly-defined elements that are to have properties displayable by PropertySheetPage. Note that in the latter case, the client will also need to register a suitable adapter factory with the platform\'s adapter manager (Platform.getAdapterManager). See Also: IAdaptable, Platform.getAdapterManager(), PropertySheetPage, IPropertySource2 extends IPropertySource Extension to the standard IPropertySource interface. This interface provides extended API to IPropertySource to allow an easier indication of properties that have a default value and can be resetted. Since: 3.0 See Also: IPropertySource '
435, 'org.eclipse.swt.custom.TreeEditor', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/custom/TreeEditor.html', 'extends ControlEditor A TreeEditor is a manager for a Control that appears above a cell in a Tree and tracks with the moving and resizing of that cell. It can be used to display a text widget above a cell in a Tree so that the user can edit the contents of that cell. It can also be used to display a button that can launch a dialog for modifying the contents of the associated cell. Here is an example of using a TreeEditor: final Tree tree = new Tree(shell, SWT.BORDER); for (int i = 0; i < 3; i++) { TreeItem item = new TreeItem(tree, SWT.NONE); item.setText(\"item \" + i); for (int j = 0; j < 3; j++) { TreeItem subItem = new TreeItem(item, SWT.NONE); subItem.setText(\"item \" + i + \" \" + j); } } final TreeEditor editor = new TreeEditor(tree); //The editor must have the same size as the cell and must //not be any smaller than 50 pixels. editor.horizontalAlignment = SWT.LEFT; editor.grabHorizontal = true; editor.minimumWidth = 50; tree.addSelectionListener(new SelectionAdapter() { public void widgetSelected(SelectionEvent e) { // Clean up any previous editor control Control oldEditor = editor.getEditor(); if (oldEditor != null) oldEditor.dispose(); // Identify the selected row TreeItem item = (TreeItem)e.item; if (item == null) return; // The control that will be the editor must be a child of the Tree Text newEditor = new Text(tree, SWT.NONE); newEditor.setText(item.getText()); newEditor.addModifyListener(new ModifyListener() { public void modifyText(ModifyEvent e) { Text text = (Text)editor.getEditor(); editor.getItem().setText(text.getText()); } }); newEditor.selectAll(); newEditor.setFocus(); editor.setEditor(newEditor, item); } }); See Also: TreeEditor snippets, Sample code and further information '
436, 'org.eclipse.ui.views.properties.PropertySheetSorter', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/views/properties/PropertySheetSorter.html', 'extends Object Class used by PropertySheetPage to sort properties. The default implementation sorts alphabetically. Subclasses may overwrite to implement custom sorting. Since: 3.1 '
437, 'org.eclipse.swt.widgets.TreeColumn', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/widgets/TreeColumn.html', 'extends Item Instances of this class represent a column in a tree widget. Styles: LEFT, RIGHT, CENTER Events: Move, Resize, Selection Note: Only one of the styles LEFT, RIGHT and CENTER may be specified. IMPORTANT: This class is not intended to be subclassed. Since: 3.1 See Also: Tree, TreeItem, TreeColumn snippets, Sample code and further information Restriction: This class is not intended to be subclassed by clients. '
438, 'org.eclipse.swt.events.ControlAdapter', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/events/ControlAdapter.html', 'extends org.eclipse.swt.internal.SWTEventListener Classes which implement this interface provide methods that deal with the events that are generated by moving and resizing controls. After creating an instance of a class that implements this interface it can be added to a control using the addControlListener method and removed using the removeControlListener method. When a control is moved or resized, the appropriate method will be invoked. See Also: ControlAdapter, ControlEvent extends Object implements ControlListener This adapter class provides default implementations for the methods described by the ControlListener interface. Classes that wish to deal with ControlEvents can extend this class and override only the methods which they are interested in. See Also: ControlListener, ControlEvent, Sample code and further information '
439, 'org.eclipse.swt.events.TreeEvent', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/events/TreeEvent.html', 'extends SelectionEvent Instances of this class are sent as a result of trees being expanded and collapsed. See Also: TreeListener, Sample code and further information, Serialized Form '
440, 'org.eclipse.swt.events.TreeListener', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/events/TreeListener.html', 'extends org.eclipse.swt.internal.SWTEventListener Classes which implement this interface provide methods that deal with the expanding and collapsing of tree branches. After creating an instance of a class that implements this interface it can be added to a tree control using the addTreeListener method and removed using the removeTreeListener method. When a branch of the tree is expanded or collapsed, the appropriate method will be invoked. See Also: TreeAdapter, TreeEvent '
441, 'org.eclipse.jface.window.IShellProvider', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/window/IShellProvider.html', 'Interface for objects that can return a shell. This is normally used for opening child windows. An object that wants to open child shells can take an IShellProvider in its constructor, and the object that implements IShellProvider can dynamically choose where child shells should be opened. Since: 3.1 '
442, 'org.eclipse.e4.ui.model.application.ui.MSnippetContainer', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/e4/ui/model/application/ui/MSnippetContainer.html', ' A representation of the model object \'Snippet Container\'. This provides a collection of model fragments that can be subsequently cloned and inserterd into the model using the EModelService. For example saving a customized Perspective will create a clone and store it in this container. Since: 1.0 The following features are supported: Snippets '
443, 'org.eclipse.e4.ui.model.application.ui.basic.MPartSashContainerElement', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/e4/ui/model/application/ui/basic/MPartSashContainerElement.html', ' A representation of the model object \'Element\'. This is the root element for all UI Model elements, defining attribtues common to every element; the element\'s id as well as three general storage elements: Tags: This is a set of strings which can be used to stereotype a particular element. Tags may be specified in element searches and can also be referred to in the CSS styling definition. PersistedState: A string to string map used to store information that nneds to be persisted between sessions. TransientData: A string to object map which can be used to store runtime data relevant to a particular model element. Since: 1.0 The following features are supported: Element Id Persisted State Tags Contributor URI Transient Data A representation of the model object \'Element\'. This is the root element for all UI Model elements, defining attribtues common to every element; the element\'s id as well as three general storage elements: Tags: This is a set of strings which can be used to stereotype a particular element. Tags may be specified in element searches and can also be referred to in the CSS styling definition. PersistedState: A string to string map used to store information that nneds to be persisted between sessions. TransientData: A string to object map which can be used to store runtime data relevant to a particular model element. Since: 1.0 The following features are supported: Element Id Persisted State Tags Contributor URI Transient Data extends MApplicationElement A representation of the model object \'UI Element\'. This is the base mix-in shared by all model elements that can be rendered into the UI presentation of the application. Its main job is to manage the bindings between the concrete element and the UI \'widget\' representing it in the UI. Since: 1.0 The following features are supported: Widget Renderer To Be Rendered On Top Visible Parent Container Data Cur Shared Ref Visible When Accessibility Phrase extends MUIElement A representation of the model object \'Part Sash Container Element\'. A class to be mixed in to any element that should be allowed to be added to a PartSashContainer. Since a PartSashContainer is itself a PartSashContainerElement we can defined nested \'trees\' of sash containment. Since: 1.0 '
444, 'org.eclipse.e4.ui.workbench.modeling.EPlaceholderResolver', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/e4/ui/workbench/modeling/EPlaceholderResolver.html', 'This service is used to resolve references from MPlaceholders. The issue is that we may be storing a cloned snippet which contains references to \'shared elements\' but instantiating the snippet in a new window requires that the shared elements list be updated. Since: 1.0 Restriction: This interface is not intended to be referenced by clients. '
445, 'org.eclipse.e4.ui.model.application.ui.advanced.MAdvancedFactory', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/e4/ui/model/application/ui/advanced/MAdvancedFactory.html', ' The Factory for the model. It provides a create method for each non-abstract class of the model. Since: 1.0 '
446, 'org.eclipse.e4.ui.model.application.ui.MGenericTile', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/e4/ui/model/application/ui/MGenericTile.html', ' A representation of the model object \'Element\'. This is the root element for all UI Model elements, defining attribtues common to every element; the element\'s id as well as three general storage elements: Tags: This is a set of strings which can be used to stereotype a particular element. Tags may be specified in element searches and can also be referred to in the CSS styling definition. PersistedState: A string to string map used to store information that nneds to be persisted between sessions. TransientData: A string to object map which can be used to store runtime data relevant to a particular model element. Since: 1.0 The following features are supported: Element Id Persisted State Tags Contributor URI Transient Data A representation of the model object \'Element\'. This is the root element for all UI Model elements, defining attribtues common to every element; the element\'s id as well as three general storage elements: Tags: This is a set of strings which can be used to stereotype a particular element. Tags may be specified in element searches and can also be referred to in the CSS styling definition. PersistedState: A string to string map used to store information that nneds to be persisted between sessions. TransientData: A string to object map which can be used to store runtime data relevant to a particular model element. Since: 1.0 The following features are supported: Element Id Persisted State Tags Contributor URI Transient Data extends MApplicationElement A representation of the model object \'UI Element\'. This is the base mix-in shared by all model elements that can be rendered into the UI presentation of the application. Its main job is to manage the bindings between the concrete element and the UI \'widget\' representing it in the UI. Since: 1.0 The following features are supported: Widget Renderer To Be Rendered On Top Visible Parent Container Data Cur Shared Ref Visible When Accessibility Phrase T extends MUIElement> extends MElementContainer<T> A representation of the model object \'Generic Tile\'. This type defines the base type for \'tile\' type containers. These containers are expected to only show all their visible children at the same time. Since: 1.0 The following features are supported: Horizontal '
447, 'org.eclipse.e4.ui.model.application.ui.basic.MWindowElement', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/e4/ui/model/application/ui/basic/MWindowElement.html', ' A representation of the model object \'Element\'. This is the root element for all UI Model elements, defining attribtues common to every element; the element\'s id as well as three general storage elements: Tags: This is a set of strings which can be used to stereotype a particular element. Tags may be specified in element searches and can also be referred to in the CSS styling definition. PersistedState: A string to string map used to store information that nneds to be persisted between sessions. TransientData: A string to object map which can be used to store runtime data relevant to a particular model element. Since: 1.0 The following features are supported: Element Id Persisted State Tags Contributor URI Transient Data A representation of the model object \'Element\'. This is the root element for all UI Model elements, defining attribtues common to every element; the element\'s id as well as three general storage elements: Tags: This is a set of strings which can be used to stereotype a particular element. Tags may be specified in element searches and can also be referred to in the CSS styling definition. PersistedState: A string to string map used to store information that nneds to be persisted between sessions. TransientData: A string to object map which can be used to store runtime data relevant to a particular model element. Since: 1.0 The following features are supported: Element Id Persisted State Tags Contributor URI Transient Data extends MApplicationElement A representation of the model object \'UI Element\'. This is the base mix-in shared by all model elements that can be rendered into the UI presentation of the application. Its main job is to manage the bindings between the concrete element and the UI \'widget\' representing it in the UI. Since: 1.0 The following features are supported: Widget Renderer To Be Rendered On Top Visible Parent Container Data Cur Shared Ref Visible When Accessibility Phrase extends MUIElement A representation of the model object \'Window Element\'. A class to be mixed in to any element that should be allowed to be added to a Window. Since: 1.0 '
448, 'org.eclipse.ui.splash.AbstractSplashHandler', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/splash/AbstractSplashHandler.html', 'extends Object Base class for splash implementations. Please note that methods on this class will be invoked while the Workbench is being instantiated. As such, any resource provided by the workbench plug-in cannot be guaranteed to be available to this class while executing. No attempt should be made to access IWorkbench or any subordinate interfaces or resources. Since: 3.3 '
449, 'org.eclipse.jface.bindings.IBindingManagerListener', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/bindings/IBindingManagerListener.html', ' An instance of BindingManagerListener can be used by clients to receive notification of changes to an instance of BindingManager. This interface may be implemented by clients. Since: 3.1 See Also: BindingManager.addBindingManagerListener(IBindingManagerListener), BindingManager.addBindingManagerListener(IBindingManagerListener), BindingManagerEvent '
450, 'org.eclipse.core.runtime.IRegistryChangeListener', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/runtime/IRegistryChangeListener.html', 'extends EventListener Note: for new implementations consider using IRegistryEventListener. A registry change listener is notified of changes to extensions points in the registry. These changes arise from subsequent manipulation of the registry after it was initially created. This interface can be used without OSGi running. Clients may implement this interface. Since: 3.0 See Also: IExtensionRegistry, IRegistryChangeEvent '
451, 'org.eclipse.equinox.app.IApplicationContext', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/equinox/app/IApplicationContext.html', 'The context used to start an application. This interface is not intended to be implemented by clients. Since: 1.0 Restriction: This interface is not intended to be implemented by clients. Restriction: This interface is not intended to be extended by clients. '
452, 'org.eclipse.core.runtime.IPlatformRunnable', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/runtime/IPlatformRunnable.html', 'Bootstrap type for the platform. Platform runnables represent executable entry points into plug-ins. Runnables can be configured into the Platform\'s org.eclipse.core.runtime.applications extension-point or be made available through code or extensions on other plug-in\'s extension-points. Clients may implement this interface. Since: 3.0 '
453, 'org.eclipse.equinox.app.IApplication', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/equinox/app/IApplication.html', 'Bootstrap type for an application. An IApplication represent executable entry points into an application. An IApplication can be configured into the Platform\'s org.eclipse.core.runtime.applications extension-point. Clients may implement this interface. Since: 1.0 '
454, 'org.eclipse.swt.graphics.DeviceData', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/graphics/DeviceData.html', 'extends Object '
455, 'org.eclipse.jface.util.SafeRunnable', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/util/SafeRunnable.html', 'Safe runnables represent blocks of code and associated exception handlers. They are typically used when a plug-in needs to call some untrusted code (e.g., code contributed by another plug-in via an extension). This interface can be used without OSGi running. Clients may implement this interface. See Also: SafeRunner.run(ISafeRunnable) extends Object implements ISafeRunnable Implements a default implementation of ISafeRunnable. The default implementation of handleException opens a dialog to show any errors as they accumulate. This may be executed on any thread. '
456, 'org.eclipse.osgi.service.runnable.StartupMonitor', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/osgi/service/runnable/StartupMonitor.html', 'Service interface used to monitor the startup process. Bundles can register a monitor in order to be given processing time on the primary thread during the startup process. Clients with threading restrictions can use this interface to process events that may have been collected from another thread. Monitors share time on the primary thread. The primary thread used to run the application will not proceed until monitors return from any operation. Because of this, monitors should not perform long running operations. Clients may implement this interface but should not invoke it. The platform is responsible for invoking the monitor at the appropriate times. Since: 3.3 '
457, 'org.eclipse.core.runtime.IProduct', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/runtime/IProduct.html', 'Products are the Eclipse unit of branding. From the runtime point of view they have a name, id and description and identify the Eclipse application to run. Since the bulk of the branding related information is specific to the UI, products also carry an arbitrary set of properties. The valid set of key-value pairs and their interpretation defined by the UI of the target environment. For example, in the standard Eclipse UI, org.eclipse.ui.branding.IProductConstants the properties of interest to the UI. Other clients may specify additional properties. Products can be defined directly using extensions to the org.eclipse.core.runtime.products extension point or by using facilities provided by IProductProvider implementations. For readers familiar with Eclipse 2.1 and earlier, products are roughly equivalent to primary features. Since: 3.0 See Also: IProductProvider '
458, 'org.eclipse.ui.IViewReference', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/IViewReference.html', 'Implements a reference to a IWorkbenchPart. The IWorkbenchPart will not be instantiated until the part becomes visible or the API getPart is sent with true; This interface is not intended to be implemented by clients. Restriction: This interface is not intended to be implemented by clients. extends IWorkbenchPartReference Defines a reference to an IViewPart. This interface is not intended to be implemented by clients. Restriction: This interface is not intended to be implemented by clients. '
459, 'org.eclipse.e4.ui.workbench.IModelResourceHandler', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/e4/ui/workbench/IModelResourceHandler.html', 'This handler allows clients load, create and save model resources Since: 1.0 Restriction: This interface is not intended to be implemented by clients. '
460, 'org.eclipse.ui.operations.IWorkbenchOperationSupport', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/operations/IWorkbenchOperationSupport.html', 'An instance of this interface provides support for managing a a shared operations history and an shared undo context at the IWorkbench level. This interface is not intended to be extended or implemented by clients. Since: 3.1 See Also: IWorkbench.getOperationSupport() Restriction: This interface is not intended to be implemented by clients. '
461, 'org.eclipse.jface.preference.PreferenceManager', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/preference/PreferenceManager.html', 'extends Object A preference manager maintains a hierarchy of preference nodes and associated preference pages. '
462, 'org.eclipse.ui.IWorkingSetManager', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/IWorkingSetManager.html', 'A working set manager stores working sets and provides property change notification when a working set is added or removed. The workbench working set manager can be accessed using IWorkbench#getWorkingSetManager() This interface is not intended to be implemented by clients. Since: 2.0 initial version, 3.0 added createWorkingSet(IMemento) See Also: IWorkingSet Restriction: This interface is not intended to be implemented by clients. '
463, 'org.eclipse.ui.ILocalWorkingSetManager', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/ILocalWorkingSetManager.html', 'A working set manager stores working sets and provides property change notification when a working set is added or removed. The workbench working set manager can be accessed using IWorkbench#getWorkingSetManager() This interface is not intended to be implemented by clients. Since: 2.0 initial version, 3.0 added createWorkingSet(IMemento) See Also: IWorkingSet Restriction: This interface is not intended to be implemented by clients. extends IWorkingSetManager A local working set manager can be used to manage a set of working sets independently from the working sets managed by the global working set manager. A local working set manager can be saved and restored using the methods saveState and restoreState. A new local working set manager can be created using IWorkbench.createLocalWorkingSetManager(). Clients of local working set managers are responsible for calling IWorkingSetManager.dispose() when the working sets it manages are no longer needed. This interface is not intended to be implemented or extended by clients. Since: 3.1 See Also: IWorkbench.createLocalWorkingSetManager() Restriction: This interface is not intended to be implemented by clients. '
464, 'org.eclipse.jface.operation.ModalContext', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/operation/ModalContext.html', 'extends Object Utility class for supporting modal operations. The runnable passed to the run method is executed in a separate thread, depending on the value of the passed fork argument. If the runnable is executed in a separate thread then the current thread either waits until the new thread ends or, if the current thread is the UI thread, it polls the SWT event queue and dispatches each event. This class is not intended to be subclassed. Restriction: This class is not intended to be subclassed by clients. Restriction: This class is not intended to be instantiated by clients. '
465, 'org.eclipse.jface.action.ExternalActionManager', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/action/ExternalActionManager.html', 'extends Object A manager for a callback facility which is capable of querying external interfaces for additional information about actions and action contribution items. This information typically includes things like accelerators and textual representations. It is only necessary to use this mechanism if you will be using a mix of actions and commands, and wish the interactions to work properly. For example, in the Eclipse workbench, this mechanism is used to allow the command architecture to override certain values in action contribution items. This class is not intended to be called or extended by any external clients. Since: 3.0 '
466, 'org.eclipse.jface.util.OpenStrategy', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/util/OpenStrategy.html', 'extends Object Implementation of single-click and double-click strategies. Usage: OpenStrategy handler = new OpenStrategy(control); handler.addOpenListener(new IOpenEventListener() { public void handleOpen(SelectionEvent e) { ... // code to handle the open event. } }); '
467, 'org.eclipse.jface.window.Window', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/window/Window.html', 'Interface for objects that can return a shell. This is normally used for opening child windows. An object that wants to open child shells can take an IShellProvider in its constructor, and the object that implements IShellProvider can dynamically choose where child shells should be opened. Since: 3.1 extends Object implements IShellProvider A JFace window is an object that has no visual representation (no widgets) until it is told to open. Creating a window involves the following steps: creating an instance of a concrete subclass of Window creating the window\'s shell and widget tree by calling create (optional) assigning the window to a window manager using WindowManager.add (optional) opening the window by calling open Opening the window will create its shell and widget tree if they have not already been created. When the window is closed, the shell and widget tree are disposed of and are no longer referenced, and the window is automatically removed from its window manager. A window may be reopened. The JFace window framework (this package) consists of this class, Window, the abstract base of all windows, and one concrete window classes (ApplicationWindow) which may also be subclassed. Clients may define additional window subclasses as required. The Window class provides methods that subclasses may override to configure the window, including: close- extend to free other SWT resources configureShell- extend or reimplement to set shell properties before window opens createContents- extend or reimplement to create controls before window opens getInitialSize- reimplement to give the initial size for the shell getInitialLocation- reimplement to give the initial location for the shell getShellListener- extend or reimplement to receive shell events handleFontChange- reimplement to respond to font changes handleShellCloseEvent- extend or reimplement to handle shell closings '
468, 'org.eclipse.ui.activities.IWorkbenchActivitySupport', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/activities/IWorkbenchActivitySupport.html', 'An instance of this interface provides support for managing IWorkbench activities. An instance of this interface may be obtained via IWorkbench.getActivitySupport(). This interface is not intended to be extended or implemented by clients. Since: 3.0 Restriction: This interface is not intended to be implemented by clients. '
469, 'org.eclipse.ui.model.IContributionService', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/model/IContributionService.html', 'Instances of this service are capable of providing standard mechanisms that clients may use to order, display, and generally work with contributions to the Workbench. Since: 3.4 '
470, 'org.eclipse.core.commands.contexts.IContextManagerListener', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/commands/contexts/IContextManagerListener.html', 'An instance of this interface can be used by clients to receive notification of changes to one or more instances of IContextManager. This interface may be implemented by clients. Since: 3.1 See Also: ContextManager.addContextManagerListener(IContextManagerListener), ContextManager.removeContextManagerListener(IContextManagerListener) '
471, 'org.eclipse.core.commands.contexts.ContextManagerEvent', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/commands/contexts/ContextManagerEvent.html', 'extends AbstractBitSetEvent An event indicating that the set of defined context identifiers has changed. Since: 3.1 See Also: IContextManagerListener.contextManagerChanged(ContextManagerEvent) '
472, 'org.eclipse.ui.commands.ICommandImageService', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/commands/ICommandImageService.html', ' The interface that should be implemented by services that make themselves available through the IAdaptable mechanism. This is the interface that drives the majority of services provided at the workbench level. A service has life-cycle. When the constructor completes, the service must be fully functional. When it comes time for the service to go away, then the service will receive a dispose() call. At this point, the service must release all resources and detach all listeners. A service can only be disposed once; it cannot be reused. This interface has nothing to do with OSGi services. This interface can be extended or implemented by clients. Since: 3.2 extends IDisposable Provides a look-up facility for images associated with commands. The type of an image indicates the state of the associated command within the user interface. The supported types are: TYPE_DEFAULT (to be used for an enabled command), TYPE_DISABLED (to be used for a disabled command) and TYPE_HOVER (to be used for an enabled command over which the mouse is hovering). The style of an image is an arbitrary string used to distinguish between sets of images associated with a command. For example, a command may appear in the menus as the default style. However, in the toolbar, the command is simply the default action for a toolbar drop down item. As such, perhaps a different image style is appropriate. The classic case is the \"Run Last Launched\" command, which appears in the menu and the toolbar, but with different icons in each location. We currently support a default image style (none) and an image style of IMAGE_STYLE_TOOLBAR. Since: 3.4 Restriction: This interface is not intended to be implemented by clients. Restriction: This interface is not intended to be extended by clients. '
473, 'org.eclipse.ui.services.ISourceProviderService', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/services/ISourceProviderService.html', ' A service from which all of the source providers can be retrieved. This service can be acquired from your service locator: ISourceProviderService service = (ISourceProviderService) getSite().getService(ISourceProviderService.class); This service is available globally. Since: 3.4 See Also: IEvaluationService Restriction: This interface is not intended to be implemented by clients. Restriction: This interface is not intended to be extended by clients. '
474, 'org.eclipse.ui.swt.IFocusService', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/swt/IFocusService.html', 'Tracks focusGained and focusLost events for a Control registered with this service, and provides the control and its registered ID as variables to the application evaluation context for evaluation by the various services. This service provides 2 variables, activeFocusControl (a Control) and activeFocusControlId (the ID registered with the service). You can use this service to provide default cut/copy/paste/selectAll for specific text controls outside of the normal workbench part lifecycle, like a control contributed to the trim. For example: <handler class=\"org.eclipse.ui.internal.handlers.WidgetMethodHandler:paste\" commandId=\"org.eclipse.ui.edit.paste\"> <activeWhen> <with variable=\"activeFocusControlId\"> <equals value=\"org.eclipse.ui.tests.focusText\"/> </with> </activeWhen> </handler> This service can be acquired from your service locator: IFocusService service = (IFocusService) getSite().getService(IFocusService.class); This service is available globally. Since: 3.3 See Also: ISources Restriction: This interface is not intended to be implemented by clients. '
475, 'org.eclipse.ui.IDecoratorManager', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/IDecoratorManager.html', 'A label provider maps an element of the viewer\'s model to an optional image and optional text string used to display the element in the viewer\'s control. Certain label providers may allow multiple labels per element. This is an \"abstract interface\", defining methods common to all label providers, but does not actually define the methods to get the label(s) for an element. This interface should never be directly implemented. Most viewers will take either an ILabelProvider or an ITableLabelProvider. A label provider must not be shared between viewers since a label provider generally manages SWT resources (images), which must be disposed when the viewer is disposed. To simplify life cycle management, the current label provider of a viewer is disposed when the viewer is disposed. Label providers can be used outside the context of viewers wherever images are needed. When label providers are used in this fashion it is the responsibility of the user to ensure dispose is called when the provider is no longer needed. See Also: ILabelProvider, ITableLabelProvider extends ILabelDecorator A delayed label decorator is a label decorator that may not have a decoration available immediately. This interface defines the methods for requesting the preparation of a decorator for an object and for querying if the decorator is ready. Interested parties should register an ILabelProviderListener with a delayed label decorator in order to be informed when the decoration is ready. Since: 3.0 A label provider maps an element of the viewer\'s model to an optional image and optional text string used to display the element in the viewer\'s control. Certain label providers may allow multiple labels per element. This is an \"abstract interface\", defining methods common to all label providers, but does not actually define the methods to get the label(s) for an element. This interface should never be directly implemented. Most viewers will take either an ILabelProvider or an ITableLabelProvider. A label provider must not be shared between viewers since a label provider generally manages SWT resources (images), which must be disposed when the viewer is disposed. To simplify life cycle management, the current label provider of a viewer is disposed when the viewer is disposed. Label providers can be used outside the context of viewers wherever images are needed. When label providers are used in this fashion it is the responsibility of the user to ensure dispose is called when the provider is no longer needed. See Also: ILabelProvider, ITableLabelProvider extends IBaseLabelProvider A label decorator decorates the label text and image for some element. The original label text and image are obtained by some other means, for example by a label provider. See Also: ILabelProvider extends IDelayedLabelDecorator Manages the decorators contributed via the decorators extension point. Views which allow decoration of their elements should use the label decorator returned by getLabelDecorator(). This class is not intended to be implemented by clients. Restriction: This interface is not intended to be implemented by clients. '
476, 'org.eclipse.ui.commands.IWorkbenchCommandSupport', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/commands/IWorkbenchCommandSupport.html', 'An instance of this interface provides support for managing commands at the IWorkbench level. This interface is not intended to be extended or implemented by clients. Since: 3.0 See Also: ICommandService, IHandlerService Restriction: This interface is not intended to be implemented by clients. '
477, 'org.eclipse.ui.contexts.IWorkbenchContextSupport', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/contexts/IWorkbenchContextSupport.html', ' An instance of this interface provides support for managing contexts at the IWorkbench level. This provides the functionality necessary to enabled contexts, disable or enabled the key binding service, as well as register shells as particular types of windows. This interface is not intended to be extended or implemented by clients. Since: 3.0 See Also: IContextService, IBindingService Restriction: This interface is not intended to be implemented by clients. '
478, 'org.eclipse.ui.intro.IIntroManager', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/intro/IIntroManager.html', 'Manages the intro part that introduces the product to new users. The intro part is typically shown the first time a product is started up. The initial behavior of the intro part is controlled by the application from via the WorkbenchWindowAdvisor.openIntro() method. See IIntroPart for details on where intro parts come from. This interface is not intended to be extended or implemented by clients. Since: 3.0 See Also: IWorkbench.getIntroManager() Restriction: This interface is not intended to be implemented by clients. '
479, 'org.eclipse.ui.help.IWorkbenchHelpSystem', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/help/IWorkbenchHelpSystem.html', ' The interface that is used to access the workbench help system. Replaces static methods on WorkbenchHelp. This interface is not intended to be implemented by clients. Since: 3.1 Restriction: This interface is not intended to be implemented by clients. '
480, 'org.eclipse.ui.browser.IWorkbenchBrowserSupport', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/browser/IWorkbenchBrowserSupport.html', 'Web browser support. This class allows you to open URLs using internal or external Web browsers. Implementers may provide varying levels of support. The most rudimentary support that must be provided is to open URLs in an external web browser window. Everything else is a hint that browser support implementation may choose to honor but is not required (although a good implementation should aspire to support all the styles if possible on the given platform). The support has a two-phase approach to opening URLs. A browser instance is created first, then openURL is called on it. This provides for browser instance reuse for as long as needed. The step of creating the browser instance encourages reuse itself by not creating new instances of browsers if one with the same id is already open. It also makes it possible to reuse browser instances restored after workbench is restarted. The simplest way to open a URL is: IWorkbenchSupport.createBrowser(\"myId\").openURL(url); The call above will show the provided URL by reusing the browser instance with the matching id, or creating a new one if one does not exist already. When more advanced control over the behavior of a browser instance is required, it is recommended to create the instance first, then reuse it as needed. This interface is not intended to be implemented by clients. Since: 3.1 See Also: IWebBrowser Restriction: This interface is not intended to be implemented by clients. Restriction: This interface is not intended to be extended by clients. '
481, 'org.eclipse.ui.wizards.IWizardRegistry', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/wizards/IWizardRegistry.html', 'A registry describing all wizard extensions known to the workbench. This interface is not intended to be implemented by clients. Since: 3.1 Restriction: This interface is not intended to be implemented by clients. '
482, 'org.eclipse.jface.operation.IRunnableContext', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/operation/IRunnableContext.html', 'Interface for UI components which can execute a long-running operation in the form of an IRunnableWithProgress. The context is responsible for displaying a progress indicator and Cancel button to the end user while the operation is in progress; the context supplies a progress monitor to be used from code running inside the operation. Note that an IRunnableContext is not a runnable itself. For examples of UI components which implement this interface, see ApplicationWindow, ProgressMonitorDialog, and WizardDialog. See Also: IRunnableWithProgress, ApplicationWindow, ProgressMonitorDialog, WizardDialog '
483, 'org.eclipse.ui.ISaveableFilter', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/ISaveableFilter.html', 'A filter for selecting Saveables. Since: 3.3 See Also: IWorkbench.saveAll(org.eclipse.jface.window.IShellProvider, org.eclipse.jface.operation.IRunnableContext, ISaveableFilter, boolean) '
484, 'org.eclipse.ui.Saveable', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/Saveable.html', 'An interface for an adaptable object. Adaptable objects can be dynamically extended to provide different interfaces (or \"adapters\"). Adapters are created by adapter factories, which are in turn managed by type by adapter managers. For example, IAdaptable a = [some adaptable]; IFoo x = (IFoo)a.getAdapter(IFoo.class); if (x != null) [do IFoo things with x] This interface can be used without OSGi running. Clients may implement this interface, or obtain a default implementation of this interface by subclassing PlatformObject. See Also: IAdapterFactory, IAdapterManager, PlatformObject extends org.eclipse.ui.internal.InternalSaveable implements IAdaptable A Saveable represents a unit of saveability, e.g. an editable subset of the underlying domain model that may contain unsaved changes. Different workbench parts (editors and views) may present the same saveables in different ways. This interface allows the workbench to provide more appropriate handling of operations such as saving and closing workbench parts. For example, if two editors sharing the same saveable with unsaved changes are closed simultaneously, the user is only prompted to save the changes once for the shared saveable, rather than once for each editor. Workbench parts that work in terms of saveables should implement ISaveablesSource. Since: 3.2 See Also: ISaveablesSource '
485, 'org.eclipse.core.runtime.MultiStatus', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/runtime/MultiStatus.html', 'A status object represents the outcome of an operation. All CoreExceptions carry a status object to indicate what went wrong. Status objects are also returned by methods needing to provide details of failures (e.g., validation methods). A status carries the following information: plug-in identifier (required) severity (required) status code (required) message (required) - localized to current locale exception (optional) - for problems stemming from a failure at a lower level Some status objects, known as multi-statuses, have other status objects as children. The class Status is the standard public implementation of status objects; the subclass MultiStatus is the implements multi-status objects. This interface can be used without OSGi running. See Also: MultiStatus, Status extends Status A concrete multi-status implementation, suitable either for instantiating or subclassing. This class can be used without OSGi running. '
486, 'org.eclipse.jface.dialogs.MessageDialog', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/dialogs/MessageDialog.html', 'Interface for objects that can return a shell. This is normally used for opening child windows. An object that wants to open child shells can take an IShellProvider in its constructor, and the object that implements IShellProvider can dynamically choose where child shells should be opened. Since: 3.1 extends IconAndMessageDialog A dialog for showing messages to the user. This concrete dialog class can be instantiated as is, or further subclassed as required. Note: This class does not use button IDs from IDialogConstants. Instead, the ID is the index of the button in the supplied array. '
487, 'org.eclipse.swt.widgets.MessageBox', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/widgets/MessageBox.html', 'extends Dialog Instances of this class are used to inform or warn the user. Styles: ICON_ERROR, ICON_INFORMATION, ICON_QUESTION, ICON_WARNING, ICON_WORKING OK, OK | CANCEL YES | NO, YES | NO | CANCEL RETRY | CANCEL ABORT | RETRY | IGNORE Events: (none) Note: Only one of the styles ICON_ERROR, ICON_INFORMATION, ICON_QUESTION, ICON_WARNING and ICON_WORKING may be specified. IMPORTANT: This class is not intended to be subclassed. See Also: SWT Example: ControlExample, Dialog tab, Sample code and further information Restriction: This class is not intended to be subclassed by clients. '
488, 'org.eclipse.swt.custom.CTabFolder2Adapter', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/custom/CTabFolder2Adapter.html', 'extends org.eclipse.swt.internal.SWTEventListener Classes which implement this interface provide methods that deal with the events that are generated by the CTabFolder control. After creating an instance of a class that implements this interface it can be added to a CTabFolder using the addCTabFolder2Listener method and removed using the removeCTabFolder2Listener method. When events occurs in a CTabFolder the appropriate method will be invoked. Since: 3.0 See Also: CTabFolder2Adapter, CTabFolderEvent extends Object implements CTabFolder2Listener This adapter class provides default implementations for the methods described by the CTabFolder2Listener interface. Classes that wish to deal with CTabFolderEvents can extend this class and override only the methods which they are interested in. Since: 3.0 See Also: CTabFolder2Listener, CTabFolderEvent, Sample code and further information '
489, 'org.eclipse.jface.action.IContributionManager', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/action/IContributionManager.html', 'A contribution manager organizes contributions to such UI components as menus, toolbars and status lines. A contribution manager keeps track of a list of contribution items. Each contribution item may has an optional identifier, which can be used to retrieve items from a manager, and for positioning items relative to each other. The list of contribution items can be subdivided into named groups using special contribution items that serve as group markers. The IContributionManager interface provides general protocol for adding, removing, and retrieving contribution items. It also provides convenience methods that make it convenient to contribute actions. This interface should be implemented by all objects that wish to manage contributions. There are several implementions of this interface in this package, including ones for menus (MenuManager), tool bars (ToolBarManager), and status lines (StatusLineManager). '
490, 'org.eclipse.jface.viewers.ISelectionProvider', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/viewers/ISelectionProvider.html', 'Interface common to all objects that provide a selection. See Also: ISelection, ISelectionChangedListener, SelectionChangedEvent '
491, 'org.eclipse.e4.ui.model.application.ui.MUILabel', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/e4/ui/model/application/ui/MUILabel.html', ' A representation of the model object \'UI Label\'. This is a mix in that will be used for UI Elements that are capable of showing label information in the GUI (e.g. Parts, Menus / Toolbars, Persepectives...) Since: 1.0 The following features are supported: Label Icon URI Tooltip '
492, 'org.eclipse.swt.custom.CTabFolderEvent', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/custom/CTabFolderEvent.html', 'extends TypedEvent This event is sent when an event is generated in the CTabFolder. See Also: Sample code and further information, Serialized Form '
493, 'org.eclipse.swt.accessibility.Accessible', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/accessibility/Accessible.html', 'extends Object Instances of this class provide a bridge between application code and assistive technology clients. Many platforms provide default accessible behavior for most widgets, and this class allows that default behavior to be overridden. Applications can get the default Accessible object for a control by sending it getAccessible, and then add an accessible listener to override simple items like the name and help string, or they can add an accessible control listener to override complex items. As a rule of thumb, an application would only want to use the accessible control listener to implement accessibility for a custom control. Since: 2.0 See Also: Control.getAccessible(), AccessibleListener, AccessibleEvent, AccessibleControlListener, AccessibleControlEvent, Accessibility snippets, Sample code and further information '
494, 'org.eclipse.ui.progress.UIJob', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/progress/UIJob.html', 'An interface for an adaptable object. Adaptable objects can be dynamically extended to provide different interfaces (or \"adapters\"). Adapters are created by adapter factories, which are in turn managed by type by adapter managers. For example, IAdaptable a = [some adaptable]; IFoo x = (IFoo)a.getAdapter(IFoo.class); if (x != null) [do IFoo things with x] This interface can be used without OSGi running. Clients may implement this interface, or obtain a default implementation of this interface by subclassing PlatformObject. See Also: IAdapterFactory, IAdapterManager, PlatformObject extends Job The UIJob is a Job that runs within the UI Thread via an asyncExec. Since: 3.0 '
495, 'org.eclipse.jface.bindings.keys.formatting.KeyFormatterFactory', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/bindings/keys/formatting/KeyFormatterFactory.html', 'extends Object A cache for formatters. It keeps a few instances of pre-defined instances of IKeyFormatter available for use. It also allows the default formatter to be changed. Since: 3.1 See Also: IKeyFormatter '
496, 'org.eclipse.e4.ui.model.application.MContribution', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/e4/ui/model/application/MContribution.html', ' A representation of the model object \'Element\'. This is the root element for all UI Model elements, defining attribtues common to every element; the element\'s id as well as three general storage elements: Tags: This is a set of strings which can be used to stereotype a particular element. Tags may be specified in element searches and can also be referred to in the CSS styling definition. PersistedState: A string to string map used to store information that nneds to be persisted between sessions. TransientData: A string to object map which can be used to store runtime data relevant to a particular model element. Since: 1.0 The following features are supported: Element Id Persisted State Tags Contributor URI Transient Data extends MApplicationElement A representation of the model object \'Contribution\'. MContribution is a mix-in class used by concrete elements such as Parts to define the location of the client supplied class implementing the specific logic needed. Since: 1.0 The following features are supported: Contribution URI Object '
497, 'org.eclipse.ui.testing.TestableObject', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/testing/TestableObject.html', 'extends Object A testable object. Allows a test harness to register itself with a testable object. The test harness is notified of test-related lifecycle events, such as when is an appropriate time to run tests on the object. This also provides API for running tests as a runnable, and for signaling when the tests are starting and when they are finished. The workbench provides an implementation of this facade, available via PlatformUI.getTestableObject(). Since: 3.0 '
498, 'org.eclipse.jface.action.ContributionManager', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/action/ContributionManager.html', 'A contribution manager organizes contributions to such UI components as menus, toolbars and status lines. A contribution manager keeps track of a list of contribution items. Each contribution item may has an optional identifier, which can be used to retrieve items from a manager, and for positioning items relative to each other. The list of contribution items can be subdivided into named groups using special contribution items that serve as group markers. The IContributionManager interface provides general protocol for adding, removing, and retrieving contribution items. It also provides convenience methods that make it convenient to contribute actions. This interface should be implemented by all objects that wish to manage contributions. There are several implementions of this interface in this package, including ones for menus (MenuManager), tool bars (ToolBarManager), and status lines (StatusLineManager). extends Object implements IContributionManager Abstract base class for all contribution managers, and standard implementation of IContributionManager. This class provides functionality common across the specific managers defined by this framework. This class maintains a list of contribution items and a dirty flag, both as internal state. In addition to providing implementations of most IContributionManager methods, this class automatically coalesces adjacent separators, hides beginning and ending separators, and deals with dynamically changing sets of contributions. When the set of contributions does change dynamically, the changes are propagated to the control via the update method, which subclasses must implement. Note: A ContributionItem cannot be shared between different ContributionManagers. '
499, 'org.eclipse.swt.accessibility.AccessibleListener', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/accessibility/AccessibleListener.html', 'extends org.eclipse.swt.internal.SWTEventListener Classes that implement this interface provide methods that deal with the events that are generated when an accessibility client sends a message to a control. After creating an instance of a class that implements this interface it can be added to a control using the addAccessibleListener method and removed using the removeAccessibleListener method. When a client requests information, the appropriate method will be invoked. Note: Accessibility clients use child identifiers to specify whether they want information about a control or one of its children. Child identifiers are increasing integers beginning with 0. The identifier CHILDID_SELF represents the control itself. Since: 2.0 See Also: AccessibleAdapter, AccessibleEvent '
500, 'org.eclipse.swt.widgets.CoolItem', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/widgets/CoolItem.html', 'extends Item Instances of this class are selectable user interface objects that represent the dynamically positionable areas of a CoolBar. Styles: DROP_DOWN Events: Selection IMPORTANT: This class is not intended to be subclassed. See Also: Sample code and further information Restriction: This class is not intended to be subclassed by clients. '
501, 'org.eclipse.swt.events.HelpListener', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/events/HelpListener.html', 'extends org.eclipse.swt.internal.SWTEventListener Classes which implement this interface provide a method that deals with the event that is generated when help is requested for a control, typically when the user presses F1. After creating an instance of a class that implements this interface it can be added to a control using the addHelpListener method and removed using the removeHelpListener method. When help is requested for a control, the helpRequested method will be invoked. See Also: HelpEvent '
502, 'org.eclipse.jface.action.LegacyActionTools', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/action/LegacyActionTools.html', 'extends Object Some static utility methods for handling labels on actions. This includes mnemonics and accelerators. Clients may neither instantiate this class nor extend. Since: 3.2 '
503, 'org.eclipse.swt.layout.RowData', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/layout/RowData.html', 'extends Object Each control controlled by a RowLayout can have its initial width and height specified by setting a RowData object into the control. The following code uses a RowData object to change the initial size of a Button in a Shell: Display display = new Display(); Shell shell = new Shell(display); shell.setLayout(new RowLayout()); Button button1 = new Button(shell, SWT.PUSH); button1.setText(\"Button 1\"); button1.setLayoutData(new RowData(50, 40)); See Also: RowLayout, Sample code and further information '
504, 'org.eclipse.swt.widgets.Monitor', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/widgets/Monitor.html', 'extends Object Instances of this class are descriptions of monitors. Since: 3.0 See Also: Display, Monitor snippets, Sample code and further information '
505, 'org.eclipse.ui.ISelectionListener', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/ISelectionListener.html', 'extends EventListener Interface for listening to selection changes. This interface may be implemented by clients. See Also: ISelectionService.addSelectionListener(ISelectionListener), ISelectionService.addSelectionListener(String, ISelectionListener), INullSelectionListener '
506, 'org.eclipse.ui.IPartListener2', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/IPartListener2.html', 'Interface for listening to part lifecycle events. This is a replacement for IPartListener. As of 3.5, if the implementation of this listener also implements IPageChangedListener then it will also be notified about PageChangedEvents from parts that implement IPageChangeProvider. This interface may be implemented by clients. See Also: IPartService.addPartListener(IPartListener2) '
507, 'org.eclipse.swt.dnd.Clipboard', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/dnd/Clipboard.html', 'extends Object The Clipboard provides a mechanism for transferring data from one application to another or within an application. IMPORTANT: This class is not intended to be subclassed. See Also: Clipboard snippets, SWT Example: ClipboardExample, Sample code and further information Restriction: This class is not intended to be subclassed by clients. '
508, 'org.eclipse.ui.operations.UndoActionHandler', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/operations/UndoActionHandler.html', 'An interface for an adaptable object. Adaptable objects can be dynamically extended to provide different interfaces (or \"adapters\"). Adapters are created by adapter factories, which are in turn managed by type by adapter managers. For example, IAdaptable a = [some adaptable]; IFoo x = (IFoo)a.getAdapter(IFoo.class); if (x != null) [do IFoo things with x] This interface can be used without OSGi running. Clients may implement this interface, or obtain a default implementation of this interface by subclassing PlatformObject. See Also: IAdapterFactory, IAdapterManager, PlatformObject An action represents the non-UI side of a command which can be triggered by the end user. Actions are typically associated with buttons, menu items, and items in tool bars. The controls for a command are built by some container, which furnished the context where these controls appear and configures them with data from properties declared by the action. When the end user triggers the command via its control, the action\'s run method is invoked to do the real work. Actions support a predefined set of properties (and possibly others as well). Clients of an action may register property change listeners so that they get notified whenever the value of a property changes. Clients should subclass the abstract base class Action to define concrete actions rather than implementing IAction from scratch. This interface exists only to define the API for actions. It is not intended to be implemented by clients. See Also: Action Restriction: This interface is not intended to be implemented by clients. extends IAction Interface for a workbench action. extends OperationHistoryActionHandler UndoActionHandler provides common behavior for performing an undo, as well as labelling and enabling the undo menu item. This class may be instantiated by clients. Since: 3.1 '
509, 'org.eclipse.ui.operations.RedoActionHandler', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/operations/RedoActionHandler.html', 'An interface for an adaptable object. Adaptable objects can be dynamically extended to provide different interfaces (or \"adapters\"). Adapters are created by adapter factories, which are in turn managed by type by adapter managers. For example, IAdaptable a = [some adaptable]; IFoo x = (IFoo)a.getAdapter(IFoo.class); if (x != null) [do IFoo things with x] This interface can be used without OSGi running. Clients may implement this interface, or obtain a default implementation of this interface by subclassing PlatformObject. See Also: IAdapterFactory, IAdapterManager, PlatformObject An action represents the non-UI side of a command which can be triggered by the end user. Actions are typically associated with buttons, menu items, and items in tool bars. The controls for a command are built by some container, which furnished the context where these controls appear and configures them with data from properties declared by the action. When the end user triggers the command via its control, the action\'s run method is invoked to do the real work. Actions support a predefined set of properties (and possibly others as well). Clients of an action may register property change listeners so that they get notified whenever the value of a property changes. Clients should subclass the abstract base class Action to define concrete actions rather than implementing IAction from scratch. This interface exists only to define the API for actions. It is not intended to be implemented by clients. See Also: Action Restriction: This interface is not intended to be implemented by clients. extends IAction Interface for a workbench action. extends OperationHistoryActionHandler RedoActionHandler provides common behavior for redoing an operation, as well as labelling and enabling the menu item. This class may be instantiated by clients. Since: 3.1 '
510, 'org.eclipse.jface.viewers.TableLayout', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/viewers/TableLayout.html', 'extends Layout A layout for a table. Call addColumnData to add columns. The TableLayout ColumnLayoutData is only valid until the table is resized. To keep the proportions constant when the table is resized see TableColumnLayout '
511, 'org.eclipse.jface.viewers.TreeViewerColumn', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/viewers/TreeViewerColumn.html', 'extends ViewerColumn ViewerColumn implementation for TreeViewer to enable column-specific label providers and editing support. Since: 3.3 '
512, 'org.eclipse.jface.viewers.ColumnPixelData', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/viewers/ColumnPixelData.html', 'extends ColumnLayoutData Describes the width of a table column in pixels, and whether the column is resizable. This class may be instantiated; it is not intended to be subclassed. Restriction: This class is not intended to be subclassed by clients. '
513, 'org.eclipse.ui.views.markers.MarkerField', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/views/markers/MarkerField.html', 'extends Object MarkerField is the abstract superclass of the definition of the content providers for columns in a Markers View. Since: 3.4 '
514, 'org.eclipse.jface.viewers.EditingSupport', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/viewers/EditingSupport.html', 'extends Object EditingSupport is the abstract superclass of the support for cell editing. Since: 3.3 '
515, 'org.eclipse.core.commands.operations.IUndoContext', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/commands/operations/IUndoContext.html', ' An undo context is used to \"tag\" operations as being applicable to a certain context. The undo context is used to filter the history of operations available for undo or redo so that only operations appropriate for a given undo context are shown when the application is presenting that context. The scope of an undo context is defined by the application that is making undo and redo of operations available. Undo contexts may be related to application models, or may be associated with UI objects that are providing undo and redo support. An undo context may be defined as \"matching\" another context. This allows applications to provide specialized implementations of an undo context that will appear in the operation history for their matching context. Since: 3.1 '
516, 'org.eclipse.jface.viewers.IContentProvider', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/viewers/IContentProvider.html', 'A content provider mediates between the viewer\'s model and the viewer itself. See Also: ContentViewer.setContentProvider(IContentProvider) '
517, 'org.eclipse.jface.viewers.ITreeSelection', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/viewers/ITreeSelection.html', 'Interface for a selection. See Also: ISelectionProvider, ISelectionChangedListener, SelectionChangedEvent Interface for a selection. See Also: ISelectionProvider, ISelectionChangedListener, SelectionChangedEvent extends ISelection A selection containing elements. extends IStructuredSelection A selection containing tree paths. It is recommended that clients do not implement this interface but instead use the standard implementation of this interface, TreeSelection. TreeSelection adds API for getting the IElementComparer of a selection (if available). This is important for clients who want to create a slightly modified tree selection based on an existing tree selection. The recommended coding pattern in this case is as follows: ITreeSelection selection = (ITreeSelection)treeViewer.getSelection(); TreePath[] paths = selection.getPaths(); IElementComparer comparer = null; if (selection instanceof TreeSelection) { comparer = ((TreeSelection)selection).getElementComparer(); } TreePath[] modifiedPaths = ... // modify as required TreeSelection modifiedSelection = new TreeSelection(modifiedPaths, comparer); See bugs 135818 and 133375 for details. Since: 3.2 '
518, 'org.eclipse.swt.events.HelpEvent', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/events/HelpEvent.html', 'extends TypedEvent Instances of this class are sent as a result of help being requested for a widget. See Also: HelpListener, Sample code and further information, Serialized Form '
519, 'org.eclipse.help.IContextProvider', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/help/IContextProvider.html', 'Dynamic context provider. Classes that implement this interface should be returned from adaptable objects when IContextProvider.class is used as the adapter key. Adaptable objects must implement org.eclipse.core.runtime.IAdaptable interface. Dynamic context providers should be used for providing focused dynamic help that changes depending on the various platform states. State change criteria is defined by bitwise-OR of the individual state change triggers. Each time a registered trigger occurs, the class that implements this interface will be called again to provide the help context for the given target. Context provider should be used for all visual artifacts that provide context help that handle context help trigger by handling the SWT help event instead of tagging the artifact with a static context Id. In addition to providing static help context, this interface can also be used to control the query string that is passed to the help search system on context switches. If not provided, the query string is computed based on the current context. Providing the string explicitly gives the context owners better control over the search outcome. Since: 3.1 See Also: IContext, IAdaptable '
520, 'org.eclipse.help.IContext', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/help/IContext.html', 'A context registered for context-sensitive help. This interface models the context-sensitive help that can be associated with SWT menus, menu items, and controls, and with JFace actions. A help context provides the text description of the object with which it is associated with, as well as topic links that contain more related information. This information would be displayed to the user when context sensitive help (F1) is requested. In the current implementation of the Help system, valid contexts can be contributed through the contexts element of the \"org.eclipse.help.contexts\" extension point. The IHelp.findContext(String) method is used at runtime to create or fetch IContext objects using there fully qualified contextIds. If there is a need to override this behavior, then this IContext interface could be implemented by a client and registered with the SWT control or JFace action. '
521, 'org.eclipse.swt.events.TreeAdapter', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/events/TreeAdapter.html', 'extends org.eclipse.swt.internal.SWTEventListener Classes which implement this interface provide methods that deal with the expanding and collapsing of tree branches. After creating an instance of a class that implements this interface it can be added to a tree control using the addTreeListener method and removed using the removeTreeListener method. When a branch of the tree is expanded or collapsed, the appropriate method will be invoked. See Also: TreeAdapter, TreeEvent extends Object implements TreeListener This adapter class provides default implementations for the methods described by the TreeListener interface. Classes that wish to deal with TreeEvents can extend this class and override only the methods which they are interested in. See Also: TreeListener, TreeEvent, Sample code and further information '
522, 'org.eclipse.ui.OpenAndLinkWithEditorHelper', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/OpenAndLinkWithEditorHelper.html', 'extends Object Helper for opening editors on the viewer\'s selection and link the selection with the editor. Since: 3.5 '
523, 'org.eclipse.core.resources.IMarker', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/resources/IMarker.html', 'An interface for an adaptable object. Adaptable objects can be dynamically extended to provide different interfaces (or \"adapters\"). Adapters are created by adapter factories, which are in turn managed by type by adapter managers. For example, IAdaptable a = [some adaptable]; IFoo x = (IFoo)a.getAdapter(IFoo.class); if (x != null) [do IFoo things with x] This interface can be used without OSGi running. Clients may implement this interface, or obtain a default implementation of this interface by subclassing PlatformObject. See Also: IAdapterFactory, IAdapterManager, PlatformObject extends IAdaptable Markers are a general mechanism for associating notes and meta-data with resources. Markers themselves are handles in the same way as IResources are handles. Instances of IMarker do not hold the attributes themselves but rather uniquely refer to the attribute container. As such, their state may change underneath the handle with no warning to the holder of the handle. The Resources plug-in provides a general framework for defining and manipulating markers and provides several standard marker types. Each marker has: a type string, specifying its type (e.g. \"org.eclipse.core.resources.taskmarker\"), an identifier which is unique (relative to a particular resource) Specific types of markers may carry additional information. The resources plug-in defines five standard types: org.eclipse.core.resources.marker org.eclipse.core.resources.taskmarker org.eclipse.core.resources.problemmarker org.eclipse.core.resources.bookmark org.eclipse.core.resources.textmarker The plug-in also provides an extension point ( org.eclipse.core.resources.markers) into which other plug-ins can install marker type declaration extensions. Marker types are declared within a multiple inheritance type system. New markers are defined in the plugin.xml file of the declaring plug-in. A valid declaration contains elements as defined by the extension point DTD: type - the unique name of the marker type super - the list of marker types of which this marker is to be considered a sub-type attributes - the list of standard attributes which may be present on this type of marker persistent - whether markers of this type should be persisted by the platform All markers declared as persistent are saved when the workspace is saved, except those explicitly set as transient (the TRANSIENT attribute is set as true). A plug-in which defines a persistent marker is not directly involved in saving and restoring the marker. Markers are not under version and configuration management, and cannot be shared via VCM repositories. Markers implement the IAdaptable interface; extensions are managed by the platform\'s adapter manager. Restriction: This interface is not intended to be implemented by clients. Restriction: This interface is not intended to be extended by clients. '
524, 'org.eclipse.ui.IViewSite', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/IViewSite.html', 'An interface for an adaptable object. Adaptable objects can be dynamically extended to provide different interfaces (or \"adapters\"). Adapters are created by adapter factories, which are in turn managed by type by adapter managers. For example, IAdaptable a = [some adaptable]; IFoo x = (IFoo)a.getAdapter(IFoo.class); if (x != null) [do IFoo things with x] This interface can be used without OSGi running. Clients may implement this interface, or obtain a default implementation of this interface by subclassing PlatformObject. See Also: IAdapterFactory, IAdapterManager, PlatformObject A component with which one or more services are registered. The services can be retrieved from this locator using some key -- typically the class representing the interface the service must implement. For example: IHandlerService service = (IHandlerService) workbenchWindow .getService(IHandlerService.class); This interface is not to be implemented or extended by clients. Since: 3.2 Interface for objects that can return a shell. This is normally used for opening child windows. An object that wants to open child shells can take an IShellProvider in its constructor, and the object that implements IShellProvider can dynamically choose where child shells should be opened. Since: 3.1 extends IWorkbenchSite The primary interface between a workbench part and the workbench. This interface is not intended to be implemented or extended by clients. Restriction: This interface is not intended to be implemented by clients. extends IAdaptable, IShellProvider, IServiceLocator The common interface between the workbench and its parts, including pages within parts. The workbench site supports a few services by default. If these services are used to allocate resources, it is important to remember to clean up those resources after you are done with them. Otherwise, the resources will exist until the workbench site is disposed. The supported services are: ICommandService IContextService IHandlerService IBindingService. Resources allocated through this service will not be cleaned up until the workbench shuts down. This interface is not intended to be implemented or extended by clients. Since: 2.0 See Also: IWorkbenchPartSite, IPageSite Restriction: This interface is not intended to be implemented by clients. extends IWorkbenchPartSite The primary interface between a view part and the workbench. The workbench exposes its implemention of view part sites via this interface, which is not intended to be implemented or extended by clients. Restriction: This interface is not intended to be implemented by clients. '
525, 'org.eclipse.ui.progress.IWorkbenchSiteProgressService', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/progress/IWorkbenchSiteProgressService.html', 'Interface for UI components which can execute a long-running operation in the form of an IRunnableWithProgress. The context is responsible for displaying a progress indicator and Cancel button to the end user while the operation is in progress; the context supplies a progress monitor to be used from code running inside the operation. Note that an IRunnableContext is not a runnable itself. For examples of UI components which implement this interface, see ApplicationWindow, ProgressMonitorDialog, and WizardDialog. See Also: IRunnableWithProgress, ApplicationWindow, ProgressMonitorDialog, WizardDialog extends IRunnableContext The progress service is the primary interface to the workbench progress support. It can be obtained from the workbench and then used to show progress for both background operations and operations that run in the UI thread. All methods on the progress service must be called from the UI thread. This service can be acquired from your service locator: IProgressService service = (IProgressService) getSite().getService(IProgressService.class); This service is available globally. NOTE The progress service must be referenced at least once before it will become the progress provider for the IJobManager in the workbench. This connection is done lazily so that RCP applications will not have to use the IProgressService as the ProgressProvider to the jobs framework if they do not wish to reference it. Since: 3.0 See Also: IWorkbench.getProgressService(), IJobManager.setProgressProvider(org.eclipse.core.runtime.jobs.ProgressProvider), IServiceLocator.getService(Class) Restriction: This interface is not intended to be implemented by clients. Interface for UI components which can execute a long-running operation in the form of an IRunnableWithProgress. The context is responsible for displaying a progress indicator and Cancel button to the end user while the operation is in progress; the context supplies a progress monitor to be used from code running inside the operation. Note that an IRunnableContext is not a runnable itself. For examples of UI components which implement this interface, see ApplicationWindow, ProgressMonitorDialog, and WizardDialog. See Also: IRunnableWithProgress, ApplicationWindow, ProgressMonitorDialog, WizardDialog extends IProgressService IWorkbenchPartProgressService is an IProgressService that adds API for jobs that change the state in a IWorkbenchPartSite while they are being run. This service can be acquired from your service locator (IWorkbenchPartSite): IWorkbenchSiteProgressService service = (IWorkbenchSiteProgressService) getSite().getService(IWorkbenchSiteProgressService.class); This service is not available globally, only at the part site level. WorkbenchParts may access an instance of IWorkbenchSiteProgressService by calling getSite().getAdapter(IWorkbenchSiteProgressService.class); , although getSite().getService(IWorkbenchSiteProgressService.class) is preferred. Since: 3.0 See Also: IAdaptable.getAdapter(Class), IServiceLocator.getService(Class) Restriction: This interface is not intended to be implemented by clients. '
526, 'org.eclipse.ui.views.markers.MarkerItem', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/views/markers/MarkerItem.html', 'extends Object The MarkerItem class is the class that represents the objects displayed a MarkerSupportView. This class is not intended to be sub-classed by clients, Since: 3.4 '
527, 'org.eclipse.jface.viewers.ILazyTreeContentProvider', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/viewers/ILazyTreeContentProvider.html', 'A content provider mediates between the viewer\'s model and the viewer itself. See Also: ContentViewer.setContentProvider(IContentProvider) extends IContentProvider The ILazyTreeContentProvider is the content provider for tree viewers created using the SWT.VIRTUAL flag that only wish to return their contents as they are queried. Since: 3.2 '
528, 'org.eclipse.swt.dnd.DragSourceAdapter', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/dnd/DragSourceAdapter.html', 'extends org.eclipse.swt.internal.SWTEventListener The DragSourceListener class provides event notification to the application for DragSource events. When the user drops data on a DropTarget, the application which defines the DragSource must provide the dropped data by implementing dragSetData. In the dragSetData, the application must support all the data types that were specified in the DragSource#setTransfer method. After the drop has completed successfully or has been aborted, the application which defines the DragSource is required to take the appropriate cleanup action. In the case of a successful move operation, the application must remove the data that was transferred. extends Object implements DragSourceListener This adapter class provides default implementations for the methods described by the DragSourceListener interface. Classes that wish to deal with DragSourceEvents can extend this class and override only the methods which they are interested in. See Also: DragSourceListener, DragSourceEvent, Sample code and further information '
529, 'org.eclipse.swt.dnd.Transfer', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/dnd/Transfer.html', 'extends Object Transfer provides a mechanism for converting between a java representation of data and a platform specific representation of data and vice versa. It is used in data transfer operations such as drag and drop and clipboard copy/paste. You should only need to become familiar with this class if you are implementing a Transfer subclass and you are unable to subclass the ByteArrayTransfer class. See Also: ByteArrayTransfer, Drag and Drop snippets, SWT Example: DNDExample, Sample code and further information '
530, 'org.eclipse.swt.dnd.DragSourceEvent', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/dnd/DragSourceEvent.html', 'extends TypedEvent The DragSourceEvent contains the event information passed in the methods of the DragSourceListener. See Also: DragSourceListener, Sample code and further information, Serialized Form '
531, 'org.eclipse.ui.part.MarkerTransfer', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/part/MarkerTransfer.html', 'extends ByteArrayTransfer A MarkerTransfer is used to transfer an array of IMarkers from one part to another in a drag and drop operation. In every drag and drop operation there is a DragSource and a DropTarget. When a drag occurs a Transfer is used to marshall the drag data from the source into a byte array. If a drop occurs another Transfer is used to marshall the byte array into drop data for the target. This class can be used for a Viewer or an SWT component directly. A singleton is provided which may be serially reused (see getInstance). It is not intended to be subclassed. See Also: StructuredViewer, DropTarget, DragSource Restriction: This class is not intended to be subclassed by clients. '
532, 'org.eclipse.swt.dnd.TextTransfer', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/dnd/TextTransfer.html', 'provides a platform specific mechanism for converting plain text represented as a java String to a platform specific representation of the data and vice versa. An example of a java String containing plain text is shown below: String textData = \"Hello World\"; Note the TextTransfer does not change the content of the text data. For a better integration with the platform, the application should convert the line delimiters used in the text data to the standard line delimiter used by the platform. See Also: Transfer '
533, 'org.eclipse.core.resources.IFile', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/resources/IFile.html', 'An interface for an adaptable object. Adaptable objects can be dynamically extended to provide different interfaces (or \"adapters\"). Adapters are created by adapter factories, which are in turn managed by type by adapter managers. For example, IAdaptable a = [some adaptable]; IFoo x = (IFoo)a.getAdapter(IFoo.class); if (x != null) [do IFoo things with x] This interface can be used without OSGi running. Clients may implement this interface, or obtain a default implementation of this interface by subclassing PlatformObject. See Also: IAdapterFactory, IAdapterManager, PlatformObject extends IStorage A storage that knows how its contents are encoded. The IEncodedStorage interface extends IStorage in order to provide access to the charset to be used when decoding its contents. Clients may implement this interface. Since: 3.0 extends IAdaptable, ISchedulingRule The workspace analog of file system files and directories. There are exactly four types of resource: files, folders, projects and the workspace root. File resources are similar to files in that they hold data directly. Folder resources are analogous to directories in that they hold other resources but cannot directly hold data. Project resources group files and folders into reusable clusters. The workspace root is the top level resource under which all others reside. Features of resources: IResource objects are handles to state maintained by a workspace. That is, resource objects do not actually contain data themselves but rather represent resource state and give it behavior. Programmers are free to manipulate handles for resources that do not exist in a workspace but must keep in mind that some methods and operations require that an actual resource be available. Resources have two different kinds of properties as detailed below. All properties are keyed by qualified names. Session properties: Session properties live for the lifetime of one execution of the workspace. They are not stored on disk. They can carry arbitrary object values. Clients should be aware that these values are kept in memory at all times and, as such, the values should not be large. Persistent properties: Persistent properties have string values which are stored on disk across platform sessions. The value of a persistent property is a string which should be short (i.e., under 2KB). Resources are identified by type and by their path, which is similar to a file system path. The name of a resource is the last segment of its path. A resource\'s parent is located by removing the last segment (the resource\'s name) from the resource\'s full path. Resources can be local or non-local. A non-local resource is one whose contents and properties have not been fetched from a repository. Phantom resources represent incoming additions or outgoing deletions which have yet to be reconciled with a synchronization partner. Resources implement the IAdaptable interface; extensions are managed by the platform\'s adapter manager. See Also: IWorkspace, Platform.getAdapterManager() Restriction: This interface is not intended to be implemented by clients. Restriction: This interface is not intended to be extended by clients. Scheduling rules are used by jobs to indicate when they need exclusive access to a resource. Scheduling rules can also be applied synchronously to a thread using IJobManager.beginRule(ISchedulingRule) and IJobManager.endRule(ISchedulingRule). The job manager guarantees that no two jobs with conflicting scheduling rules will run concurrently. Multiple rules can be applied to a given thread only if the outer rule explicitly allows the nesting as specified by the contains method. Clients may implement this interface. Since: 3.0 See Also: Job.getRule(), Job.setRule(ISchedulingRule), Job.schedule(long), IJobManager.beginRule(ISchedulingRule, org.eclipse.core.runtime.IProgressMonitor), IJobManager.endRule(ISchedulingRule) extends IAdaptable A storage object represents a set of bytes which can be accessed. These may be in the form of an IFile or IFileState or any other object supplied by user code. The main role of an IStorage is to provide a uniform API for access to, and presentation of, its content. Storage objects implement the IAdaptable interface; extensions are managed by the platform\'s adapter manager. Clients may implement this interface. extends IResource, IEncodedStorage, IAdaptable Files are leaf resources which contain data. The contents of a file resource is stored as a file in the local file system. Files, like folders, may exist in the workspace but not be local; non-local file resources serve as place-holders for files whose content and properties have not yet been fetched from a repository. Files implement the IAdaptable interface; extensions are managed by the platform\'s adapter manager. See Also: Platform.getAdapterManager() Restriction: This interface is not intended to be implemented by clients. Restriction: This interface is not intended to be extended by clients. '
534, 'org.eclipse.ui.ide.ResourceUtil', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/ide/ResourceUtil.html', 'extends Object Utility class for manipulating resources and determining correspondences between resources and workbench objects. This class provides all its functionality via static methods. It is not intended to be instantiated or subclassed. Since: 3.1 '
535, 'org.eclipse.ui.ide.IDE', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/ide/IDE.html', 'extends Object Collection of IDE-specific APIs factored out of existing workbench. This class cannot be instantiated; all functionality is provided by static methods and fields. Since: 3.0 '
536, 'org.eclipse.jface.action.ToolBarContributionItem', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/action/ToolBarContributionItem.html', 'A contribution item represents a contribution to a shared UI resource such as a menu or tool bar. More generally, contribution items are managed by a contribution manager. For instance, in a tool bar a contribution item is a tool bar button or a separator. In a menu bar a contribution item is a menu, and in a menu a contribution item is a menu item or separator. A contribution item can realize itself in different SWT widgets, using the different fill methods. The same type of contribution item can be used with a MenuBarManager, ToolBarManager, CoolBarManager, or a StatusLineManager. This interface is internal to the framework; it should not be implemented outside the framework. See Also: IContributionManager Restriction: This interface is not intended to be implemented by clients. extends ContributionItem implements org.eclipse.jface.internal.provisional.action.IToolBarContributionItem The ToolBarContributionItem class provides a wrapper for tool bar managers when used in cool bar managers. It extends ContributionItem but and provides some additional methods to customize the size of the cool item and to retrieve the underlying tool bar manager. This class may be instantiated; it is not intended to be subclassed. Since: 3.0 Restriction: This class is not intended to be subclassed by clients. '
537, 'org.eclipse.ui.activities.IIdentifier', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/activities/IIdentifier.html', 'extends Comparable An instance of this interface can be obtained from an instance of IActivityManagerfor any identifier. An IIdentifier is an object that offers an easy means to determine if a given string matches the pattern bindings of any IActivity objects. Additionaly, one may query if an identifier is enabled. An identifier is always considered enabled unless it matches only disabled activities. The handle-based nature of this API allows it to work well with runtime plugin activation and deactivation, which can cause dynamic changes to the extension registry. This interface is not intended to be extended or implemented by clients. Since: 3.0 See Also: IActivityManager.getIdentifier(String) Restriction: This interface is not intended to be implemented by clients. '
538, 'org.eclipse.ui.IFolderLayout', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/IFolderLayout.html', 'An IPlaceholderFolderLayout is used to define the initial view placeholders within a folder. The folder itself is contained within an IPageLayout. This interface is not intended to be implemented by clients. Since: 2.0 See Also: IPageLayout.createPlaceholderFolder(java.lang.String, int, float, java.lang.String) Restriction: This interface is not intended to be implemented by clients. extends IPlaceholderFolderLayout An IFolderLayout is used to define the initial views within a folder. The folder itself is contained within an IPageLayout. This interface is not intended to be implemented by clients. See Also: IPageLayout.createFolder(java.lang.String, int, float, java.lang.String) Restriction: This interface is not intended to be implemented by clients. '
539, 'org.eclipse.ui.IViewLayout', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/IViewLayout.html', 'Represents the layout info for a view or placeholder in an IPageLayout. This interface is not intended to be implemented by clients. Since: 3.0 Restriction: This interface is not intended to be implemented by clients. '
540, 'org.eclipse.jface.viewers.IDelayedLabelDecorator', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/viewers/IDelayedLabelDecorator.html', 'A label provider maps an element of the viewer\'s model to an optional image and optional text string used to display the element in the viewer\'s control. Certain label providers may allow multiple labels per element. This is an \"abstract interface\", defining methods common to all label providers, but does not actually define the methods to get the label(s) for an element. This interface should never be directly implemented. Most viewers will take either an ILabelProvider or an ITableLabelProvider. A label provider must not be shared between viewers since a label provider generally manages SWT resources (images), which must be disposed when the viewer is disposed. To simplify life cycle management, the current label provider of a viewer is disposed when the viewer is disposed. Label providers can be used outside the context of viewers wherever images are needed. When label providers are used in this fashion it is the responsibility of the user to ensure dispose is called when the provider is no longer needed. See Also: ILabelProvider, ITableLabelProvider A label provider maps an element of the viewer\'s model to an optional image and optional text string used to display the element in the viewer\'s control. Certain label providers may allow multiple labels per element. This is an \"abstract interface\", defining methods common to all label providers, but does not actually define the methods to get the label(s) for an element. This interface should never be directly implemented. Most viewers will take either an ILabelProvider or an ITableLabelProvider. A label provider must not be shared between viewers since a label provider generally manages SWT resources (images), which must be disposed when the viewer is disposed. To simplify life cycle management, the current label provider of a viewer is disposed when the viewer is disposed. Label providers can be used outside the context of viewers wherever images are needed. When label providers are used in this fashion it is the responsibility of the user to ensure dispose is called when the provider is no longer needed. See Also: ILabelProvider, ITableLabelProvider extends IBaseLabelProvider A label decorator decorates the label text and image for some element. The original label text and image are obtained by some other means, for example by a label provider. See Also: ILabelProvider extends ILabelDecorator A delayed label decorator is a label decorator that may not have a decoration available immediately. This interface defines the methods for requesting the preparation of a decorator for an object and for querying if the decorator is ready. Interested parties should register an ILabelProviderListener with a delayed label decorator in order to be informed when the decoration is ready. Since: 3.0 '
541, 'org.eclipse.swt.widgets.Tracker', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/widgets/Tracker.html', 'extends Widget Instances of this class implement rubber banding rectangles that are drawn onto a parent Composite or Display. These rectangles can be specified to respond to mouse and key events by either moving or resizing themselves accordingly. Trackers are typically used to represent window geometries in a lightweight manner. Styles: LEFT, RIGHT, UP, DOWN, RESIZE Events: Move, Resize Note: Rectangle move behavior is assumed unless RESIZE is specified. IMPORTANT: This class is not intended to be subclassed. See Also: Tracker snippets, Sample code and further information Restriction: This class is not intended to be subclassed by clients. '
542, 'org.eclipse.swt.events.KeyListener', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/events/KeyListener.html', 'extends org.eclipse.swt.internal.SWTEventListener Classes which implement this interface provide methods that deal with the events that are generated as keys are pressed on the system keyboard. After creating an instance of a class that implements this interface it can be added to a control using the addKeyListener method and removed using the removeKeyListener method. When a key is pressed or released, the appropriate method will be invoked. See Also: KeyAdapter, KeyEvent '
543, 'org.eclipse.jface.action.IMenuListener2', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/action/IMenuListener2.html', 'A menu listener that gets informed when a menu is about to show. See Also: MenuManager.addMenuListener(org.eclipse.jface.action.IMenuListener) extends IMenuListener A menu listener that gets informed when a menu is about to hide. Since: 3.2 See Also: MenuManager.addMenuListener(org.eclipse.jface.action.IMenuListener) '
544, 'org.eclipse.jface.action.ExternalActionManager.ICallback', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/action/ExternalActionManager.ICallback.html', 'A callback mechanism for some external tool to communicate extra information to actions and action contribution items. Since: 3.0 '
545, 'org.eclipse.swt.events.MenuAdapter', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/events/MenuAdapter.html', 'extends org.eclipse.swt.internal.SWTEventListener Classes which implement this interface provide methods that deal with the hiding and showing of menus. After creating an instance of a class that implements this interface it can be added to a menu using the addMenuListener method and removed using the removeMenuListener method. When the menu is hidden or shown, the appropriate method will be invoked. See Also: MenuAdapter, MenuEvent extends Object implements MenuListener This adapter class provides default implementations for the methods described by the MenuListener interface. Classes that wish to deal with MenuEvents can extend this class and override only the methods which they are interested in. See Also: MenuListener, MenuEvent, Sample code and further information '
546, 'org.eclipse.e4.ui.model.application.commands.MHandlerContainer', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/e4/ui/model/application/commands/MHandlerContainer.html', ' A representation of the model object \'Handler Container\'. This provides a container in which to store lists of Handlers. Since: 1.0 The following features are supported: Handlers '
547, 'org.eclipse.core.expressions.EvaluationResult', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/expressions/EvaluationResult.html', 'extends Object An evaluation result represents the result of an expression evaluation. There are exact three instances of evaluation result. They are: FALSE, TRUE and NOT_LOADED. NOT_LOADED represents the fact that an expression couldn\'t be evaluated since a plug-in providing certain test expressions isn\'t loaded yet. In addition the class implements the three operation and , or and not. The operation are defined as follows: The and operation: AND FALSE TRUE NOT_LOADED FALSE FALSE FALSE FALSE TRUE FALSE TRUE NOT_LOADED NOT_LOADED FALSE NOT_LOADED NOT_LOADED The or operation: OR FALSE TRUE NOT_LOADED FALSE FALSE TRUE NOT_LOADED TRUE TRUE TRUE TRUE NOT_LOADED NOT_LOADED TRUE NOT_LOADED The not operation: NOT FALSE TRUE NOT_LOADED TRUE FALSE NOT_LOADED The class is not intended to be subclassed by clients. Since: 3.0 Restriction: This class is not intended to be subclassed by clients. '
548, 'org.eclipse.core.expressions.ExpressionConverter', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/expressions/ExpressionConverter.html', 'extends Object An expression converter converts an XML expression represented by an IConfigurationElement or Element (DOM) subtree into a corresponding expression tree. An expression converter manages a list of ElementHandlers. Element handlers are responsible to do the actual conversion. The element handlers build a chain of responsibility. Since: 3.0 '
549, 'org.eclipse.ui.IWorkbenchWindowPulldownDelegate', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/IWorkbenchWindowPulldownDelegate.html', 'Interface for actions contributed via an extension point. This interface should be implemented by clients who need to contribute actions via an extension point. The workbench will generate a proxy action object on behalf of the plug-in to avoid having to activate the plug-in until the user needs it. If the action is performed the workbench will load the class that implements this interface and create what is called an action delegate object. Then the request, and all subsequent ones, are forwarded through the proxy action to the action delegate, which does the real work. The proxy action is the one that appears in the UI, so the action delegate will need to talk to the proxy action in order to keep up an appropriate appearance. Once the action delegate has been created, it will be notified of all selection changes, allowing it to enable or disable the proxy action appropriately. An action delegate cannot be consulted about selection changes before the action is performed because it does not exist. For this reason, control of the action\'s enable state should also be exercised through simple XML rules contained in the extension. These rules allow enable state control before the action delegate\'s plug-in is loaded. Clients can choose to subclass the provided abstract implementation org.eclipse.ui.actions.ActionDelegate or implement the interface directly. See Also: ActionDelegate, IActionDelegate2 extends IActionDelegate Interface for an action that is contributed into the workbench window menu or tool bar. It extends IActionDelegate and adds an initialization method for connecting the delegate to the workbench window it should work with. extends IWorkbenchWindowActionDelegate Interface for a pulldown action that is contributed into the workbench window tool bar. It extends IWorkbenchWindowActionDelegate and adds an initialization method to define the menu creator for the action. '
550, 'org.eclipse.ui.IWorkbenchWindowPulldownDelegate2', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/IWorkbenchWindowPulldownDelegate2.html', 'Interface for actions contributed via an extension point. This interface should be implemented by clients who need to contribute actions via an extension point. The workbench will generate a proxy action object on behalf of the plug-in to avoid having to activate the plug-in until the user needs it. If the action is performed the workbench will load the class that implements this interface and create what is called an action delegate object. Then the request, and all subsequent ones, are forwarded through the proxy action to the action delegate, which does the real work. The proxy action is the one that appears in the UI, so the action delegate will need to talk to the proxy action in order to keep up an appropriate appearance. Once the action delegate has been created, it will be notified of all selection changes, allowing it to enable or disable the proxy action appropriately. An action delegate cannot be consulted about selection changes before the action is performed because it does not exist. For this reason, control of the action\'s enable state should also be exercised through simple XML rules contained in the extension. These rules allow enable state control before the action delegate\'s plug-in is loaded. Clients can choose to subclass the provided abstract implementation org.eclipse.ui.actions.ActionDelegate or implement the interface directly. See Also: ActionDelegate, IActionDelegate2 extends IActionDelegate Interface for an action that is contributed into the workbench window menu or tool bar. It extends IActionDelegate and adds an initialization method for connecting the delegate to the workbench window it should work with. Interface for actions contributed via an extension point. This interface should be implemented by clients who need to contribute actions via an extension point. The workbench will generate a proxy action object on behalf of the plug-in to avoid having to activate the plug-in until the user needs it. If the action is performed the workbench will load the class that implements this interface and create what is called an action delegate object. Then the request, and all subsequent ones, are forwarded through the proxy action to the action delegate, which does the real work. The proxy action is the one that appears in the UI, so the action delegate will need to talk to the proxy action in order to keep up an appropriate appearance. Once the action delegate has been created, it will be notified of all selection changes, allowing it to enable or disable the proxy action appropriately. An action delegate cannot be consulted about selection changes before the action is performed because it does not exist. For this reason, control of the action\'s enable state should also be exercised through simple XML rules contained in the extension. These rules allow enable state control before the action delegate\'s plug-in is loaded. Clients can choose to subclass the provided abstract implementation org.eclipse.ui.actions.ActionDelegate or implement the interface directly. See Also: ActionDelegate, IActionDelegate2 extends IActionDelegate Interface for an action that is contributed into the workbench window menu or tool bar. It extends IActionDelegate and adds an initialization method for connecting the delegate to the workbench window it should work with. extends IWorkbenchWindowActionDelegate Interface for a pulldown action that is contributed into the workbench window tool bar. It extends IWorkbenchWindowActionDelegate and adds an initialization method to define the menu creator for the action. extends IWorkbenchWindowPulldownDelegate Extension of IWorkbenchWindowPulldownDelegate that allows the delegate dropdown menu to be a child of a Menu item. Necessary for CoolBar support. If a coolbar group of items is not fully displayed, a chevron and a drop down menu will be used to show the group\'s tool items. Therefore, a getMenu(Menu) method is necessary, since the delegate drop down menu will be a child of the chevron menu item (not the tool control). '
551, 'org.eclipse.ui.IWorkbenchCommandConstants', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/IWorkbenchCommandConstants.html', 'Constants for all commands defined by the Eclipse workbench. Since: 3.5 Restriction: This interface is not intended to be implemented by clients. Restriction: This interface is not intended to be extended by clients. '
552, 'org.eclipse.core.runtime.IAdapterManager', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/runtime/IAdapterManager.html', 'An adapter manager maintains a registry of adapter factories. Clients directly invoke methods on an adapter manager to register and unregister adapters. All adaptable objects (that is, objects that implement the IAdaptable interface) funnel IAdaptable.getAdapter invocations to their adapter manager\'s IAdapterManger.getAdapter method. The adapter manager then forwards this request unmodified to the IAdapterFactory.getAdapter method on one of the registered adapter factories. Adapter factories can be registered programmatically using the registerAdapters method. Alternatively, they can be registered declaratively using the org.eclipse.core.runtime.adapters extension point. Factories registered with this extension point will not be able to provide adapters until their corresponding plugin has been activated. The following code snippet shows how one might register an adapter of type com.example.acme.Sticky on resources in the workspace. IAdapterFactory pr = new IAdapterFactory() { public Class[] getAdapterList() { return new Class[] { com.example.acme.Sticky.class }; } public Object getAdapter(Object adaptableObject, Class adapterType) { IResource res = (IResource) adaptableObject; QualifiedName key = new QualifiedName(\"com.example.acme\", \"sticky-note\"); try { com.example.acme.Sticky v = (com.example.acme.Sticky) res.getSessionProperty(key); if (v == null) { v = new com.example.acme.Sticky(); res.setSessionProperty(key, v); } } catch (CoreException e) { // unable to access session property - ignore } return v; } } Platform.getAdapterManager().registerAdapters(pr, IResource.class); This interface can be used without OSGi running. This interface is not intended to be implemented by clients. See Also: IAdaptable, IAdapterFactory Restriction: This interface is not intended to be implemented by clients. Restriction: This interface is not intended to be extended by clients. '
553, 'org.eclipse.ui.IWorkbenchPartSite', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/IWorkbenchPartSite.html', 'An interface for an adaptable object. Adaptable objects can be dynamically extended to provide different interfaces (or \"adapters\"). Adapters are created by adapter factories, which are in turn managed by type by adapter managers. For example, IAdaptable a = [some adaptable]; IFoo x = (IFoo)a.getAdapter(IFoo.class); if (x != null) [do IFoo things with x] This interface can be used without OSGi running. Clients may implement this interface, or obtain a default implementation of this interface by subclassing PlatformObject. See Also: IAdapterFactory, IAdapterManager, PlatformObject A component with which one or more services are registered. The services can be retrieved from this locator using some key -- typically the class representing the interface the service must implement. For example: IHandlerService service = (IHandlerService) workbenchWindow .getService(IHandlerService.class); This interface is not to be implemented or extended by clients. Since: 3.2 Interface for objects that can return a shell. This is normally used for opening child windows. An object that wants to open child shells can take an IShellProvider in its constructor, and the object that implements IShellProvider can dynamically choose where child shells should be opened. Since: 3.1 extends IAdaptable, IShellProvider, IServiceLocator The common interface between the workbench and its parts, including pages within parts. The workbench site supports a few services by default. If these services are used to allocate resources, it is important to remember to clean up those resources after you are done with them. Otherwise, the resources will exist until the workbench site is disposed. The supported services are: ICommandService IContextService IHandlerService IBindingService. Resources allocated through this service will not be cleaned up until the workbench shuts down. This interface is not intended to be implemented or extended by clients. Since: 2.0 See Also: IWorkbenchPartSite, IPageSite Restriction: This interface is not intended to be implemented by clients. extends IWorkbenchSite The primary interface between a workbench part and the workbench. This interface is not intended to be implemented or extended by clients. Restriction: This interface is not intended to be implemented by clients. '
554, 'org.eclipse.jface.viewers.IPostSelectionProvider', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/viewers/IPostSelectionProvider.html', 'Interface common to all objects that provide a selection. See Also: ISelection, ISelectionChangedListener, SelectionChangedEvent extends ISelectionProvider Selection provider extension interface to allow providers to notify about post selection changed events. A post selection changed event is equivalent to selection changed event if the selection change was triggered by the mouse, but it has a delay if the selection change is triggered by keyboard navigation. Since: 3.0 See Also: ISelectionProvider '
555, 'org.eclipse.ui.part.MultiEditorInput', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/part/MultiEditorInput.html', 'An interface for an adaptable object. Adaptable objects can be dynamically extended to provide different interfaces (or \"adapters\"). Adapters are created by adapter factories, which are in turn managed by type by adapter managers. For example, IAdaptable a = [some adaptable]; IFoo x = (IFoo)a.getAdapter(IFoo.class); if (x != null) [do IFoo things with x] This interface can be used without OSGi running. Clients may implement this interface, or obtain a default implementation of this interface by subclassing PlatformObject. See Also: IAdapterFactory, IAdapterManager, PlatformObject An interface for an adaptable object. Adaptable objects can be dynamically extended to provide different interfaces (or \"adapters\"). Adapters are created by adapter factories, which are in turn managed by type by adapter managers. For example, IAdaptable a = [some adaptable]; IFoo x = (IFoo)a.getAdapter(IFoo.class); if (x != null) [do IFoo things with x] This interface can be used without OSGi running. Clients may implement this interface, or obtain a default implementation of this interface by subclassing PlatformObject. See Also: IAdapterFactory, IAdapterManager, PlatformObject extends IAdaptable IEditorInput is a light weight descriptor of editor input, like a file name but more abstract. It is not a model. It is a description of the model source for an IEditorPart. Clients implementing this editor input interface should override Object.equals(Object) to answer true for two inputs that are the same. The IWorbenchPage.openEditor APIs are dependent on this to find an editor with the same input. Clients should extend this interface to declare new types of editor inputs. An editor input is passed to an editor via the IEditorPart.init method. Due to the wide range of valid editor inputs, it is not possible to define generic methods for getting and setting bytes. Editor input must implement the IAdaptable interface; extensions are managed by the platform\'s adapter manager. Please note that it is important that the editor input be light weight. Within the workbench, the navigation history tends to hold on to editor inputs as a means of reconstructing the editor at a later time. The navigation history can hold on to quite a few inputs (i.e., the default is fifty). The actual data model should probably not be held in the input. See Also: IEditorPart, IWorkbenchPage.openEditor(IEditorInput, String), IWorkbenchPage.openEditor(IEditorInput, String, boolean) extends Object implements IEditorInput Implements an input for a AbstractMultiEditor. This class is intended to be instantiated by clients but is not intended to be subclassed. Restriction: This class is not intended to be subclassed by clients. '
556, 'org.eclipse.ui.part.MultiEditor', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/part/MultiEditor.html', 'An interface for an adaptable object. Adaptable objects can be dynamically extended to provide different interfaces (or \"adapters\"). Adapters are created by adapter factories, which are in turn managed by type by adapter managers. For example, IAdaptable a = [some adaptable]; IFoo x = (IFoo)a.getAdapter(IFoo.class); if (x != null) [do IFoo things with x] This interface can be used without OSGi running. Clients may implement this interface, or obtain a default implementation of this interface by subclassing PlatformObject. See Also: IAdapterFactory, IAdapterManager, PlatformObject Interface for executable extension classes that require access to their configuration element, or implement an extension adapter. Extension adapters are typically required in cases where the extension implementation does not follow the interface rules specified by the provider of the extension point. In these cases, the role of the adapter is to map between the extension point interface, and the actual extension implementation. In general, adapters are used when attempting to plug-in existing Java implementations, or non-Java implementations (e.g., external executables). This interface can be used without OSGi running. Clients may implement this interface. See Also: IConfigurationElement.createExecutableExtension(String) An interface for an adaptable object. Adaptable objects can be dynamically extended to provide different interfaces (or \"adapters\"). Adapters are created by adapter factories, which are in turn managed by type by adapter managers. For example, IAdaptable a = [some adaptable]; IFoo x = (IFoo)a.getAdapter(IFoo.class); if (x != null) [do IFoo things with x] This interface can be used without OSGi running. Clients may implement this interface, or obtain a default implementation of this interface by subclassing PlatformObject. See Also: IAdapterFactory, IAdapterManager, PlatformObject Workbench parts implement or adapt to this interface to participate in the enablement and execution of the Save and Save As actions. Since: 2.1 See Also: IEditorPart An interface for an adaptable object. Adaptable objects can be dynamically extended to provide different interfaces (or \"adapters\"). Adapters are created by adapter factories, which are in turn managed by type by adapter managers. For example, IAdaptable a = [some adaptable]; IFoo x = (IFoo)a.getAdapter(IFoo.class); if (x != null) [do IFoo things with x] This interface can be used without OSGi running. Clients may implement this interface, or obtain a default implementation of this interface by subclassing PlatformObject. See Also: IAdapterFactory, IAdapterManager, PlatformObject extends IAdaptable A workbench part is a visual component within a workbench page. There are two subtypes: view and editor, as defined by IViewPart and IEditorPart. A view is typically used to navigate a hierarchy of information (like the workspace), open an editor, or display properties for the active editor. Modifications made in a view are saved immediately. An editor is typically used to edit or browse a document or input object. The input is identified using an IEditorInput. Modifications made in an editor part follow an open-save-close lifecycle model. This interface may be implemented directly. For convenience, a base implementation is defined in WorkbenchPart. The lifecycle of a workbench part is as follows: When a part extension is created: instantiate the part create a part site call part.init(site) When a part becomes visible in the workbench: add part to presentation by calling part.createPartControl(parent) to create actual widgets fire partOpened event to all listeners When a part is activated or gets focus: call part.setFocus() fire partActivated event to all listeners When a part is closed: if save is needed, do save; if it fails or is canceled return if part is active, deactivate part fire partClosed event to all listeners remove part from presentation; part controls are disposed as part of the SWT widget tree call part.dispose() After createPartControl has been called, the implementor may safely reference the controls created. When the part is closed these controls will be disposed as part of an SWT composite. This occurs before the IWorkbenchPart.dispose method is called. If there is a need to free SWT resources the part should define a dispose listener for its own control and free those resources from the dispose listener. If the part invokes any method on the disposed SWT controls after this point an SWTError will be thrown. The last method called on IWorkbenchPart is dispose. This signals the end of the part lifecycle. An important point to note about this lifecycle is that following a call to init, createPartControl may never be called. Thus in the dispose method, implementors must not assume controls were created. Workbench parts implement the IAdaptable interface; extensions are managed by the platform\'s adapter manager. See Also: IViewPart, IEditorPart extends IWorkbenchPart, ISaveablePart An editor is a visual component within a workbench page. It is typically used to edit or browse a document or input object. The input is identified using an IEditorInput. Modifications made in an editor part follow an open-save-close lifecycle model (in contrast to a view part, where modifications are saved to the workbench immediately). An editor is document or input-centric. Each editor has an input, and only one editor can exist for each editor input within a page. This policy has been designed to simplify part management. An editor should be used in place of a view whenever more than one instance of a document type can exist. This interface may be implemented directly. For convenience, a base implementation is defined in EditorPart. An editor part is added to the workbench in two stages: An editor extension is contributed to the workbench registry. This extension defines the extension id, extension class, and the file extensions which are supported by the editor. An editor part based upon the extension is created and added to the workbench when the user opens a file with one of the supported file extensions (or some other suitable form of editor input). All editor parts implement the IAdaptable interface; extensions are managed by the platform\'s adapter manager. See Also: IWorkbenchPage.openEditor(IEditorInput, String), EditorPart Workbench parts implement or adapt to this interface to participate in the enablement and execution of the Save and Save As actions. Since: 2.1 See Also: IEditorPart An interface for an adaptable object. Adaptable objects can be dynamically extended to provide different interfaces (or \"adapters\"). Adapters are created by adapter factories, which are in turn managed by type by adapter managers. For example, IAdaptable a = [some adaptable]; IFoo x = (IFoo)a.getAdapter(IFoo.class); if (x != null) [do IFoo things with x] This interface can be used without OSGi running. Clients may implement this interface, or obtain a default implementation of this interface by subclassing PlatformObject. See Also: IAdapterFactory, IAdapterManager, PlatformObject extends IAdaptable A workbench part is a visual component within a workbench page. There are two subtypes: view and editor, as defined by IViewPart and IEditorPart. A view is typically used to navigate a hierarchy of information (like the workspace), open an editor, or display properties for the active editor. Modifications made in a view are saved immediately. An editor is typically used to edit or browse a document or input object. The input is identified using an IEditorInput. Modifications made in an editor part follow an open-save-close lifecycle model. This interface may be implemented directly. For convenience, a base implementation is defined in WorkbenchPart. The lifecycle of a workbench part is as follows: When a part extension is created: instantiate the part create a part site call part.init(site) When a part becomes visible in the workbench: add part to presentation by calling part.createPartControl(parent) to create actual widgets fire partOpened event to all listeners When a part is activated or gets focus: call part.setFocus() fire partActivated event to all listeners When a part is closed: if save is needed, do save; if it fails or is canceled return if part is active, deactivate part fire partClosed event to all listeners remove part from presentation; part controls are disposed as part of the SWT widget tree call part.dispose() After createPartControl has been called, the implementor may safely reference the controls created. When the part is closed these controls will be disposed as part of an SWT composite. This occurs before the IWorkbenchPart.dispose method is called. If there is a need to free SWT resources the part should define a dispose listener for its own control and free those resources from the dispose listener. If the part invokes any method on the disposed SWT controls after this point an SWTError will be thrown. The last method called on IWorkbenchPart is dispose. This signals the end of the part lifecycle. An important point to note about this lifecycle is that following a call to init, createPartControl may never be called. Thus in the dispose method, implementors must not assume controls were created. Workbench parts implement the IAdaptable interface; extensions are managed by the platform\'s adapter manager. See Also: IViewPart, IEditorPart An interface for an adaptable object. Adaptable objects can be dynamically extended to provide different interfaces (or \"adapters\"). Adapters are created by adapter factories, which are in turn managed by type by adapter managers. For example, IAdaptable a = [some adaptable]; IFoo x = (IFoo)a.getAdapter(IFoo.class); if (x != null) [do IFoo things with x] This interface can be used without OSGi running. Clients may implement this interface, or obtain a default implementation of this interface by subclassing PlatformObject. See Also: IAdapterFactory, IAdapterManager, PlatformObject An interface for an adaptable object. Adaptable objects can be dynamically extended to provide different interfaces (or \"adapters\"). Adapters are created by adapter factories, which are in turn managed by type by adapter managers. For example, IAdaptable a = [some adaptable]; IFoo x = (IFoo)a.getAdapter(IFoo.class); if (x != null) [do IFoo things with x] This interface can be used without OSGi running. Clients may implement this interface, or obtain a default implementation of this interface by subclassing PlatformObject. See Also: IAdapterFactory, IAdapterManager, PlatformObject extends IAdaptable A workbench part is a visual component within a workbench page. There are two subtypes: view and editor, as defined by IViewPart and IEditorPart. A view is typically used to navigate a hierarchy of information (like the workspace), open an editor, or display properties for the active editor. Modifications made in a view are saved immediately. An editor is typically used to edit or browse a document or input object. The input is identified using an IEditorInput. Modifications made in an editor part follow an open-save-close lifecycle model. This interface may be implemented directly. For convenience, a base implementation is defined in WorkbenchPart. The lifecycle of a workbench part is as follows: When a part extension is created: instantiate the part create a part site call part.init(site) When a part becomes visible in the workbench: add part to presentation by calling part.createPartControl(parent) to create actual widgets fire partOpened event to all listeners When a part is activated or gets focus: call part.setFocus() fire partActivated event to all listeners When a part is closed: if save is needed, do save; if it fails or is canceled return if part is active, deactivate part fire partClosed event to all listeners remove part from presentation; part controls are disposed as part of the SWT widget tree call part.dispose() After createPartControl has been called, the implementor may safely reference the controls created. When the part is closed these controls will be disposed as part of an SWT composite. This occurs before the IWorkbenchPart.dispose method is called. If there is a need to free SWT resources the part should define a dispose listener for its own control and free those resources from the dispose listener. If the part invokes any method on the disposed SWT controls after this point an SWTError will be thrown. The last method called on IWorkbenchPart is dispose. This signals the end of the part lifecycle. An important point to note about this lifecycle is that following a call to init, createPartControl may never be called. Thus in the dispose method, implementors must not assume controls were created. Workbench parts implement the IAdaptable interface; extensions are managed by the platform\'s adapter manager. See Also: IViewPart, IEditorPart extends IWorkbenchPart Extends IWorkbenchPart, adding the name and status text properties. Prior to 3.0, a view\'s title was often modified to show both the part name and extra status text. With this interface, the distinction is made more explicit. Since: 3.0 An interface for an adaptable object. Adaptable objects can be dynamically extended to provide different interfaces (or \"adapters\"). Adapters are created by adapter factories, which are in turn managed by type by adapter managers. For example, IAdaptable a = [some adaptable]; IFoo x = (IFoo)a.getAdapter(IFoo.class); if (x != null) [do IFoo things with x] This interface can be used without OSGi running. Clients may implement this interface, or obtain a default implementation of this interface by subclassing PlatformObject. See Also: IAdapterFactory, IAdapterManager, PlatformObject An interface for an adaptable object. Adaptable objects can be dynamically extended to provide different interfaces (or \"adapters\"). Adapters are created by adapter factories, which are in turn managed by type by adapter managers. For example, IAdaptable a = [some adaptable]; IFoo x = (IFoo)a.getAdapter(IFoo.class); if (x != null) [do IFoo things with x] This interface can be used without OSGi running. Clients may implement this interface, or obtain a default implementation of this interface by subclassing PlatformObject. See Also: IAdapterFactory, IAdapterManager, PlatformObject extends IAdaptable A workbench part is a visual component within a workbench page. There are two subtypes: view and editor, as defined by IViewPart and IEditorPart. A view is typically used to navigate a hierarchy of information (like the workspace), open an editor, or display properties for the active editor. Modifications made in a view are saved immediately. An editor is typically used to edit or browse a document or input object. The input is identified using an IEditorInput. Modifications made in an editor part follow an open-save-close lifecycle model. This interface may be implemented directly. For convenience, a base implementation is defined in WorkbenchPart. The lifecycle of a workbench part is as follows: When a part extension is created: instantiate the part create a part site call part.init(site) When a part becomes visible in the workbench: add part to presentation by calling part.createPartControl(parent) to create actual widgets fire partOpened event to all listeners When a part is activated or gets focus: call part.setFocus() fire partActivated event to all listeners When a part is closed: if save is needed, do save; if it fails or is canceled return if part is active, deactivate part fire partClosed event to all listeners remove part from presentation; part controls are disposed as part of the SWT widget tree call part.dispose() After createPartControl has been called, the implementor may safely reference the controls created. When the part is closed these controls will be disposed as part of an SWT composite. This occurs before the IWorkbenchPart.dispose method is called. If there is a need to free SWT resources the part should define a dispose listener for its own control and free those resources from the dispose listener. If the part invokes any method on the disposed SWT controls after this point an SWTError will be thrown. The last method called on IWorkbenchPart is dispose. This signals the end of the part lifecycle. An important point to note about this lifecycle is that following a call to init, createPartControl may never be called. Thus in the dispose method, implementors must not assume controls were created. Workbench parts implement the IAdaptable interface; extensions are managed by the platform\'s adapter manager. See Also: IViewPart, IEditorPart extends IWorkbenchPart Extends IWorkbenchPart, adding the name and status text properties. Prior to 3.0, a view\'s title was often modified to show both the part name and extra status text. With this interface, the distinction is made more explicit. Since: 3.0 extends IWorkbenchPart2 A part can provide arbitrary properties. The properties will be persisted between sessions by the part reference, and will be available from the part reference as well as the part. The properties can only be set on a part, not on the reference. The properties will be available to the IPresentablePart. Setting a property must fire a PropertyChangeEvent. Since: 3.3 The IWorkbenchPartOrientation is the interface that defines the orientation of the part. If a type does not implement this interface an orientation of SWT.NONE will be assumed. Since: 3.1 See Also: SWT.RIGHT_TO_LEFT, SWT.LEFT_TO_RIGHT, SWT.NONE, Window.getDefaultOrientation() extends AbstractMultiEditor A MultiEditor is a composite of editors. This class is intended to be subclassed. '
557, 'org.eclipse.ui.part.AbstractMultiEditor', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/part/AbstractMultiEditor.html', 'An interface for an adaptable object. Adaptable objects can be dynamically extended to provide different interfaces (or \"adapters\"). Adapters are created by adapter factories, which are in turn managed by type by adapter managers. For example, IAdaptable a = [some adaptable]; IFoo x = (IFoo)a.getAdapter(IFoo.class); if (x != null) [do IFoo things with x] This interface can be used without OSGi running. Clients may implement this interface, or obtain a default implementation of this interface by subclassing PlatformObject. See Also: IAdapterFactory, IAdapterManager, PlatformObject Interface for executable extension classes that require access to their configuration element, or implement an extension adapter. Extension adapters are typically required in cases where the extension implementation does not follow the interface rules specified by the provider of the extension point. In these cases, the role of the adapter is to map between the extension point interface, and the actual extension implementation. In general, adapters are used when attempting to plug-in existing Java implementations, or non-Java implementations (e.g., external executables). This interface can be used without OSGi running. Clients may implement this interface. See Also: IConfigurationElement.createExecutableExtension(String) An interface for an adaptable object. Adaptable objects can be dynamically extended to provide different interfaces (or \"adapters\"). Adapters are created by adapter factories, which are in turn managed by type by adapter managers. For example, IAdaptable a = [some adaptable]; IFoo x = (IFoo)a.getAdapter(IFoo.class); if (x != null) [do IFoo things with x] This interface can be used without OSGi running. Clients may implement this interface, or obtain a default implementation of this interface by subclassing PlatformObject. See Also: IAdapterFactory, IAdapterManager, PlatformObject Workbench parts implement or adapt to this interface to participate in the enablement and execution of the Save and Save As actions. Since: 2.1 See Also: IEditorPart An interface for an adaptable object. Adaptable objects can be dynamically extended to provide different interfaces (or \"adapters\"). Adapters are created by adapter factories, which are in turn managed by type by adapter managers. For example, IAdaptable a = [some adaptable]; IFoo x = (IFoo)a.getAdapter(IFoo.class); if (x != null) [do IFoo things with x] This interface can be used without OSGi running. Clients may implement this interface, or obtain a default implementation of this interface by subclassing PlatformObject. See Also: IAdapterFactory, IAdapterManager, PlatformObject extends IAdaptable A workbench part is a visual component within a workbench page. There are two subtypes: view and editor, as defined by IViewPart and IEditorPart. A view is typically used to navigate a hierarchy of information (like the workspace), open an editor, or display properties for the active editor. Modifications made in a view are saved immediately. An editor is typically used to edit or browse a document or input object. The input is identified using an IEditorInput. Modifications made in an editor part follow an open-save-close lifecycle model. This interface may be implemented directly. For convenience, a base implementation is defined in WorkbenchPart. The lifecycle of a workbench part is as follows: When a part extension is created: instantiate the part create a part site call part.init(site) When a part becomes visible in the workbench: add part to presentation by calling part.createPartControl(parent) to create actual widgets fire partOpened event to all listeners When a part is activated or gets focus: call part.setFocus() fire partActivated event to all listeners When a part is closed: if save is needed, do save; if it fails or is canceled return if part is active, deactivate part fire partClosed event to all listeners remove part from presentation; part controls are disposed as part of the SWT widget tree call part.dispose() After createPartControl has been called, the implementor may safely reference the controls created. When the part is closed these controls will be disposed as part of an SWT composite. This occurs before the IWorkbenchPart.dispose method is called. If there is a need to free SWT resources the part should define a dispose listener for its own control and free those resources from the dispose listener. If the part invokes any method on the disposed SWT controls after this point an SWTError will be thrown. The last method called on IWorkbenchPart is dispose. This signals the end of the part lifecycle. An important point to note about this lifecycle is that following a call to init, createPartControl may never be called. Thus in the dispose method, implementors must not assume controls were created. Workbench parts implement the IAdaptable interface; extensions are managed by the platform\'s adapter manager. See Also: IViewPart, IEditorPart extends IWorkbenchPart, ISaveablePart An editor is a visual component within a workbench page. It is typically used to edit or browse a document or input object. The input is identified using an IEditorInput. Modifications made in an editor part follow an open-save-close lifecycle model (in contrast to a view part, where modifications are saved to the workbench immediately). An editor is document or input-centric. Each editor has an input, and only one editor can exist for each editor input within a page. This policy has been designed to simplify part management. An editor should be used in place of a view whenever more than one instance of a document type can exist. This interface may be implemented directly. For convenience, a base implementation is defined in EditorPart. An editor part is added to the workbench in two stages: An editor extension is contributed to the workbench registry. This extension defines the extension id, extension class, and the file extensions which are supported by the editor. An editor part based upon the extension is created and added to the workbench when the user opens a file with one of the supported file extensions (or some other suitable form of editor input). All editor parts implement the IAdaptable interface; extensions are managed by the platform\'s adapter manager. See Also: IWorkbenchPage.openEditor(IEditorInput, String), EditorPart Workbench parts implement or adapt to this interface to participate in the enablement and execution of the Save and Save As actions. Since: 2.1 See Also: IEditorPart An interface for an adaptable object. Adaptable objects can be dynamically extended to provide different interfaces (or \"adapters\"). Adapters are created by adapter factories, which are in turn managed by type by adapter managers. For example, IAdaptable a = [some adaptable]; IFoo x = (IFoo)a.getAdapter(IFoo.class); if (x != null) [do IFoo things with x] This interface can be used without OSGi running. Clients may implement this interface, or obtain a default implementation of this interface by subclassing PlatformObject. See Also: IAdapterFactory, IAdapterManager, PlatformObject extends IAdaptable A workbench part is a visual component within a workbench page. There are two subtypes: view and editor, as defined by IViewPart and IEditorPart. A view is typically used to navigate a hierarchy of information (like the workspace), open an editor, or display properties for the active editor. Modifications made in a view are saved immediately. An editor is typically used to edit or browse a document or input object. The input is identified using an IEditorInput. Modifications made in an editor part follow an open-save-close lifecycle model. This interface may be implemented directly. For convenience, a base implementation is defined in WorkbenchPart. The lifecycle of a workbench part is as follows: When a part extension is created: instantiate the part create a part site call part.init(site) When a part becomes visible in the workbench: add part to presentation by calling part.createPartControl(parent) to create actual widgets fire partOpened event to all listeners When a part is activated or gets focus: call part.setFocus() fire partActivated event to all listeners When a part is closed: if save is needed, do save; if it fails or is canceled return if part is active, deactivate part fire partClosed event to all listeners remove part from presentation; part controls are disposed as part of the SWT widget tree call part.dispose() After createPartControl has been called, the implementor may safely reference the controls created. When the part is closed these controls will be disposed as part of an SWT composite. This occurs before the IWorkbenchPart.dispose method is called. If there is a need to free SWT resources the part should define a dispose listener for its own control and free those resources from the dispose listener. If the part invokes any method on the disposed SWT controls after this point an SWTError will be thrown. The last method called on IWorkbenchPart is dispose. This signals the end of the part lifecycle. An important point to note about this lifecycle is that following a call to init, createPartControl may never be called. Thus in the dispose method, implementors must not assume controls were created. Workbench parts implement the IAdaptable interface; extensions are managed by the platform\'s adapter manager. See Also: IViewPart, IEditorPart An interface for an adaptable object. Adaptable objects can be dynamically extended to provide different interfaces (or \"adapters\"). Adapters are created by adapter factories, which are in turn managed by type by adapter managers. For example, IAdaptable a = [some adaptable]; IFoo x = (IFoo)a.getAdapter(IFoo.class); if (x != null) [do IFoo things with x] This interface can be used without OSGi running. Clients may implement this interface, or obtain a default implementation of this interface by subclassing PlatformObject. See Also: IAdapterFactory, IAdapterManager, PlatformObject An interface for an adaptable object. Adaptable objects can be dynamically extended to provide different interfaces (or \"adapters\"). Adapters are created by adapter factories, which are in turn managed by type by adapter managers. For example, IAdaptable a = [some adaptable]; IFoo x = (IFoo)a.getAdapter(IFoo.class); if (x != null) [do IFoo things with x] This interface can be used without OSGi running. Clients may implement this interface, or obtain a default implementation of this interface by subclassing PlatformObject. See Also: IAdapterFactory, IAdapterManager, PlatformObject extends IAdaptable A workbench part is a visual component within a workbench page. There are two subtypes: view and editor, as defined by IViewPart and IEditorPart. A view is typically used to navigate a hierarchy of information (like the workspace), open an editor, or display properties for the active editor. Modifications made in a view are saved immediately. An editor is typically used to edit or browse a document or input object. The input is identified using an IEditorInput. Modifications made in an editor part follow an open-save-close lifecycle model. This interface may be implemented directly. For convenience, a base implementation is defined in WorkbenchPart. The lifecycle of a workbench part is as follows: When a part extension is created: instantiate the part create a part site call part.init(site) When a part becomes visible in the workbench: add part to presentation by calling part.createPartControl(parent) to create actual widgets fire partOpened event to all listeners When a part is activated or gets focus: call part.setFocus() fire partActivated event to all listeners When a part is closed: if save is needed, do save; if it fails or is canceled return if part is active, deactivate part fire partClosed event to all listeners remove part from presentation; part controls are disposed as part of the SWT widget tree call part.dispose() After createPartControl has been called, the implementor may safely reference the controls created. When the part is closed these controls will be disposed as part of an SWT composite. This occurs before the IWorkbenchPart.dispose method is called. If there is a need to free SWT resources the part should define a dispose listener for its own control and free those resources from the dispose listener. If the part invokes any method on the disposed SWT controls after this point an SWTError will be thrown. The last method called on IWorkbenchPart is dispose. This signals the end of the part lifecycle. An important point to note about this lifecycle is that following a call to init, createPartControl may never be called. Thus in the dispose method, implementors must not assume controls were created. Workbench parts implement the IAdaptable interface; extensions are managed by the platform\'s adapter manager. See Also: IViewPart, IEditorPart extends IWorkbenchPart Extends IWorkbenchPart, adding the name and status text properties. Prior to 3.0, a view\'s title was often modified to show both the part name and extra status text. With this interface, the distinction is made more explicit. Since: 3.0 An interface for an adaptable object. Adaptable objects can be dynamically extended to provide different interfaces (or \"adapters\"). Adapters are created by adapter factories, which are in turn managed by type by adapter managers. For example, IAdaptable a = [some adaptable]; IFoo x = (IFoo)a.getAdapter(IFoo.class); if (x != null) [do IFoo things with x] This interface can be used without OSGi running. Clients may implement this interface, or obtain a default implementation of this interface by subclassing PlatformObject. See Also: IAdapterFactory, IAdapterManager, PlatformObject An interface for an adaptable object. Adaptable objects can be dynamically extended to provide different interfaces (or \"adapters\"). Adapters are created by adapter factories, which are in turn managed by type by adapter managers. For example, IAdaptable a = [some adaptable]; IFoo x = (IFoo)a.getAdapter(IFoo.class); if (x != null) [do IFoo things with x] This interface can be used without OSGi running. Clients may implement this interface, or obtain a default implementation of this interface by subclassing PlatformObject. See Also: IAdapterFactory, IAdapterManager, PlatformObject extends IAdaptable A workbench part is a visual component within a workbench page. There are two subtypes: view and editor, as defined by IViewPart and IEditorPart. A view is typically used to navigate a hierarchy of information (like the workspace), open an editor, or display properties for the active editor. Modifications made in a view are saved immediately. An editor is typically used to edit or browse a document or input object. The input is identified using an IEditorInput. Modifications made in an editor part follow an open-save-close lifecycle model. This interface may be implemented directly. For convenience, a base implementation is defined in WorkbenchPart. The lifecycle of a workbench part is as follows: When a part extension is created: instantiate the part create a part site call part.init(site) When a part becomes visible in the workbench: add part to presentation by calling part.createPartControl(parent) to create actual widgets fire partOpened event to all listeners When a part is activated or gets focus: call part.setFocus() fire partActivated event to all listeners When a part is closed: if save is needed, do save; if it fails or is canceled return if part is active, deactivate part fire partClosed event to all listeners remove part from presentation; part controls are disposed as part of the SWT widget tree call part.dispose() After createPartControl has been called, the implementor may safely reference the controls created. When the part is closed these controls will be disposed as part of an SWT composite. This occurs before the IWorkbenchPart.dispose method is called. If there is a need to free SWT resources the part should define a dispose listener for its own control and free those resources from the dispose listener. If the part invokes any method on the disposed SWT controls after this point an SWTError will be thrown. The last method called on IWorkbenchPart is dispose. This signals the end of the part lifecycle. An important point to note about this lifecycle is that following a call to init, createPartControl may never be called. Thus in the dispose method, implementors must not assume controls were created. Workbench parts implement the IAdaptable interface; extensions are managed by the platform\'s adapter manager. See Also: IViewPart, IEditorPart extends IWorkbenchPart Extends IWorkbenchPart, adding the name and status text properties. Prior to 3.0, a view\'s title was often modified to show both the part name and extra status text. With this interface, the distinction is made more explicit. Since: 3.0 extends IWorkbenchPart2 A part can provide arbitrary properties. The properties will be persisted between sessions by the part reference, and will be available from the part reference as well as the part. The properties can only be set on a part, not on the reference. The properties will be available to the IPresentablePart. Setting a property must fire a PropertyChangeEvent. Since: 3.3 The IWorkbenchPartOrientation is the interface that defines the orientation of the part. If a type does not implement this interface an orientation of SWT.NONE will be assumed. Since: 3.1 See Also: SWT.RIGHT_TO_LEFT, SWT.LEFT_TO_RIGHT, SWT.NONE, Window.getDefaultOrientation() extends EditorPart A AbstractMultiEditor is a composite of editors. This class is intended to be subclassed. Since: 3.5 '
558, 'org.eclipse.jface.dialogs.IPageChangedListener', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/dialogs/IPageChangedListener.html', 'A listener which is notified when the current page of the multi-page dialog is changed. Since: 3.1 See Also: IPageChangeProvider, PageChangedEvent '
559, 'org.eclipse.ui.IWorkingSet', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/IWorkingSet.html', 'An interface for an adaptable object. Adaptable objects can be dynamically extended to provide different interfaces (or \"adapters\"). Adapters are created by adapter factories, which are in turn managed by type by adapter managers. For example, IAdaptable a = [some adaptable]; IFoo x = (IFoo)a.getAdapter(IFoo.class); if (x != null) [do IFoo things with x] This interface can be used without OSGi running. Clients may implement this interface, or obtain a default implementation of this interface by subclassing PlatformObject. See Also: IAdapterFactory, IAdapterManager, PlatformObject Objects implementing this interface are capable of saving their state in an IMemento. Since: 3.1 Objects implementing this interface are capable of saving their state in an IMemento. Since: 3.1 extends IPersistable Interface for asking an object to store its state in a memento. This interface is typically included in interfaces where persistance is required. When the workbench is shutdown objects which implement this interface will be persisted. At this time the getFactoryId method is invoked to discover the id of the element factory that will be used to re-create the object from a memento. Then the saveState method is invoked to store the element data into a newly created memento. The resulting mementos are collected up and written out to a single file. During workbench startup these mementos are read from the file. The factory Id for each is retrieved and mapped to an IElementFactory which has been registered in the element factory extension point. If a factory exists for the Id it will be engaged to re-create the original object. See Also: IAdaptable, IMemento, IElementFactory extends IPersistableElement, IAdaptable A working set holds a number of IAdaptable elements. A working set is intended to group elements for presentation to the user or for operations on a set of elements. Since: 2.0 initial version, 3.0 now extends IPersistableElement, 3.2 now extends IAdaptable Restriction: This interface is not intended to be implemented by clients. '
560, 'org.eclipse.ui.part.ShowInContext', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/part/ShowInContext.html', 'extends Object Carries the context for the Show In action. The default implementation carries an input and a selection. Subclasses may extend. Since: 2.1 See Also: IShowInSource, IShowInTarget '
561, 'org.eclipse.ui.part.IShowInSource', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/part/IShowInSource.html', 'Parts which need to provide a particular context to a Show In... target can provide this interface. The part can either directly implement this interface, or provide it via IAdaptable.getAdapter(IShowInSource.class). Since: 2.1 See Also: IShowInTarget '
562, 'org.eclipse.ui.IPartListener', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/IPartListener.html', 'Interface for listening to part lifecycle events. This interface may be implemented by clients. See Also: IPartService.addPartListener(IPartListener) '
563, 'org.eclipse.ui.INavigationHistory', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/INavigationHistory.html', 'Manages a list of entries to keep a history of locations on editors, enabling the user to go back and forward without losing context. The history is a list of INavigationLocation and a pointer to the current location. Whenever the back or forward action runs the history restores the previous or next location. The back and/or forward actions should not change the content of the history in any way. If the user steps N times in one direction (back or forward) and then N times to the oposite direction, the editor and location should be exactly the same as before. Clients must guarantee that the current location is always in the history, which can be done either by marking a new location or by updating the current location. Not intended to be implemented by clients. Since: 2.1 Restriction: This interface is not intended to be implemented by clients. '
564, 'org.eclipse.ui.IEditorMatchingStrategy', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/IEditorMatchingStrategy.html', 'An editor matching strategy allows editor extensions to provide their own algorithm for matching the input of an open editor of that type to a given editor input. This is used to find a matching editor during IWorkbenchPage.openEditor(IEditorInput, String, boolean) and IWorkbenchPage.findEditor(IEditorInput). Since: 3.1 '
565, 'org.eclipse.ui.model.IWorkbenchAdapter', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/model/IWorkbenchAdapter.html', 'This adapter interface provides visual presentation and hierarchical structure for workbench elements, allowing them to be displayed in the UI without having to know the concrete type of the element. There is an associate label provider and content provider for showing elements with a registered workbench adapter in JFace structured viewers. See Also: WorkbenchLabelProvider, BaseWorkbenchContentProvider '
566, 'org.eclipse.swt.dnd.DropTarget', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/dnd/DropTarget.html', 'extends Widget Class DropTarget defines the target object for a drag and drop transfer. IMPORTANT: This class is not intended to be subclassed. This class identifies the Control over which the user must position the cursor in order to drop the data being transferred. It also specifies what data types can be dropped on this control and what operations can be performed. You may have several DropTragets in an application but there can only be a one to one mapping between a Control and a DropTarget. The DropTarget can receive data from within the same application or from other applications (such as text dragged from a text editor like Word). int operations = DND.DROP_MOVE | DND.DROP_COPY | DND.DROP_LINK; Transfer[] types = new Transfer[] {TextTransfer.getInstance()}; DropTarget target = new DropTarget(label, operations); target.setTransfer(types); The application is notified of data being dragged over this control and of when a drop occurs by implementing the interface DropTargetListener which uses the class DropTargetEvent. The application can modify the type of drag being performed on this Control at any stage of the drag by modifying the event.detail field or the event.currentDataType field. When the data is dropped, it is the responsibility of the application to copy this data for its own purposes. target.addDropListener (new DropTargetListener() { public void dragEnter(DropTargetEvent event) {}; public void dragOver(DropTargetEvent event) {}; public void dragLeave(DropTargetEvent event) {}; public void dragOperationChanged(DropTargetEvent event) {}; public void dropAccept(DropTargetEvent event) {} public void drop(DropTargetEvent event) { // A drop has occurred, copy over the data if (event.data == null) { // no data to copy, indicate failure in event.detail event.detail = DND.DROP_NONE; return; } label.setText ((String) event.data); // data copied to label text } }); Styles DND.DROP_NONE, DND.DROP_COPY, DND.DROP_MOVE, DND.DROP_LINK Events DND.DragEnter, DND.DragLeave, DND.DragOver, DND.DragOperationChanged, DND.DropAccept, DND.Drop See Also: Drag and Drop snippets, SWT Example: DNDExample, Sample code and further information Restriction: This class is not intended to be subclassed by clients. '
567, 'org.eclipse.swt.dnd.DropTargetListener', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/dnd/DropTargetListener.html', 'extends org.eclipse.swt.internal.SWTEventListener The DropTargetListener class provides event notification to the application for DropTarget events. As the user moves the cursor into, over and out of a Control that has been designated as a DropTarget, events indicate what operation can be performed and what data can be transferred if a drop where to occur at that point. The application can respond to these events and change the type of data that will be dropped by modifying event.currentDataType, or change the operation that will be performed by modifying the event.detail field or stop any drop from happening on the current target by setting the event.detail field to DND_DROP_NONE. When the user causes a drop to happen by releasing the mouse over a valid drop target, the application has one last chance to change the data type of the drop through the DropAccept event. If the drop is still allowed, the DropAccept event is immediately followed by the Drop event. In the Drop event, the application can still change the operation that is performed but the data type is fixed. See Also: DropTargetEvent '
568, 'org.eclipse.ui.IReusableEditor', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/IReusableEditor.html', 'An interface for an adaptable object. Adaptable objects can be dynamically extended to provide different interfaces (or \"adapters\"). Adapters are created by adapter factories, which are in turn managed by type by adapter managers. For example, IAdaptable a = [some adaptable]; IFoo x = (IFoo)a.getAdapter(IFoo.class); if (x != null) [do IFoo things with x] This interface can be used without OSGi running. Clients may implement this interface, or obtain a default implementation of this interface by subclassing PlatformObject. See Also: IAdapterFactory, IAdapterManager, PlatformObject An interface for an adaptable object. Adaptable objects can be dynamically extended to provide different interfaces (or \"adapters\"). Adapters are created by adapter factories, which are in turn managed by type by adapter managers. For example, IAdaptable a = [some adaptable]; IFoo x = (IFoo)a.getAdapter(IFoo.class); if (x != null) [do IFoo things with x] This interface can be used without OSGi running. Clients may implement this interface, or obtain a default implementation of this interface by subclassing PlatformObject. See Also: IAdapterFactory, IAdapterManager, PlatformObject Workbench parts implement or adapt to this interface to participate in the enablement and execution of the Save and Save As actions. Since: 2.1 See Also: IEditorPart An interface for an adaptable object. Adaptable objects can be dynamically extended to provide different interfaces (or \"adapters\"). Adapters are created by adapter factories, which are in turn managed by type by adapter managers. For example, IAdaptable a = [some adaptable]; IFoo x = (IFoo)a.getAdapter(IFoo.class); if (x != null) [do IFoo things with x] This interface can be used without OSGi running. Clients may implement this interface, or obtain a default implementation of this interface by subclassing PlatformObject. See Also: IAdapterFactory, IAdapterManager, PlatformObject extends IAdaptable A workbench part is a visual component within a workbench page. There are two subtypes: view and editor, as defined by IViewPart and IEditorPart. A view is typically used to navigate a hierarchy of information (like the workspace), open an editor, or display properties for the active editor. Modifications made in a view are saved immediately. An editor is typically used to edit or browse a document or input object. The input is identified using an IEditorInput. Modifications made in an editor part follow an open-save-close lifecycle model. This interface may be implemented directly. For convenience, a base implementation is defined in WorkbenchPart. The lifecycle of a workbench part is as follows: When a part extension is created: instantiate the part create a part site call part.init(site) When a part becomes visible in the workbench: add part to presentation by calling part.createPartControl(parent) to create actual widgets fire partOpened event to all listeners When a part is activated or gets focus: call part.setFocus() fire partActivated event to all listeners When a part is closed: if save is needed, do save; if it fails or is canceled return if part is active, deactivate part fire partClosed event to all listeners remove part from presentation; part controls are disposed as part of the SWT widget tree call part.dispose() After createPartControl has been called, the implementor may safely reference the controls created. When the part is closed these controls will be disposed as part of an SWT composite. This occurs before the IWorkbenchPart.dispose method is called. If there is a need to free SWT resources the part should define a dispose listener for its own control and free those resources from the dispose listener. If the part invokes any method on the disposed SWT controls after this point an SWTError will be thrown. The last method called on IWorkbenchPart is dispose. This signals the end of the part lifecycle. An important point to note about this lifecycle is that following a call to init, createPartControl may never be called. Thus in the dispose method, implementors must not assume controls were created. Workbench parts implement the IAdaptable interface; extensions are managed by the platform\'s adapter manager. See Also: IViewPart, IEditorPart extends IWorkbenchPart, ISaveablePart An editor is a visual component within a workbench page. It is typically used to edit or browse a document or input object. The input is identified using an IEditorInput. Modifications made in an editor part follow an open-save-close lifecycle model (in contrast to a view part, where modifications are saved to the workbench immediately). An editor is document or input-centric. Each editor has an input, and only one editor can exist for each editor input within a page. This policy has been designed to simplify part management. An editor should be used in place of a view whenever more than one instance of a document type can exist. This interface may be implemented directly. For convenience, a base implementation is defined in EditorPart. An editor part is added to the workbench in two stages: An editor extension is contributed to the workbench registry. This extension defines the extension id, extension class, and the file extensions which are supported by the editor. An editor part based upon the extension is created and added to the workbench when the user opens a file with one of the supported file extensions (or some other suitable form of editor input). All editor parts implement the IAdaptable interface; extensions are managed by the platform\'s adapter manager. See Also: IWorkbenchPage.openEditor(IEditorInput, String), EditorPart Workbench parts implement or adapt to this interface to participate in the enablement and execution of the Save and Save As actions. Since: 2.1 See Also: IEditorPart An interface for an adaptable object. Adaptable objects can be dynamically extended to provide different interfaces (or \"adapters\"). Adapters are created by adapter factories, which are in turn managed by type by adapter managers. For example, IAdaptable a = [some adaptable]; IFoo x = (IFoo)a.getAdapter(IFoo.class); if (x != null) [do IFoo things with x] This interface can be used without OSGi running. Clients may implement this interface, or obtain a default implementation of this interface by subclassing PlatformObject. See Also: IAdapterFactory, IAdapterManager, PlatformObject extends IAdaptable A workbench part is a visual component within a workbench page. There are two subtypes: view and editor, as defined by IViewPart and IEditorPart. A view is typically used to navigate a hierarchy of information (like the workspace), open an editor, or display properties for the active editor. Modifications made in a view are saved immediately. An editor is typically used to edit or browse a document or input object. The input is identified using an IEditorInput. Modifications made in an editor part follow an open-save-close lifecycle model. This interface may be implemented directly. For convenience, a base implementation is defined in WorkbenchPart. The lifecycle of a workbench part is as follows: When a part extension is created: instantiate the part create a part site call part.init(site) When a part becomes visible in the workbench: add part to presentation by calling part.createPartControl(parent) to create actual widgets fire partOpened event to all listeners When a part is activated or gets focus: call part.setFocus() fire partActivated event to all listeners When a part is closed: if save is needed, do save; if it fails or is canceled return if part is active, deactivate part fire partClosed event to all listeners remove part from presentation; part controls are disposed as part of the SWT widget tree call part.dispose() After createPartControl has been called, the implementor may safely reference the controls created. When the part is closed these controls will be disposed as part of an SWT composite. This occurs before the IWorkbenchPart.dispose method is called. If there is a need to free SWT resources the part should define a dispose listener for its own control and free those resources from the dispose listener. If the part invokes any method on the disposed SWT controls after this point an SWTError will be thrown. The last method called on IWorkbenchPart is dispose. This signals the end of the part lifecycle. An important point to note about this lifecycle is that following a call to init, createPartControl may never be called. Thus in the dispose method, implementors must not assume controls were created. Workbench parts implement the IAdaptable interface; extensions are managed by the platform\'s adapter manager. See Also: IViewPart, IEditorPart extends IEditorPart Interface for reusable editors. An editors may support changing its input so that the workbench may change its contents instead of opening a new editor. '
569, 'org.eclipse.ui.IPathEditorInput', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/IPathEditorInput.html', 'An interface for an adaptable object. Adaptable objects can be dynamically extended to provide different interfaces (or \"adapters\"). Adapters are created by adapter factories, which are in turn managed by type by adapter managers. For example, IAdaptable a = [some adaptable]; IFoo x = (IFoo)a.getAdapter(IFoo.class); if (x != null) [do IFoo things with x] This interface can be used without OSGi running. Clients may implement this interface, or obtain a default implementation of this interface by subclassing PlatformObject. See Also: IAdapterFactory, IAdapterManager, PlatformObject An interface for an adaptable object. Adaptable objects can be dynamically extended to provide different interfaces (or \"adapters\"). Adapters are created by adapter factories, which are in turn managed by type by adapter managers. For example, IAdaptable a = [some adaptable]; IFoo x = (IFoo)a.getAdapter(IFoo.class); if (x != null) [do IFoo things with x] This interface can be used without OSGi running. Clients may implement this interface, or obtain a default implementation of this interface by subclassing PlatformObject. See Also: IAdapterFactory, IAdapterManager, PlatformObject extends IAdaptable IEditorInput is a light weight descriptor of editor input, like a file name but more abstract. It is not a model. It is a description of the model source for an IEditorPart. Clients implementing this editor input interface should override Object.equals(Object) to answer true for two inputs that are the same. The IWorbenchPage.openEditor APIs are dependent on this to find an editor with the same input. Clients should extend this interface to declare new types of editor inputs. An editor input is passed to an editor via the IEditorPart.init method. Due to the wide range of valid editor inputs, it is not possible to define generic methods for getting and setting bytes. Editor input must implement the IAdaptable interface; extensions are managed by the platform\'s adapter manager. Please note that it is important that the editor input be light weight. Within the workbench, the navigation history tends to hold on to editor inputs as a means of reconstructing the editor at a later time. The navigation history can hold on to quite a few inputs (i.e., the default is fifty). The actual data model should probably not be held in the input. See Also: IEditorPart, IWorkbenchPage.openEditor(IEditorInput, String), IWorkbenchPage.openEditor(IEditorInput, String, boolean) extends IEditorInput This interface defines an editor input based on the local file system path of a file. Clients implementing this editor input interface should override Object.equals(Object) to answer true for two inputs that are the same. The IWorkbenchPage.openEditor APIs are dependent on this to find an editor with the same input. Path-oriented editors should support this as a valid input type, and can allow full read-write editing of its content. All editor inputs must implement the IAdaptable interface; extensions are managed by the platform\'s adapter manager. Since: 3.0 See Also: IPath '
570, 'org.eclipse.ui.IShowEditorInput', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/IShowEditorInput.html', 'Shows the given editor input. Used when an editor is being opened and an existing editor\'s input matches the one being opened. Editors can optionally implement this interface, giving the editor the opportunity to show the given input if it represents a different subset of the editor\'s content than the one currently being shown. Since: 3.1 '
571, 'org.eclipse.swt.program.Program', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/program/Program.html', 'extends Object Instances of this class represent programs and their associated file extensions in the operating system. See Also: Program snippets, Sample code and further information '
572, 'org.eclipse.ui.IEditorDescriptor', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/IEditorDescriptor.html', 'Description of a workbench part. The part descriptor contains the information needed to create part instances. This interface is not intended to be implemented by clients. Restriction: This interface is not intended to be implemented by clients. extends IWorkbenchPartDescriptor Description of an editor in the workbench editor registry. The editor descriptor contains the information needed to create editor instances. An editor descriptor typically represents one of three types of editors: a file editor extension for a specific file extension. a file editor added by the user (via the workbench preference page) a general editor extension which works on objects other than files. This interface is not intended to be implemented or extended by clients. See Also: IEditorRegistry Restriction: This interface is not intended to be implemented by clients. '
573, 'org.eclipse.ui.ISaveablePart2', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/ISaveablePart2.html', 'Workbench parts implement or adapt to this interface to participate in the enablement and execution of the Save and Save As actions. Since: 2.1 See Also: IEditorPart extends ISaveablePart Workbench parts implement or adapt to this interface to participate in actions that require a prompt for the user to provide input on what to do with unsaved data when the part is closed or the Workbench is shut down. Note that if a part implements this interface, it is excluded from the common \"prompt to save\" dialog, and instead opens its own dialog. This may cause multiple prompts to the end user during a single user operation. Implementors should be aware that this may lead to a less than optimal user experience. Since: 3.1 '
574, 'org.eclipse.ui.model.WorkbenchPartLabelProvider', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/model/WorkbenchPartLabelProvider.html', 'A label provider maps an element of the viewer\'s model to an optional image and optional text string used to display the element in the viewer\'s control. Certain label providers may allow multiple labels per element. This is an \"abstract interface\", defining methods common to all label providers, but does not actually define the methods to get the label(s) for an element. This interface should never be directly implemented. Most viewers will take either an ILabelProvider or an ITableLabelProvider. A label provider must not be shared between viewers since a label provider generally manages SWT resources (images), which must be disposed when the viewer is disposed. To simplify life cycle management, the current label provider of a viewer is disposed when the viewer is disposed. Label providers can be used outside the context of viewers wherever images are needed. When label providers are used in this fashion it is the responsibility of the user to ensure dispose is called when the provider is no longer needed. See Also: ILabelProvider, ITableLabelProvider A label provider maps an element of the viewer\'s model to an optional image and optional text string used to display the element in the viewer\'s control. Certain label providers may allow multiple labels per element. This is an \"abstract interface\", defining methods common to all label providers, but does not actually define the methods to get the label(s) for an element. This interface should never be directly implemented. Most viewers will take either an ILabelProvider or an ITableLabelProvider. A label provider must not be shared between viewers since a label provider generally manages SWT resources (images), which must be disposed when the viewer is disposed. To simplify life cycle management, the current label provider of a viewer is disposed when the viewer is disposed. Label providers can be used outside the context of viewers wherever images are needed. When label providers are used in this fashion it is the responsibility of the user to ensure dispose is called when the provider is no longer needed. See Also: ILabelProvider, ITableLabelProvider extends IBaseLabelProvider Extends IBaseLabelProvider with the methods to provide the text and/or image for the label of a given element. Used by most structured viewers, except table viewers. A label provider maps an element of the viewer\'s model to an optional image and optional text string used to display the element in the viewer\'s control. Certain label providers may allow multiple labels per element. This is an \"abstract interface\", defining methods common to all label providers, but does not actually define the methods to get the label(s) for an element. This interface should never be directly implemented. Most viewers will take either an ILabelProvider or an ITableLabelProvider. A label provider must not be shared between viewers since a label provider generally manages SWT resources (images), which must be disposed when the viewer is disposed. To simplify life cycle management, the current label provider of a viewer is disposed when the viewer is disposed. Label providers can be used outside the context of viewers wherever images are needed. When label providers are used in this fashion it is the responsibility of the user to ensure dispose is called when the provider is no longer needed. See Also: ILabelProvider, ITableLabelProvider extends IBaseLabelProvider Extends IBaseLabelProvider with the methods to provide the text and/or image for each column of a given element. Used by table viewers. See Also: TableViewer extends LabelProvider implements ITableLabelProvider A table label provider implementation for showing workbench views and editors (objects of type IWorkbenchPart) in tree- and table-structured viewers. Clients may instantiate this class. It is not intended to be subclassed. Since: 3.0 '
575, 'org.eclipse.core.runtime.SubProgressMonitor', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/runtime/SubProgressMonitor.html', 'The IProgressMonitor interface is implemented by objects that monitor the progress of an activity; the methods in this interface are invoked by code that performs the activity. All activity is broken down into a linear sequence of tasks against which progress is reported. When a task begins, a beginTask(String, int) notification is reported, followed by any number and mixture of progress reports (worked()) and subtask notifications (subTask(String)). When the task is eventually completed, a done() notification is reported. After the done() notification, the progress monitor cannot be reused; i.e., beginTask(String, int) cannot be called again after the call to done(). A request to cancel an operation can be signaled using the setCanceled method. Operations taking a progress monitor are expected to poll the monitor (using isCanceled) periodically and abort at their earliest convenience. Operation can however choose to ignore cancelation requests. Since notification is synchronous with the activity itself, the listener should provide a fast and robust implementation. If the handling of notifications would involve blocking operations, or operations which might throw uncaught exceptions, the notifications should be queued, and the actual processing deferred (or perhaps delegated to a separate thread). This interface can be used without OSGi running. Clients may implement this interface. extends IProgressMonitor An extension to the IProgressMonitor interface for monitors that want to support feedback when an activity is blocked due to concurrent activity in another thread. When a monitor that supports this extension is passed to an operation, the operation should call setBlocked whenever it knows that it must wait for a lock that is currently held by another thread. The operation should continue to check for and respond to cancelation requests while blocked. When the operation is no longer blocked, it must call clearBlocked to clear the blocked state. This interface can be used without OSGi running. Clients may implement this interface. Since: 3.0 See Also: IProgressMonitor extends ProgressMonitorWrapper For new implementations consider using SubMonitor. A progress monitor that uses a given amount of work ticks from a parent monitor. It can be used as follows: try { pm.beginTask(\"Main Task\", 100); doSomeWork(pm, 30); SubProgressMonitor subMonitor= new SubProgressMonitor(pm, 40); try { subMonitor.beginTask(\"\", 300); doSomeWork(subMonitor, 300); } finally { subMonitor.done(); } doSomeWork(pm, 30); } finally { pm.done(); } This class can be used without OSGi running. This class may be instantiated or subclassed by clients. See Also: SubMonitor '
576, 'org.eclipse.ui.ISaveablesSource', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/ISaveablesSource.html', 'Represents a source of Saveable objects (units of saveability). Workbench parts that show more than one unit of saveability, or whose units of saveability change over time, should implement this interface in order to provide better integration with workbench facilities like the Save command, prompts to save on part close or shutdown, etc. IMPORTANT: As of 3.2, implementers of ISaveablesSource must satisfy the following conditions: If ISaveablesSource is implemented by an IWorkbenchPart: the part must implement ISaveablePart if any of its Saveable objects are dirty, the part must return true from ISaveablePart.isDirty() the part must return true from ISaveablePart.isSaveOnCloseNeeded() if it is dirty (the default behaviour implemented by EditorPart) the part must not implement ISaveablePart2 If ISaveablesSource is implemented by a non-part (possible as of 3.2.1 and 3.3): the Workbench\'s ISaveablesLifecycleListener (obtained from the Workbench by calling workbench.getService(ISaveablesLifecycleListener.class)) must be notified of any change to the result of getSaveables() getActiveSaveables() should be implemented to return an empty array If any of these conditions are not met, it is undefined whether the Workbench will prompt to save dirty Saveables when closing parts or the Workbench. These conditions may be relaxed in future releases. Since: 3.2 '
577, 'org.eclipse.ui.views.IStickyViewDescriptor', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/views/IStickyViewDescriptor.html', 'Supplemental view interface that describes various sticky characteristics that a view may possess. This interface is not intended to be implemented by clients. Since: 3.1 See Also: IViewRegistry, IViewDescriptor Restriction: This interface is not intended to be implemented by clients. '
578, 'org.eclipse.jface.dialogs.IPageChangeProvider', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/dialogs/IPageChangeProvider.html', 'Minimal interface to a page change provider. Used for dialogs which can switch between multiple pages. Since: 3.1 '
579, 'org.eclipse.ui.IEditorLauncher', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/IEditorLauncher.html', 'An editor launcher is used to launch external editors on a file in the local file system. Clients should implement this interface to define a new type of editor launcher. Each new launcher must be registered as an editor in the workbench\'s editor extension point (named \"org.eclipse.ui.editors\"). For example, the plug-in\'s XML markup might contain: <extension point = \"org.eclipse.ui.editors\"> <editor id=\"org.eclipse.ui.SwingEditorLauncher\" name=\"Swing Editor\" extensions=\"xml\" launcher=\"org.eclipse.ui.examples.swingeditor.SwingEditorLauncher\" icon=\"icons/xml.gif\"> </editor> </extension> In this example a launcher has been registered for use with xml files. Once registered, the launcher will appear in the Open With menu for an xml file. If the item is invoked the workbench will create an instance of the launcher class and call open on it, passing the input file. '
580, 'org.eclipse.e4.ui.model.application.commands.MBindings', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/e4/ui/model/application/commands/MBindings.html', ' A representation of the model object \'Bindings\'. Mixin interface that lists MBindingContexts that should be active when this object is active. Example values: org.eclipse.ui.contexts.dialog, org.eclipse.ui.contexts.window Since: 1.0 The following features are supported: Binding Contexts '
581, 'org.eclipse.e4.ui.model.application.commands.MKeySequence', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/e4/ui/model/application/commands/MKeySequence.html', ' A representation of the model object \'Key Sequence\'. This represents the sequence of characters in a KeyBinding whose detection will fire the associated Command. Since: 1.0 The following features are supported: Key Sequence '
582, 'org.eclipse.e4.ui.model.application.ui.MGenericTrimContainer', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/e4/ui/model/application/ui/MGenericTrimContainer.html', ' A representation of the model object \'Element\'. This is the root element for all UI Model elements, defining attribtues common to every element; the element\'s id as well as three general storage elements: Tags: This is a set of strings which can be used to stereotype a particular element. Tags may be specified in element searches and can also be referred to in the CSS styling definition. PersistedState: A string to string map used to store information that nneds to be persisted between sessions. TransientData: A string to object map which can be used to store runtime data relevant to a particular model element. Since: 1.0 The following features are supported: Element Id Persisted State Tags Contributor URI Transient Data A representation of the model object \'Element\'. This is the root element for all UI Model elements, defining attribtues common to every element; the element\'s id as well as three general storage elements: Tags: This is a set of strings which can be used to stereotype a particular element. Tags may be specified in element searches and can also be referred to in the CSS styling definition. PersistedState: A string to string map used to store information that nneds to be persisted between sessions. TransientData: A string to object map which can be used to store runtime data relevant to a particular model element. Since: 1.0 The following features are supported: Element Id Persisted State Tags Contributor URI Transient Data extends MApplicationElement A representation of the model object \'UI Element\'. This is the base mix-in shared by all model elements that can be rendered into the UI presentation of the application. Its main job is to manage the bindings between the concrete element and the UI \'widget\' representing it in the UI. Since: 1.0 The following features are supported: Widget Renderer To Be Rendered On Top Visible Parent Container Data Cur Shared Ref Visible When Accessibility Phrase T extends MUIElement> extends MElementContainer<T> A representation of the model object \'Generic Trim Container\'. This provides a collection specifically for TrimBars. Since: 1.0 The following features are supported: Side '
583, 'org.eclipse.e4.ui.model.application.commands.MBindingTableContainer', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/e4/ui/model/application/commands/MBindingTableContainer.html', ' A representation of the model object \'Binding Table Container\'. This type contains the list of binding \'tables\', representing the various sets of bindings based on the applicaiton\'s current running \'context\'. Here the \'context\' represents the applicaiton\'s UI state (i.e. whenther a Dialog is open...). Since: 1.0 The following features are supported: Binding Tables Root Context '
584, 'org.eclipse.e4.ui.model.application.descriptor.basic.MPartDescriptorContainer', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/e4/ui/model/application/descriptor/basic/MPartDescriptorContainer.html', ' A representation of the model object \'Part Descriptor Container\'. A type specific collection of PartDescriptors. Since: 1.0 The following features are supported: Descriptors '
585, 'org.eclipse.e4.ui.model.application.ui.menu.MMenuContributions', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/e4/ui/model/application/ui/menu/MMenuContributions.html', ' A representation of the model object \'Contributions\'. Provisional for 4.3. This is a container aggregating the menu contributions to be applied to menus. Since: 1.0 The following features are supported: Menu Contributions Restriction: This interface is not intended to be referenced by clients. '
586, 'org.eclipse.e4.ui.model.application.ui.menu.MToolBarContributions', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/e4/ui/model/application/ui/menu/MToolBarContributions.html', ' A representation of the model object \'Tool Bar Contributions\'. Provisional for 4.3. This is a container aggregating the toolbar contributions to be applied to existing toolbars. Since: 1.0 The following features are supported: Tool Bar Contributions Restriction: This interface is not intended to be referenced by clients. '
587, 'org.eclipse.e4.ui.model.application.ui.menu.MTrimContributions', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/e4/ui/model/application/ui/menu/MTrimContributions.html', ' A representation of the model object \'Trim Contributions\'. Provisional for 4.3. This is a container aggregating the trim bar contributions to be applied. Since: 1.0 The following features are supported: Trim Contributions Restriction: This interface is not intended to be referenced by clients. '
588, 'org.eclipse.e4.ui.model.application.ui.MUiFactory', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/e4/ui/model/application/ui/MUiFactory.html', ' The Factory for the model. It provides a create method for each non-abstract class of the model. Since: 1.0 '
589, 'org.eclipse.core.databinding.observable.list.IObservableList', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/databinding/observable/list/IObservableList.html', 'An object with state that allows to listen for state changes. Implementations must not manage listeners themselves, listener management must be delegated to a private instance of type ChangeSupport if it is not inherited from AbstractObservable. Since: 1.0 Restriction: This interface is not intended to be implemented by clients. Clients should instead subclass one of the classes in the framework that implement this interface. Note that direct implementers of this interface outside of the framework will be broken in future releases when methods are added to this interface. extends IObservable, Collection Interface for observable collections. Only general change listeners can be added to an observable collection. Listeners interested in incremental changes have to be added using more concrete subtypes such as IObservableList or IObservableSet. Since: 1.0 Restriction: This interface is not intended to be implemented by clients. Clients should instead subclass one of the classes that implement this interface. Note that direct implementers of this interface outside of the framework will be broken in future releases when methods are added to this interface. Restriction: This interface is not intended to be extended by clients. extends List, IObservableCollection A list whose changes can be tracked by list change listeners. Since: 1.0 See Also: AbstractObservableList, ObservableList Restriction: This interface is not intended to be implemented by clients. Clients should instead subclass one of the framework classes that implement this interface. Note that direct implementers of this interface outside of the framework will be broken in future releases when methods are added to this interface. '
590, 'org.eclipse.core.databinding.observable.list.WritableList', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/databinding/observable/list/WritableList.html', 'An object with state that allows to listen for state changes. Implementations must not manage listeners themselves, listener management must be delegated to a private instance of type ChangeSupport if it is not inherited from AbstractObservable. Since: 1.0 Restriction: This interface is not intended to be implemented by clients. Clients should instead subclass one of the classes in the framework that implement this interface. Note that direct implementers of this interface outside of the framework will be broken in future releases when methods are added to this interface. extends IObservable, Collection Interface for observable collections. Only general change listeners can be added to an observable collection. Listeners interested in incremental changes have to be added using more concrete subtypes such as IObservableList or IObservableSet. Since: 1.0 Restriction: This interface is not intended to be implemented by clients. Clients should instead subclass one of the classes that implement this interface. Note that direct implementers of this interface outside of the framework will be broken in future releases when methods are added to this interface. Restriction: This interface is not intended to be extended by clients. An object with state that allows to listen for state changes. Implementations must not manage listeners themselves, listener management must be delegated to a private instance of type ChangeSupport if it is not inherited from AbstractObservable. Since: 1.0 Restriction: This interface is not intended to be implemented by clients. Clients should instead subclass one of the classes in the framework that implement this interface. Note that direct implementers of this interface outside of the framework will be broken in future releases when methods are added to this interface. extends IObservable, Collection Interface for observable collections. Only general change listeners can be added to an observable collection. Listeners interested in incremental changes have to be added using more concrete subtypes such as IObservableList or IObservableSet. Since: 1.0 Restriction: This interface is not intended to be implemented by clients. Clients should instead subclass one of the classes that implement this interface. Note that direct implementers of this interface outside of the framework will be broken in future releases when methods are added to this interface. Restriction: This interface is not intended to be extended by clients. extends List, IObservableCollection A list whose changes can be tracked by list change listeners. Since: 1.0 See Also: AbstractObservableList, ObservableList Restriction: This interface is not intended to be implemented by clients. Clients should instead subclass one of the framework classes that implement this interface. Note that direct implementers of this interface outside of the framework will be broken in future releases when methods are added to this interface. extends ObservableList Mutable observable list backed by an ArrayList. This class is thread safe. All state accessing methods must be invoked from the current realm. Methods for adding and removing listeners may be invoked from any thread. Since: 1.0 '
591, 'org.eclipse.jface.layout.TableColumnLayout', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/layout/TableColumnLayout.html', 'extends AbstractColumnLayout The TableColumnLayout is the Layout used to maintain TableColumn sizes in a Table. You can only add the Layout to a container whose only child is the Table control you want the Layout applied to. Don\'t assign the layout directly the Table Since: 3.3 '
592, 'org.eclipse.jface.viewers.TableViewerColumn', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/viewers/TableViewerColumn.html', 'extends ViewerColumn ViewerColumn implementation for TableViewer to enable column-specific label providers and editing support. Since: 3.3 '
593, 'org.eclipse.jface.viewers.ColumnWeightData', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/viewers/ColumnWeightData.html', 'extends ColumnLayoutData Describes the width of a table column in terms of a weight, a minimum width, and whether the column is resizable. This class may be instantiated; it is not intended to be subclassed. Restriction: This class is not intended to be subclassed by clients. '
594, 'org.eclipse.jface.databinding.viewers.ObservableListContentProvider', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/databinding/viewers/ObservableListContentProvider.html', 'A content provider mediates between the viewer\'s model and the viewer itself. See Also: ContentViewer.setContentProvider(IContentProvider) extends IContentProvider An interface to content providers for structured viewers. See Also: StructuredViewer extends Object implements IStructuredContentProvider A content provider for AbstractTableViewer or AbstractListViewer that provides elements of an IObservableList when set as the viewer\'s input. Objects of this class listen for changes to the observable list, and will insert and remove viewer elements to reflect observed changes. Since: 1.1 Restriction: This class is not intended to be subclassed by clients. '
595, 'org.eclipse.jface.databinding.viewers.ObservableMapLabelProvider', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/databinding/viewers/ObservableMapLabelProvider.html', 'A label provider maps an element of the viewer\'s model to an optional image and optional text string used to display the element in the viewer\'s control. Certain label providers may allow multiple labels per element. This is an \"abstract interface\", defining methods common to all label providers, but does not actually define the methods to get the label(s) for an element. This interface should never be directly implemented. Most viewers will take either an ILabelProvider or an ITableLabelProvider. A label provider must not be shared between viewers since a label provider generally manages SWT resources (images), which must be disposed when the viewer is disposed. To simplify life cycle management, the current label provider of a viewer is disposed when the viewer is disposed. Label providers can be used outside the context of viewers wherever images are needed. When label providers are used in this fashion it is the responsibility of the user to ensure dispose is called when the provider is no longer needed. See Also: ILabelProvider, ITableLabelProvider A label provider maps an element of the viewer\'s model to an optional image and optional text string used to display the element in the viewer\'s control. Certain label providers may allow multiple labels per element. This is an \"abstract interface\", defining methods common to all label providers, but does not actually define the methods to get the label(s) for an element. This interface should never be directly implemented. Most viewers will take either an ILabelProvider or an ITableLabelProvider. A label provider must not be shared between viewers since a label provider generally manages SWT resources (images), which must be disposed when the viewer is disposed. To simplify life cycle management, the current label provider of a viewer is disposed when the viewer is disposed. Label providers can be used outside the context of viewers wherever images are needed. When label providers are used in this fashion it is the responsibility of the user to ensure dispose is called when the provider is no longer needed. See Also: ILabelProvider, ITableLabelProvider extends IBaseLabelProvider Extends IBaseLabelProvider with the methods to provide the text and/or image for the label of a given element. Used by most structured viewers, except table viewers. A label provider maps an element of the viewer\'s model to an optional image and optional text string used to display the element in the viewer\'s control. Certain label providers may allow multiple labels per element. This is an \"abstract interface\", defining methods common to all label providers, but does not actually define the methods to get the label(s) for an element. This interface should never be directly implemented. Most viewers will take either an ILabelProvider or an ITableLabelProvider. A label provider must not be shared between viewers since a label provider generally manages SWT resources (images), which must be disposed when the viewer is disposed. To simplify life cycle management, the current label provider of a viewer is disposed when the viewer is disposed. Label providers can be used outside the context of viewers wherever images are needed. When label providers are used in this fashion it is the responsibility of the user to ensure dispose is called when the provider is no longer needed. See Also: ILabelProvider, ITableLabelProvider extends IBaseLabelProvider Extends IBaseLabelProvider with the methods to provide the text and/or image for each column of a given element. Used by table viewers. See Also: TableViewer extends LabelProvider implements ILabelProvider, ITableLabelProvider A label provider based on one or more observable maps that track attributes that this label provider uses for display. Clients may customize by subclassing and overriding getColumnText(Object, int), getColumnImage(Object, int), for tables or trees with columns, or by implementing additional mixin interfaces for colors, fonts etc. Since: 1.1 '
596, 'org.eclipse.core.databinding.observable.map.IObservableMap', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/databinding/observable/map/IObservableMap.html', 'An object with state that allows to listen for state changes. Implementations must not manage listeners themselves, listener management must be delegated to a private instance of type ChangeSupport if it is not inherited from AbstractObservable. Since: 1.0 Restriction: This interface is not intended to be implemented by clients. Clients should instead subclass one of the classes in the framework that implement this interface. Note that direct implementers of this interface outside of the framework will be broken in future releases when methods are added to this interface. extends Map, IObservable Observable Map. Since: 1.1 See Also: AbstractObservableMap, ObservableMap Restriction: This interface is not intended to be implemented by clients. Clients should instead subclass one of the classes that implement this interface. Note that direct implementers of this interface outside of the framework will be broken in future releases when methods are added to this interface. '
597, 'org.eclipse.core.databinding.beans.BeansObservables', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/databinding/beans/BeansObservables.html', 'extends Object A factory for creating observable objects of Java objects that conform to the JavaBean specification for bound properties. Since: 1.1 '
598, 'org.eclipse.jface.viewers.ContentViewer', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/viewers/ContentViewer.html', 'Interface common to all objects that provide an input. extends IInputProvider, ISelectionProvider Interface common to all objects that provide both an input and a selection. Interface common to all objects that provide a selection. See Also: ISelection, ISelectionChangedListener, SelectionChangedEvent extends Viewer A content viewer is a model-based adapter on a widget which accesses its model by means of a content provider and a label provider. A viewer\'s model consists of elements, represented by objects. A viewer defines and implements generic infrastructure for handling model input, updates, and selections in terms of elements. Input is obtained by querying an IContentProvider which returns elements. The elements themselves are not displayed directly. They are mapped to labels, containing text and/or an image, using the viewer\'s ILabelProvider. Implementing a concrete content viewer typically involves the following steps: create SWT controls for viewer (in constructor) (optional) initialize SWT controls from input (inputChanged) define viewer-specific update methods support selections (setSelection, getSelection) '
599, 'org.eclipse.jface.viewers.IElementComparer', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/viewers/IElementComparer.html', 'This interface is used to compare elements in a viewer for equality, and to provide the hash code for an element. This allows the client of the viewer to specify different equality criteria and a different hash code implementation than the equals and hashCode implementations of the elements themselves. See Also: StructuredViewer.setComparer(org.eclipse.jface.viewers.IElementComparer) '
600, 'org.eclipse.jface.viewers.StructuredViewerInternals.AssociateListener', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/viewers/StructuredViewerInternals.AssociateListener.html', 'Nothing to see here. Since: 3.5 Restriction: This interface is not intended to be implemented by clients. Restriction: This interface is not intended to be extended by clients. '
601, 'org.eclipse.jface.viewers.IOpenListener', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/viewers/IOpenListener.html', 'A listener which is notified of open events on viewers. '
602, 'org.eclipse.swt.dnd.DragSource', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/dnd/DragSource.html', 'extends Widget DragSource defines the source object for a drag and drop transfer. IMPORTANT: This class is not intended to be subclassed. A drag source is the object which originates a drag and drop operation. For the specified widget, it defines the type of data that is available for dragging and the set of operations that can be performed on that data. The operations can be any bit-wise combination of DND.MOVE, DND.COPY or DND.LINK. The type of data that can be transferred is specified by subclasses of Transfer such as TextTransfer or FileTransfer. The type of data transferred can be a predefined system type or it can be a type defined by the application. For instructions on how to define your own transfer type, refer to ByteArrayTransfer. You may have several DragSources in an application but you can only have one DragSource per Control. Data dragged from this DragSource can be dropped on a site within this application or it can be dropped on another application such as an external Text editor. The application supplies the content of the data being transferred by implementing the DragSourceListener and associating it with the DragSource via DragSource#addDragListener. When a successful move operation occurs, the application is required to take the appropriate action to remove the data from its display and remove any associated operating system resources or internal references. Typically in a move operation, the drop target makes a copy of the data and the drag source deletes the original. However, sometimes copying the data can take a long time (such as copying a large file). Therefore, on some platforms, the drop target may actually move the data in the operating system rather than make a copy. This is usually only done in file transfers. In this case, the drag source is informed in the DragEnd event that a DROP_TARGET_MOVE was performed. It is the responsibility of the drag source at this point to clean up its displayed information. No action needs to be taken on the operating system resources. The following example shows a Label widget that allows text to be dragged from it. // Enable a label as a Drag Source Label label = new Label(shell, SWT.NONE); // This example will allow text to be dragged Transfer[] types = new Transfer[] {TextTransfer.getInstance()}; // This example will allow the text to be copied or moved to the drop target int operations = DND.DROP_MOVE | DND.DROP_COPY; DragSource source = new DragSource(label, operations); source.setTransfer(types); source.addDragListener(new DragSourceListener() { public void dragStart(DragSourceEvent e) { // Only start the drag if there is actually text in the // label - this text will be what is dropped on the target. if (label.getText().length() == 0) { event.doit = false; } }; public void dragSetData(DragSourceEvent event) { // A drop has been performed, so provide the data of the // requested type. // (Checking the type of the requested data is only // necessary if the drag source supports more than // one data type but is shown here as an example). if (TextTransfer.getInstance().isSupportedType(event.dataType)){ event.data = label.getText(); } } public void dragFinished(DragSourceEvent event) { // A Move operation has been performed so remove the data // from the source if (event.detail == DND.DROP_MOVE) label.setText(\"\"); } }); Styles DND.DROP_NONE, DND.DROP_COPY, DND.DROP_MOVE, DND.DROP_LINK Events DND.DragStart, DND.DragSetData, DND.DragEnd See Also: Drag and Drop snippets, SWT Example: DNDExample, Sample code and further information Restriction: This class is not intended to be subclassed by clients. '
603, 'org.eclipse.swt.dnd.DragSourceListener', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/dnd/DragSourceListener.html', 'extends org.eclipse.swt.internal.SWTEventListener The DragSourceListener class provides event notification to the application for DragSource events. When the user drops data on a DropTarget, the application which defines the DragSource must provide the dropped data by implementing dragSetData. In the dragSetData, the application must support all the data types that were specified in the DragSource#setTransfer method. After the drop has completed successfully or has been aborted, the application which defines the DragSource is required to take the appropriate cleanup action. In the case of a successful move operation, the application must remove the data that was transferred. '
604, 'org.eclipse.jface.util.Policy', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/util/Policy.html', 'extends Object The Policy class handles settings for behaviour, debug flags and logging within JFace. Since: 3.0 '
605, 'org.eclipse.jface.viewers.OpenEvent', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/viewers/OpenEvent.html', 'extends EventObject Event object describing an open which may be generated from a selection or default selection event. The source of these events is a viewer. See Also: IOpenListener, Serialized Form '
606, 'org.eclipse.jface.viewers.IStructuredContentProvider', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/viewers/IStructuredContentProvider.html', 'A content provider mediates between the viewer\'s model and the viewer itself. See Also: ContentViewer.setContentProvider(IContentProvider) extends IContentProvider An interface to content providers for structured viewers. See Also: StructuredViewer '
607, 'org.eclipse.jface.viewers.LabelProviderChangedEvent', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/viewers/LabelProviderChangedEvent.html', 'extends EventObject Event object describing a label provider state change. See Also: ILabelProviderListener, Serialized Form '
608, 'org.eclipse.jface.util.IOpenEventListener', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/util/IOpenEventListener.html', 'Listener for open events which are generated on selection of default selection depending on the user preferences. Usage: OpenStrategy handler = new OpenStrategy(control); handler.addOpenListener(new IOpenEventListener() { public void handleOpen(SelectionEvent e) { ... // code to handle the open event. } }); See Also: OpenStrategy '
609, 'org.eclipse.jface.viewers.IBaseLabelProvider', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/viewers/IBaseLabelProvider.html', 'A label provider maps an element of the viewer\'s model to an optional image and optional text string used to display the element in the viewer\'s control. Certain label providers may allow multiple labels per element. This is an \"abstract interface\", defining methods common to all label providers, but does not actually define the methods to get the label(s) for an element. This interface should never be directly implemented. Most viewers will take either an ILabelProvider or an ITableLabelProvider. A label provider must not be shared between viewers since a label provider generally manages SWT resources (images), which must be disposed when the viewer is disposed. To simplify life cycle management, the current label provider of a viewer is disposed when the viewer is disposed. Label providers can be used outside the context of viewers wherever images are needed. When label providers are used in this fashion it is the responsibility of the user to ensure dispose is called when the provider is no longer needed. See Also: ILabelProvider, ITableLabelProvider '
610, 'org.eclipse.jface.viewers.ViewerLabel', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/viewers/ViewerLabel.html', 'extends Object The ViewerLabel is the class that is passed to a viewer to handle updates of labels. It keeps track of both original and updates text. Since: 3.0 See Also: IViewerLabelProvider '
611, 'org.eclipse.jface.viewers.IViewerLabelProvider', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/viewers/IViewerLabelProvider.html', 'A label provider maps an element of the viewer\'s model to an optional image and optional text string used to display the element in the viewer\'s control. Certain label providers may allow multiple labels per element. This is an \"abstract interface\", defining methods common to all label providers, but does not actually define the methods to get the label(s) for an element. This interface should never be directly implemented. Most viewers will take either an ILabelProvider or an ITableLabelProvider. A label provider must not be shared between viewers since a label provider generally manages SWT resources (images), which must be disposed when the viewer is disposed. To simplify life cycle management, the current label provider of a viewer is disposed when the viewer is disposed. Label providers can be used outside the context of viewers wherever images are needed. When label providers are used in this fashion it is the responsibility of the user to ensure dispose is called when the provider is no longer needed. See Also: ILabelProvider, ITableLabelProvider extends IBaseLabelProvider Extends IBaseLabelProvider with the methods to update the label for a given element. The label is represented by a ViewerLabel. Unlike ILabelProvider, this allows the text and image to be set in the same request, rather than via separate requests. It also allows the current values for the text and image to be considered by the label provider, allowing for potential optimizations. For example, decorating label providers that run in the background can hold off applying an update to a previously populated label until the decoration is ready, thereby reducing flicker. Since: 3.0 See Also: IDelayedLabelDecorator '
612, 'org.eclipse.jface.viewers.TreePath', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/viewers/TreePath.html', 'extends Object A tree path denotes a model element in a tree viewer. Tree path objects have value semantics. A model element is represented by a path of elements in the tree from the root element to the leaf element. Clients may instantiate this class. Not intended to be subclassed. Since: 3.2 '
613, 'org.eclipse.jface.viewers.ITreePathLabelProvider', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/viewers/ITreePathLabelProvider.html', 'A label provider maps an element of the viewer\'s model to an optional image and optional text string used to display the element in the viewer\'s control. Certain label providers may allow multiple labels per element. This is an \"abstract interface\", defining methods common to all label providers, but does not actually define the methods to get the label(s) for an element. This interface should never be directly implemented. Most viewers will take either an ILabelProvider or an ITableLabelProvider. A label provider must not be shared between viewers since a label provider generally manages SWT resources (images), which must be disposed when the viewer is disposed. To simplify life cycle management, the current label provider of a viewer is disposed when the viewer is disposed. Label providers can be used outside the context of viewers wherever images are needed. When label providers are used in this fashion it is the responsibility of the user to ensure dispose is called when the provider is no longer needed. See Also: ILabelProvider, ITableLabelProvider extends IBaseLabelProvider An extension to ILabelProvider that is given the path of the element being decorated, when it is available. Since: 3.2 '
614, 'org.eclipse.jface.viewers.ColumnViewerToolTipSupport', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/viewers/ColumnViewerToolTipSupport.html', 'extends DefaultToolTip The ColumnViewerTooltipSupport is the class that provides tool tips for ColumnViewers. Since: 3.3 '
615, 'org.eclipse.ui.dialogs.WizardResourceImportPage', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/dialogs/WizardResourceImportPage.html', 'Interface for a page in a multi-page dialog. Minimal interface to a message provider. Used for dialog pages which can provide a message with an icon. Since: 2.0 extends IDialogPage Interface for a wizard page. The class WizardPage provides an abstract implementation of this interface. However, clients are also free to implement this interface if WizardPage does not suit their needs. Implementers of Listener provide a simple handleEvent() method that is used internally by SWT to dispatch events. After creating an instance of a class that implements this interface it can be added to a widget using the addListener(int eventType, Listener handler) method and removed using the removeListener (int eventType, Listener handler) method. When the specified event occurs, handleEvent(...) will be sent to the instance. Classes which implement this interface are described within SWT as providing the untyped listener API. Typically, widgets will also provide a higher-level typed listener API, that is based on the standard java.util.EventListener pattern. Note that, since all internal SWT event dispatching is based on untyped listeners, it is simple to build subsets of SWT for use on memory constrained, small footprint devices, by removing the classes and methods which implement the typed listener API. See Also: Widget.addListener(int, org.eclipse.swt.widgets.Listener), EventListener, org.eclipse.swt.events Implementors of this interface answer one of the prescribed return codes when asked whether to overwrite a certain path string (which could represent a resource path, a file system path, etc). extends WizardDataTransferPage The abstract superclass for a typical import wizard\'s main page. Clients may subclass this page to inherit its common destination resource selection facilities. Subclasses must implement createSourceGroup Subclasses may override allowNewContainerName Subclasses may extend handleEvent '
616, 'org.eclipse.swt.widgets.Group', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/widgets/Group.html', 'Implementers of Drawable can have a graphics context (GC) created for them, and then they can be drawn on by sending messages to their associated GC. SWT images, and device objects such as the Display device and the Printer device, are drawables. IMPORTANT: This interface is not part of the SWT public API. It is marked public only so that it can be shared within the packages provided by SWT. It should never be referenced from application code. See Also: Device, Image, GC extends Composite Instances of this class provide an etched border with an optional title. Shadow styles are hints and may not be honoured by the platform. To create a group with the default shadow style for the platform, do not specify a shadow style. Styles: SHADOW_ETCHED_IN, SHADOW_ETCHED_OUT, SHADOW_IN, SHADOW_OUT, SHADOW_NONE Events: (none) Note: Only one of the above styles may be specified. IMPORTANT: This class is not intended to be subclassed. See Also: SWT Example: ControlExample, Sample code and further information Restriction: This class is not intended to be subclassed by clients. '
617, 'org.eclipse.core.resources.IResource', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/resources/IResource.html', 'An interface for an adaptable object. Adaptable objects can be dynamically extended to provide different interfaces (or \"adapters\"). Adapters are created by adapter factories, which are in turn managed by type by adapter managers. For example, IAdaptable a = [some adaptable]; IFoo x = (IFoo)a.getAdapter(IFoo.class); if (x != null) [do IFoo things with x] This interface can be used without OSGi running. Clients may implement this interface, or obtain a default implementation of this interface by subclassing PlatformObject. See Also: IAdapterFactory, IAdapterManager, PlatformObject Scheduling rules are used by jobs to indicate when they need exclusive access to a resource. Scheduling rules can also be applied synchronously to a thread using IJobManager.beginRule(ISchedulingRule) and IJobManager.endRule(ISchedulingRule). The job manager guarantees that no two jobs with conflicting scheduling rules will run concurrently. Multiple rules can be applied to a given thread only if the outer rule explicitly allows the nesting as specified by the contains method. Clients may implement this interface. Since: 3.0 See Also: Job.getRule(), Job.setRule(ISchedulingRule), Job.schedule(long), IJobManager.beginRule(ISchedulingRule, org.eclipse.core.runtime.IProgressMonitor), IJobManager.endRule(ISchedulingRule) extends IAdaptable, ISchedulingRule The workspace analog of file system files and directories. There are exactly four types of resource: files, folders, projects and the workspace root. File resources are similar to files in that they hold data directly. Folder resources are analogous to directories in that they hold other resources but cannot directly hold data. Project resources group files and folders into reusable clusters. The workspace root is the top level resource under which all others reside. Features of resources: IResource objects are handles to state maintained by a workspace. That is, resource objects do not actually contain data themselves but rather represent resource state and give it behavior. Programmers are free to manipulate handles for resources that do not exist in a workspace but must keep in mind that some methods and operations require that an actual resource be available. Resources have two different kinds of properties as detailed below. All properties are keyed by qualified names. Session properties: Session properties live for the lifetime of one execution of the workspace. They are not stored on disk. They can carry arbitrary object values. Clients should be aware that these values are kept in memory at all times and, as such, the values should not be large. Persistent properties: Persistent properties have string values which are stored on disk across platform sessions. The value of a persistent property is a string which should be short (i.e., under 2KB). Resources are identified by type and by their path, which is similar to a file system path. The name of a resource is the last segment of its path. A resource\'s parent is located by removing the last segment (the resource\'s name) from the resource\'s full path. Resources can be local or non-local. A non-local resource is one whose contents and properties have not been fetched from a repository. Phantom resources represent incoming additions or outgoing deletions which have yet to be reconciled with a synchronization partner. Resources implement the IAdaptable interface; extensions are managed by the platform\'s adapter manager. See Also: IWorkspace, Platform.getAdapterManager() Restriction: This interface is not intended to be implemented by clients. Restriction: This interface is not intended to be extended by clients. '
618, 'org.eclipse.ui.wizards.datatransfer.IImportStructureProvider', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/wizards/datatransfer/IImportStructureProvider.html', 'Interface which can provide structure and content information for an element (for example, a file system element). Used by the import wizards to abstract the commonalities between importing from the file system and importing from an archive. '
619, 'org.eclipse.ui.wizards.datatransfer.ImportOperation', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/wizards/datatransfer/ImportOperation.html', 'The IRunnableWithProgress interface should be implemented by any class whose instances are intended to be executed as a long-running operation. Long-running operations are typically presented at the UI via a modal dialog showing a progress indicator and a Cancel button. The class must define a run method that takes a progress monitor. The run method is usually not invoked directly, but rather by passing the IRunnableWithProgress to the run method of an IRunnableContext, which provides the UI for the progress monitor and Cancel button. See Also: IRunnableContext A thread listener is an object that is interested in receiving notifications of thread changes. For example, a thread listener can be used to notify a runnable of the thread that will execute it, allowing the runnable to transfer thread-local state from the calling thread before control passes to the new thread. Since: 3.1 extends WorkspaceModifyOperation An operation which does the actual work of copying objects from the local file system into the workspace. This class may be instantiated; it is not intended to be subclassed. Restriction: This class is not intended to be subclassed by clients. '
620, 'org.eclipse.jface.dialogs.ErrorDialog', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/dialogs/ErrorDialog.html', 'Interface for objects that can return a shell. This is normally used for opening child windows. An object that wants to open child shells can take an IShellProvider in its constructor, and the object that implements IShellProvider can dynamically choose where child shells should be opened. Since: 3.1 extends IconAndMessageDialog A dialog to display one or more errors to the user, as contained in an IStatus object. If an error contains additional detailed information then a Details button is automatically supplied, which shows or hides an error details viewer when pressed by the user. This dialog should be considered being a \"local\" way of error handling. It cannot be changed or replaced by \"global\" error handling facility ( org.eclipse.ui.statushandler.StatusManager). If product defines its own way of handling errors, this error dialog may cause UI inconsistency, so until it is absolutely necessary, StatusManager should be used. See Also: IStatus '
621, 'org.eclipse.ui.dialogs.FileSystemElement', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/dialogs/FileSystemElement.html', 'An interface for an adaptable object. Adaptable objects can be dynamically extended to provide different interfaces (or \"adapters\"). Adapters are created by adapter factories, which are in turn managed by type by adapter managers. For example, IAdaptable a = [some adaptable]; IFoo x = (IFoo)a.getAdapter(IFoo.class); if (x != null) [do IFoo things with x] This interface can be used without OSGi running. Clients may implement this interface, or obtain a default implementation of this interface by subclassing PlatformObject. See Also: IAdapterFactory, IAdapterManager, PlatformObject extends Object implements IAdaptable Instances of this class represent files or file-like entities (eg.- zip file entries) on the local file system. They do not represent resources within the workbench. This distinction is made because the representation of a file system resource is significantly different from that of a workbench resource. If self represents a collection (eg.- file system directory, zip directory) then its icon will be the folderIcon static field. Otherwise (ie.- self represents a file system file) self\'s icon is stored in field \"icon\", and is determined by the extension of the file that self represents. This class is adaptable, and implements one adapter itself, namely the IWorkbenchAdapter adapter used for navigation and display in the workbench. '
622, 'org.eclipse.ui.model.WorkbenchContentProvider', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/model/WorkbenchContentProvider.html', 'extends EventListener A resource change listener is notified of changes to resources in the workspace. These changes arise from direct manipulation of resources, or indirectly through re-synchronization with the local file system. Clients may implement this interface. See Also: IResourceDelta, IWorkspace.addResourceChangeListener(IResourceChangeListener, int) A content provider mediates between the viewer\'s model and the viewer itself. See Also: ContentViewer.setContentProvider(IContentProvider) A content provider mediates between the viewer\'s model and the viewer itself. See Also: ContentViewer.setContentProvider(IContentProvider) extends IContentProvider An interface to content providers for structured viewers. See Also: StructuredViewer A content provider mediates between the viewer\'s model and the viewer itself. See Also: ContentViewer.setContentProvider(IContentProvider) extends IContentProvider An interface to content providers for structured viewers. See Also: StructuredViewer extends IStructuredContentProvider An interface to content providers for tree-structure-oriented viewers. See Also: AbstractTreeViewer extends BaseWorkbenchContentProvider implements IResourceChangeListener Tree content provider for resource objects that can be adapted to the interface IWorkbenchAdapter. This provider will listen for resource changes within the workspace and update the viewer as necessary. This class may be instantiated, or subclassed by clients. '
623, 'org.eclipse.swt.widgets.DirectoryDialog', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/widgets/DirectoryDialog.html', 'extends Dialog Instances of this class allow the user to navigate the file system and select a directory. Styles: (none) Events: (none) IMPORTANT: This class is not intended to be subclassed. See Also: DirectoryDialog snippets, SWT Example: ControlExample, Dialog tab, Sample code and further information Restriction: This class is not intended to be subclassed by clients. '
624, 'org.eclipse.core.resources.IContainer', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/resources/IContainer.html', 'An interface for an adaptable object. Adaptable objects can be dynamically extended to provide different interfaces (or \"adapters\"). Adapters are created by adapter factories, which are in turn managed by type by adapter managers. For example, IAdaptable a = [some adaptable]; IFoo x = (IFoo)a.getAdapter(IFoo.class); if (x != null) [do IFoo things with x] This interface can be used without OSGi running. Clients may implement this interface, or obtain a default implementation of this interface by subclassing PlatformObject. See Also: IAdapterFactory, IAdapterManager, PlatformObject An interface for an adaptable object. Adaptable objects can be dynamically extended to provide different interfaces (or \"adapters\"). Adapters are created by adapter factories, which are in turn managed by type by adapter managers. For example, IAdaptable a = [some adaptable]; IFoo x = (IFoo)a.getAdapter(IFoo.class); if (x != null) [do IFoo things with x] This interface can be used without OSGi running. Clients may implement this interface, or obtain a default implementation of this interface by subclassing PlatformObject. See Also: IAdapterFactory, IAdapterManager, PlatformObject Scheduling rules are used by jobs to indicate when they need exclusive access to a resource. Scheduling rules can also be applied synchronously to a thread using IJobManager.beginRule(ISchedulingRule) and IJobManager.endRule(ISchedulingRule). The job manager guarantees that no two jobs with conflicting scheduling rules will run concurrently. Multiple rules can be applied to a given thread only if the outer rule explicitly allows the nesting as specified by the contains method. Clients may implement this interface. Since: 3.0 See Also: Job.getRule(), Job.setRule(ISchedulingRule), Job.schedule(long), IJobManager.beginRule(ISchedulingRule, org.eclipse.core.runtime.IProgressMonitor), IJobManager.endRule(ISchedulingRule) extends IAdaptable, ISchedulingRule The workspace analog of file system files and directories. There are exactly four types of resource: files, folders, projects and the workspace root. File resources are similar to files in that they hold data directly. Folder resources are analogous to directories in that they hold other resources but cannot directly hold data. Project resources group files and folders into reusable clusters. The workspace root is the top level resource under which all others reside. Features of resources: IResource objects are handles to state maintained by a workspace. That is, resource objects do not actually contain data themselves but rather represent resource state and give it behavior. Programmers are free to manipulate handles for resources that do not exist in a workspace but must keep in mind that some methods and operations require that an actual resource be available. Resources have two different kinds of properties as detailed below. All properties are keyed by qualified names. Session properties: Session properties live for the lifetime of one execution of the workspace. They are not stored on disk. They can carry arbitrary object values. Clients should be aware that these values are kept in memory at all times and, as such, the values should not be large. Persistent properties: Persistent properties have string values which are stored on disk across platform sessions. The value of a persistent property is a string which should be short (i.e., under 2KB). Resources are identified by type and by their path, which is similar to a file system path. The name of a resource is the last segment of its path. A resource\'s parent is located by removing the last segment (the resource\'s name) from the resource\'s full path. Resources can be local or non-local. A non-local resource is one whose contents and properties have not been fetched from a repository. Phantom resources represent incoming additions or outgoing deletions which have yet to be reconciled with a synchronization partner. Resources implement the IAdaptable interface; extensions are managed by the platform\'s adapter manager. See Also: IWorkspace, Platform.getAdapterManager() Restriction: This interface is not intended to be implemented by clients. Restriction: This interface is not intended to be extended by clients. Scheduling rules are used by jobs to indicate when they need exclusive access to a resource. Scheduling rules can also be applied synchronously to a thread using IJobManager.beginRule(ISchedulingRule) and IJobManager.endRule(ISchedulingRule). The job manager guarantees that no two jobs with conflicting scheduling rules will run concurrently. Multiple rules can be applied to a given thread only if the outer rule explicitly allows the nesting as specified by the contains method. Clients may implement this interface. Since: 3.0 See Also: Job.getRule(), Job.setRule(ISchedulingRule), Job.schedule(long), IJobManager.beginRule(ISchedulingRule, org.eclipse.core.runtime.IProgressMonitor), IJobManager.endRule(ISchedulingRule) extends IResource, IAdaptable Interface for resources which may contain other resources (termed its members). While the workspace itself is not considered a container in this sense, the workspace root resource is a container. Containers implement the IAdaptable interface; extensions are managed by the platform\'s adapter manager. See Also: Platform.getAdapterManager(), IProject, IFolder, IWorkspaceRoot Restriction: This interface is not intended to be implemented by clients. Restriction: This interface is not intended to be extended by clients. '
625, 'org.eclipse.jface.dialogs.IDialogSettings', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/dialogs/IDialogSettings.html', 'An interface to a storage mechanism for making dialog settings persistent. The store manages a collection of key/value pairs. The keys must be strings and the values can be either, strings or array of strings. Convenience API to convert primitive types to strings is provided. See Also: DialogSettings '
626, 'org.eclipse.jface.dialogs.ProgressMonitorDialog', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/dialogs/ProgressMonitorDialog.html', 'Interface for UI components which can execute a long-running operation in the form of an IRunnableWithProgress. The context is responsible for displaying a progress indicator and Cancel button to the end user while the operation is in progress; the context supplies a progress monitor to be used from code running inside the operation. Note that an IRunnableContext is not a runnable itself. For examples of UI components which implement this interface, see ApplicationWindow, ProgressMonitorDialog, and WizardDialog. See Also: IRunnableWithProgress, ApplicationWindow, ProgressMonitorDialog, WizardDialog Interface for objects that can return a shell. This is normally used for opening child windows. An object that wants to open child shells can take an IShellProvider in its constructor, and the object that implements IShellProvider can dynamically choose where child shells should be opened. Since: 3.1 extends IconAndMessageDialog implements IRunnableContext A modal dialog that displays progress during a long running operation. This concrete dialog class can be instantiated as is, or further subclassed as required. Typical usage is: try { IRunnableWithProgress op = ...; new ProgressMonitorDialog(activeShell).run(true, true, op); } catch (InvocationTargetException e) { // handle exception } catch (InterruptedException e) { // handle cancelation } Note that the ProgressMonitorDialog is not intended to be used with multiple runnables - this dialog should be discarded after completion of one IRunnableWithProgress and a new one instantiated for use by a second or sebsequent IRunnableWithProgress to ensure proper initialization. Note that not forking the process will result in it running in the UI which may starve the UI. The most obvious symptom of this problem is non responsiveness of the cancel button. If you are running within the UI Thread you should do the bulk of your work in another Thread to prevent starvation. It is recommended that fork is set to true in most cases. '
627, 'org.eclipse.jface.viewers.ITreeViewerListener', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/viewers/ITreeViewerListener.html', 'A listener which is notified when a tree viewer expands or collapses a node. '
628, 'org.eclipse.jface.viewers.TreeExpansionEvent', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/viewers/TreeExpansionEvent.html', 'extends EventObject Event object describing a tree node being expanded or collapsed. The source of these events is the tree viewer. See Also: ITreeViewerListener, Serialized Form '
629, 'org.eclipse.core.resources.IWorkspaceRoot', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/resources/IWorkspaceRoot.html', 'An interface for an adaptable object. Adaptable objects can be dynamically extended to provide different interfaces (or \"adapters\"). Adapters are created by adapter factories, which are in turn managed by type by adapter managers. For example, IAdaptable a = [some adaptable]; IFoo x = (IFoo)a.getAdapter(IFoo.class); if (x != null) [do IFoo things with x] This interface can be used without OSGi running. Clients may implement this interface, or obtain a default implementation of this interface by subclassing PlatformObject. See Also: IAdapterFactory, IAdapterManager, PlatformObject An interface for an adaptable object. Adaptable objects can be dynamically extended to provide different interfaces (or \"adapters\"). Adapters are created by adapter factories, which are in turn managed by type by adapter managers. For example, IAdaptable a = [some adaptable]; IFoo x = (IFoo)a.getAdapter(IFoo.class); if (x != null) [do IFoo things with x] This interface can be used without OSGi running. Clients may implement this interface, or obtain a default implementation of this interface by subclassing PlatformObject. See Also: IAdapterFactory, IAdapterManager, PlatformObject An interface for an adaptable object. Adaptable objects can be dynamically extended to provide different interfaces (or \"adapters\"). Adapters are created by adapter factories, which are in turn managed by type by adapter managers. For example, IAdaptable a = [some adaptable]; IFoo x = (IFoo)a.getAdapter(IFoo.class); if (x != null) [do IFoo things with x] This interface can be used without OSGi running. Clients may implement this interface, or obtain a default implementation of this interface by subclassing PlatformObject. See Also: IAdapterFactory, IAdapterManager, PlatformObject Scheduling rules are used by jobs to indicate when they need exclusive access to a resource. Scheduling rules can also be applied synchronously to a thread using IJobManager.beginRule(ISchedulingRule) and IJobManager.endRule(ISchedulingRule). The job manager guarantees that no two jobs with conflicting scheduling rules will run concurrently. Multiple rules can be applied to a given thread only if the outer rule explicitly allows the nesting as specified by the contains method. Clients may implement this interface. Since: 3.0 See Also: Job.getRule(), Job.setRule(ISchedulingRule), Job.schedule(long), IJobManager.beginRule(ISchedulingRule, org.eclipse.core.runtime.IProgressMonitor), IJobManager.endRule(ISchedulingRule) extends IAdaptable, ISchedulingRule The workspace analog of file system files and directories. There are exactly four types of resource: files, folders, projects and the workspace root. File resources are similar to files in that they hold data directly. Folder resources are analogous to directories in that they hold other resources but cannot directly hold data. Project resources group files and folders into reusable clusters. The workspace root is the top level resource under which all others reside. Features of resources: IResource objects are handles to state maintained by a workspace. That is, resource objects do not actually contain data themselves but rather represent resource state and give it behavior. Programmers are free to manipulate handles for resources that do not exist in a workspace but must keep in mind that some methods and operations require that an actual resource be available. Resources have two different kinds of properties as detailed below. All properties are keyed by qualified names. Session properties: Session properties live for the lifetime of one execution of the workspace. They are not stored on disk. They can carry arbitrary object values. Clients should be aware that these values are kept in memory at all times and, as such, the values should not be large. Persistent properties: Persistent properties have string values which are stored on disk across platform sessions. The value of a persistent property is a string which should be short (i.e., under 2KB). Resources are identified by type and by their path, which is similar to a file system path. The name of a resource is the last segment of its path. A resource\'s parent is located by removing the last segment (the resource\'s name) from the resource\'s full path. Resources can be local or non-local. A non-local resource is one whose contents and properties have not been fetched from a repository. Phantom resources represent incoming additions or outgoing deletions which have yet to be reconciled with a synchronization partner. Resources implement the IAdaptable interface; extensions are managed by the platform\'s adapter manager. See Also: IWorkspace, Platform.getAdapterManager() Restriction: This interface is not intended to be implemented by clients. Restriction: This interface is not intended to be extended by clients. Scheduling rules are used by jobs to indicate when they need exclusive access to a resource. Scheduling rules can also be applied synchronously to a thread using IJobManager.beginRule(ISchedulingRule) and IJobManager.endRule(ISchedulingRule). The job manager guarantees that no two jobs with conflicting scheduling rules will run concurrently. Multiple rules can be applied to a given thread only if the outer rule explicitly allows the nesting as specified by the contains method. Clients may implement this interface. Since: 3.0 See Also: Job.getRule(), Job.setRule(ISchedulingRule), Job.schedule(long), IJobManager.beginRule(ISchedulingRule, org.eclipse.core.runtime.IProgressMonitor), IJobManager.endRule(ISchedulingRule) extends IResource, IAdaptable Interface for resources which may contain other resources (termed its members). While the workspace itself is not considered a container in this sense, the workspace root resource is a container. Containers implement the IAdaptable interface; extensions are managed by the platform\'s adapter manager. See Also: Platform.getAdapterManager(), IProject, IFolder, IWorkspaceRoot Restriction: This interface is not intended to be implemented by clients. Restriction: This interface is not intended to be extended by clients. An interface for an adaptable object. Adaptable objects can be dynamically extended to provide different interfaces (or \"adapters\"). Adapters are created by adapter factories, which are in turn managed by type by adapter managers. For example, IAdaptable a = [some adaptable]; IFoo x = (IFoo)a.getAdapter(IFoo.class); if (x != null) [do IFoo things with x] This interface can be used without OSGi running. Clients may implement this interface, or obtain a default implementation of this interface by subclassing PlatformObject. See Also: IAdapterFactory, IAdapterManager, PlatformObject Scheduling rules are used by jobs to indicate when they need exclusive access to a resource. Scheduling rules can also be applied synchronously to a thread using IJobManager.beginRule(ISchedulingRule) and IJobManager.endRule(ISchedulingRule). The job manager guarantees that no two jobs with conflicting scheduling rules will run concurrently. Multiple rules can be applied to a given thread only if the outer rule explicitly allows the nesting as specified by the contains method. Clients may implement this interface. Since: 3.0 See Also: Job.getRule(), Job.setRule(ISchedulingRule), Job.schedule(long), IJobManager.beginRule(ISchedulingRule, org.eclipse.core.runtime.IProgressMonitor), IJobManager.endRule(ISchedulingRule) extends IAdaptable, ISchedulingRule The workspace analog of file system files and directories. There are exactly four types of resource: files, folders, projects and the workspace root. File resources are similar to files in that they hold data directly. Folder resources are analogous to directories in that they hold other resources but cannot directly hold data. Project resources group files and folders into reusable clusters. The workspace root is the top level resource under which all others reside. Features of resources: IResource objects are handles to state maintained by a workspace. That is, resource objects do not actually contain data themselves but rather represent resource state and give it behavior. Programmers are free to manipulate handles for resources that do not exist in a workspace but must keep in mind that some methods and operations require that an actual resource be available. Resources have two different kinds of properties as detailed below. All properties are keyed by qualified names. Session properties: Session properties live for the lifetime of one execution of the workspace. They are not stored on disk. They can carry arbitrary object values. Clients should be aware that these values are kept in memory at all times and, as such, the values should not be large. Persistent properties: Persistent properties have string values which are stored on disk across platform sessions. The value of a persistent property is a string which should be short (i.e., under 2KB). Resources are identified by type and by their path, which is similar to a file system path. The name of a resource is the last segment of its path. A resource\'s parent is located by removing the last segment (the resource\'s name) from the resource\'s full path. Resources can be local or non-local. A non-local resource is one whose contents and properties have not been fetched from a repository. Phantom resources represent incoming additions or outgoing deletions which have yet to be reconciled with a synchronization partner. Resources implement the IAdaptable interface; extensions are managed by the platform\'s adapter manager. See Also: IWorkspace, Platform.getAdapterManager() Restriction: This interface is not intended to be implemented by clients. Restriction: This interface is not intended to be extended by clients. Scheduling rules are used by jobs to indicate when they need exclusive access to a resource. Scheduling rules can also be applied synchronously to a thread using IJobManager.beginRule(ISchedulingRule) and IJobManager.endRule(ISchedulingRule). The job manager guarantees that no two jobs with conflicting scheduling rules will run concurrently. Multiple rules can be applied to a given thread only if the outer rule explicitly allows the nesting as specified by the contains method. Clients may implement this interface. Since: 3.0 See Also: Job.getRule(), Job.setRule(ISchedulingRule), Job.schedule(long), IJobManager.beginRule(ISchedulingRule, org.eclipse.core.runtime.IProgressMonitor), IJobManager.endRule(ISchedulingRule) extends IContainer, IAdaptable A root resource represents the top of the resource hierarchy in a workspace. There is exactly one root in a workspace. The root resource has the following behavior: It cannot be moved or copied It always exists. Deleting the root deletes all of the children under the root but leaves the root itself It is always local. It is never a phantom. Workspace roots implement the IAdaptable interface; extensions are managed by the platform\'s adapter manager. See Also: Platform.getAdapterManager() Restriction: This interface is not intended to be implemented by clients. Restriction: This interface is not intended to be extended by clients. '
630, 'org.eclipse.ui.dialogs.WizardDataTransferPage', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/dialogs/WizardDataTransferPage.html', 'Interface for a page in a multi-page dialog. Minimal interface to a message provider. Used for dialog pages which can provide a message with an icon. Since: 2.0 extends IDialogPage Interface for a wizard page. The class WizardPage provides an abstract implementation of this interface. However, clients are also free to implement this interface if WizardPage does not suit their needs. Implementers of Listener provide a simple handleEvent() method that is used internally by SWT to dispatch events. After creating an instance of a class that implements this interface it can be added to a widget using the addListener(int eventType, Listener handler) method and removed using the removeListener (int eventType, Listener handler) method. When the specified event occurs, handleEvent(...) will be sent to the instance. Classes which implement this interface are described within SWT as providing the untyped listener API. Typically, widgets will also provide a higher-level typed listener API, that is based on the standard java.util.EventListener pattern. Note that, since all internal SWT event dispatching is based on untyped listeners, it is simple to build subsets of SWT for use on memory constrained, small footprint devices, by removing the classes and methods which implement the typed listener API. See Also: Widget.addListener(int, org.eclipse.swt.widgets.Listener), EventListener, org.eclipse.swt.events Implementors of this interface answer one of the prescribed return codes when asked whether to overwrite a certain path string (which could represent a resource path, a file system path, etc). extends WizardPage implements Listener, IOverwriteQuery The common superclass for wizard import and export pages. This class is not intended to be subclassed outside of the workbench. Restriction: This class is not intended to be subclassed by clients. '
631, 'org.eclipse.jface.util.BidiUtils', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/util/BidiUtils.html', 'extends Object This class provides API to handle Base Text Direction (BTD) and Structured Text support for SWT Text widgets. Since: 3.9 '
632, 'org.eclipse.ui.model.WorkbenchLabelProvider', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/model/WorkbenchLabelProvider.html', 'extends IBaseLabelProvider Interface marking a label provider that provides styled text labels and images. The DelegatingStyledCellLabelProvider.IStyledLabelProvider can optionally implement IColorProvider and IFontProvider to provide foreground and background color and a default font. A label provider maps an element of the viewer\'s model to an optional image and optional text string used to display the element in the viewer\'s control. Certain label providers may allow multiple labels per element. This is an \"abstract interface\", defining methods common to all label providers, but does not actually define the methods to get the label(s) for an element. This interface should never be directly implemented. Most viewers will take either an ILabelProvider or an ITableLabelProvider. A label provider must not be shared between viewers since a label provider generally manages SWT resources (images), which must be disposed when the viewer is disposed. To simplify life cycle management, the current label provider of a viewer is disposed when the viewer is disposed. Label providers can be used outside the context of viewers wherever images are needed. When label providers are used in this fashion it is the responsibility of the user to ensure dispose is called when the provider is no longer needed. See Also: ILabelProvider, ITableLabelProvider Interface to provide color representation for a given element. See Also: IColorDecorator Interface to provide font representation for a given element. Since: 3.0 See Also: IFontDecorator A label provider maps an element of the viewer\'s model to an optional image and optional text string used to display the element in the viewer\'s control. Certain label providers may allow multiple labels per element. This is an \"abstract interface\", defining methods common to all label providers, but does not actually define the methods to get the label(s) for an element. This interface should never be directly implemented. Most viewers will take either an ILabelProvider or an ITableLabelProvider. A label provider must not be shared between viewers since a label provider generally manages SWT resources (images), which must be disposed when the viewer is disposed. To simplify life cycle management, the current label provider of a viewer is disposed when the viewer is disposed. Label providers can be used outside the context of viewers wherever images are needed. When label providers are used in this fashion it is the responsibility of the user to ensure dispose is called when the provider is no longer needed. See Also: ILabelProvider, ITableLabelProvider extends IBaseLabelProvider Extends IBaseLabelProvider with the methods to provide the text and/or image for the label of a given element. Used by most structured viewers, except table viewers. extends LabelProvider implements IColorProvider, IFontProvider, DelegatingStyledCellLabelProvider.IStyledLabelProvider Provides basic labels for adaptable objects that have the IWorkbenchAdapter adapter associated with them. All dispensed images are cached until the label provider is explicitly disposed. This class provides a facility for subclasses to define annotations on the labels and icons of adaptable objects. '
633, 'org.eclipse.ui.dialogs.TypeFilteringDialog', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/dialogs/TypeFilteringDialog.html', 'Interface for objects that can return a shell. This is normally used for opening child windows. An object that wants to open child shells can take an IShellProvider in its constructor, and the object that implements IShellProvider can dynamically choose where child shells should be opened. Since: 3.1 extends SelectionDialog The TypeFilteringDialog is a SelectionDialog that allows the user to select a file editor. '
634, 'org.eclipse.jface.viewers.ICellModifier', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/viewers/ICellModifier.html', 'A cell modifier is used to access the data model from a cell editor in an abstract way. It offers methods to: to check if a a model element\'s property can be edited or not retrieve a value a model element\'s property to store a cell editor\'s value back into the model element\'s property This interface should be implemented by classes that wish to act as cell modifiers. '
635, 'org.eclipse.jface.viewers.TextCellEditor', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/viewers/TextCellEditor.html', 'extends CellEditor A cell editor that manages a text entry field. The cell editor\'s value is the text string itself. This class may be instantiated or subclassed. '
636, 'org.eclipse.jface.viewers.OwnerDrawLabelProvider', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/viewers/OwnerDrawLabelProvider.html', 'A label provider maps an element of the viewer\'s model to an optional image and optional text string used to display the element in the viewer\'s control. Certain label providers may allow multiple labels per element. This is an \"abstract interface\", defining methods common to all label providers, but does not actually define the methods to get the label(s) for an element. This interface should never be directly implemented. Most viewers will take either an ILabelProvider or an ITableLabelProvider. A label provider must not be shared between viewers since a label provider generally manages SWT resources (images), which must be disposed when the viewer is disposed. To simplify life cycle management, the current label provider of a viewer is disposed when the viewer is disposed. Label providers can be used outside the context of viewers wherever images are needed. When label providers are used in this fashion it is the responsibility of the user to ensure dispose is called when the provider is no longer needed. See Also: ILabelProvider, ITableLabelProvider extends CellLabelProvider OwnerDrawLabelProvider is an abstract implementation of a label provider that handles custom draw. This class is intended to be subclassed by implementors. Since: 3.3 '
637, 'org.eclipse.core.resources.WorkspaceJob', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/resources/WorkspaceJob.html', 'An interface for an adaptable object. Adaptable objects can be dynamically extended to provide different interfaces (or \"adapters\"). Adapters are created by adapter factories, which are in turn managed by type by adapter managers. For example, IAdaptable a = [some adaptable]; IFoo x = (IFoo)a.getAdapter(IFoo.class); if (x != null) [do IFoo things with x] This interface can be used without OSGi running. Clients may implement this interface, or obtain a default implementation of this interface by subclassing PlatformObject. See Also: IAdapterFactory, IAdapterManager, PlatformObject extends org.eclipse.core.internal.resources.InternalWorkspaceJob A job that makes an atomic modification to the workspace. Clients must implement the abstract method runInWorkspace instead of the usual Job.run method. After running a method that modifies resources in the workspace, registered listeners receive after-the-fact notification of what just transpired, in the form of a resource change event. This method allows clients to call a number of methods that modify resources and only have resource change event notifications reported at the end of the entire batch. This mechanism is used to avoid unnecessary builds and notifications. Platform may decide to perform notifications during the operation. The reason for this is that it is possible for multiple threads to be modifying the workspace concurrently. When one thread finishes modifying the workspace, a notification is required to prevent responsiveness problems, even if the other operation has not yet completed. A WorkspaceJob is the asynchronous equivalent of IWorkspaceRunnable Note that the workspace is not locked against other threads during the execution of a workspace job. Other threads can be modifying the workspace concurrently with a workspace job. To obtain exclusive access to a portion of the workspace, set the scheduling rule on the job to be a resource scheduling rule. The interface IResourceRuleFactory is used to create a scheduling rule for a particular workspace modification operation. Since: 3.0 See Also: IWorkspaceRunnable, IResourceRuleFactory, IWorkspace.run(IWorkspaceRunnable, ISchedulingRule, int, IProgressMonitor) '
638, 'org.eclipse.ui.actions.GlobalBuildAction', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/actions/GlobalBuildAction.html', 'An action represents the non-UI side of a command which can be triggered by the end user. Actions are typically associated with buttons, menu items, and items in tool bars. The controls for a command are built by some container, which furnished the context where these controls appear and configures them with data from properties declared by the action. When the end user triggers the command via its control, the action\'s run method is invoked to do the real work. Actions support a predefined set of properties (and possibly others as well). Clients of an action may register property change listeners so that they get notified whenever the value of a property changes. Clients should subclass the abstract base class Action to define concrete actions rather than implementing IAction from scratch. This interface exists only to define the API for actions. It is not intended to be implemented by clients. See Also: Action Restriction: This interface is not intended to be implemented by clients. extends IAction Interface for a workbench action. extends Action implements ActionFactory.IWorkbenchAction Standard action for full and incremental builds of all projects within the workspace. This class may be instantiated; it is not intended to be subclassed. Restriction: This class is not intended to be subclassed by clients. '
639, 'org.eclipse.jface.bindings.keys.KeyStroke', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/bindings/keys/KeyStroke.html', 'extends Trigger implements Comparable A KeyStroke is defined as an optional set of modifier keys followed optionally by a natural key. A KeyStroke is said to be complete if it contains a natural key. A natural key is any Unicode character (e.g., \"backspace\", etc.), any character belonging to a natural language (e.g., \"A\", \"1\", \"[\", etc.), or any special control character specific to computers (e.g., \"F10\", \"PageUp\", etc.). All KeyStroke objects have a formal string representation available via the toString() method. There are a number of methods to get instances of KeyStroke objects, including one which can parse this formal string representation. All KeyStroke objects, via the format() method, provide a version of their formal string representation translated by platform and locale, suitable for display to a user. KeyStroke objects are immutable. Clients are not permitted to extend this class. Since: 3.1 '
640, 'org.eclipse.jface.bindings.keys.SWTKeySupport', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/bindings/keys/SWTKeySupport.html', 'extends Object A utility class for converting SWT events into key strokes. Since: 3.1 '
641, 'org.eclipse.swt.browser.Browser', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/browser/Browser.html', 'Implementers of Drawable can have a graphics context (GC) created for them, and then they can be drawn on by sending messages to their associated GC. SWT images, and device objects such as the Display device and the Printer device, are drawables. IMPORTANT: This interface is not part of the SWT public API. It is marked public only so that it can be shared within the packages provided by SWT. It should never be referenced from application code. See Also: Device, Image, GC extends Composite Instances of this class implement the browser user interface metaphor. It allows the user to visualize and navigate through HTML documents. Note that although this class is a subclass of Composite, it does not make sense to set a layout on it. Styles: MOZILLA, WEBKIT Events: CloseWindowListener, LocationListener, OpenWindowListener, ProgressListener, StatusTextListener, TitleListener, VisibilityWindowListener Note: At most one of the styles MOZILLA and WEBKIT may be specified. IMPORTANT: This class is not intended to be subclassed. Since: 3.0 See Also: Browser snippets, SWT Examples: ControlExample, BrowserExample, Sample code and further information Restriction: This class is not intended to be subclassed by clients. '
642, 'org.eclipse.swt.custom.CCombo', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/custom/CCombo.html', 'Implementers of Drawable can have a graphics context (GC) created for them, and then they can be drawn on by sending messages to their associated GC. SWT images, and device objects such as the Display device and the Printer device, are drawables. IMPORTANT: This interface is not part of the SWT public API. It is marked public only so that it can be shared within the packages provided by SWT. It should never be referenced from application code. See Also: Device, Image, GC extends Composite The CCombo class represents a selectable user interface object that combines a text field and a list and issues notification when an item is selected from the list. CCombo was written to work around certain limitations in the native combo box. Specifically, on win32, the height of a CCombo can be set; attempts to set the height of a Combo are ignored. CCombo can be used anywhere that having the increased flexibility is more important than getting native L&F, but the decision should not be taken lightly. There is no is no strict requirement that CCombo look or behave the same as the native combo box. Note that although this class is a subclass of Composite, it does not make sense to add children to it, or set a layout on it. Styles: BORDER, READ_ONLY, FLAT Events: DefaultSelection, Modify, Selection, Verify See Also: CCombo snippets, SWT Example: CustomControlExample, Sample code and further information '
643, 'org.eclipse.swt.custom.StyledText', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/custom/StyledText.html', 'Implementers of Drawable can have a graphics context (GC) created for them, and then they can be drawn on by sending messages to their associated GC. SWT images, and device objects such as the Display device and the Printer device, are drawables. IMPORTANT: This interface is not part of the SWT public API. It is marked public only so that it can be shared within the packages provided by SWT. It should never be referenced from application code. See Also: Device, Image, GC extends Canvas A StyledText is an editable user interface object that displays lines of text. The following style attributes can be defined for the text: foreground color background color font style (bold, italic, bold-italic, regular) underline strikeout In addition to text style attributes, the background color of a line may be specified. There are two ways to use this widget when specifying text style information. You may use the API that is defined for StyledText or you may define your own LineStyleListener. If you define your own listener, you will be responsible for maintaining the text style information for the widget. IMPORTANT: You may not define your own listener and use the StyledText API. The following StyledText API is not supported if you have defined a LineStyleListener: getStyleRangeAtOffset(int) getStyleRanges() replaceStyleRanges(int,int,StyleRange[]) setStyleRange(StyleRange) setStyleRanges(StyleRange[]) There are two ways to use this widget when specifying line background colors. You may use the API that is defined for StyledText or you may define your own LineBackgroundListener. If you define your own listener, you will be responsible for maintaining the line background color information for the widget. IMPORTANT: You may not define your own listener and use the StyledText API. The following StyledText API is not supported if you have defined a LineBackgroundListener: getLineBackground(int) setLineBackground(int,int,Color) The content implementation for this widget may also be user-defined. To do so, you must implement the StyledTextContent interface and use the StyledText API setContent(StyledTextContent) to initialize the widget. Styles: FULL_SELECTION, MULTI, READ_ONLY, SINGLE, WRAP Events: ExtendedModify, LineGetBackground, LineGetSegments, LineGetStyle, Modify, Selection, Verify, VerifyKey, OrientationChange IMPORTANT: This class is not intended to be subclassed. See Also: StyledText snippets, SWT Examples: CustomControlExample, TextEditor, Sample code and further information Restriction: This class is not intended to be subclassed by clients. '
644, 'org.eclipse.jface.dialogs.PopupDialog', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/dialogs/PopupDialog.html', 'Interface for objects that can return a shell. This is normally used for opening child windows. An object that wants to open child shells can take an IShellProvider in its constructor, and the object that implements IShellProvider can dynamically choose where child shells should be opened. Since: 3.1 extends Window A lightweight, transient dialog that is popped up to show contextual or temporal information and is easily dismissed. Clients control whether the dialog should be able to receive input focus. An optional title area at the top and an optional info area at the bottom can be used to provide additional information. Because the dialog is short-lived, most of the configuration of the dialog is done in the constructor. Set methods are only provided for those values that are expected to be dynamically computed based on a particular instance\'s internal state. Clients are expected to override the creation of the main dialog area, and may optionally override the creation of the title area and info area in order to add content. In general, however, the creation of stylistic features, such as the dialog menu, separator styles, and fonts, is kept private so that all popup dialogs will have a similar appearance. Since: 3.2 '
645, 'org.eclipse.jface.window.ToolTip', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/window/ToolTip.html', 'extends Object This class gives implementors to provide customized tooltips for any control. Since: 3.3 '
646, 'org.eclipse.ui.presentations.StackPresentation', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/presentations/StackPresentation.html', 'extends Object implements ISizeProvider This represents an object that can supply trim around a IPresentablePart. Clients can implement subclasses to provide the appearance for editor workbooks, view folders, fast views, and detached windows. StackPresentations do not store any persistent state and cannot directly make changes to the workbench. They are given an IStackPresentationSite reference on creation, which allows them to send events and requests to the workbench. However, the workbench is free to ignore these requests. The workbench will call one of the public methods on StackPresentation when (and if) the presentation is expected to change state. For example, if the user clicks a button that is intended to close a part, the StackPresentation will send a close request to its site, but should not assume that the part has been closed until the workbench responds with a call StackPresentation.remove. Since: 3.0 '
647, 'org.eclipse.ui.presentations.IPresentablePart', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/presentations/IPresentablePart.html', 'extends ISizeProvider This is a skin\'s interface to the contents of a view or editor. Note that this is essentially the same as IWorkbenchPart, except it does not provide access to lifecycle events and allows repositioning of the part. Not intended to be implemented by clients. Since: 3.0, 3.4 now extends ISizeProvider Restriction: This interface is not intended to be implemented by clients. '
648, 'org.eclipse.ui.presentations.IStackPresentationSite', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/presentations/IStackPresentationSite.html', 'Represents the main interface between a StackPresentation and the workbench. Not intended to be implemented by clients. Since: 3.0 Restriction: This interface is not intended to be implemented by clients. '
649, 'org.eclipse.ui.presentations.PresentationUtil', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/presentations/PresentationUtil.html', 'extends Object Contains various utility methods for Presentation authors Since: 3.0 '
650, 'org.eclipse.ui.presentations.StackDropResult', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/presentations/StackDropResult.html', 'extends Object This structure describes a drop event that will cause a dragged part to be stacked in a position currently occupied by another part. Since: 3.0 '
651, 'org.eclipse.swt.custom.ViewForm', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/custom/ViewForm.html', 'Implementers of Drawable can have a graphics context (GC) created for them, and then they can be drawn on by sending messages to their associated GC. SWT images, and device objects such as the Display device and the Printer device, are drawables. IMPORTANT: This interface is not part of the SWT public API. It is marked public only so that it can be shared within the packages provided by SWT. It should never be referenced from application code. See Also: Device, Image, GC extends Composite Instances of this class implement a Composite that positions and sizes children and allows programmatic control of layout and border parameters. ViewForm is used in the workbench to lay out a view\'s label/menu/toolbar local bar. Note that although this class is a subclass of Composite, it does not make sense to set a layout on it. Styles: BORDER, FLAT Events: (None) IMPORTANT: This class is not intended to be subclassed. See Also: Sample code and further information Restriction: This class is not intended to be subclassed by clients. '
652, 'org.eclipse.ui.presentations.IPartMenu', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/presentations/IPartMenu.html', 'Interface to a menu created by a part that will be displayed in a presentation. This interface is not intended to be implemented by clients. Since: 3.0 Restriction: This interface is not intended to be implemented by clients. '
653, 'org.eclipse.ui.presentations.IPresentationSerializer', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/presentations/IPresentationSerializer.html', 'This interface is given to a StackPresentation when it is loading or saving its state. Not intended to be implemented by clients Since: 3.0 Restriction: This interface is not intended to be implemented by clients. '
654, 'org.eclipse.jface.util.Geometry', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/util/Geometry.html', 'extends Object Contains static methods for performing simple geometric operations on the SWT geometry classes. Since: 3.0 '
655, 'org.eclipse.ui.part.IWorkbenchPartOrientation', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/part/IWorkbenchPartOrientation.html', 'The IWorkbenchPartOrientation is the interface that defines the orientation of the part. If a type does not implement this interface an orientation of SWT.NONE will be assumed. Since: 3.1 See Also: SWT.RIGHT_TO_LEFT, SWT.LEFT_TO_RIGHT, SWT.NONE, Window.getDefaultOrientation() '
656, 'org.eclipse.jface.dialogs.MessageDialogWithToggle', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/dialogs/MessageDialogWithToggle.html', 'Interface for objects that can return a shell. This is normally used for opening child windows. An object that wants to open child shells can take an IShellProvider in its constructor, and the object that implements IShellProvider can dynamically choose where child shells should be opened. Since: 3.1 extends MessageDialog A message dialog which also allows the user to adjust a toggle setting. If a preference store is provided and the user selects the toggle, then the user\'s answer (yes/ok or no) will be persisted in the store. If no store is provided, then this information can be queried after the dialog closes. This type of dialog should be used whenever you want to user to be able to avoid being prompted in the future. It is strongly recommended that a cancel option be provided, so that the user has the option of making the decision at a later point in time. The semantic for a cancel button should be to cancel the operation (if it has not yet started), or stop the operation (if it has already started). It is the responsibility of the developer to provide a mechanism for the user to change this preference at some later point in time (e.g., through a preference page). Since: 3.0 '
657, 'org.eclipse.ui.PerspectiveAdapter', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/PerspectiveAdapter.html', 'Interface for listening to perspective lifecycle events. This interface may be implemented by clients. See Also: IPageService.addPerspectiveListener(IPerspectiveListener), PerspectiveAdapter extends IPerspectiveListener Extension interface to IPerspectiveListener which adds support for listening to part-specific perspective lifecycle events. For example, this allows a perspective listener to determine which view is being hidden during a CHANGE_VIEW_HIDE event. This interface may be implemented by clients. Since: 3.0 See Also: IPageService.addPerspectiveListener(IPerspectiveListener), PerspectiveAdapter extends IPerspectiveListener2 Extension interface to IPerspectiveListener which adds support for listening to perspective open and close events. This interface may be implemented by clients. Since: 3.1 See Also: IPageService.addPerspectiveListener(IPerspectiveListener), PerspectiveAdapter extends IPerspectiveListener3 Extension interface to IPerspectiveListener which adds support for listening to perspective pre-deactivate events. This interface may be implemented by clients. Since: 3.2 See Also: IPageService.addPerspectiveListener(IPerspectiveListener), PerspectiveAdapter extends Object implements IPerspectiveListener4 This adapter class provides default implementations for the methods described by the IPerspectiveListener interface and its extension interfaces. Classes that wish to deal with events which occur as perspectives are added, removed, activated and changed, can extend this class and override only the methods which they are interested in. Since: 3.1 See Also: IPerspectiveListener, IPerspectiveListener2, IPerspectiveListener3, IPerspectiveListener4 '
658, 'org.eclipse.ui.IFileEditorInput', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/IFileEditorInput.html', 'An interface for an adaptable object. Adaptable objects can be dynamically extended to provide different interfaces (or \"adapters\"). Adapters are created by adapter factories, which are in turn managed by type by adapter managers. For example, IAdaptable a = [some adaptable]; IFoo x = (IFoo)a.getAdapter(IFoo.class); if (x != null) [do IFoo things with x] This interface can be used without OSGi running. Clients may implement this interface, or obtain a default implementation of this interface by subclassing PlatformObject. See Also: IAdapterFactory, IAdapterManager, PlatformObject An interface for an adaptable object. Adaptable objects can be dynamically extended to provide different interfaces (or \"adapters\"). Adapters are created by adapter factories, which are in turn managed by type by adapter managers. For example, IAdaptable a = [some adaptable]; IFoo x = (IFoo)a.getAdapter(IFoo.class); if (x != null) [do IFoo things with x] This interface can be used without OSGi running. Clients may implement this interface, or obtain a default implementation of this interface by subclassing PlatformObject. See Also: IAdapterFactory, IAdapterManager, PlatformObject extends IAdaptable IEditorInput is a light weight descriptor of editor input, like a file name but more abstract. It is not a model. It is a description of the model source for an IEditorPart. Clients implementing this editor input interface should override Object.equals(Object) to answer true for two inputs that are the same. The IWorbenchPage.openEditor APIs are dependent on this to find an editor with the same input. Clients should extend this interface to declare new types of editor inputs. An editor input is passed to an editor via the IEditorPart.init method. Due to the wide range of valid editor inputs, it is not possible to define generic methods for getting and setting bytes. Editor input must implement the IAdaptable interface; extensions are managed by the platform\'s adapter manager. Please note that it is important that the editor input be light weight. Within the workbench, the navigation history tends to hold on to editor inputs as a means of reconstructing the editor at a later time. The navigation history can hold on to quite a few inputs (i.e., the default is fifty). The actual data model should probably not be held in the input. See Also: IEditorPart, IWorkbenchPage.openEditor(IEditorInput, String), IWorkbenchPage.openEditor(IEditorInput, String, boolean) extends IEditorInput Interface for a IStorage input to an editor. Clients implementing this editor input interface should override Object.equals(Object) to answer true for two inputs that are the same. The IWorbenchPage.openEditor APIs are dependent on this to find an editor with the same input. Clients should implement this interface to declare new types of IStorage editor inputs. File-oriented editors should support this as a valid input type, and display its content for viewing (but not allow modification). Within the editor, the \"save\" and \"save as\" operations should create a new file resource within the workspace. All editor inputs must implement the IAdaptable interface; extensions are managed by the platform\'s adapter manager. extends IStorageEditorInput This interface defines a file-oriented input to an editor. Clients implementing this editor input interface should override Object.equals(Object) to answer true for two inputs that are the same. The IWorbenchPage.openEditor APIs are dependent on this to find an editor with the same input. File-oriented editors should support this as a valid input type, and allow full read-write editing of its content. A default implementation of this interface is provided by org.eclipse.ui.part.FileEditorInput. All editor inputs must implement the IAdaptable interface; extensions are managed by the platform\'s adapter manager. See Also: IFile '
659, 'org.eclipse.ui.ide.FileStoreEditorInput', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/ide/FileStoreEditorInput.html', 'An interface for an adaptable object. Adaptable objects can be dynamically extended to provide different interfaces (or \"adapters\"). Adapters are created by adapter factories, which are in turn managed by type by adapter managers. For example, IAdaptable a = [some adaptable]; IFoo x = (IFoo)a.getAdapter(IFoo.class); if (x != null) [do IFoo things with x] This interface can be used without OSGi running. Clients may implement this interface, or obtain a default implementation of this interface by subclassing PlatformObject. See Also: IAdapterFactory, IAdapterManager, PlatformObject An interface for an adaptable object. Adaptable objects can be dynamically extended to provide different interfaces (or \"adapters\"). Adapters are created by adapter factories, which are in turn managed by type by adapter managers. For example, IAdaptable a = [some adaptable]; IFoo x = (IFoo)a.getAdapter(IFoo.class); if (x != null) [do IFoo things with x] This interface can be used without OSGi running. Clients may implement this interface, or obtain a default implementation of this interface by subclassing PlatformObject. See Also: IAdapterFactory, IAdapterManager, PlatformObject extends IAdaptable IEditorInput is a light weight descriptor of editor input, like a file name but more abstract. It is not a model. It is a description of the model source for an IEditorPart. Clients implementing this editor input interface should override Object.equals(Object) to answer true for two inputs that are the same. The IWorbenchPage.openEditor APIs are dependent on this to find an editor with the same input. Clients should extend this interface to declare new types of editor inputs. An editor input is passed to an editor via the IEditorPart.init method. Due to the wide range of valid editor inputs, it is not possible to define generic methods for getting and setting bytes. Editor input must implement the IAdaptable interface; extensions are managed by the platform\'s adapter manager. Please note that it is important that the editor input be light weight. Within the workbench, the navigation history tends to hold on to editor inputs as a means of reconstructing the editor at a later time. The navigation history can hold on to quite a few inputs (i.e., the default is fifty). The actual data model should probably not be held in the input. See Also: IEditorPart, IWorkbenchPage.openEditor(IEditorInput, String), IWorkbenchPage.openEditor(IEditorInput, String, boolean) Objects implementing this interface are capable of saving their state in an IMemento. Since: 3.1 Objects implementing this interface are capable of saving their state in an IMemento. Since: 3.1 extends IPersistable Interface for asking an object to store its state in a memento. This interface is typically included in interfaces where persistance is required. When the workbench is shutdown objects which implement this interface will be persisted. At this time the getFactoryId method is invoked to discover the id of the element factory that will be used to re-create the object from a memento. Then the saveState method is invoked to store the element data into a newly created memento. The resulting mementos are collected up and written out to a single file. During workbench startup these mementos are read from the file. The factory Id for each is retrieved and mapped to an IElementFactory which has been registered in the element factory extension point. If a factory exists for the Id it will be engaged to re-create the original object. See Also: IAdaptable, IMemento, IElementFactory extends IEditorInput This interface defines an editor input based on a URI. Clients implementing this editor input interface should override Object.equals(Object) to answer true for two inputs that are the same. The IWorkbenchPage.openEditor APIs are dependent on this to find an editor with the same input. Path-oriented editors should support this as a valid input type, and can allow full read-write editing of its content. All editor inputs must implement the IAdaptable interface; extensions are managed by the platform\'s adapter manager. Since: 3.3 See Also: URI extends Object implements IURIEditorInput, IPersistableElement Implements an IEditorInput instance appropriate for IFileStore elements that represent files that are not part of the current workspace. Since: 3.3 '
660, 'org.eclipse.ui.dialogs.WorkingSetGroup', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/dialogs/WorkingSetGroup.html', 'extends Object Instances of this class provide a WorkingSetConfigurationBlock wrapped with an SWT Group container. Since: 3.4 '
661, 'org.eclipse.jface.layout.PixelConverter', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/layout/PixelConverter.html', 'extends Object PixelConverter performs various conversions from device-independent units (such as DLUs or characters) to pixels. It can be associated with a control or a font. In the case of a control, the font used by the control at the time the PixelConverter is created is used for the pixel calculations. In the case of a specific font, the supplied font is used for the calculations. The control and/or font must not be disposed at the time the PixelConverter is created. Since: 3.5 '
662, 'org.eclipse.swt.widgets.FileDialog', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/widgets/FileDialog.html', 'extends Dialog Instances of this class allow the user to navigate the file system and select or enter a file name. Styles: SAVE, OPEN, MULTI Events: (none) Note: Only one of the styles SAVE and OPEN may be specified. IMPORTANT: This class is not intended to be subclassed. See Also: FileDialog snippets, SWT Example: ControlExample, Dialog tab, Sample code and further information Restriction: This class is not intended to be subclassed by clients. '
663, 'org.eclipse.ui.actions.WorkspaceModifyOperation', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/actions/WorkspaceModifyOperation.html', 'The IRunnableWithProgress interface should be implemented by any class whose instances are intended to be executed as a long-running operation. Long-running operations are typically presented at the UI via a modal dialog showing a progress indicator and a Cancel button. The class must define a run method that takes a progress monitor. The run method is usually not invoked directly, but rather by passing the IRunnableWithProgress to the run method of an IRunnableContext, which provides the UI for the progress monitor and Cancel button. See Also: IRunnableContext A thread listener is an object that is interested in receiving notifications of thread changes. For example, a thread listener can be used to notify a runnable of the thread that will execute it, allowing the runnable to transfer thread-local state from the calling thread before control passes to the new thread. Since: 3.1 extends Object implements IRunnableWithProgress, IThreadListener An operation which potentially makes changes to the workspace. All resource modification should be performed using this operation. The primary consequence of using this operation is that events which typically occur as a result of workspace changes (such as the firing of resource deltas, performance of autobuilds, etc.) are generally deferred until the outermost operation has successfully completed. The platform may still decide to broadcast periodic resource change notifications during the scope of the operation if the operation runs for a long time or another thread modifies the workspace concurrently. If a scheduling rule is provided, the operation will obtain that scheduling rule for the duration of its execute method. If no scheduling rule is provided, the operation will obtain a scheduling rule that locks the entire workspace for the duration of the operation. Subclasses must implement execute to do the work of the operation. See Also: ISchedulingRule, IWorkspace.run(IWorkspaceRunnable, IProgressMonitor) '
664, 'org.eclipse.core.resources.IProjectDescription', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/resources/IProjectDescription.html', 'A project description contains the meta-data required to define a project. In effect, a project description is a project\'s \"content\". Restriction: This interface is not intended to be implemented by clients. Restriction: This interface is not intended to be extended by clients. '
665, 'org.eclipse.ui.wizards.datatransfer.FileSystemStructureProvider', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/wizards/datatransfer/FileSystemStructureProvider.html', 'Interface which can provide structure and content information for an element (for example, a file system element). Used by the import wizards to abstract the commonalities between importing from the file system and importing from an archive. extends Object implements IImportStructureProvider This class provides information regarding the structure and content of specified file system File objects. '
666, 'org.eclipse.jface.viewers.TreeViewerFocusCellManager', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/viewers/TreeViewerFocusCellManager.html', 'extends Object This class is responsible to provide the concept of cells for Tree. This concept is needed to provide features like editor activation with the keyboard Since: 3.3 '
667, 'org.eclipse.jface.viewers.ColumnViewerEditorActivationStrategy', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/viewers/ColumnViewerEditorActivationStrategy.html', 'extends Object This class is responsible to determine if a cell selection event is triggers an editor activation. Implementors can extend and overwrite to implement custom editing behavior Since: 3.3 '
668, 'org.eclipse.jface.viewers.ColumnLabelProvider', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/viewers/ColumnLabelProvider.html', 'A label provider maps an element of the viewer\'s model to an optional image and optional text string used to display the element in the viewer\'s control. Certain label providers may allow multiple labels per element. This is an \"abstract interface\", defining methods common to all label providers, but does not actually define the methods to get the label(s) for an element. This interface should never be directly implemented. Most viewers will take either an ILabelProvider or an ITableLabelProvider. A label provider must not be shared between viewers since a label provider generally manages SWT resources (images), which must be disposed when the viewer is disposed. To simplify life cycle management, the current label provider of a viewer is disposed when the viewer is disposed. Label providers can be used outside the context of viewers wherever images are needed. When label providers are used in this fashion it is the responsibility of the user to ensure dispose is called when the provider is no longer needed. See Also: ILabelProvider, ITableLabelProvider Interface to provide color representation for a given element. See Also: IColorDecorator Interface to provide font representation for a given element. Since: 3.0 See Also: IFontDecorator A label provider maps an element of the viewer\'s model to an optional image and optional text string used to display the element in the viewer\'s control. Certain label providers may allow multiple labels per element. This is an \"abstract interface\", defining methods common to all label providers, but does not actually define the methods to get the label(s) for an element. This interface should never be directly implemented. Most viewers will take either an ILabelProvider or an ITableLabelProvider. A label provider must not be shared between viewers since a label provider generally manages SWT resources (images), which must be disposed when the viewer is disposed. To simplify life cycle management, the current label provider of a viewer is disposed when the viewer is disposed. Label providers can be used outside the context of viewers wherever images are needed. When label providers are used in this fashion it is the responsibility of the user to ensure dispose is called when the provider is no longer needed. See Also: ILabelProvider, ITableLabelProvider extends IBaseLabelProvider Extends IBaseLabelProvider with the methods to provide the text and/or image for the label of a given element. Used by most structured viewers, except table viewers. extends CellLabelProvider implements IFontProvider, IColorProvider, ILabelProvider The ColumnLabelProvider is the label provider for viewers that have column support such as TreeViewer and TableViewer This classes is intended to be subclassed Since: 3.3 '
669, 'org.eclipse.jface.viewers.FocusCellOwnerDrawHighlighter', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/viewers/FocusCellOwnerDrawHighlighter.html', 'extends FocusCellHighlighter A concrete implementation of FocusCellHighlighter using by setting the control into owner draw mode and highlighting the currently selected cell. To make the use this class you should create the control with the SWT.FULL_SELECTION bit set This class can be subclassed to configure how the coloring of the selected cell. Since: 3.3 '
670, 'org.eclipse.jface.viewers.ColumnViewerEditorActivationEvent', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/viewers/ColumnViewerEditorActivationEvent.html', 'extends EventObject This event is passed on when a cell-editor is going to be activated Since: 3.3 See Also: Serialized Form '
671, 'org.eclipse.jface.viewers.TreeViewerEditor', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/viewers/TreeViewerEditor.html', 'extends ColumnViewerEditor This is an editor implementation for Tree Since: 3.3 '
672, 'org.eclipse.ui.AbstractSourceProvider', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/AbstractSourceProvider.html', ' A provider of notifications for when a change has occurred to a particular type of source. These providers can be given to the appropriate service, and this service will then re-evaluate the appropriate pieces of its internal state in response to these changes. It is recommended that clients subclass AbstractSourceProvider instead, as this provides some common support for listeners. Since: 3.1 See Also: IHandlerService, ISources extends Object implements ISourceProvider An implementation of ISourceProvider that provides listener support. Subclasses need only call fireSourceChanged whenever appropriate. Since: 3.1 '
673, 'org.eclipse.ui.part.EditorPart', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/part/EditorPart.html', 'An interface for an adaptable object. Adaptable objects can be dynamically extended to provide different interfaces (or \"adapters\"). Adapters are created by adapter factories, which are in turn managed by type by adapter managers. For example, IAdaptable a = [some adaptable]; IFoo x = (IFoo)a.getAdapter(IFoo.class); if (x != null) [do IFoo things with x] This interface can be used without OSGi running. Clients may implement this interface, or obtain a default implementation of this interface by subclassing PlatformObject. See Also: IAdapterFactory, IAdapterManager, PlatformObject Interface for executable extension classes that require access to their configuration element, or implement an extension adapter. Extension adapters are typically required in cases where the extension implementation does not follow the interface rules specified by the provider of the extension point. In these cases, the role of the adapter is to map between the extension point interface, and the actual extension implementation. In general, adapters are used when attempting to plug-in existing Java implementations, or non-Java implementations (e.g., external executables). This interface can be used without OSGi running. Clients may implement this interface. See Also: IConfigurationElement.createExecutableExtension(String) An interface for an adaptable object. Adaptable objects can be dynamically extended to provide different interfaces (or \"adapters\"). Adapters are created by adapter factories, which are in turn managed by type by adapter managers. For example, IAdaptable a = [some adaptable]; IFoo x = (IFoo)a.getAdapter(IFoo.class); if (x != null) [do IFoo things with x] This interface can be used without OSGi running. Clients may implement this interface, or obtain a default implementation of this interface by subclassing PlatformObject. See Also: IAdapterFactory, IAdapterManager, PlatformObject Workbench parts implement or adapt to this interface to participate in the enablement and execution of the Save and Save As actions. Since: 2.1 See Also: IEditorPart An interface for an adaptable object. Adaptable objects can be dynamically extended to provide different interfaces (or \"adapters\"). Adapters are created by adapter factories, which are in turn managed by type by adapter managers. For example, IAdaptable a = [some adaptable]; IFoo x = (IFoo)a.getAdapter(IFoo.class); if (x != null) [do IFoo things with x] This interface can be used without OSGi running. Clients may implement this interface, or obtain a default implementation of this interface by subclassing PlatformObject. See Also: IAdapterFactory, IAdapterManager, PlatformObject extends IAdaptable A workbench part is a visual component within a workbench page. There are two subtypes: view and editor, as defined by IViewPart and IEditorPart. A view is typically used to navigate a hierarchy of information (like the workspace), open an editor, or display properties for the active editor. Modifications made in a view are saved immediately. An editor is typically used to edit or browse a document or input object. The input is identified using an IEditorInput. Modifications made in an editor part follow an open-save-close lifecycle model. This interface may be implemented directly. For convenience, a base implementation is defined in WorkbenchPart. The lifecycle of a workbench part is as follows: When a part extension is created: instantiate the part create a part site call part.init(site) When a part becomes visible in the workbench: add part to presentation by calling part.createPartControl(parent) to create actual widgets fire partOpened event to all listeners When a part is activated or gets focus: call part.setFocus() fire partActivated event to all listeners When a part is closed: if save is needed, do save; if it fails or is canceled return if part is active, deactivate part fire partClosed event to all listeners remove part from presentation; part controls are disposed as part of the SWT widget tree call part.dispose() After createPartControl has been called, the implementor may safely reference the controls created. When the part is closed these controls will be disposed as part of an SWT composite. This occurs before the IWorkbenchPart.dispose method is called. If there is a need to free SWT resources the part should define a dispose listener for its own control and free those resources from the dispose listener. If the part invokes any method on the disposed SWT controls after this point an SWTError will be thrown. The last method called on IWorkbenchPart is dispose. This signals the end of the part lifecycle. An important point to note about this lifecycle is that following a call to init, createPartControl may never be called. Thus in the dispose method, implementors must not assume controls were created. Workbench parts implement the IAdaptable interface; extensions are managed by the platform\'s adapter manager. See Also: IViewPart, IEditorPart extends IWorkbenchPart, ISaveablePart An editor is a visual component within a workbench page. It is typically used to edit or browse a document or input object. The input is identified using an IEditorInput. Modifications made in an editor part follow an open-save-close lifecycle model (in contrast to a view part, where modifications are saved to the workbench immediately). An editor is document or input-centric. Each editor has an input, and only one editor can exist for each editor input within a page. This policy has been designed to simplify part management. An editor should be used in place of a view whenever more than one instance of a document type can exist. This interface may be implemented directly. For convenience, a base implementation is defined in EditorPart. An editor part is added to the workbench in two stages: An editor extension is contributed to the workbench registry. This extension defines the extension id, extension class, and the file extensions which are supported by the editor. An editor part based upon the extension is created and added to the workbench when the user opens a file with one of the supported file extensions (or some other suitable form of editor input). All editor parts implement the IAdaptable interface; extensions are managed by the platform\'s adapter manager. See Also: IWorkbenchPage.openEditor(IEditorInput, String), EditorPart Workbench parts implement or adapt to this interface to participate in the enablement and execution of the Save and Save As actions. Since: 2.1 See Also: IEditorPart An interface for an adaptable object. Adaptable objects can be dynamically extended to provide different interfaces (or \"adapters\"). Adapters are created by adapter factories, which are in turn managed by type by adapter managers. For example, IAdaptable a = [some adaptable]; IFoo x = (IFoo)a.getAdapter(IFoo.class); if (x != null) [do IFoo things with x] This interface can be used without OSGi running. Clients may implement this interface, or obtain a default implementation of this interface by subclassing PlatformObject. See Also: IAdapterFactory, IAdapterManager, PlatformObject extends IAdaptable A workbench part is a visual component within a workbench page. There are two subtypes: view and editor, as defined by IViewPart and IEditorPart. A view is typically used to navigate a hierarchy of information (like the workspace), open an editor, or display properties for the active editor. Modifications made in a view are saved immediately. An editor is typically used to edit or browse a document or input object. The input is identified using an IEditorInput. Modifications made in an editor part follow an open-save-close lifecycle model. This interface may be implemented directly. For convenience, a base implementation is defined in WorkbenchPart. The lifecycle of a workbench part is as follows: When a part extension is created: instantiate the part create a part site call part.init(site) When a part becomes visible in the workbench: add part to presentation by calling part.createPartControl(parent) to create actual widgets fire partOpened event to all listeners When a part is activated or gets focus: call part.setFocus() fire partActivated event to all listeners When a part is closed: if save is needed, do save; if it fails or is canceled return if part is active, deactivate part fire partClosed event to all listeners remove part from presentation; part controls are disposed as part of the SWT widget tree call part.dispose() After createPartControl has been called, the implementor may safely reference the controls created. When the part is closed these controls will be disposed as part of an SWT composite. This occurs before the IWorkbenchPart.dispose method is called. If there is a need to free SWT resources the part should define a dispose listener for its own control and free those resources from the dispose listener. If the part invokes any method on the disposed SWT controls after this point an SWTError will be thrown. The last method called on IWorkbenchPart is dispose. This signals the end of the part lifecycle. An important point to note about this lifecycle is that following a call to init, createPartControl may never be called. Thus in the dispose method, implementors must not assume controls were created. Workbench parts implement the IAdaptable interface; extensions are managed by the platform\'s adapter manager. See Also: IViewPart, IEditorPart An interface for an adaptable object. Adaptable objects can be dynamically extended to provide different interfaces (or \"adapters\"). Adapters are created by adapter factories, which are in turn managed by type by adapter managers. For example, IAdaptable a = [some adaptable]; IFoo x = (IFoo)a.getAdapter(IFoo.class); if (x != null) [do IFoo things with x] This interface can be used without OSGi running. Clients may implement this interface, or obtain a default implementation of this interface by subclassing PlatformObject. See Also: IAdapterFactory, IAdapterManager, PlatformObject An interface for an adaptable object. Adaptable objects can be dynamically extended to provide different interfaces (or \"adapters\"). Adapters are created by adapter factories, which are in turn managed by type by adapter managers. For example, IAdaptable a = [some adaptable]; IFoo x = (IFoo)a.getAdapter(IFoo.class); if (x != null) [do IFoo things with x] This interface can be used without OSGi running. Clients may implement this interface, or obtain a default implementation of this interface by subclassing PlatformObject. See Also: IAdapterFactory, IAdapterManager, PlatformObject extends IAdaptable A workbench part is a visual component within a workbench page. There are two subtypes: view and editor, as defined by IViewPart and IEditorPart. A view is typically used to navigate a hierarchy of information (like the workspace), open an editor, or display properties for the active editor. Modifications made in a view are saved immediately. An editor is typically used to edit or browse a document or input object. The input is identified using an IEditorInput. Modifications made in an editor part follow an open-save-close lifecycle model. This interface may be implemented directly. For convenience, a base implementation is defined in WorkbenchPart. The lifecycle of a workbench part is as follows: When a part extension is created: instantiate the part create a part site call part.init(site) When a part becomes visible in the workbench: add part to presentation by calling part.createPartControl(parent) to create actual widgets fire partOpened event to all listeners When a part is activated or gets focus: call part.setFocus() fire partActivated event to all listeners When a part is closed: if save is needed, do save; if it fails or is canceled return if part is active, deactivate part fire partClosed event to all listeners remove part from presentation; part controls are disposed as part of the SWT widget tree call part.dispose() After createPartControl has been called, the implementor may safely reference the controls created. When the part is closed these controls will be disposed as part of an SWT composite. This occurs before the IWorkbenchPart.dispose method is called. If there is a need to free SWT resources the part should define a dispose listener for its own control and free those resources from the dispose listener. If the part invokes any method on the disposed SWT controls after this point an SWTError will be thrown. The last method called on IWorkbenchPart is dispose. This signals the end of the part lifecycle. An important point to note about this lifecycle is that following a call to init, createPartControl may never be called. Thus in the dispose method, implementors must not assume controls were created. Workbench parts implement the IAdaptable interface; extensions are managed by the platform\'s adapter manager. See Also: IViewPart, IEditorPart extends IWorkbenchPart Extends IWorkbenchPart, adding the name and status text properties. Prior to 3.0, a view\'s title was often modified to show both the part name and extra status text. With this interface, the distinction is made more explicit. Since: 3.0 An interface for an adaptable object. Adaptable objects can be dynamically extended to provide different interfaces (or \"adapters\"). Adapters are created by adapter factories, which are in turn managed by type by adapter managers. For example, IAdaptable a = [some adaptable]; IFoo x = (IFoo)a.getAdapter(IFoo.class); if (x != null) [do IFoo things with x] This interface can be used without OSGi running. Clients may implement this interface, or obtain a default implementation of this interface by subclassing PlatformObject. See Also: IAdapterFactory, IAdapterManager, PlatformObject An interface for an adaptable object. Adaptable objects can be dynamically extended to provide different interfaces (or \"adapters\"). Adapters are created by adapter factories, which are in turn managed by type by adapter managers. For example, IAdaptable a = [some adaptable]; IFoo x = (IFoo)a.getAdapter(IFoo.class); if (x != null) [do IFoo things with x] This interface can be used without OSGi running. Clients may implement this interface, or obtain a default implementation of this interface by subclassing PlatformObject. See Also: IAdapterFactory, IAdapterManager, PlatformObject extends IAdaptable A workbench part is a visual component within a workbench page. There are two subtypes: view and editor, as defined by IViewPart and IEditorPart. A view is typically used to navigate a hierarchy of information (like the workspace), open an editor, or display properties for the active editor. Modifications made in a view are saved immediately. An editor is typically used to edit or browse a document or input object. The input is identified using an IEditorInput. Modifications made in an editor part follow an open-save-close lifecycle model. This interface may be implemented directly. For convenience, a base implementation is defined in WorkbenchPart. The lifecycle of a workbench part is as follows: When a part extension is created: instantiate the part create a part site call part.init(site) When a part becomes visible in the workbench: add part to presentation by calling part.createPartControl(parent) to create actual widgets fire partOpened event to all listeners When a part is activated or gets focus: call part.setFocus() fire partActivated event to all listeners When a part is closed: if save is needed, do save; if it fails or is canceled return if part is active, deactivate part fire partClosed event to all listeners remove part from presentation; part controls are disposed as part of the SWT widget tree call part.dispose() After createPartControl has been called, the implementor may safely reference the controls created. When the part is closed these controls will be disposed as part of an SWT composite. This occurs before the IWorkbenchPart.dispose method is called. If there is a need to free SWT resources the part should define a dispose listener for its own control and free those resources from the dispose listener. If the part invokes any method on the disposed SWT controls after this point an SWTError will be thrown. The last method called on IWorkbenchPart is dispose. This signals the end of the part lifecycle. An important point to note about this lifecycle is that following a call to init, createPartControl may never be called. Thus in the dispose method, implementors must not assume controls were created. Workbench parts implement the IAdaptable interface; extensions are managed by the platform\'s adapter manager. See Also: IViewPart, IEditorPart extends IWorkbenchPart Extends IWorkbenchPart, adding the name and status text properties. Prior to 3.0, a view\'s title was often modified to show both the part name and extra status text. With this interface, the distinction is made more explicit. Since: 3.0 extends IWorkbenchPart2 A part can provide arbitrary properties. The properties will be persisted between sessions by the part reference, and will be available from the part reference as well as the part. The properties can only be set on a part, not on the reference. The properties will be available to the IPresentablePart. Setting a property must fire a PropertyChangeEvent. Since: 3.3 The IWorkbenchPartOrientation is the interface that defines the orientation of the part. If a type does not implement this interface an orientation of SWT.NONE will be assumed. Since: 3.1 See Also: SWT.RIGHT_TO_LEFT, SWT.LEFT_TO_RIGHT, SWT.NONE, Window.getDefaultOrientation() extends WorkbenchPart implements IEditorPart Abstract base implementation of all workbench editors. This class should be subclassed by clients wishing to define new editors. The name of the subclass should be given as the \"class\" attribute in a editor extension contributed to the workbench\'s view extension point (named \"org.eclipse.ui.editors\"). For example, the plug-in\'s XML markup might contain: <extension point=\"org.eclipse.ui.editors\"> <editor id=\"com.example.myplugin.ed\" name=\"My Editor\" icon=\"./images/cedit.gif\" extensions=\"foo\" class=\"com.example.myplugin.MyFooEditor\" contributorClass=\"com.example.myplugin.MyFooEditorContributor\" /> </extension> where com.example.myplugin.MyEditor is the name of the EditorPart subclass. Subclasses must implement the following methods: IEditorPart.init - to initialize editor when assigned its site IWorkbenchPart.createPartControl - to create the editor\'s controls IWorkbenchPart.setFocus - to accept focus IEditorPart.isDirty - to decide whether a significant change has occurred IEditorPart.doSave - to save contents of editor IEditorPart.doSaveAs - to save contents of editor IEditorPart.isSaveAsAllowed - to control Save As Subclasses may extend or reimplement the following methods as required: IExecutableExtension.setInitializationData - extend to provide additional initialization when editor extension is instantiated IWorkbenchPart.dispose - extend to provide additional cleanup IAdaptable.getAdapter - reimplement to make the editor adaptable '
674, 'org.eclipse.swt.custom.ScrolledComposite', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/custom/ScrolledComposite.html', 'Implementers of Drawable can have a graphics context (GC) created for them, and then they can be drawn on by sending messages to their associated GC. SWT images, and device objects such as the Display device and the Printer device, are drawables. IMPORTANT: This interface is not part of the SWT public API. It is marked public only so that it can be shared within the packages provided by SWT. It should never be referenced from application code. See Also: Device, Image, GC extends Composite A ScrolledComposite provides scrollbars and will scroll its content when the user uses the scrollbars. There are two ways to use the ScrolledComposite: 1) Set the size of the control that is being scrolled and the ScrolledComposite will show scrollbars when the contained control can not be fully seen. 2) The second way imitates the way a browser would work. Set the minimum size of the control and the ScrolledComposite will show scroll bars if the visible area is less than the minimum size of the control and it will expand the size of the control if the visible area is greater than the minimum size. This requires invoking both setMinWidth(), setMinHeight() and setExpandHorizontal(), setExpandVertical(). public static void main (String [] args) { Display display = new Display (); Color red = display.getSystemColor(SWT.COLOR_RED); Color blue = display.getSystemColor(SWT.COLOR_BLUE); Shell shell = new Shell (display); shell.setLayout(new FillLayout()); // set the size of the scrolled content - method 1 final ScrolledComposite sc1 = new ScrolledComposite(shell, SWT.H_SCROLL | SWT.V_SCROLL | SWT.BORDER); final Composite c1 = new Composite(sc1, SWT.NONE); sc1.setContent(c1); c1.setBackground(red); GridLayout layout = new GridLayout(); layout.numColumns = 4; c1.setLayout(layout); Button b1 = new Button (c1, SWT.PUSH); b1.setText(\"first button\"); c1.setSize(c1.computeSize(SWT.DEFAULT, SWT.DEFAULT)); // set the minimum width and height of the scrolled content - method 2 final ScrolledComposite sc2 = new ScrolledComposite(shell, SWT.H_SCROLL | SWT.V_SCROLL | SWT.BORDER); sc2.setExpandHorizontal(true); sc2.setExpandVertical(true); final Composite c2 = new Composite(sc2, SWT.NONE); sc2.setContent(c2); c2.setBackground(blue); layout = new GridLayout(); layout.numColumns = 4; c2.setLayout(layout); Button b2 = new Button (c2, SWT.PUSH); b2.setText(\"first button\"); sc2.setMinSize(c2.computeSize(SWT.DEFAULT, SWT.DEFAULT)); Button add = new Button (shell, SWT.PUSH); add.setText(\"add children\"); final int[] index = new int[]{0}; add.addListener(SWT.Selection, new Listener() { public void handleEvent(Event e) { index[0]++; Button button = new Button(c1, SWT.PUSH); button.setText(\"button \"+index[0]); // reset size of content so children can be seen - method 1 c1.setSize(c1.computeSize(SWT.DEFAULT, SWT.DEFAULT)); c1.layout(); button = new Button(c2, SWT.PUSH); button.setText(\"button \"+index[0]); // reset the minimum width and height so children can be seen - method 2 sc2.setMinSize(c2.computeSize(SWT.DEFAULT, SWT.DEFAULT)); c2.layout(); } }); shell.open (); while (!shell.isDisposed ()) { if (!display.readAndDispatch ()) display.sleep (); } display.dispose (); } Styles: H_SCROLL, V_SCROLL See Also: ScrolledComposite snippets, Sample code and further information '
675, 'org.eclipse.jface.resource.JFaceColors', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/resource/JFaceColors.html', 'extends Object JFaceColors is the class that stores references to all of the colors used by JFace. '
676, 'org.eclipse.jface.preference.JFacePreferences', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/preference/JFacePreferences.html', 'extends Object JFacePreferences is a class used to administer the preferences used by JFace objects. '
677, 'org.eclipse.swt.custom.CLabel', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/custom/CLabel.html', 'Implementers of Drawable can have a graphics context (GC) created for them, and then they can be drawn on by sending messages to their associated GC. SWT images, and device objects such as the Display device and the Printer device, are drawables. IMPORTANT: This interface is not part of the SWT public API. It is marked public only so that it can be shared within the packages provided by SWT. It should never be referenced from application code. See Also: Device, Image, GC extends Canvas A Label which supports aligned text and/or an image and different border styles. If there is not enough space a CLabel uses the following strategy to fit the information into the available space: ignores the indent in left align mode ignores the image and the gap shortens the text by replacing the center portion of the label with an ellipsis shortens the text by removing the center portion of the label Styles: LEFT, RIGHT, CENTER, SHADOW_IN, SHADOW_OUT, SHADOW_NONE Events: This class may be subclassed for the purpose of overriding the default string shortening algorithm that is implemented in method shortenText(). See Also: SWT Example: CustomControlExample, Sample code and further information, shortenText(GC, String, int) '
678, 'org.eclipse.ui.menus.IWorkbenchContribution', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/menus/IWorkbenchContribution.html', 'Allow a menu contribution to be initialized with the appropriate service locator. Since: 3.4 '
679, 'org.eclipse.ui.services.IServiceLocator', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/services/IServiceLocator.html', ' A component with which one or more services are registered. The services can be retrieved from this locator using some key -- typically the class representing the interface the service must implement. For example: IHandlerService service = (IHandlerService) workbenchWindow .getService(IHandlerService.class); This interface is not to be implemented or extended by clients. Since: 3.2 '
680, 'org.eclipse.ui.part.IShowInTargetList', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/part/IShowInTargetList.html', 'Show In sources which need to provide additional entries to the Show In list of targets can provide this interface. The part can either directly implement this interface, or provide it via IAdaptable.getAdapter(IShowInTargetList). Since: 2.1 See Also: IShowInSource, IShowInTarget '
681, 'org.eclipse.core.runtime.IContributor', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/runtime/IContributor.html', 'This interface describes a registry contributor - an entity that supplies information to the extension registry. Registry contributor objects can be obtained by calling IExtensionPoint.getContributor(), IExtension.getContributor(), and IConfigurationElement.getContributor(). Alternatively, a contributor factory appropriate for the registry in use can be called to directly obtain an IContributor object. This interface can be used without OSGi running. This interface is not intended to be implemented or extended by clients. Since: org.eclipse.equinox.registry 3.2 See Also: ContributorFactoryOSGi, ContributorFactorySimple Restriction: This interface is not intended to be implemented by clients. Restriction: This interface is not intended to be extended by clients. '
682, 'org.eclipse.core.runtime.spi.RegistryContributor', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/runtime/spi/RegistryContributor.html', 'This interface describes a registry contributor - an entity that supplies information to the extension registry. Registry contributor objects can be obtained by calling IExtensionPoint.getContributor(), IExtension.getContributor(), and IConfigurationElement.getContributor(). Alternatively, a contributor factory appropriate for the registry in use can be called to directly obtain an IContributor object. This interface can be used without OSGi running. This interface is not intended to be implemented or extended by clients. Since: org.eclipse.equinox.registry 3.2 See Also: ContributorFactoryOSGi, ContributorFactorySimple Restriction: This interface is not intended to be implemented by clients. Restriction: This interface is not intended to be extended by clients. extends Object implements IContributor This class describes a registry contributor which is an entity that supplies information to the extension registry. Depending on the registry strategy, contributor might delegate some of its functionality to a \"host\" contributor. For instance, OSGi registry strategy uses \"host\" contributor to delegate some functionality from fragments to plug-ins. This class can be instantiated by the registry Service Providers. This class can be used without OSGi running. This class can not be extended. Note: This class/interface is part of an interim API that is still under development and expected to change significantly before reaching stability. It is being made available at this early stage to solicit feedback from pioneering adopters on the understanding that any code that uses this API will almost certainly be broken (repeatedly) as the API evolves. Since: org.eclipse.equinox.registry 3.2 Restriction: This class is not intended to be subclassed by clients. '
683, 'org.eclipse.e4.ui.model.fragment.MModelFragments', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/e4/ui/model/fragment/MModelFragments.html', ' A representation of the model object \'Model Fragments\'. Developers: Add more detailed documentation by editing this comment in /org.eclipse.e4.ui.model.workbench/model/ModelFragment.ecore. There is a GenModel/documentation node under each type and attribute. Since: 1.0 The following features are supported: Imports Fragments '
684, 'org.eclipse.e4.ui.model.fragment.MModelFragment', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/e4/ui/model/fragment/MModelFragment.html', ' A representation of the model object \'Model Fragment\'. Developers: Add more detailed documentation by editing this comment in /org.eclipse.e4.ui.model.workbench/model/ModelFragment.ecore. There is a GenModel/documentation node under each type and attribute. Since: 1.0 The following features are supported: Elements '
685, 'org.eclipse.core.runtime.ILog', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/runtime/ILog.html', 'A log to which status events can be written. Logs appear on individual plug-ins and on the platform itself. Clients can register log listeners which will receive notification of all log events as they come in. XXX Need to create a new log interface on common plugin. That interface should be a super interface of this ILog. getBundle() would stay here. In the super interface we would have getName() Restriction: This interface is not intended to be implemented by clients. '
686, 'org.eclipse.core.runtime.preferences.AbstractPreferenceInitializer', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/runtime/preferences/AbstractPreferenceInitializer.html', 'extends Object Abstract class used to aid in default preference value initialization. Clients who extend the org.eclipse.core.runtime.preferences extension point are able to specify a class within an initializer element. Since: 3.0 '
687, 'org.eclipse.core.runtime.preferences.DefaultScope', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/runtime/preferences/DefaultScope.html', 'Clients implement this interface to provide context to a particular scope. Instances of implementations of this interface are passed to the IPreferencesService for use in preference searching. Clients may implement this interface. Since: 3.0 See Also: IPreferencesService extends org.eclipse.core.internal.preferences.AbstractScope Object representing the default scope in the Eclipse preferences hierarchy. Can be used as a context for searching for preference values (in the IPreferencesService APIs) or for determining the correct preference node to set values in the store. Default preferences are not persisted to disk. The path for preferences defined in the default scope hierarchy is as follows: /default/<qualifier> Note about product preference customization: Clients who define their own org.eclipse.core.runtime.IProduct are able to specify a product key of \"preferenceCustomization\". (defined as a constant in org.eclipse.ui.branding.IProductConstants) Its value is either a URL or a file-system path to a file whose contents are used to customize default preferences. This class is not intended to be subclassed. This class may be instantiated. Since: 3.0 '
688, 'org.eclipse.ui.IPlaceholderFolderLayout', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/IPlaceholderFolderLayout.html', 'An IPlaceholderFolderLayout is used to define the initial view placeholders within a folder. The folder itself is contained within an IPageLayout. This interface is not intended to be implemented by clients. Since: 2.0 See Also: IPageLayout.createPlaceholderFolder(java.lang.String, int, float, java.lang.String) Restriction: This interface is not intended to be implemented by clients. '
689, 'org.eclipse.core.runtime.IRegistryChangeEvent', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/runtime/IRegistryChangeEvent.html', 'Registry change events describe changes to the extension registry. This interface can be used without OSGi running. This interface is not intended to be implemented by clients. Since: 3.0 See Also: IExtensionRegistry, IRegistryChangeListener Restriction: This interface is not intended to be implemented by clients. '
690, 'org.eclipse.core.runtime.IExtensionDelta', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/runtime/IExtensionDelta.html', 'An extension delta represents changes to the extension registry. This interface can be used without OSGi running. This interface is not intended to be implemented by clients. Since: 3.0 Restriction: This interface is not intended to be implemented by clients. '
691, 'org.eclipse.core.runtime.dynamichelpers.IExtensionChangeHandler', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/runtime/dynamichelpers/IExtensionChangeHandler.html', 'Extension change handlers are notified of changes for a given extension point in the context of an extension tracker. This interface can be used without OSGi running. This interface is intended to be implemented by clients. Since: 3.1 '
692, 'org.eclipse.jface.dialogs.TitleAreaDialog', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/dialogs/TitleAreaDialog.html', 'Interface for objects that can return a shell. This is normally used for opening child windows. An object that wants to open child shells can take an IShellProvider in its constructor, and the object that implements IShellProvider can dynamically choose where child shells should be opened. Since: 3.1 extends TrayDialog A dialog that has a title area for displaying a title and an image as well as a common area for displaying a description, a message, or an error message. This dialog class may be subclassed. '
693, 'org.eclipse.jface.wizard.IWizardContainer2', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/wizard/IWizardContainer2.html', 'Interface for UI components which can execute a long-running operation in the form of an IRunnableWithProgress. The context is responsible for displaying a progress indicator and Cancel button to the end user while the operation is in progress; the context supplies a progress monitor to be used from code running inside the operation. Note that an IRunnableContext is not a runnable itself. For examples of UI components which implement this interface, see ApplicationWindow, ProgressMonitorDialog, and WizardDialog. See Also: IRunnableWithProgress, ApplicationWindow, ProgressMonitorDialog, WizardDialog extends IRunnableContext Interface for containers that can host a wizard. It displays wizard pages, at most one of which is considered the current page. getCurrentPage returns the current page; showPage programmatically changes the the current page. Note that the pages need not all belong to the same wizard. The class WizardDialog provides a fully functional implementation of this interface which will meet the needs of most clients. However, clients are also free to implement this interface if WizardDialog does not suit their needs. Implementors are responsible for disposing of their wizards. See Also: IWizardContainer2 extends IWizardContainer IWizardContainer2 is a supplement to IWizardContainer that adds a method for updating the size of the wizard shell based on the contents of the current page. The class WizardDialog provides a fully functional implementation of this interface which will meet the needs of most clients. However, clients are also free to implement this interface if WizardDialog does not suit their needs. Since: 3.0 See Also: IWizardContainer '
694, 'org.eclipse.jface.wizard.IWizard', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/wizard/IWizard.html', 'Interface for a wizard. A wizard maintains a list of wizard pages, stacked on top of each other in card layout fashion. The class Wizard provides an abstract implementation of this interface. However, clients are also free to implement this interface if Wizard does not suit their needs. See Also: Wizard '
695, 'org.eclipse.jface.wizard.IWizardPage', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/wizard/IWizardPage.html', 'Interface for a page in a multi-page dialog. extends IDialogPage Interface for a wizard page. The class WizardPage provides an abstract implementation of this interface. However, clients are also free to implement this interface if WizardPage does not suit their needs. '
696, 'org.eclipse.jface.wizard.ProgressMonitorPart', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/wizard/ProgressMonitorPart.html', 'The IProgressMonitor interface is implemented by objects that monitor the progress of an activity; the methods in this interface are invoked by code that performs the activity. All activity is broken down into a linear sequence of tasks against which progress is reported. When a task begins, a beginTask(String, int) notification is reported, followed by any number and mixture of progress reports (worked()) and subtask notifications (subTask(String)). When the task is eventually completed, a done() notification is reported. After the done() notification, the progress monitor cannot be reused; i.e., beginTask(String, int) cannot be called again after the call to done(). A request to cancel an operation can be signaled using the setCanceled method. Operations taking a progress monitor are expected to poll the monitor (using isCanceled) periodically and abort at their earliest convenience. Operation can however choose to ignore cancelation requests. Since notification is synchronous with the activity itself, the listener should provide a fast and robust implementation. If the handling of notifications would involve blocking operations, or operations which might throw uncaught exceptions, the notifications should be queued, and the actual processing deferred (or perhaps delegated to a separate thread). This interface can be used without OSGi running. Clients may implement this interface. extends IProgressMonitor An extension to the IProgressMonitor interface for monitors that want to support feedback when an activity is blocked due to concurrent activity in another thread. When a monitor that supports this extension is passed to an operation, the operation should call setBlocked whenever it knows that it must wait for a lock that is currently held by another thread. The operation should continue to check for and respond to cancelation requests while blocked. When the operation is no longer blocked, it must call clearBlocked to clear the blocked state. This interface can be used without OSGi running. Clients may implement this interface. Since: 3.0 See Also: IProgressMonitor Implementers of Drawable can have a graphics context (GC) created for them, and then they can be drawn on by sending messages to their associated GC. SWT images, and device objects such as the Display device and the Printer device, are drawables. IMPORTANT: This interface is not part of the SWT public API. It is marked public only so that it can be shared within the packages provided by SWT. It should never be referenced from application code. See Also: Device, Image, GC extends Composite implements IProgressMonitorWithBlocking A standard implementation of an IProgressMonitor. It consists of a label displaying the task and subtask name, and a progress indicator to show progress. In contrast to ProgressMonitorDialog this class only implements IProgressMonitor. '
697, 'org.eclipse.jface.dialogs.IDialogConstants', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/dialogs/IDialogConstants.html', 'IDialogConstants is the interface for common dialog strings and ids used throughout JFace. It is recommended that you use these labels and ids wherever for consistency with the JFace dialogs. '
698, 'org.eclipse.jface.dialogs.PageChangingEvent', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/dialogs/PageChangingEvent.html', 'extends EventObject Event object describing an IDialogPage in the midst of changing. Since: 3.3 See Also: IPageChangingListener, Serialized Form '
699, 'org.eclipse.jface.dialogs.ControlEnableState', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/dialogs/ControlEnableState.html', 'extends Object Helper class to save the enable/disable state of a control including all its descendent controls. '
700, 'org.eclipse.jface.dialogs.PageChangedEvent', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/dialogs/PageChangedEvent.html', 'extends EventObject Event object describing a page selection change. The source of these events is a page change provider. Since: 3.1 See Also: IPageChangeProvider, IPageChangedListener, Serialized Form '
701, 'org.eclipse.jface.dialogs.IMessageProvider', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/dialogs/IMessageProvider.html', 'Minimal interface to a message provider. Used for dialog pages which can provide a message with an icon. Since: 2.0 '
702, 'org.eclipse.jface.dialogs.IPageChangingListener', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/dialogs/IPageChangingListener.html', 'A listener which is notified when the current page of a multi-page dialog is changing. Use this listener to perform long-running work that should only be executed once, when the page is in the process of changing, rather then during validation of page controls. Since: 3.3 See Also: PageChangingEvent '
703, 'org.eclipse.jface.fieldassist.ControlDecoration', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/fieldassist/ControlDecoration.html', 'extends Object ControlDecoration renders an image decoration near a control. It allows clients to specify an image and a position for the image relative to the control. A ControlDecoration may be assigned description text, which can optionally be shown when the user hovers over the image. Clients can decorate any kind of control. Decoration images always appear on the left or right side of the field, never above or below it. Decorations can be positioned at the top, center, or bottom of either side of the control. Future implementations may provide additional positioning options for decorations. ControlDecoration renders the image adjacent to the specified (already created) control, with no guarantee that it won\'t be clipped or otherwise obscured or overlapped by adjacent controls, including another ControlDecoration placed in the same location. Clients should ensure that there is adequate space adjacent to the control to show the decoration properly. Clients using ControlDecoration should typically ensure that enough margin space is reserved for a decoration by altering the layout data margins, although this is not assumed or required by the ControlDecoration implementation. This class is intended to be instantiated and used by clients. It is not intended to be subclassed by clients. Since: 3.3 See Also: FieldDecoration, FieldDecorationRegistry Restriction: This class is not intended to be subclassed by clients. '
704, 'org.eclipse.core.commands.ParameterType', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/commands/ParameterType.html', ' An object that is unique identifiable based on the combination of its class and its identifier. Since: 3.2 See Also: HandleObject extends HandleObject implements Comparable Provides information about the type of a command parameter. Clients can use a parameter type to check if an object matches the type of the parameter with isCompatible(Object) and can get an AbstractParameterValueConverter to convert between objects matching the parameter type and strings that encode the object\'s identity. A command parameter is not required to declare a type. To determine if a given parameter has a type, check if an IParameter implements ITypedParameter and if so, use ITypedParameter.getParameterType() like this: IParameter parameter = // ... get IParameter from Command if (parameter instanceof ITypedParameter) { ParameterType type = ((ITypedParameter)parameter).getParameterType(); if (type != null) { // this parameter has a ParameterType } } Since: 3.2 See Also: IParameter, ITypedParameter.getParameterType() '
705, 'org.eclipse.core.commands.AbstractParameterValueConverter', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/commands/AbstractParameterValueConverter.html', 'extends Object Supports conversion between objects and strings for command parameter values. Extenders must produce strings that identify objects (of a specific command parameter type) as well as consume the strings to locate and return the objects they identify. This class offers multiple handlers of a command a consistent way of converting string parameter values into the objects that the handlers would prefer to deal with. This class also gives clients a way to serialize object parameters as strings so that entire parameterized commands can be serialized, stored and later deserialized and executed. This class will typically be extended so the subclass can be referenced from the converter attribute of the commandParameterType elemement of the org.eclipse.ui.commands extension-point. Objects implementing this interface may also be passed directly to ParameterType.define(String, AbstractParameterValueConverter) by clients. Since: 3.2 See Also: ParameterType.define(String, AbstractParameterValueConverter), ParameterizedCommand.serialize() '
706, 'org.eclipse.jface.preference.IntegerFieldEditor', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/preference/IntegerFieldEditor.html', 'extends StringFieldEditor A field editor for an integer type preference. '
707, 'org.eclipse.jface.preference.FieldEditor', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/preference/FieldEditor.html', 'extends Object Abstract base class for all field editors. A field editor presents the value of a preference to the end user. The value is loaded from a preference store; if modified by the end user, the value is validated and eventually stored back to the preference store. A field editor reports an event when the value, or the validity of the value, changes. Field editors should be used in conjunction with a field editor preference page (FieldEditorPreferencePage) which coordinates everything and provides the message line which display messages emanating from the editor. This package contains ready-to-use field editors for various types of preferences: BooleanFieldEditor - booleans IntegerFieldEditor - integers StringFieldEditor - text strings RadioGroupFieldEditor - enumerations ColorFieldEditor - RGB colors FontFieldEditor - fonts DirectoryFieldEditor - directories FileFieldEditor - files PathEditor - paths '
708, 'org.eclipse.ui.ide.dialogs.ResourceEncodingFieldEditor', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/ide/dialogs/ResourceEncodingFieldEditor.html', 'extends AbstractEncodingFieldEditor The ResourceEncodingFieldEditor is a field editor for editing the encoding of a resource and does not use a preference store. This class may be instantiated; it is not intended to be subclassed. Since: 3.1 '
709, 'org.eclipse.jface.preference.RadioGroupFieldEditor', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/preference/RadioGroupFieldEditor.html', 'extends FieldEditor A field editor for an enumeration type preference. The choices are presented as a list of radio buttons. '
710, 'org.eclipse.ui.dialogs.PreferenceLinkArea', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/dialogs/PreferenceLinkArea.html', 'extends Object The PreferenceLinkArea is the link area used to open a specific preference page. Since: 3.1 '
711, 'org.eclipse.ui.preferences.IWorkbenchPreferenceContainer', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/preferences/IWorkbenchPreferenceContainer.html', 'IWorkbenchPreferenceContainer is the class that specifies the workbench specific preferences support. Since: 3.1 '
712, 'org.eclipse.core.resources.IWorkspaceDescription', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/resources/IWorkspaceDescription.html', 'A workspace description represents the workspace preferences. It can be used to query the current preferences and set new ones. The workspace preference values are stored in the preference store and are also accessible via the preference mechanism. Constants for the preference keys are found on the ResourcesPlugin class. See Also: IWorkspace.getDescription(), IWorkspace.setDescription(IWorkspaceDescription), IWorkspace.newProjectDescription(String) Restriction: This interface is not intended to be implemented by clients. Restriction: This interface is not intended to be extended by clients. '
713, 'org.eclipse.jface.preference.StringFieldEditor', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/preference/StringFieldEditor.html', 'extends FieldEditor A field editor for a string type preference. This class may be used as is, or subclassed as required. '
714, 'org.eclipse.ui.WorkbenchEncoding', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/WorkbenchEncoding.html', 'extends Object WorkbenchEncoding is a utility class for plug-ins that want to use the list of encodings defined by default in the workbench. Since: 3.1 '
715, 'org.eclipse.core.runtime.Preferences', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/runtime/Preferences.html', 'extends Object A table of preference settings, mapping named properties to values. Property names are non-empty strings; property values can be either booleans, non-null strings, or values of one of the primitive number types. The table consists of two, sparse, layers: the lower layer holds default values for properties, and the upper layer holds explicitly set values for properties. Normal retrieval looks for an explicitly set value for the given property in the upper layer; if there is nothing for that property in the upper layer, it next looks for a default value for the given property in the lower layer; if there is nothing for that property in the lower layer, it returns a standard default-default value. The default-default values for the primitive types are as follows: boolean = false double = 0.0 float = 0.0f int = 0 long = 0L String = \"\" (the empty string) Internally, all properties values (in both layers) are stored as strings. Standard conversions to and from numeric and boolean types are performed on demand. The typical usage is to establish the defaults for all known properties and then restore previously stored values for properties whose values were explicitly set. The existing settings can be changed and new properties can be set (setValue). If the values specified is the same as the default value, the explicit setting is deleted from the top layer. It is also possible to reset a property value back to the default value using setToDefault. After the properties have been modified, the properties with explicit settings are written to disk. The default values are never saved. This two-tiered approach to saving and restoring property setting minimizes the number of properties that need to be persisted; indeed, the normal starting state does not require storing any properties at all. It also makes it easy to use different default settings in different environments while maintaining just those property settings the user has adjusted. A property change event is reported whenever a property\'s value actually changes (either through setValue, setToDefault). Note, however, that manipulating default values (with setDefault) does not cause any events to be reported. Clients may instantiate this class. The implementation is based on a pair of internal java.util.Properties objects, one holding explicitly set values (set using setValue), the other holding the default values (set using setDefaultValue). The load and store methods persist the non-default property values to streams (the default values are not saved). If a client sets a default value to be equivalent to the default-default for that type, the value is still known to the preference store as having a default value. That is, the name will still be returned in the result of the defaultPropertyNames and contains methods. Since: 2.0 Restriction: This class is not intended to be subclassed by clients. '
716, 'org.eclipse.ui.ide.IDEEncoding', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/ide/IDEEncoding.html', 'extends Object IDEEncoding is a utility class for managing encoding information that includes user preferences from the IDE and core resources. This class provides all its functionality via static methods. It is not intended to be instantiated or subclassed. Since: 3.1 See Also: WorkbenchEncoding, ResourcesPlugin '
717, 'org.eclipse.ui.progress.IJobRunnable', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/progress/IJobRunnable.html', 'Interface for runnables that can be run as jobs. Since: 3.3 '
718, 'org.eclipse.core.runtime.SubMonitor', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/runtime/SubMonitor.html', 'The IProgressMonitor interface is implemented by objects that monitor the progress of an activity; the methods in this interface are invoked by code that performs the activity. All activity is broken down into a linear sequence of tasks against which progress is reported. When a task begins, a beginTask(String, int) notification is reported, followed by any number and mixture of progress reports (worked()) and subtask notifications (subTask(String)). When the task is eventually completed, a done() notification is reported. After the done() notification, the progress monitor cannot be reused; i.e., beginTask(String, int) cannot be called again after the call to done(). A request to cancel an operation can be signaled using the setCanceled method. Operations taking a progress monitor are expected to poll the monitor (using isCanceled) periodically and abort at their earliest convenience. Operation can however choose to ignore cancelation requests. Since notification is synchronous with the activity itself, the listener should provide a fast and robust implementation. If the handling of notifications would involve blocking operations, or operations which might throw uncaught exceptions, the notifications should be queued, and the actual processing deferred (or perhaps delegated to a separate thread). This interface can be used without OSGi running. Clients may implement this interface. extends IProgressMonitor An extension to the IProgressMonitor interface for monitors that want to support feedback when an activity is blocked due to concurrent activity in another thread. When a monitor that supports this extension is passed to an operation, the operation should call setBlocked whenever it knows that it must wait for a lock that is currently held by another thread. The operation should continue to check for and respond to cancelation requests while blocked. When the operation is no longer blocked, it must call clearBlocked to clear the blocked state. This interface can be used without OSGi running. Clients may implement this interface. Since: 3.0 See Also: IProgressMonitor extends Object implements IProgressMonitorWithBlocking A progress monitor that uses a given amount of work ticks from a parent monitor. This is intended as a safer, easier-to-use alternative to SubProgressMonitor. The main benefits of SubMonitor over SubProgressMonitor are: It is not necessary to call beginTask() or done() on an instance of SubMonitor. SubMonitor has a simpler syntax for creating nested monitors. SubMonitor is more efficient for deep recursion chains. SubMonitor has a setWorkRemining method that allows the remaining space on the monitor to be redistributed without reporting any work. SubMonitor protects the caller from common progress reporting bugs in a called method. For example, if a called method fails to call done() on the given monitor or fails to consume all the ticks on the given monitor, the parent will correct the problem after the method returns. USAGE: When implementing a method that accepts an IProgressMonitor: At the start of your method, use SubMonitor.convert(...). to convert the IProgressMonitor into a SubMonitor. Use SubMonitor.newChild(...) whenever you need to call another method that accepts an IProgressMonitor. DEFAULT BEHAVIOR: When writing JavaDoc for a method that accepts an IProgressMonitor, you should assume the following default behavior unless the method\'s JavaDoc says otherwise: It WILL call beginTask on the IProgressMonitor. It WILL NOT accept a null argument. It WILL call done on the IProgressMonitor. BEST PRACTISES: We recommend that newly-written methods follow the given contract: It WILL call beginTask on the IProgressMonitor. It WILL accept a null argument, indicating that no progress should be reported and the operation cannot be cancelled. It WILL NOT call done on the IProgressMonitor, leaving this responsibility up to the caller. If you wish to follow these conventions, you may copy and paste the following text into your method\'s JavaDoc: @param monitor the progress monitor to use for reporting progress to the user. It is the caller\'s responsibility to call done() on the given monitor. Accepts null, indicating that no progress should be reported and that the operation cannot be cancelled. Example: Recommended usage This example demonstrates how the recommended usage of SubMonitor makes it unnecessary to call IProgressMonitor.done() in most situations. It is never necessary to call done() on a monitor obtained from convert or progress.newChild(). In this example, there is no guarantee that monitor is an instance of SubMonitor, making it necessary to call monitor.done(). The JavaDoc contract makes this the responsibility of the caller. // param monitor the progress monitor to use for reporting progress to the user. It is the caller\'s responsibility // to call done() on the given monitor. Accepts null, indicating that no progress should be // reported and that the operation cannot be cancelled. // void doSomething(IProgressMonitor monitor) { // Convert the given monitor into a progress instance SubMonitor progress = SubMonitor.convert(monitor, 100); // Use 30% of the progress to do some work doSomeWork(progress.newChild(30)); // Advance the monitor by another 30% progress.worked(30); // Use the remaining 40% of the progress to do some more work doSomeWork(progress.newChild(40)); } Example: Default usage You will often need to implement a method that does not explicitly stipulate that calling done() is the responsibility of the caller. In this case, you should use the following pattern: // param monitor the progress monitor to use for reporting progress to the user, or null indicating // that no progress should be reported and the operation cannot be cancelled. // void doSomething(IProgressMonitor monitor) { // Convert the given monitor into a progress instance SubMonitor progress = SubMonitor.convert(monitor, 100); try { // Use 30% of the progress to do some work doSomeWork(progress.newChild(30)); // Advance the monitor by another 30% progress.worked(30); // Use the remaining 40% of the progress to do some more work doSomeWork(progress.newChild(40)); } finally { if (monitor != null) { monitor.done(); } } } Example: Branches This example demonstrates how to smoothly report progress in situations where some of the work is optional. void doSomething(IProgressMonitor monitor) { SubMonitor progress = SubMonitor.convert(monitor, 100); if (condition) { // Use 50% of the progress to do some work doSomeWork(progress.newChild(50)); } // Don\'t report any work, but ensure that we have 50 ticks remaining on the progress monitor. // If we already consumed 50 ticks in the above branch, this is a no-op. Otherwise, the remaining // space in the monitor is redistributed into 50 ticks. progress.setWorkRemaining(50); // Use the remainder of the progress monitor to do the rest of the work doSomeWork(progress.newChild(50)); } Please beware of the following anti-pattern: if (condition) { // Use 50% of the progress to do some work doSomeWork(progress.newChild(50)); } else { // Bad: Causes the progress monitor to appear to start at 50%, wasting half of the // space in the monitor. progress.worked(50); } Example: Loops This example demonstrates how to report progress in a loop. void doSomething(IProgressMonitor monitor, Collection someCollection) { SubMonitor progress = SubMonitor.convert(monitor, 100); // Create a new progress monitor that uses 70% of the total progress and will allocate one tick // for each element of the given collection. SubMonitor loopProgress = progress.newChild(70).setWorkRemaining(someCollection.size()); for (Iterator iter = someCollection.iterator(); iter.hasNext();) { Object next = iter.next(); doWorkOnElement(next, loopProgress.newChild(1)); } // Use the remaining 30% of the progress monitor to do some work outside the loop doSomeWork(progress.newChild(30)); } Example: Infinite progress This example demonstrates how to report logarithmic progress in situations where the number of ticks cannot be easily computed in advance. void doSomething(IProgressMonitor monitor, LinkedListNode node) { SubMonitor progress = SubMonitor.convert(monitor); while (node != null) { // Regardless of the amount of progress reported so far, // use 0.01% of the space remaining in the monitor to process the next node. progress.setWorkRemaining(10000); doWorkOnElement(node, progress.newChild(1)); node = node.next; } } This class can be used without OSGi running. Since: org.eclipse.equinox.common 3.3 '
719, 'org.eclipse.core.runtime.URIUtil', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/runtime/URIUtil.html', 'extends Object A utility class for manipulating URIs. This class works around some of the undesirable behavior of the URI class, and provides additional path manipulation methods that are not available on the URI class. Since: org.eclipse.equinox.common 3.5 Restriction: This class is not intended to be instantiated by clients. '
720, 'org.eclipse.core.commands.HandlerEvent', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/commands/HandlerEvent.html', 'extends AbstractBitSetEvent An instance of this class describes changes to an instance of IHandler. This class is not intended to be extended by clients. Since: 3.1 See Also: IHandlerListener.handlerChanged(HandlerEvent) '
721, 'org.eclipse.ui.SubActionBars', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/SubActionBars.html', 'Used by a part to access its menu, toolbar, and status line managers. Within the workbench each part, editor or view, has a private set of action bars. This set, which contains a menu, toolbar, and status line, appears in the local toolbar for a view and in the window for an editor. The view may provide an implementation for pre-existing actions or add new actions to the action bars. In a workbench window there are a number of actions which are applicable to all parts. Some common examples are CUT, COPY and PASTE. These actions, known as \"global actions\", are contributed to the workbench window by the window itself and shared by all parts. The presentation is owned by the window. The implementation is delegated to the active part. To participate in the global action design an IWorkbenchPart should register a handler for each global action which is implemented by the part. This can be done by calling setGlobalActionHandler. For convenience, the standard global actions are defined in org.eclipse.ui.IWorkbenchActionConstants. Additional work is required for the Delete global action. In this case the accelerator is defined in the menu item text but is not hooked on the window. This is to support text editors where the Delete key is functional even when the Delete action is disabled (no text is selected). An implementation for this accelerator must be defined locally, in each part, by listening for Delete key events. A part may also contribute new actions to the action bars as required. To do this, call getMenuManager, getToolBarManager, or getStatusLineManager as appropriate to get the action target. Add the action(s) to the target and call update to commit any changes to the underlying widgets. This interface is not intended to be implemented by clients. Restriction: This interface is not intended to be implemented by clients. extends EventManager implements IActionBars Generic implementation of the IActionBars interface. '
722, 'org.eclipse.core.databinding.observable.set.AbstractObservableSet', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/databinding/observable/set/AbstractObservableSet.html', 'An object with state that allows to listen for state changes. Implementations must not manage listeners themselves, listener management must be delegated to a private instance of type ChangeSupport if it is not inherited from AbstractObservable. Since: 1.0 Restriction: This interface is not intended to be implemented by clients. Clients should instead subclass one of the classes in the framework that implement this interface. Note that direct implementers of this interface outside of the framework will be broken in future releases when methods are added to this interface. extends IObservable, Collection Interface for observable collections. Only general change listeners can be added to an observable collection. Listeners interested in incremental changes have to be added using more concrete subtypes such as IObservableList or IObservableSet. Since: 1.0 Restriction: This interface is not intended to be implemented by clients. Clients should instead subclass one of the classes that implement this interface. Note that direct implementers of this interface outside of the framework will be broken in future releases when methods are added to this interface. Restriction: This interface is not intended to be extended by clients. extends Set, IObservableCollection A set whose changes can be tracked by set change listeners. Since: 1.0 See Also: AbstractObservableSet, ObservableSet Restriction: This interface is not intended to be implemented by clients. Clients should instead subclass one of the classes that implement this interface. Note that direct implementers of this interface outside of the framework will be broken in future releases when methods are added to this interface. extends AbstractObservable implements IObservableSet Abstract implementation of IObservableSet. This class is thread safe. All state accessing methods must be invoked from the current realm. Methods for adding and removing listeners may be invoked from any thread. Since: 1.0 '
723, 'org.eclipse.core.databinding.observable.ObservableTracker', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/databinding/observable/ObservableTracker.html', 'extends Object This class makes it possible to monitor whenever an IObservable is read from. This can be used to automatically attach and remove listeners. How to use it: If you are implementing an IObservable, invoke getterCalled(this) whenever a getter is called - that is, whenever your observable is read from. You only need to do this once per method call. If one getter delegates to another, the outer getter doesn\'t need to call the method since the inner one will. If you want to determine what observables were used in a particular block of code, call runAndMonitor(Runnable). This will execute the given runnable and return the set of observables that were read from. This can be used to automatically attach listeners. For example, imagine you have a block of code that updates some widget by reading from a bunch of observables. Whenever one of those observables changes, you want to re-run the code and cause the widget to be refreshed. You could do this in the traditional manner by attaching one listener to each observable and re-running your widget update code whenever one of them changes, but this code is repetitive and requires updating the listener code whenever you refactor the widget updating code. Alternatively, you could use a utility class that runs the code in a runAndMonitor block and automatically attach listeners to any observable used in updating the widget. The advantage of the latter approach is that it, eliminates the code for attaching and detaching listeners and will always stay in synch with changes to the widget update logic. Since: 1.0 '
724, 'org.eclipse.core.databinding.observable.set.SetDiff', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/databinding/observable/set/SetDiff.html', 'extends Object implements IDiff Since: 1.0 '
725, 'org.eclipse.core.databinding.observable.IChangeListener', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/databinding/observable/IChangeListener.html', 'extends IObservablesListener Listener for generic change events. Note that the change events do not carry information about the change, they only specify the affected observable. To listen for specific change events, use more specific change listeners. Since: 1.0 See Also: IValueChangeListener, IListChangeListener, ISetChangeListener, IMapChangeListener '
726, 'org.eclipse.core.databinding.observable.set.ISetChangeListener', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/databinding/observable/set/ISetChangeListener.html', 'extends IObservablesListener Listener for changes to observable sets. Since: 1.0 '
727, 'org.eclipse.jface.viewers.ComboBoxCellEditor', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/viewers/ComboBoxCellEditor.html', 'extends CellEditor A cell editor that presents a list of items in a combo box. The cell editor\'s value is the zero-based index of the selected item. This class may be instantiated; it is not intended to be subclassed. Restriction: This class is not intended to be subclassed by clients. '
728, 'org.eclipse.jface.viewers.CellNavigationStrategy', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/viewers/CellNavigationStrategy.html', 'extends Object This class implementation the strategy how the table is navigated using the keyboard. Subclasses can implement their custom navigation algorithms Since: 3.3 '
729, 'org.eclipse.jface.viewers.TableViewerFocusCellManager', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/viewers/TableViewerFocusCellManager.html', 'extends Object This class is responsible to provide the concept of cells for Table. This concept is needed to provide features like editor activation with the keyboard Since: 3.3 '
730, 'org.eclipse.jface.viewers.ColumnViewerEditorActivationListener', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/viewers/ColumnViewerEditorActivationListener.html', 'extends Object Parties interested in activation and deactivation of editors extend this class and implement any or all of the methods Since: 3.3 '
731, 'org.eclipse.jface.viewers.ColumnViewerEditorDeactivationEvent', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/viewers/ColumnViewerEditorDeactivationEvent.html', 'extends EventObject This event is fired when an editor deactivated Since: 3.3 See Also: Serialized Form Restriction: This class is not intended to be subclassed by clients. '
732, 'org.eclipse.jface.viewers.TableViewerEditor', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/viewers/TableViewerEditor.html', 'extends ColumnViewerEditor This is an editor-implementation for Table Since: 3.3 '
733, 'org.eclipse.jface.viewers.DelegatingStyledCellLabelProvider', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/viewers/DelegatingStyledCellLabelProvider.html', 'A label provider maps an element of the viewer\'s model to an optional image and optional text string used to display the element in the viewer\'s control. Certain label providers may allow multiple labels per element. This is an \"abstract interface\", defining methods common to all label providers, but does not actually define the methods to get the label(s) for an element. This interface should never be directly implemented. Most viewers will take either an ILabelProvider or an ITableLabelProvider. A label provider must not be shared between viewers since a label provider generally manages SWT resources (images), which must be disposed when the viewer is disposed. To simplify life cycle management, the current label provider of a viewer is disposed when the viewer is disposed. Label providers can be used outside the context of viewers wherever images are needed. When label providers are used in this fashion it is the responsibility of the user to ensure dispose is called when the provider is no longer needed. See Also: ILabelProvider, ITableLabelProvider extends StyledCellLabelProvider A DelegatingStyledCellLabelProvider is a StyledCellLabelProvider that delegates requests for the styled string and the image to a DelegatingStyledCellLabelProvider.IStyledLabelProvider. Existing label providers can be enhanced by implementing DelegatingStyledCellLabelProvider.IStyledLabelProvider so they can be used in viewers with styled labels. The DelegatingStyledCellLabelProvider.IStyledLabelProvider can optionally implement IColorProvider and IFontProvider to provide foreground and background color and a default font. Since: 3.4 '
734, 'org.eclipse.jface.viewers.ViewerRow', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/viewers/ViewerRow.html', 'extends Object implements Cloneable ViewerRow is the abstract superclass of the part that represents items in a Table or Tree. Implementors of ColumnViewer have to provide a concrete implementation for the underlying widget Since: 3.3 '
735, 'org.eclipse.jface.viewers.IInputProvider', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/viewers/IInputProvider.html', 'Interface common to all objects that provide an input. '
736, 'org.eclipse.jface.viewers.ILazyContentProvider', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/viewers/ILazyContentProvider.html', 'A content provider mediates between the viewer\'s model and the viewer itself. See Also: ContentViewer.setContentProvider(IContentProvider) extends IContentProvider The ILazyContentProvider is the content provider for table viewers created using the SWT.VIRTUAL flag that only wish to return their contents as they are queried. NOTE: As the ILazyContentProvider does not have API for determining the total item count any changes to the number of items for this object while require a call to #setItemCount on the viewer that uses it. '
737, 'org.eclipse.jface.viewers.TableViewerRow', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/viewers/TableViewerRow.html', 'extends ViewerRow TableViewerRow is the Table specific implementation of ViewerRow Since: 3.3 '
738, 'org.eclipse.jface.viewers.AbstractTableViewer', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/viewers/AbstractTableViewer.html', 'Interface common to all objects that provide an input. extends IInputProvider, ISelectionProvider Interface common to all objects that provide both an input and a selection. Interface common to all objects that provide a selection. See Also: ISelection, ISelectionChangedListener, SelectionChangedEvent extends ISelectionProvider Selection provider extension interface to allow providers to notify about post selection changed events. A post selection changed event is equivalent to selection changed event if the selection change was triggered by the mouse, but it has a delay if the selection change is triggered by keyboard navigation. Since: 3.0 See Also: ISelectionProvider Interface common to all objects that provide a selection. See Also: ISelection, ISelectionChangedListener, SelectionChangedEvent extends ColumnViewer This is a widget independent class implementors of Table like widgets can use to provide a viewer on top of their widget implementations. Since: 3.3 '
739, 'org.eclipse.jface.viewers.ColumnViewerEditor', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/viewers/ColumnViewerEditor.html', 'extends Object This is the base for all editor implementations of Viewers. ColumnViewer implementors have to subclass this class and implement the missing methods Since: 3.3 See Also: TableViewerEditor, TreeViewerEditor '
740, 'org.eclipse.jface.viewers.IIndexableLazyContentProvider', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/viewers/IIndexableLazyContentProvider.html', 'A content provider mediates between the viewer\'s model and the viewer itself. See Also: ContentViewer.setContentProvider(IContentProvider) A content provider mediates between the viewer\'s model and the viewer itself. See Also: ContentViewer.setContentProvider(IContentProvider) extends IContentProvider The ILazyContentProvider is the content provider for table viewers created using the SWT.VIRTUAL flag that only wish to return their contents as they are queried. NOTE: As the ILazyContentProvider does not have API for determining the total item count any changes to the number of items for this object while require a call to #setItemCount on the viewer that uses it. extends ILazyContentProvider Adds efficient element indexing support to ILazyContentProvider. Since: 3.5 '
741, 'org.eclipse.jface.viewers.AbstractListViewer', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/viewers/AbstractListViewer.html', 'Interface common to all objects that provide an input. extends IInputProvider, ISelectionProvider Interface common to all objects that provide both an input and a selection. Interface common to all objects that provide a selection. See Also: ISelection, ISelectionChangedListener, SelectionChangedEvent extends ISelectionProvider Selection provider extension interface to allow providers to notify about post selection changed events. A post selection changed event is equivalent to selection changed event if the selection change was triggered by the mouse, but it has a delay if the selection change is triggered by keyboard navigation. Since: 3.0 See Also: ISelectionProvider Interface common to all objects that provide a selection. See Also: ISelection, ISelectionChangedListener, SelectionChangedEvent extends StructuredViewer Abstract base class for viewers that contain lists of items (such as a combo or list). Most of the viewer implementation is in this base class, except for the minimal code that actually communicates with the underlying widget. Since: 3.0 See Also: ListViewer, ComboViewer '
742, 'org.eclipse.core.resources.mapping.ResourceMapping', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/resources/mapping/ResourceMapping.html', 'An interface for an adaptable object. Adaptable objects can be dynamically extended to provide different interfaces (or \"adapters\"). Adapters are created by adapter factories, which are in turn managed by type by adapter managers. For example, IAdaptable a = [some adaptable]; IFoo x = (IFoo)a.getAdapter(IFoo.class); if (x != null) [do IFoo things with x] This interface can be used without OSGi running. Clients may implement this interface, or obtain a default implementation of this interface by subclassing PlatformObject. See Also: IAdapterFactory, IAdapterManager, PlatformObject extends PlatformObject A resource mapping supports the transformation of an application model object into its underlying file system resources. It provides the bridge between a logical element and the physical resource(s) into which it is stored but does not provide more comprehensive model access or manipulations. Mappings provide two means of model traversal. The accept(org.eclipse.core.resources.mapping.ResourceMappingContext, org.eclipse.core.resources.IResourceVisitor, org.eclipse.core.runtime.IProgressMonitor) method can be used to visit the resources that constitute the model object. Alternatively, a set or traversals can be obtained by calling getTraversals(org.eclipse.core.resources.mapping.ResourceMappingContext, org.eclipse.core.runtime.IProgressMonitor). A traversal contains a set of resources and a depth. This allows clients (such a repository providers) to do optimal traversals of the resources w.r.t. the operation that is being performed on the model object. This class may be subclassed by clients. Since: 3.2 See Also: IResource, ResourceTraversal '
743, 'org.eclipse.core.resources.ICommand', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/resources/ICommand.html', 'A builder command names a builder and supplies a table of name-value argument pairs. Changes to a command will only take effect if the modified command is installed into a project description via IProjectDescription.setBuildSpec(ICommand[]). See Also: IProjectDescription Restriction: This interface is not intended to be implemented by clients. Restriction: This interface is not intended to be extended by clients. '
744, 'org.eclipse.jface.layout.GridDataFactory', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/layout/GridDataFactory.html', 'extends Object This class provides a convienient shorthand for creating and initializing GridData. This offers several benefits over creating GridData normal way: The same factory can be used many times to create several GridData instances The setters on GridDataFactory all return \"this\", allowing them to be chained GridDataFactory uses vector setters (it accepts Points), making it easy to set X and Y values together GridDataFactory instances are created using one of the static methods on this class. Example usage: //////////////////////////////////////////////////////////// // Example 1: Typical grid data for a non-wrapping label // GridDataFactory version GridDataFactory.fillDefaults().applyTo(myLabel); // Equivalent SWT version GridData labelData = new GridData(GridData.HORIZONTAL_ALIGN_FILL | GridData.VERTICAL_ALIGN_FILL); myLabel.setLayoutData(labelData); /////////////////////////////////////////////////////////// // Example 2: Typical grid data for a wrapping label // GridDataFactory version GridDataFactory.fillDefaults() .align(SWT.FILL, SWT.CENTER) .hint(150, SWT.DEFAULT) .grab(true, false) .applyTo(wrappingLabel); // Equivalent SWT version GridData wrappingLabelData = new GridData(GridData.FILL_HORIZONTAL | GridData.VERTICAL_ALIGN_CENTER); wrappingLabelData.minimumWidth = 1; wrappingLabelData.widthHint = 150; wrappingLabel.setLayoutData(wrappingLabelData); ////////////////////////////////////////////////////////////// // Example 3: Typical grid data for a scrollable control (a list box, tree, table, etc.) // GridDataFactory version GridDataFactory.fillDefaults().grab(true, true).hint(150, 150).applyTo(listBox); // Equivalent SWT version GridData listBoxData = new GridData(GridData.FILL_BOTH); listBoxData.widthHint = 150; listBoxData.heightHint = 150; listBoxData.minimumWidth = 1; listBoxData.minimumHeight = 1; listBox.setLayoutData(listBoxData); ///////////////////////////////////////////////////////////// // Example 4: Typical grid data for a button // GridDataFactory version Point preferredSize = button.computeSize(SWT.DEFAULT, SWT.DEFAULT, false); Point hint = Geometry.max(LayoutConstants.getMinButtonSize(), preferredSize); GridDataFactory.fillDefaults().align(SWT.FILL, SWT.CENTER).hint(hint).applyTo(button); // Equivalent SWT version Point preferredSize = button.computeSize(SWT.DEFAULT, SWT.DEFAULT, false); Point hint = Geometry.max(LayoutConstants.getMinButtonSize(), preferredSize); GridData buttonData = new GridData(GridData.HORIZONTAL_ALIGN_FILL | GridData.VERTICAL_ALIGN_CENTER); buttonData.widthHint = hint.x; buttonData.heightHint = hint.y; button.setLayoutData(buttonData); ///////////////////////////////////////////////////////////// // Example 5: Generated GridData // Generates GridData a wrapping label that spans 2 columns GridDataFactory.generate(wrappingLabel, 2, 1); // Generates GridData for a listbox. and adjusts the preferred size to 300x400 pixels GridDataFactory.defaultsFor(listBox).hint(300, 400).applyTo(listBox); // Generates GridData equivalent to example 4 GridDataFactory.generate(button, 1, 1); Since: 3.2 '
745, 'org.eclipse.core.commands.common.HandleObject', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/commands/common/HandleObject.html', ' An object that is unique identifiable based on the combination of its class and its identifier. Since: 3.2 See Also: HandleObject extends EventManager implements IIdentifiable An object that can exist in one of two states: defined and undefined. This is used by APIs that want to give a handle to an object, even though the object does not fully exist yet. This way, users can attach listeners to objects before they come into existence. It also protects the API from users that do not release references when they should. To enforce good coding practice, all handle objects must implement equals and toString. Please use string to cache the result for toString once calculated. All handle objects are referred to using a single identifier. This identifier is a instance of String. It is important that this identifier remain unique within whatever context that handle object is being used. For example, there should only ever be one instance of Command with a given identifier. Since: 3.1 '
746, 'org.eclipse.jface.bindings.Scheme', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/bindings/Scheme.html', ' An object that is unique identifiable based on the combination of its class and its identifier. Since: 3.2 See Also: HandleObject extends NamedHandleObject implements Comparable An instance of IScheme is a handle representing a binding scheme as defined by the extension point org.eclipse.ui.bindings. The identifier of the handle is the identifier of the scheme being represented. An instance of IScheme can be obtained from an instance of ICommandManager for any identifier, whether or not a scheme with that identifier is defined in the plugin registry. The handle-based nature of this API allows it to work well with runtime plugin activation and deactivation. If a scheme is defined, that means that its corresponding plug-in is active. If the plug-in is then deactivated, the scheme will still exist but it will be undefined. An attempt to use an undefined scheme will result in a NotDefinedException being thrown. This class is not intended to be extended by clients. Since: 3.1 See Also: ISchemeListener, CommandManager '
747, 'org.eclipse.ui.menus.WorkbenchWindowControlContribution', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/menus/WorkbenchWindowControlContribution.html', 'A contribution item represents a contribution to a shared UI resource such as a menu or tool bar. More generally, contribution items are managed by a contribution manager. For instance, in a tool bar a contribution item is a tool bar button or a separator. In a menu bar a contribution item is a menu, and in a menu a contribution item is a menu item or separator. A contribution item can realize itself in different SWT widgets, using the different fill methods. The same type of contribution item can be used with a MenuBarManager, ToolBarManager, CoolBarManager, or a StatusLineManager. This interface is internal to the framework; it should not be implemented outside the framework. See Also: IContributionManager Restriction: This interface is not intended to be implemented by clients. extends org.eclipse.ui.internal.menus.InternalControlContribution Abstract base class from which all controls contributions to the workbench through the \'org.eclipse.ui.menus\' extension point must derive. The extends the ControlContribution by adding accessor methods that provide extra state information about the placement of the control: getWorkbenchWindow() - indicates which workbench window this control is being hosted by getCurSide() - indicates which side of the workbench window the control is being displayed on Since: 3.3 See Also: ControlContribution '
748, 'org.eclipse.core.commands.IParameter', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/commands/IParameter.html', ' A parameter for a command. A parameter identifies a type of information that the command might accept. For example, a \"Show View\" command might accept the id of a view for display. This parameter also identifies possible values, for display in the user interface. Since: 3.1 '
749, 'org.eclipse.jface.viewers.IInputSelectionProvider', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/viewers/IInputSelectionProvider.html', 'Interface common to all objects that provide an input. Interface common to all objects that provide a selection. See Also: ISelection, ISelectionChangedListener, SelectionChangedEvent extends IInputProvider, ISelectionProvider Interface common to all objects that provide both an input and a selection. '
750, 'org.eclipse.jface.wizard.WizardPage', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/wizard/WizardPage.html', 'Interface for a page in a multi-page dialog. Minimal interface to a message provider. Used for dialog pages which can provide a message with an icon. Since: 2.0 Interface for a page in a multi-page dialog. extends IDialogPage Interface for a wizard page. The class WizardPage provides an abstract implementation of this interface. However, clients are also free to implement this interface if WizardPage does not suit their needs. extends DialogPage implements IWizardPage An abstract base implementation of a wizard page. Subclasses must implement the createControl method to create the specific controls for the wizard page. Subclasses may call the following methods to configure the wizard page: setDescription setErrorMessage setImageDescriptor setMessage setPageComplete setPreviousPage setTitle Subclasses may override these methods if required: performHelp - may be reimplemented to display help for the page canFlipToNextPage - may be extended or reimplemented isPageComplete - may be extended setDescription - may be extended setTitle - may be extended dispose - may be extended to dispose additional allocated SWT resources Note that clients are free to implement IWizardPage from scratch instead of subclassing WizardPage. Correct implementations of IWizardPage will work with any correct implementation of IWizard. '
751, 'org.eclipse.jface.wizard.IWizardNode', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/wizard/IWizardNode.html', 'A wizard node acts a placeholder for a real wizard in a wizard selection page. It is done in such a way that the actual creation of a wizard can be deferred until the wizard is really needed. When a wizard node comes into existence, its wizard may or may not have been created yet; isContentCreated can be used to determine which. A node may be asked for its wizard using getWizard, which will force it to be created if required. Once the client is done with a wizard node, its disposemethod must be called to free up the wizard; once disposes, the node should no longer be used. This interface should be implemented by clients wishing to support this kind of wizard placeholder in a wizard selection page. See Also: WizardSelectionPage '
752, 'org.eclipse.jface.wizard.IWizardContainer', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/wizard/IWizardContainer.html', 'Interface for UI components which can execute a long-running operation in the form of an IRunnableWithProgress. The context is responsible for displaying a progress indicator and Cancel button to the end user while the operation is in progress; the context supplies a progress monitor to be used from code running inside the operation. Note that an IRunnableContext is not a runnable itself. For examples of UI components which implement this interface, see ApplicationWindow, ProgressMonitorDialog, and WizardDialog. See Also: IRunnableWithProgress, ApplicationWindow, ProgressMonitorDialog, WizardDialog extends IRunnableContext Interface for containers that can host a wizard. It displays wizard pages, at most one of which is considered the current page. getCurrentPage returns the current page; showPage programmatically changes the the current page. Note that the pages need not all belong to the same wizard. The class WizardDialog provides a fully functional implementation of this interface which will meet the needs of most clients. However, clients are also free to implement this interface if WizardDialog does not suit their needs. Implementors are responsible for disposing of their wizards. See Also: IWizardContainer2 '
753, 'org.eclipse.ui.part.FileEditorInput', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/part/FileEditorInput.html', 'An interface for an adaptable object. Adaptable objects can be dynamically extended to provide different interfaces (or \"adapters\"). Adapters are created by adapter factories, which are in turn managed by type by adapter managers. For example, IAdaptable a = [some adaptable]; IFoo x = (IFoo)a.getAdapter(IFoo.class); if (x != null) [do IFoo things with x] This interface can be used without OSGi running. Clients may implement this interface, or obtain a default implementation of this interface by subclassing PlatformObject. See Also: IAdapterFactory, IAdapterManager, PlatformObject An interface for an adaptable object. Adaptable objects can be dynamically extended to provide different interfaces (or \"adapters\"). Adapters are created by adapter factories, which are in turn managed by type by adapter managers. For example, IAdaptable a = [some adaptable]; IFoo x = (IFoo)a.getAdapter(IFoo.class); if (x != null) [do IFoo things with x] This interface can be used without OSGi running. Clients may implement this interface, or obtain a default implementation of this interface by subclassing PlatformObject. See Also: IAdapterFactory, IAdapterManager, PlatformObject extends IAdaptable IEditorInput is a light weight descriptor of editor input, like a file name but more abstract. It is not a model. It is a description of the model source for an IEditorPart. Clients implementing this editor input interface should override Object.equals(Object) to answer true for two inputs that are the same. The IWorbenchPage.openEditor APIs are dependent on this to find an editor with the same input. Clients should extend this interface to declare new types of editor inputs. An editor input is passed to an editor via the IEditorPart.init method. Due to the wide range of valid editor inputs, it is not possible to define generic methods for getting and setting bytes. Editor input must implement the IAdaptable interface; extensions are managed by the platform\'s adapter manager. Please note that it is important that the editor input be light weight. Within the workbench, the navigation history tends to hold on to editor inputs as a means of reconstructing the editor at a later time. The navigation history can hold on to quite a few inputs (i.e., the default is fifty). The actual data model should probably not be held in the input. See Also: IEditorPart, IWorkbenchPage.openEditor(IEditorInput, String), IWorkbenchPage.openEditor(IEditorInput, String, boolean) An interface for an adaptable object. Adaptable objects can be dynamically extended to provide different interfaces (or \"adapters\"). Adapters are created by adapter factories, which are in turn managed by type by adapter managers. For example, IAdaptable a = [some adaptable]; IFoo x = (IFoo)a.getAdapter(IFoo.class); if (x != null) [do IFoo things with x] This interface can be used without OSGi running. Clients may implement this interface, or obtain a default implementation of this interface by subclassing PlatformObject. See Also: IAdapterFactory, IAdapterManager, PlatformObject An interface for an adaptable object. Adaptable objects can be dynamically extended to provide different interfaces (or \"adapters\"). Adapters are created by adapter factories, which are in turn managed by type by adapter managers. For example, IAdaptable a = [some adaptable]; IFoo x = (IFoo)a.getAdapter(IFoo.class); if (x != null) [do IFoo things with x] This interface can be used without OSGi running. Clients may implement this interface, or obtain a default implementation of this interface by subclassing PlatformObject. See Also: IAdapterFactory, IAdapterManager, PlatformObject extends IAdaptable IEditorInput is a light weight descriptor of editor input, like a file name but more abstract. It is not a model. It is a description of the model source for an IEditorPart. Clients implementing this editor input interface should override Object.equals(Object) to answer true for two inputs that are the same. The IWorbenchPage.openEditor APIs are dependent on this to find an editor with the same input. Clients should extend this interface to declare new types of editor inputs. An editor input is passed to an editor via the IEditorPart.init method. Due to the wide range of valid editor inputs, it is not possible to define generic methods for getting and setting bytes. Editor input must implement the IAdaptable interface; extensions are managed by the platform\'s adapter manager. Please note that it is important that the editor input be light weight. Within the workbench, the navigation history tends to hold on to editor inputs as a means of reconstructing the editor at a later time. The navigation history can hold on to quite a few inputs (i.e., the default is fifty). The actual data model should probably not be held in the input. See Also: IEditorPart, IWorkbenchPage.openEditor(IEditorInput, String), IWorkbenchPage.openEditor(IEditorInput, String, boolean) extends IEditorInput Interface for a IStorage input to an editor. Clients implementing this editor input interface should override Object.equals(Object) to answer true for two inputs that are the same. The IWorbenchPage.openEditor APIs are dependent on this to find an editor with the same input. Clients should implement this interface to declare new types of IStorage editor inputs. File-oriented editors should support this as a valid input type, and display its content for viewing (but not allow modification). Within the editor, the \"save\" and \"save as\" operations should create a new file resource within the workspace. All editor inputs must implement the IAdaptable interface; extensions are managed by the platform\'s adapter manager. extends IStorageEditorInput This interface defines a file-oriented input to an editor. Clients implementing this editor input interface should override Object.equals(Object) to answer true for two inputs that are the same. The IWorbenchPage.openEditor APIs are dependent on this to find an editor with the same input. File-oriented editors should support this as a valid input type, and allow full read-write editing of its content. A default implementation of this interface is provided by org.eclipse.ui.part.FileEditorInput. All editor inputs must implement the IAdaptable interface; extensions are managed by the platform\'s adapter manager. See Also: IFile An interface for an adaptable object. Adaptable objects can be dynamically extended to provide different interfaces (or \"adapters\"). Adapters are created by adapter factories, which are in turn managed by type by adapter managers. For example, IAdaptable a = [some adaptable]; IFoo x = (IFoo)a.getAdapter(IFoo.class); if (x != null) [do IFoo things with x] This interface can be used without OSGi running. Clients may implement this interface, or obtain a default implementation of this interface by subclassing PlatformObject. See Also: IAdapterFactory, IAdapterManager, PlatformObject An interface for an adaptable object. Adaptable objects can be dynamically extended to provide different interfaces (or \"adapters\"). Adapters are created by adapter factories, which are in turn managed by type by adapter managers. For example, IAdaptable a = [some adaptable]; IFoo x = (IFoo)a.getAdapter(IFoo.class); if (x != null) [do IFoo things with x] This interface can be used without OSGi running. Clients may implement this interface, or obtain a default implementation of this interface by subclassing PlatformObject. See Also: IAdapterFactory, IAdapterManager, PlatformObject extends IAdaptable IEditorInput is a light weight descriptor of editor input, like a file name but more abstract. It is not a model. It is a description of the model source for an IEditorPart. Clients implementing this editor input interface should override Object.equals(Object) to answer true for two inputs that are the same. The IWorbenchPage.openEditor APIs are dependent on this to find an editor with the same input. Clients should extend this interface to declare new types of editor inputs. An editor input is passed to an editor via the IEditorPart.init method. Due to the wide range of valid editor inputs, it is not possible to define generic methods for getting and setting bytes. Editor input must implement the IAdaptable interface; extensions are managed by the platform\'s adapter manager. Please note that it is important that the editor input be light weight. Within the workbench, the navigation history tends to hold on to editor inputs as a means of reconstructing the editor at a later time. The navigation history can hold on to quite a few inputs (i.e., the default is fifty). The actual data model should probably not be held in the input. See Also: IEditorPart, IWorkbenchPage.openEditor(IEditorInput, String), IWorkbenchPage.openEditor(IEditorInput, String, boolean) extends IEditorInput This interface defines an editor input based on the local file system path of a file. Clients implementing this editor input interface should override Object.equals(Object) to answer true for two inputs that are the same. The IWorkbenchPage.openEditor APIs are dependent on this to find an editor with the same input. Path-oriented editors should support this as a valid input type, and can allow full read-write editing of its content. All editor inputs must implement the IAdaptable interface; extensions are managed by the platform\'s adapter manager. Since: 3.0 See Also: IPath Objects implementing this interface are capable of saving their state in an IMemento. Since: 3.1 Objects implementing this interface are capable of saving their state in an IMemento. Since: 3.1 extends IPersistable Interface for asking an object to store its state in a memento. This interface is typically included in interfaces where persistance is required. When the workbench is shutdown objects which implement this interface will be persisted. At this time the getFactoryId method is invoked to discover the id of the element factory that will be used to re-create the object from a memento. Then the saveState method is invoked to store the element data into a newly created memento. The resulting mementos are collected up and written out to a single file. During workbench startup these mementos are read from the file. The factory Id for each is retrieved and mapped to an IElementFactory which has been registered in the element factory extension point. If a factory exists for the Id it will be engaged to re-create the original object. See Also: IAdaptable, IMemento, IElementFactory extends IEditorInput Interface for a IStorage input to an editor. Clients implementing this editor input interface should override Object.equals(Object) to answer true for two inputs that are the same. The IWorbenchPage.openEditor APIs are dependent on this to find an editor with the same input. Clients should implement this interface to declare new types of IStorage editor inputs. File-oriented editors should support this as a valid input type, and display its content for viewing (but not allow modification). Within the editor, the \"save\" and \"save as\" operations should create a new file resource within the workspace. All editor inputs must implement the IAdaptable interface; extensions are managed by the platform\'s adapter manager. extends IEditorInput This interface defines an editor input based on a URI. Clients implementing this editor input interface should override Object.equals(Object) to answer true for two inputs that are the same. The IWorkbenchPage.openEditor APIs are dependent on this to find an editor with the same input. Path-oriented editors should support this as a valid input type, and can allow full read-write editing of its content. All editor inputs must implement the IAdaptable interface; extensions are managed by the platform\'s adapter manager. Since: 3.3 See Also: URI extends PlatformObject implements IFileEditorInput, IPathEditorInput, IURIEditorInput, IPersistableElement Adapter for making a file resource a suitable input for an editor. This class may be instantiated; it is not intended to be subclassed. Restriction: This class is not intended to be subclassed by clients. '
754, 'org.eclipse.jface.fieldassist.DecoratedField', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/fieldassist/DecoratedField.html', 'extends Object DecoratedField manages image decorations around a control. It allows clients to specify an image decoration and a position for the decoration relative to the field. Decorations may be assigned descriptions, which are shown when the user hovers over the decoration. Clients can decorate any kind of control by supplying a IControlCreator to create the control that is decorated. Decorations always appear on either horizontal side of the field, never above or below it. Decorations can be positioned at the top or bottom of either side. Future implementations may provide additional positioning options for decorations. By default, DecoratedField will consult the FieldDecorationRegistry to determine how much space should be reserved for each decoration. This allows fields with decorations from different sources to align properly on the same dialog, since the registry tracks the size of all decorations registered. Therefore, it is recommended, but not required, that clients of DecoratedField register the decorations used. In cases where alignment between different fields is not a concern, clients can use setUseMaximumDecorationWidth(false) and need not register their decorations. This class is not intended to be subclassed. Since: 3.2 '
755, 'org.eclipse.jface.fieldassist.TextControlCreator', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/fieldassist/TextControlCreator.html', 'extends Object implements IControlCreator An IControlCreator for SWT Text controls. This is a convenience class for creating text controls to be supplied to a decorated field. Since: 3.2 '
756, 'org.eclipse.jface.fieldassist.FieldDecorationRegistry', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/fieldassist/FieldDecorationRegistry.html', 'extends Object FieldDecorationRegistry is a common registry used to define shared field decorations within an application. Unlike resource registries, the FieldDecorationRegistry does not perform any lifecycle management of the decorations. Clients may specify images for the decorations in several different ways. Images may be described by their image id in a specified ImageRegistry. In this case, the life cycle of the image is managed by the image registry, and the decoration registry will not attempt to obtain an image from the image registry until the decoration is actually requested. In cases where the client has access to an already-created image, the image itself can be specified when registering the decoration. In this case, the life cycle should be managed by the specifying client. Since: 3.2 See Also: FieldDecoration, ImageRegistry '
757, 'org.eclipse.jface.dialogs.IDialogBlockedHandler', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/dialogs/IDialogBlockedHandler.html', 'The IDialogBlockedHandler is the handler used by JFace to provide extra information when a blocking has occured. There is one static instance of this class used by WizardDialog and ModalContext. Since: 3.0 See Also: IProgressMonitorWithBlocking.clearBlocked(), IProgressMonitorWithBlocking.setBlocked(IStatus), WizardDialog '
758, 'org.eclipse.jface.window.SameShellProvider', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/window/SameShellProvider.html', 'Interface for objects that can return a shell. This is normally used for opening child windows. An object that wants to open child shells can take an IShellProvider in its constructor, and the object that implements IShellProvider can dynamically choose where child shells should be opened. Since: 3.1 extends Object implements IShellProvider Standard shell provider that always returns the shell containing the given control. This will always return the correct shell for the control, even if the control is reparented. Since: 3.1 '
759, 'org.eclipse.jface.dialogs.IDialogPage', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/dialogs/IDialogPage.html', 'Interface for a page in a multi-page dialog. '
760, 'org.eclipse.swt.accessibility.AccessibleAttributeAdapter', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/accessibility/AccessibleAttributeAdapter.html', 'extends org.eclipse.swt.internal.SWTEventListener Classes which implement this interface provide methods that handle AccessibleAttribute events. After creating an instance of a class that implements this interface it can be added to an accessible using the addAccessibleAttributeListener method and removed using the removeAccessibleAttributeListener method. Since: 3.6 See Also: AccessibleAttributeAdapter, AccessibleAttributeEvent, AccessibleTextAttributeEvent extends Object implements AccessibleAttributeListener This adapter class provides default implementations for the methods in the AccessibleAttributeListener interface. Classes that wish to deal with AccessibleAttribute events can extend this class and override only the methods that they are interested in. Since: 3.6 See Also: AccessibleAttributeListener, AccessibleAttributeEvent, AccessibleTextAttributeEvent '
761, 'org.eclipse.swt.accessibility.AccessibleAttributeEvent', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/accessibility/AccessibleAttributeEvent.html', 'extends org.eclipse.swt.internal.SWTEventObject Instances of this class are sent as a result of accessibility clients sending AccessibleAttribute messages to an accessible object. Since: 3.6 See Also: AccessibleAttributeListener, AccessibleAttributeAdapter, Serialized Form '
762, 'org.eclipse.jface.dialogs.IInputValidator', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/dialogs/IInputValidator.html', 'The IInputValidator is the interface for simple validators. See Also: InputDialog '
763, 'org.eclipse.jface.dialogs.ControlAnimator', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/dialogs/ControlAnimator.html', 'extends Object ControlAnimator provides a simple implementation to display or hide a control at the bottom of the parent composite. Other animations will be written as subclasses of this class. Instances of this class can be created using an AnimatorFactory. Since: 3.2 '
764, 'org.eclipse.jface.viewers.ICheckable', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/viewers/ICheckable.html', 'Interface for objects that support elements with a checked state. See Also: ICheckStateListener, CheckStateChangedEvent '
765, 'org.eclipse.swt.dnd.DropTargetAdapter', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/dnd/DropTargetAdapter.html', 'extends org.eclipse.swt.internal.SWTEventListener The DropTargetListener class provides event notification to the application for DropTarget events. As the user moves the cursor into, over and out of a Control that has been designated as a DropTarget, events indicate what operation can be performed and what data can be transferred if a drop where to occur at that point. The application can respond to these events and change the type of data that will be dropped by modifying event.currentDataType, or change the operation that will be performed by modifying the event.detail field or stop any drop from happening on the current target by setting the event.detail field to DND_DROP_NONE. When the user causes a drop to happen by releasing the mouse over a valid drop target, the application has one last chance to change the data type of the drop through the DropAccept event. If the drop is still allowed, the DropAccept event is immediately followed by the Drop event. In the Drop event, the application can still change the operation that is performed but the data type is fixed. See Also: DropTargetEvent extends Object implements DropTargetListener This adapter class provides default implementations for the methods described by the DropTargetListener interface. Classes that wish to deal with DropTargetEvents can extend this class and override only the methods which they are interested in. See Also: DropTargetListener, DropTargetEvent, Sample code and further information '
766, 'org.eclipse.swt.dnd.DropTargetEvent', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/dnd/DropTargetEvent.html', 'extends TypedEvent The DropTargetEvent contains the event information passed in the methods of the DropTargetListener. See Also: Sample code and further information, Serialized Form '
767, 'org.eclipse.swt.dnd.TransferData', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/dnd/TransferData.html', 'extends Object The TransferData class is a platform specific data structure for describing the type and the contents of data being converted by a transfer agent. As an application writer, you do not need to know the specifics of TransferData. TransferData instances are passed to a subclass of Transfer and the Transfer object manages the platform specific issues. You can ask a Transfer subclass if it can handle this data by calling Transfer.isSupportedType(transferData). You should only need to become familiar with the fields in this class if you are implementing a Transfer subclass and you are unable to subclass the ByteArrayTransfer class. See Also: Sample code and further information '
768, 'org.eclipse.swt.custom.TableTree', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/custom/TableTree.html', 'extends Composite A TableTree is a selectable user interface object that displays a hierarchy of items, and issues notification when an item is selected. A TableTree may be single or multi select. The item children that may be added to instances of this class must be of type TableTreeItem. Note that although this class is a subclass of Composite, it does not make sense to add Control children to it, or set a layout on it. Styles: SINGLE, MULTI, CHECK, FULL_SELECTION Events: Selection, DefaultSelection, Collapse, Expand Note: Only one of the styles SINGLE, and MULTI may be specified. '
769, 'org.eclipse.swt.custom.TableTreeEditor', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/custom/TableTreeEditor.html', 'extends ControlEditor A TableTreeEditor is a manager for a Control that appears above a cell in a TableTree and tracks with the moving and resizing of that cell. It can be used to display a text widget above a cell in a TableTree so that the user can edit the contents of that cell. It can also be used to display a button that can launch a dialog for modifying the contents of the associated cell. Here is an example of using a TableTreeEditor: final TableTree tableTree = new TableTree(shell, SWT.FULL_SELECTION | SWT.HIDE_SELECTION); final Table table = tableTree.getTable(); TableColumn column1 = new TableColumn(table, SWT.NONE); TableColumn column2 = new TableColumn(table, SWT.NONE); for (int i = 0; i < 10; i++) { TableTreeItem item = new TableTreeItem(tableTree, SWT.NONE); item.setText(0, \"item \" + i); item.setText(1, \"edit this value\"); for (int j = 0; j < 3; j++) { TableTreeItem subitem = new TableTreeItem(item, SWT.NONE); subitem.setText(0, \"subitem \" + i + \" \" + j); subitem.setText(1, \"edit this value\"); } } column1.setWidth(100); column2.pack(); final TableTreeEditor editor = new TableTreeEditor(tableTree); //The editor must have the same size as the cell and must //not be any smaller than 50 pixels. editor.horizontalAlignment = SWT.LEFT; editor.grabHorizontal = true; editor.minimumWidth = 50; // editing the second column final int EDITABLECOLUMN = 1; tableTree.addSelectionListener(new SelectionAdapter() { public void widgetSelected(SelectionEvent e) { // Clean up any previous editor control Control oldEditor = editor.getEditor(); if (oldEditor != null) oldEditor.dispose(); // Identify the selected row TableTreeItem item = (TableTreeItem)e.item; if (item == null) return; // The control that will be the editor must be a child of the Table Text newEditor = new Text(table, SWT.NONE); newEditor.setText(item.getText(EDITABLECOLUMN)); newEditor.addModifyListener(new ModifyListener() { public void modifyText(ModifyEvent e) { Text text = (Text)editor.getEditor(); editor.getItem().setText(EDITABLECOLUMN, text.getText()); } }); newEditor.selectAll(); newEditor.setFocus(); editor.setEditor(newEditor, item, EDITABLECOLUMN); } }); '
770, 'org.eclipse.swt.custom.TableTreeItem', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/custom/TableTreeItem.html', 'extends Item A TableTreeItem is a selectable user interface object that represents an item in a hierarchy of items in a TableTree. '
771, 'org.eclipse.jface.viewers.TreePathViewerSorter', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/viewers/TreePathViewerSorter.html', 'extends ViewerSorter A viewer sorter that is provided extra context in the form of the path of the parent element of the elements being sorted. Since: 3.2 '
772, 'org.eclipse.jface.viewers.ITreePathContentProvider', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/viewers/ITreePathContentProvider.html', 'A content provider mediates between the viewer\'s model and the viewer itself. See Also: ContentViewer.setContentProvider(IContentProvider) A content provider mediates between the viewer\'s model and the viewer itself. See Also: ContentViewer.setContentProvider(IContentProvider) extends IContentProvider An interface to content providers for structured viewers. See Also: StructuredViewer extends IStructuredContentProvider An interface to content providers for tree-structure-oriented viewers that provides content based on the path of elements in the tree viewer. Since: 3.2 See Also: AbstractTreeViewer '
773, 'org.eclipse.jface.viewers.TreeSelection', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/viewers/TreeSelection.html', 'Interface for a selection. See Also: ISelectionProvider, ISelectionChangedListener, SelectionChangedEvent Interface for a selection. See Also: ISelectionProvider, ISelectionChangedListener, SelectionChangedEvent extends ISelection A selection containing elements. Interface for a selection. See Also: ISelectionProvider, ISelectionChangedListener, SelectionChangedEvent Interface for a selection. See Also: ISelectionProvider, ISelectionChangedListener, SelectionChangedEvent extends ISelection A selection containing elements. extends IStructuredSelection A selection containing tree paths. It is recommended that clients do not implement this interface but instead use the standard implementation of this interface, TreeSelection. TreeSelection adds API for getting the IElementComparer of a selection (if available). This is important for clients who want to create a slightly modified tree selection based on an existing tree selection. The recommended coding pattern in this case is as follows: ITreeSelection selection = (ITreeSelection)treeViewer.getSelection(); TreePath[] paths = selection.getPaths(); IElementComparer comparer = null; if (selection instanceof TreeSelection) { comparer = ((TreeSelection)selection).getElementComparer(); } TreePath[] modifiedPaths = ... // modify as required TreeSelection modifiedSelection = new TreeSelection(modifiedPaths, comparer); See bugs 135818 and 133375 for details. Since: 3.2 extends StructuredSelection implements ITreeSelection A concrete implementation of the ITreeSelection interface, suitable for instantiating. This class is not intended to be subclassed. Since: 3.2 '
774, 'org.eclipse.swt.widgets.Scrollable', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/widgets/Scrollable.html', 'Implementers of Drawable can have a graphics context (GC) created for them, and then they can be drawn on by sending messages to their associated GC. SWT images, and device objects such as the Display device and the Printer device, are drawables. IMPORTANT: This interface is not part of the SWT public API. It is marked public only so that it can be shared within the packages provided by SWT. It should never be referenced from application code. See Also: Device, Image, GC extends Control This class is the abstract superclass of all classes which represent controls that have standard scroll bars. Styles: H_SCROLL, V_SCROLL Events: (none) IMPORTANT: This class is intended to be subclassed only within the SWT implementation. See Also: Sample code and further information Restriction: This class is not intended to be subclassed by clients. '
775, 'org.eclipse.jface.preference.ListEditor', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/preference/ListEditor.html', 'extends FieldEditor An abstract field editor that manages a list of input values. The editor displays a list containing the values, buttons for adding and removing values, and Up and Down buttons to adjust the order of elements in the list. Subclasses must implement the parseString, createList, and getNewInputObject framework methods. '
776, 'org.eclipse.jface.preference.IPreferencePageContainer', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/preference/IPreferencePageContainer.html', 'An interface used by a preference page to talk to its dialog. '
777, 'org.eclipse.jface.preference.IPreferencePage', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/preference/IPreferencePage.html', 'Interface for a page in a multi-page dialog. extends IDialogPage An interface for a preference page. This interface is used primarily by the page\'s container '
778, 'org.eclipse.jface.dialogs.DialogMessageArea', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/dialogs/DialogMessageArea.html', 'extends Object The DialogMessageArea is a resusable component for adding an accessible message area to a dialog. When the message is normal a CLabel is used but an errors replaces the message area with a non editable text that can take focus for use by screen readers. Since: 3.0 '
779, 'org.eclipse.jface.preference.IPreferenceNode', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/preference/IPreferenceNode.html', 'Interface to a node in a preference dialog. A preference node maintains a label and image used to display the node in a preference dialog (usually in the form of a tree), as well as the preference page this node stands for. The node may use lazy creation for its page Note that all preference nodes must be dispose their resources. The node must dispose the page managed by this node, and any SWT resources allocated by this node (Images, Fonts, etc). However the node itself may be reused. '
780, 'org.eclipse.swt.widgets.Sash', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/widgets/Sash.html', 'Implementers of Drawable can have a graphics context (GC) created for them, and then they can be drawn on by sending messages to their associated GC. SWT images, and device objects such as the Display device and the Printer device, are drawables. IMPORTANT: This interface is not part of the SWT public API. It is marked public only so that it can be shared within the packages provided by SWT. It should never be referenced from application code. See Also: Device, Image, GC extends Control Instances of the receiver represent a selectable user interface object that allows the user to drag a rubber banded outline of the sash within the parent control. Styles: HORIZONTAL, VERTICAL, SMOOTH Events: Selection Note: Only one of the styles HORIZONTAL and VERTICAL may be specified. IMPORTANT: This class is not intended to be subclassed. See Also: Sash snippets, SWT Example: ControlExample, Sample code and further information Restriction: This class is not intended to be subclassed by clients. '
781, 'org.eclipse.jface.preference.PreferenceLabelProvider', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/preference/PreferenceLabelProvider.html', 'A label provider maps an element of the viewer\'s model to an optional image and optional text string used to display the element in the viewer\'s control. Certain label providers may allow multiple labels per element. This is an \"abstract interface\", defining methods common to all label providers, but does not actually define the methods to get the label(s) for an element. This interface should never be directly implemented. Most viewers will take either an ILabelProvider or an ITableLabelProvider. A label provider must not be shared between viewers since a label provider generally manages SWT resources (images), which must be disposed when the viewer is disposed. To simplify life cycle management, the current label provider of a viewer is disposed when the viewer is disposed. Label providers can be used outside the context of viewers wherever images are needed. When label providers are used in this fashion it is the responsibility of the user to ensure dispose is called when the provider is no longer needed. See Also: ILabelProvider, ITableLabelProvider A label provider maps an element of the viewer\'s model to an optional image and optional text string used to display the element in the viewer\'s control. Certain label providers may allow multiple labels per element. This is an \"abstract interface\", defining methods common to all label providers, but does not actually define the methods to get the label(s) for an element. This interface should never be directly implemented. Most viewers will take either an ILabelProvider or an ITableLabelProvider. A label provider must not be shared between viewers since a label provider generally manages SWT resources (images), which must be disposed when the viewer is disposed. To simplify life cycle management, the current label provider of a viewer is disposed when the viewer is disposed. Label providers can be used outside the context of viewers wherever images are needed. When label providers are used in this fashion it is the responsibility of the user to ensure dispose is called when the provider is no longer needed. See Also: ILabelProvider, ITableLabelProvider extends IBaseLabelProvider Extends IBaseLabelProvider with the methods to provide the text and/or image for the label of a given element. Used by most structured viewers, except table viewers. extends LabelProvider Provides labels for IPreferenceNode objects. Since: 3.0 '
782, 'org.eclipse.jface.preference.PreferenceContentProvider', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/preference/PreferenceContentProvider.html', 'A content provider mediates between the viewer\'s model and the viewer itself. See Also: ContentViewer.setContentProvider(IContentProvider) A content provider mediates between the viewer\'s model and the viewer itself. See Also: ContentViewer.setContentProvider(IContentProvider) extends IContentProvider An interface to content providers for structured viewers. See Also: StructuredViewer A content provider mediates between the viewer\'s model and the viewer itself. See Also: ContentViewer.setContentProvider(IContentProvider) extends IContentProvider An interface to content providers for structured viewers. See Also: StructuredViewer extends IStructuredContentProvider An interface to content providers for tree-structure-oriented viewers. See Also: AbstractTreeViewer extends Object implements ITreeContentProvider Provides a tree model for PreferenceManager content. Since: 3.0 '
783, 'org.eclipse.jface.preference.IPersistentPreferenceStore', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/preference/IPersistentPreferenceStore.html', 'The IPreferenceStore interface represents a table mapping named preferences to values. If there is no value for a given name, then that preferences\'s default value is returned; and if there is no default value for that preference, then a default-default value is returned. The default-default values for the primitive types are as follows: boolean = false double = 0.0 float = 0.0f int = 0 long = 0 String = \"\" (the empty string) Thus a preference store maintains two values for each of a set of names: a current value and a default value. The typical usage is to establish the defaults for all known preferences and then restore previously stored values for preferences whose values were different from their defaults. After the current values of the preferences have been modified, it is a simple matter to write out only those preferences whose values are different from their defaults. This two-tiered approach to saving and restoring preference setting minimized the number of preferences that need to be persisted; indeed, the normal starting state does not require storing any preferences at all. A property change event is reported whenever a preferences current value actually changes (whether through setValue, setToDefault, or other unspecified means). Note, however, that manipulating default values (with setDefault) does not cause such events to be reported. Clients who need a preference store may implement this interface or instantiate the standard implementation PreferenceStore. See Also: PreferenceStore extends IPreferenceStore IPersistentPreferenceStore is a preference store that can be saved. '
784, 'org.eclipse.jface.dialogs.DialogPage', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/dialogs/DialogPage.html', 'Interface for a page in a multi-page dialog. Minimal interface to a message provider. Used for dialog pages which can provide a message with an icon. Since: 2.0 extends Object implements IDialogPage, IMessageProvider Abstract base implementation of a dialog page. All dialog pages are subclasses of this one. '
785, 'org.eclipse.jface.preference.PreferenceNode', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/preference/PreferenceNode.html', 'Interface to a node in a preference dialog. A preference node maintains a label and image used to display the node in a preference dialog (usually in the form of a tree), as well as the preference page this node stands for. The node may use lazy creation for its page Note that all preference nodes must be dispose their resources. The node must dispose the page managed by this node, and any SWT resources allocated by this node (Images, Fonts, etc). However the node itself may be reused. extends Object implements IPreferenceNode A concrete implementation of a node in a preference dialog tree. This class also supports lazy creation of the node\'s preference page. '
786, 'org.eclipse.jface.fieldassist.IContentProposalProvider', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/fieldassist/IContentProposalProvider.html', 'IContentProposalProvider provides an array of IContentProposals that are appropriate for a textual dialog field, given the field\'s current content and the current cursor position. Since: 3.2 See Also: SimpleContentProposalProvider '
787, 'org.eclipse.jface.fieldassist.ContentProposal', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/fieldassist/ContentProposal.html', 'IContentProposal describes a content proposal to be shown. It consists of the content that will be provided if the proposal is accepted, an optional label used to describe the content to the user, and an optional description that further elaborates the meaning of the proposal. It also includes a a zero-based index position within the contents where the cursor should be placed after a proposal is accepted. Since: 3.2 See Also: ContentProposal extends Object implements IContentProposal A default implementation of IContentProposal that allows clients to specify a content proposal using simple constructors. Since: 3.6 '
788, 'org.eclipse.jface.fieldassist.IControlCreator', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/fieldassist/IControlCreator.html', 'This interface is used to create a control with a specific parent and style bits. It is used by DecoratedField to create the control to be decorated. Clients are expected to implement this interface in order to create a particular kind of control for decoration. Since: 3.2 '
789, 'org.eclipse.jface.fieldassist.IControlContentAdapter', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/fieldassist/IControlContentAdapter.html', 'This interface is used to set and retrieve text content from an arbitrary control. Clients are expected to implement this interface when defining a ContentProposalAdapter, in order to specify how to retrieve and set the contents of the control being adapted. Since: 3.2 '
790, 'org.eclipse.jface.fieldassist.IContentProposalListener', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/fieldassist/IContentProposalListener.html', 'This interface is used to listen to notifications from a ContentProposalAdapter. Since: 3.2 '
791, 'org.eclipse.jface.fieldassist.IContentProposalListener2', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/fieldassist/IContentProposalListener2.html', 'This interface is used to listen to additional notifications from a ContentProposalAdapter. Since: 3.3 '
792, 'org.eclipse.jface.fieldassist.IControlContentAdapter2', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/fieldassist/IControlContentAdapter2.html', 'This interface is used by a ContentProposalAdapter in order to retrieve and set the selection range in a control. Since: 3.4 '
793, 'org.eclipse.jface.fieldassist.FieldDecoration', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/fieldassist/FieldDecoration.html', 'extends Object FieldDecoration is a simple data structure class for specifying a decoration for a field. A decoration may be rendered in different ways depending on the type of field it is used with. Since: 3.2 See Also: FieldDecorationRegistry '
794, 'org.eclipse.jface.resource.DeviceResourceDescriptor', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/resource/DeviceResourceDescriptor.html', 'extends Object Instances of this class can allocate and dispose SWT resources. Each instance describes a particular resource (such as a Color, Font, or Image) and can create and destroy that resource on demand. DeviceResourceDescriptors are managed by a ResourceRegistry. Since: 3.1 See Also: ResourceManager '
795, 'org.eclipse.jface.resource.ColorDescriptor', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/resource/ColorDescriptor.html', 'extends DeviceResourceDescriptor Lightweight descriptor for an SWT color. Each ColorDescriptor will create a particular SWT Color on demand. This object will be compared so hashCode(...) and equals(...) must return meaningful values. Since: 3.1 '
796, 'org.eclipse.jface.resource.DeviceResourceManager', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/resource/DeviceResourceManager.html', 'extends ResourceManager Manages SWT resources for a particular device. IMPORTANT: in most cases clients should use a LocalResourceManager instead of a DeviceResourceManager. To create a resource manager on a particular display, use new LocalResourceManager(JFaceResources.getResources(myDisplay)). DeviceResourceManager should only be used directly when managing resources for a device other than a Display (such as a printer). Since: 3.1 See Also: LocalResourceManager '
797, 'org.eclipse.jface.resource.FontDescriptor', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/resource/FontDescriptor.html', 'extends DeviceResourceDescriptor Lightweight descriptor for a font. Creates the described font on demand. Subclasses can implement different ways of describing a font. These objects will be compared, so hashCode(...) and equals(...) must return something meaningful. Since: 3.1 '
798, 'org.eclipse.jface.wizard.Wizard', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/wizard/Wizard.html', 'Interface for a wizard. A wizard maintains a list of wizard pages, stacked on top of each other in card layout fashion. The class Wizard provides an abstract implementation of this interface. However, clients are also free to implement this interface if Wizard does not suit their needs. See Also: Wizard extends Object implements IWizard An abstract base implementation of a wizard. A typical client subclasses Wizard to implement a particular wizard. Subclasses may call the following methods to configure the wizard: addPage setHelpAvailable setDefaultPageImageDescriptor setDialogSettings setNeedsProgressMonitor setTitleBarColor setWindowTitle Subclasses may override these methods if required: reimplement createPageControls reimplement performCancel extend addPages reimplement performFinish extend dispose Note that clients are free to implement IWizard from scratch instead of subclassing Wizard. Correct implementations of IWizard will work with any correct implementation of IWizardPage. '
799, 'org.eclipse.jface.preference.PreferenceDialog', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/preference/PreferenceDialog.html', 'Minimal interface to a page change provider. Used for dialogs which can switch between multiple pages. Since: 3.1 An interface used by a preference page to talk to its dialog. Interface for objects that can return a shell. This is normally used for opening child windows. An object that wants to open child shells can take an IShellProvider in its constructor, and the object that implements IShellProvider can dynamically choose where child shells should be opened. Since: 3.1 extends TrayDialog implements IPreferencePageContainer, IPageChangeProvider A preference dialog is a hierarchical presentation of preference pages. Each page is represented by a node in the tree shown on the left hand side of the dialog; when a node is selected, the corresponding page is shown on the right hand side. '
800, 'org.eclipse.jface.resource.ResourceRegistry', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/resource/ResourceRegistry.html', 'extends EventManager Abstract base class for various JFace registries. Since: 3.0 '
801, 'org.eclipse.jface.util.ILogger', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/util/ILogger.html', 'A mechanism to log errors throughout JFace. Clients may provide their own implementation to change how errors are logged from within JFace. Since: 3.1 See Also: Policy.getLog(), Policy.setLog(ILogger) '
802, 'org.eclipse.jface.dialogs.AnimatorFactory', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/dialogs/AnimatorFactory.html', 'extends Object Factory for control animators used by JFace to animate the display of an SWT Control. Through the use of the method Policy.setAnimatorFactory(AnimatorFactory) a new type of animator factory can be plugged into JFace. Since: 3.2 '
803, 'org.eclipse.jface.dialogs.ErrorSupportProvider', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/dialogs/ErrorSupportProvider.html', 'extends Object A ErrorSupportProvider defines the area to be shown in an error dialog for extra support information. Since: 3.3 '
804, 'org.eclipse.jface.util.StatusHandler', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/util/StatusHandler.html', 'extends Object A mechanism to handle statuses throughout JFace. Clients may provide their own implementation to change how statuses are handled from within JFace. Since: 3.4 See Also: Policy.getStatusHandler(), Policy.setStatusHandler(StatusHandler) '
805, 'org.eclipse.jface.util.TransferDropTargetListener', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/util/TransferDropTargetListener.html', 'extends org.eclipse.swt.internal.SWTEventListener The DropTargetListener class provides event notification to the application for DropTarget events. As the user moves the cursor into, over and out of a Control that has been designated as a DropTarget, events indicate what operation can be performed and what data can be transferred if a drop where to occur at that point. The application can respond to these events and change the type of data that will be dropped by modifying event.currentDataType, or change the operation that will be performed by modifying the event.detail field or stop any drop from happening on the current target by setting the event.detail field to DND_DROP_NONE. When the user causes a drop to happen by releasing the mouse over a valid drop target, the application has one last chance to change the data type of the drop through the DropAccept event. If the drop is still allowed, the DropAccept event is immediately followed by the Drop event. In the Drop event, the application can still change the operation that is performed but the data type is fixed. See Also: DropTargetEvent extends DropTargetListener A TransferDropTargetListener is a DropTragetListener that handles one type of SWT Transfer. The purpose of a TransferDropTargetListener is to: Determine enablement for a drop operation. A TransferDropTargetListener will not be used if isEnabled returns false. When enabled, optionally show feedback on the DropTarget. Perform the actual drop A DelegatingDropAdapter allows these functions to be implemented separately for unrelated types of drags. DelegatingDropAdapter then combines the function of each TransferDropTargetListener, while allowing them to be implemented as if they were the only DragSourceListener. Since: 3.0 '
806, 'org.eclipse.jface.util.ISafeRunnableRunner', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/util/ISafeRunnableRunner.html', 'Runs a safe runnables. Clients may provide their own implementation to change how safe runnables are run from within JFace. Since: 3.1 See Also: SafeRunnable.getRunner(), SafeRunnable.setRunner(ISafeRunnableRunner), SafeRunnable.run(ISafeRunnable) '
807, 'org.eclipse.swt.events.SegmentListener', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/events/SegmentListener.html', 'extends org.eclipse.swt.internal.SWTEventListener This listener interface may be implemented in order to receive SegmentEvents. Since: 3.8 See Also: SegmentEvent '
808, 'org.eclipse.swt.custom.BidiSegmentListener', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/custom/BidiSegmentListener.html', 'extends org.eclipse.swt.internal.SWTEventListener This listener interface may be implemented in order to receive BidiSegmentEvents. See Also: BidiSegmentEvent '
809, 'org.eclipse.swt.custom.BidiSegmentEvent', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/custom/BidiSegmentEvent.html', 'extends SegmentEvent This event is sent to BidiSegmentListeners when a line is to be measured or rendered in a bidi locale. The segments field can be used in conjunction with the segmentsChars field or by itself. Setting only the segmentsChars field has no effect. When used by itself, the segments field specify text ranges in the line that should be treated as separate segments for bidi reordering. Each segment will be reordered and rendered separately. The elements in the segments field specify the start offset of a segment relative to the start of the line. They must follow the following rules: elements must be in ascending order and must not have duplicates elements must not exceed the line length In addition, the first element may be set to zero and the last element may be set to the end of the line but this is not required. The segments field may be left null if the entire line should be reordered as is. A BidiSegmentListener may be used when adjacent segments of right-to-left text should not be reordered relative to each other. For example, within a Java editor, you may wish multiple right-to-left string literals to be reordered differently than the bidi algorithm specifies. Example: stored line = \"R1R2R3\" + \"R4R5R6\" R1 to R6 are right-to-left characters. The quotation marks are part of the line text. The line is 13 characters long. segments = null: entire line will be reordered and thus the two R2L segments swapped (as per the bidi algorithm). visual line (rendered on screen) = \"R6R5R4\" + \"R3R2R1\" segments = [0, 5, 8] \"R1R2R3\" will be reordered, followed by [blank]+[blank] and \"R4R5R6\". visual line = \"R3R2R1\" + \"R6R5R4\" The segments and segmentsChars fields can be used together to obtain different types of bidi reordering and text display. The application can use these two fields to insert Unicode Control Characters in specific offsets in the line, the character at segmentsChars[i] is inserted at the offset specified by segments[i]. When both fields are set, the rules for the segments field are less restrictive: elements must be in ascending order, duplicates are allowed elements must not exceed the line length See Also: Sample code and further information, Serialized Form '
810, 'org.eclipse.jface.util.StructuredTextSegmentListener', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/util/StructuredTextSegmentListener.html', 'extends org.eclipse.swt.internal.SWTEventListener This listener interface may be implemented in order to receive SegmentEvents. Since: 3.8 See Also: SegmentEvent extends Object implements SegmentListener Segment listener that implements bidi-structured text reordering. The reordering is specified by the structured text type that is passed to the constructor. Note: This class only works if the org.eclipse.equinox.bidi bundle is on the classpath! Since: 3.9 Restriction: This class is not intended to be subclassed by clients. '
811, 'org.eclipse.jface.util.TransferDragSourceListener', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/util/TransferDragSourceListener.html', 'extends org.eclipse.swt.internal.SWTEventListener The DragSourceListener class provides event notification to the application for DragSource events. When the user drops data on a DropTarget, the application which defines the DragSource must provide the dropped data by implementing dragSetData. In the dragSetData, the application must support all the data types that were specified in the DragSource#setTransfer method. After the drop has completed successfully or has been aborted, the application which defines the DragSource is required to take the appropriate cleanup action. In the case of a successful move operation, the application must remove the data that was transferred. extends DragSourceListener A TransferDragSourceListener is a DragSourceListener that can handle one type of SWT Transfer. The purpose of a TransferDragSourceListener is to: Determine enablement for a drag operation. A TransferDragSourceListener will not be used in a drag operation if the DragSourceEvent#doit field is set to false in DragSourceListener#dragStart(DragSourceEvent). Set data for a single type of drag and Transfer type. A DelegatingDragAdapter allows these functions to be implemented separately for unrelated types of drags. DelegatingDragAdapter then combines the function of each TransferDragSourceListener, while allowing them to be implemented as if they were the only DragSourceListener. Since: 3.0 '
812, 'org.eclipse.core.filesystem.IFileStore', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/filesystem/IFileStore.html', 'An interface for an adaptable object. Adaptable objects can be dynamically extended to provide different interfaces (or \"adapters\"). Adapters are created by adapter factories, which are in turn managed by type by adapter managers. For example, IAdaptable a = [some adaptable]; IFoo x = (IFoo)a.getAdapter(IFoo.class); if (x != null) [do IFoo things with x] This interface can be used without OSGi running. Clients may implement this interface, or obtain a default implementation of this interface by subclassing PlatformObject. See Also: IAdapterFactory, IAdapterManager, PlatformObject extends IAdaptable A file store is responsible for storage and retrieval of a single file in some file system. The actual protocols and media used for communicating with the file system are abstracted away by this interface, apart from the store\'s ability to represent itself as a hierarchical URI. File store instances are lightweight handle objects; a store knows how to access and store file information, but does not retain a large memory footprint or operating system connections such as sockets or file handles. The presence of a file store instance does not imply the existence of a corresponding file in the file system represented by that store. A store that has a corresponding file in its file system is said to exist. As much as possible, implementations of this API maintain the characteristics of the underlying file system represented by this store. For example, store instances will be case-sensitive and case-preserving only when representing case-sensitive and case-preserving file systems. Since: org.eclipse.core.filesystem 1.0 Restriction: This interface is not intended to be implemented by clients. File store implementations must subclass FileStore rather than implementing this interface directly. '
813, 'org.eclipse.core.filesystem.IFileInfo', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/filesystem/IFileInfo.html', 'extends Comparable, Cloneable A file info is a simple structure holding information about a file or directory. The information contained here is static; changes to this object will not cause corresponding changes to any file on disk, and changes to files on disk are not reflected in this object. At best, an IFileInfo represents a snapshot of the state of a file at a particular moment in time. Since: org.eclipse.core.filesystem 1.0 See Also: IFileStore.fetchInfo(int, IProgressMonitor), IFileStore.putInfo(IFileInfo, int, IProgressMonitor) Restriction: This interface is not intended to be implemented by clients. File store implementations should use the concrete class FileStore '
814, 'org.eclipse.core.resources.IFolder', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/resources/IFolder.html', 'An interface for an adaptable object. Adaptable objects can be dynamically extended to provide different interfaces (or \"adapters\"). Adapters are created by adapter factories, which are in turn managed by type by adapter managers. For example, IAdaptable a = [some adaptable]; IFoo x = (IFoo)a.getAdapter(IFoo.class); if (x != null) [do IFoo things with x] This interface can be used without OSGi running. Clients may implement this interface, or obtain a default implementation of this interface by subclassing PlatformObject. See Also: IAdapterFactory, IAdapterManager, PlatformObject An interface for an adaptable object. Adaptable objects can be dynamically extended to provide different interfaces (or \"adapters\"). Adapters are created by adapter factories, which are in turn managed by type by adapter managers. For example, IAdaptable a = [some adaptable]; IFoo x = (IFoo)a.getAdapter(IFoo.class); if (x != null) [do IFoo things with x] This interface can be used without OSGi running. Clients may implement this interface, or obtain a default implementation of this interface by subclassing PlatformObject. See Also: IAdapterFactory, IAdapterManager, PlatformObject An interface for an adaptable object. Adaptable objects can be dynamically extended to provide different interfaces (or \"adapters\"). Adapters are created by adapter factories, which are in turn managed by type by adapter managers. For example, IAdaptable a = [some adaptable]; IFoo x = (IFoo)a.getAdapter(IFoo.class); if (x != null) [do IFoo things with x] This interface can be used without OSGi running. Clients may implement this interface, or obtain a default implementation of this interface by subclassing PlatformObject. See Also: IAdapterFactory, IAdapterManager, PlatformObject Scheduling rules are used by jobs to indicate when they need exclusive access to a resource. Scheduling rules can also be applied synchronously to a thread using IJobManager.beginRule(ISchedulingRule) and IJobManager.endRule(ISchedulingRule). The job manager guarantees that no two jobs with conflicting scheduling rules will run concurrently. Multiple rules can be applied to a given thread only if the outer rule explicitly allows the nesting as specified by the contains method. Clients may implement this interface. Since: 3.0 See Also: Job.getRule(), Job.setRule(ISchedulingRule), Job.schedule(long), IJobManager.beginRule(ISchedulingRule, org.eclipse.core.runtime.IProgressMonitor), IJobManager.endRule(ISchedulingRule) extends IAdaptable, ISchedulingRule The workspace analog of file system files and directories. There are exactly four types of resource: files, folders, projects and the workspace root. File resources are similar to files in that they hold data directly. Folder resources are analogous to directories in that they hold other resources but cannot directly hold data. Project resources group files and folders into reusable clusters. The workspace root is the top level resource under which all others reside. Features of resources: IResource objects are handles to state maintained by a workspace. That is, resource objects do not actually contain data themselves but rather represent resource state and give it behavior. Programmers are free to manipulate handles for resources that do not exist in a workspace but must keep in mind that some methods and operations require that an actual resource be available. Resources have two different kinds of properties as detailed below. All properties are keyed by qualified names. Session properties: Session properties live for the lifetime of one execution of the workspace. They are not stored on disk. They can carry arbitrary object values. Clients should be aware that these values are kept in memory at all times and, as such, the values should not be large. Persistent properties: Persistent properties have string values which are stored on disk across platform sessions. The value of a persistent property is a string which should be short (i.e., under 2KB). Resources are identified by type and by their path, which is similar to a file system path. The name of a resource is the last segment of its path. A resource\'s parent is located by removing the last segment (the resource\'s name) from the resource\'s full path. Resources can be local or non-local. A non-local resource is one whose contents and properties have not been fetched from a repository. Phantom resources represent incoming additions or outgoing deletions which have yet to be reconciled with a synchronization partner. Resources implement the IAdaptable interface; extensions are managed by the platform\'s adapter manager. See Also: IWorkspace, Platform.getAdapterManager() Restriction: This interface is not intended to be implemented by clients. Restriction: This interface is not intended to be extended by clients. Scheduling rules are used by jobs to indicate when they need exclusive access to a resource. Scheduling rules can also be applied synchronously to a thread using IJobManager.beginRule(ISchedulingRule) and IJobManager.endRule(ISchedulingRule). The job manager guarantees that no two jobs with conflicting scheduling rules will run concurrently. Multiple rules can be applied to a given thread only if the outer rule explicitly allows the nesting as specified by the contains method. Clients may implement this interface. Since: 3.0 See Also: Job.getRule(), Job.setRule(ISchedulingRule), Job.schedule(long), IJobManager.beginRule(ISchedulingRule, org.eclipse.core.runtime.IProgressMonitor), IJobManager.endRule(ISchedulingRule) extends IResource, IAdaptable Interface for resources which may contain other resources (termed its members). While the workspace itself is not considered a container in this sense, the workspace root resource is a container. Containers implement the IAdaptable interface; extensions are managed by the platform\'s adapter manager. See Also: Platform.getAdapterManager(), IProject, IFolder, IWorkspaceRoot Restriction: This interface is not intended to be implemented by clients. Restriction: This interface is not intended to be extended by clients. An interface for an adaptable object. Adaptable objects can be dynamically extended to provide different interfaces (or \"adapters\"). Adapters are created by adapter factories, which are in turn managed by type by adapter managers. For example, IAdaptable a = [some adaptable]; IFoo x = (IFoo)a.getAdapter(IFoo.class); if (x != null) [do IFoo things with x] This interface can be used without OSGi running. Clients may implement this interface, or obtain a default implementation of this interface by subclassing PlatformObject. See Also: IAdapterFactory, IAdapterManager, PlatformObject Scheduling rules are used by jobs to indicate when they need exclusive access to a resource. Scheduling rules can also be applied synchronously to a thread using IJobManager.beginRule(ISchedulingRule) and IJobManager.endRule(ISchedulingRule). The job manager guarantees that no two jobs with conflicting scheduling rules will run concurrently. Multiple rules can be applied to a given thread only if the outer rule explicitly allows the nesting as specified by the contains method. Clients may implement this interface. Since: 3.0 See Also: Job.getRule(), Job.setRule(ISchedulingRule), Job.schedule(long), IJobManager.beginRule(ISchedulingRule, org.eclipse.core.runtime.IProgressMonitor), IJobManager.endRule(ISchedulingRule) extends IAdaptable, ISchedulingRule The workspace analog of file system files and directories. There are exactly four types of resource: files, folders, projects and the workspace root. File resources are similar to files in that they hold data directly. Folder resources are analogous to directories in that they hold other resources but cannot directly hold data. Project resources group files and folders into reusable clusters. The workspace root is the top level resource under which all others reside. Features of resources: IResource objects are handles to state maintained by a workspace. That is, resource objects do not actually contain data themselves but rather represent resource state and give it behavior. Programmers are free to manipulate handles for resources that do not exist in a workspace but must keep in mind that some methods and operations require that an actual resource be available. Resources have two different kinds of properties as detailed below. All properties are keyed by qualified names. Session properties: Session properties live for the lifetime of one execution of the workspace. They are not stored on disk. They can carry arbitrary object values. Clients should be aware that these values are kept in memory at all times and, as such, the values should not be large. Persistent properties: Persistent properties have string values which are stored on disk across platform sessions. The value of a persistent property is a string which should be short (i.e., under 2KB). Resources are identified by type and by their path, which is similar to a file system path. The name of a resource is the last segment of its path. A resource\'s parent is located by removing the last segment (the resource\'s name) from the resource\'s full path. Resources can be local or non-local. A non-local resource is one whose contents and properties have not been fetched from a repository. Phantom resources represent incoming additions or outgoing deletions which have yet to be reconciled with a synchronization partner. Resources implement the IAdaptable interface; extensions are managed by the platform\'s adapter manager. See Also: IWorkspace, Platform.getAdapterManager() Restriction: This interface is not intended to be implemented by clients. Restriction: This interface is not intended to be extended by clients. Scheduling rules are used by jobs to indicate when they need exclusive access to a resource. Scheduling rules can also be applied synchronously to a thread using IJobManager.beginRule(ISchedulingRule) and IJobManager.endRule(ISchedulingRule). The job manager guarantees that no two jobs with conflicting scheduling rules will run concurrently. Multiple rules can be applied to a given thread only if the outer rule explicitly allows the nesting as specified by the contains method. Clients may implement this interface. Since: 3.0 See Also: Job.getRule(), Job.setRule(ISchedulingRule), Job.schedule(long), IJobManager.beginRule(ISchedulingRule, org.eclipse.core.runtime.IProgressMonitor), IJobManager.endRule(ISchedulingRule) extends IContainer, IAdaptable Folders may be leaf or non-leaf resources and may contain files and/or other folders. A folder resource is stored as a directory in the local file system. Folders, like other resource types, may exist in the workspace but not be local; non-local folder resources serve as place-holders for folders whose properties have not yet been fetched from a repository. Folders implement the IAdaptable interface; extensions are managed by the platform\'s adapter manager. See Also: Platform.getAdapterManager() Restriction: This interface is not intended to be implemented by clients. Restriction: This interface is not intended to be extended by clients. '
815, 'org.eclipse.core.filesystem.URIUtil', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/filesystem/URIUtil.html', 'extends Object This class provides utility methods for comparing, inspecting, and manipulating URIs. More specifically, this class is useful for dealing with URIs that represent file systems represented by the org.eclipse.core.filesystem.filesystems extension point. For such URIs the file system implementation can be consulted to interpret the URI in a way that is not possible at a generic level. Since: org.eclipse.core.filesystem 1.0 Restriction: This class is not intended to be subclassed by clients. Restriction: This class is not intended to be instantiated by clients. '
816, 'org.eclipse.core.filesystem.EFS', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/filesystem/EFS.html', 'extends Object This class is the main entry point for clients of the Eclipse file system API. This class has factory methods for obtaining instances of file systems and file stores, and provides constants for option values and error codes. Since: org.eclipse.core.filesystem 1.0 Restriction: This class is not intended to be subclassed by clients. Restriction: This class is not intended to be instantiated by clients. '
817, 'org.eclipse.ui.ide.dialogs.ImportTypeDialog', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/ide/dialogs/ImportTypeDialog.html', 'Interface for objects that can return a shell. This is normally used for opening child windows. An object that wants to open child shells can take an IShellProvider in its constructor, and the object that implements IShellProvider can dynamically choose where child shells should be opened. Since: 3.1 extends TrayDialog Dialog to let the user customise how files and resources are created in a project hierarchy after the user drag and drop items on a workspace container. Files and folders can be created either by copying the source objects, creating linked resources, and/or creating virtual folders. Since: 3.6 Restriction: This class is not intended to be subclassed by clients. '
818, 'org.eclipse.jface.dialogs.InputDialog', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/dialogs/InputDialog.html', 'Interface for objects that can return a shell. This is normally used for opening child windows. An object that wants to open child shells can take an IShellProvider in its constructor, and the object that implements IShellProvider can dynamically choose where child shells should be opened. Since: 3.1 extends Dialog A simple input dialog for soliciting an input string from the user. This concrete dialog class can be instantiated as is, or further subclassed as required. '
819, 'org.eclipse.ui.ide.undo.AbstractWorkspaceOperation', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/ide/undo/AbstractWorkspaceOperation.html', ' IAdvancedUndoableOperation defines an interface for undoable operations that modify one or more elements in a model and attempt to keep model listeners up to date with changes that occur in the undo and redo history involving particular model elements. It also defines methods for computing the validity of an operation for undo or redo before attempting to perform the undo or redo. This interface is intended to be used by legacy frameworks that are adapting their original undo and redo support to this framework. The methods in this interface allow legacy clients to maintain features not supported in the basic operations framework. Since: 3.1 IAdvancedUndoableOperation2 defines a method for computing the validity of executing an operation before attempting to execute it. It also defines a way for clients to specify that computing status should be done quietly, without consulting the user. This interface is useful when implementing IOperationApprover2, or any other object that performs validation of the undo history. It also allows operations to specify whether they should be run in the UI thread. Since: 3.3 IUndoableOperation defines an operation that can be executed, undone, and redone. Operations typically have fully defined parameters. That is, they are usually created after the user has been queried for any input needed to define the operation. Operations determine their ability to execute, undo, or redo according to the current state of the application. They do not make decisions about their validity based on where they occur in the operation history. That is left to the particular operation history. Since: 3.1 extends AbstractOperation implements IAdvancedUndoableOperation, IAdvancedUndoableOperation2 An AbstractWorkspaceOperation represents an undoable operation that affects the workspace. It handles common workspace operation activities such as tracking which resources are affected by an operation, prompting the user when there are possible side effects of operations, building execution exceptions from core exceptions, etc. Clients may call the public API from a background thread. This class is not intended to be subclassed by clients. Since: 3.3 Restriction: This class is not intended to be subclassed by clients. '
820, 'org.eclipse.ui.ide.undo.CopyResourcesOperation', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/ide/undo/CopyResourcesOperation.html', ' IAdvancedUndoableOperation defines an interface for undoable operations that modify one or more elements in a model and attempt to keep model listeners up to date with changes that occur in the undo and redo history involving particular model elements. It also defines methods for computing the validity of an operation for undo or redo before attempting to perform the undo or redo. This interface is intended to be used by legacy frameworks that are adapting their original undo and redo support to this framework. The methods in this interface allow legacy clients to maintain features not supported in the basic operations framework. Since: 3.1 IAdvancedUndoableOperation2 defines a method for computing the validity of executing an operation before attempting to execute it. It also defines a way for clients to specify that computing status should be done quietly, without consulting the user. This interface is useful when implementing IOperationApprover2, or any other object that performs validation of the undo history. It also allows operations to specify whether they should be run in the UI thread. Since: 3.3 IUndoableOperation defines an operation that can be executed, undone, and redone. Operations typically have fully defined parameters. That is, they are usually created after the user has been queried for any input needed to define the operation. Operations determine their ability to execute, undo, or redo according to the current state of the application. They do not make decisions about their validity based on where they occur in the operation history. That is left to the particular operation history. Since: 3.1 extends AbstractWorkspaceOperation A CopyResourcesOperation represents an undoable operation for copying one or more resources in the workspace. Clients may call the public API from a background thread. This operation can track any overwritten resources and restore them when the copy is undone. It is up to clients to determine whether overwrites are allowed. If a resource should not be overwritten, it should not be included in this operation. In addition to checking for overwrites, the target location for the copy is assumed to have already been validated by the client. It will not be revalidated on undo and redo. This class is intended to be instantiated and used by clients. It is not intended to be subclassed by clients. Since: 3.3 Restriction: This class is not intended to be subclassed by clients. '
821, 'org.eclipse.ui.dialogs.IOverwriteQuery', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/dialogs/IOverwriteQuery.html', 'Implementors of this interface answer one of the prescribed return codes when asked whether to overwrite a certain path string (which could represent a resource path, a file system path, etc). '
822, 'org.eclipse.jface.fieldassist.IContentProposal', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/fieldassist/IContentProposal.html', 'IContentProposal describes a content proposal to be shown. It consists of the content that will be provided if the proposal is accepted, an optional label used to describe the content to the user, and an optional description that further elaborates the meaning of the proposal. It also includes a a zero-based index position within the contents where the cursor should be placed after a proposal is accepted. Since: 3.2 See Also: ContentProposal '
823, 'org.eclipse.ui.part.IPage', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/part/IPage.html', 'This interface has been replaced by IPageBookViewPage but is preserved for backward compatibility. This class is not intended to be directly implemented by clients; clients should instead subclass Page. See Also: PageBookView, Page Restriction: This interface is not intended to be implemented by clients. '
824, 'org.eclipse.ui.part.PageSite', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/part/PageSite.html', 'An interface for an adaptable object. Adaptable objects can be dynamically extended to provide different interfaces (or \"adapters\"). Adapters are created by adapter factories, which are in turn managed by type by adapter managers. For example, IAdaptable a = [some adaptable]; IFoo x = (IFoo)a.getAdapter(IFoo.class); if (x != null) [do IFoo things with x] This interface can be used without OSGi running. Clients may implement this interface, or obtain a default implementation of this interface by subclassing PlatformObject. See Also: IAdapterFactory, IAdapterManager, PlatformObject Interface for objects that can return a shell. This is normally used for opening child windows. An object that wants to open child shells can take an IShellProvider in its constructor, and the object that implements IShellProvider can dynamically choose where child shells should be opened. Since: 3.1 extends IAdaptable, IShellProvider, IServiceLocator The common interface between the workbench and its parts, including pages within parts. The workbench site supports a few services by default. If these services are used to allocate resources, it is important to remember to clean up those resources after you are done with them. Otherwise, the resources will exist until the workbench site is disposed. The supported services are: ICommandService IContextService IHandlerService IBindingService. Resources allocated through this service will not be cleaned up until the workbench shuts down. This interface is not intended to be implemented or extended by clients. Since: 2.0 See Also: IWorkbenchPartSite, IPageSite Restriction: This interface is not intended to be implemented by clients. extends IWorkbenchSite The primary interface between a page and the outside world. The workbench exposes its implemention of page sites via this interface, which is not intended to be implemented or extended by clients. Restriction: This interface is not intended to be implemented by clients. A component with which one or more services are registered. The services can be retrieved from this locator using some key -- typically the class representing the interface the service must implement. For example: IHandlerService service = (IHandlerService) workbenchWindow .getService(IHandlerService.class); This interface is not to be implemented or extended by clients. Since: 3.2 extends Object implements IPageSite, org.eclipse.ui.internal.services.INestable This implementation of IPageSite provides a site for a page within a PageBookView. Most methods are forwarded to the view\'s site. '
825, 'org.eclipse.ui.part.IPageBookViewPage', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/part/IPageBookViewPage.html', 'extends IPage Interface for a page in a pagebook view. Pages should implement this interface. See Also: PageBookView, Page '
826, 'org.eclipse.jface.dialogs.DialogSettings', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/dialogs/DialogSettings.html', 'An interface to a storage mechanism for making dialog settings persistent. The store manages a collection of key/value pairs. The keys must be strings and the values can be either, strings or array of strings. Convenience API to convert primitive types to strings is provided. See Also: DialogSettings extends Object implements IDialogSettings Concrete implementation of a dialog settings (IDialogSettings) using a hash table and XML. The dialog store can be read from and saved to a stream. All keys and values must be strings or array of strings. Primitive types are converted to strings. This class was not designed to be subclassed. Here is an example of using a DialogSettings: DialogSettings settings = new DialogSettings(\"root\"); settings.put(\"Boolean1\",true); settings.put(\"Long1\",100); settings.put(\"Array1\",new String[]{\"aaaa1\",\"bbbb1\",\"cccc1\"}); DialogSettings section = new DialogSettings(\"sectionName\"); settings.addSection(section); section.put(\"Int2\",200); section.put(\"Float2\",1.1); section.put(\"Array2\",new String[]{\"aaaa2\",\"bbbb2\",\"cccc2\"}); settings.save(\"c:\\\\temp\\\\test\\\\dialog.xml\"); Restriction: This class is not intended to be subclassed by clients. '
827, 'org.eclipse.jface.dialogs.IconAndMessageDialog', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/dialogs/IconAndMessageDialog.html', 'Interface for objects that can return a shell. This is normally used for opening child windows. An object that wants to open child shells can take an IShellProvider in its constructor, and the object that implements IShellProvider can dynamically choose where child shells should be opened. Since: 3.1 extends Dialog The IconAndMessageDialog is the abstract superclass of dialogs that have an icon and a message as the first two widgets. In this dialog the icon and message are direct children of the shell in order that they can be read by accessibility tools more easily. Note: Clients are expected to call createMessageArea(Composite), otherwise neither the icon nor the message will appear. '
828, 'org.eclipse.swt.widgets.List', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/widgets/List.html', 'Implementers of Drawable can have a graphics context (GC) created for them, and then they can be drawn on by sending messages to their associated GC. SWT images, and device objects such as the Display device and the Printer device, are drawables. IMPORTANT: This interface is not part of the SWT public API. It is marked public only so that it can be shared within the packages provided by SWT. It should never be referenced from application code. See Also: Device, Image, GC extends Scrollable Instances of this class represent a selectable user interface object that displays a list of strings and issues notification when a string is selected. A list may be single or multi select. Styles: SINGLE, MULTI Events: Selection, DefaultSelection Note: Only one of SINGLE and MULTI may be specified. IMPORTANT: This class is not intended to be subclassed. See Also: List snippets, SWT Example: ControlExample, Sample code and further information Restriction: This class is not intended to be subclassed by clients. '
829, 'org.eclipse.jface.dialogs.ProgressIndicator', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/dialogs/ProgressIndicator.html', 'Implementers of Drawable can have a graphics context (GC) created for them, and then they can be drawn on by sending messages to their associated GC. SWT images, and device objects such as the Display device and the Printer device, are drawables. IMPORTANT: This interface is not part of the SWT public API. It is marked public only so that it can be shared within the packages provided by SWT. It should never be referenced from application code. See Also: Device, Image, GC extends Composite A control for showing progress feedback for a long running operation. This control supports both determinate and indeterminate SWT progress bars. For indeterminate progress, we don\'t have to know the total amount of work in advance and no worked method needs to be called. '
830, 'org.eclipse.jface.dialogs.DialogTray', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/dialogs/DialogTray.html', 'extends Object This class is the abstract superclass of all dialog trays. A tray can be opened in any TrayDialog. Since: 3.2 See Also: TrayDialog '
831, 'org.eclipse.jface.layout.LayoutConstants', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/layout/LayoutConstants.html', 'extends Object Contains various layout constants to be used in dialogs. Since: 3.2 '
832, 'org.eclipse.jface.commands.PersistentState', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/commands/PersistentState.html', 'extends State This is a state that can be made persistent. A state is persisted to a preference store. Clients may extend this class. Since: 3.2 '
833, 'org.eclipse.jface.window.WindowManager', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/window/WindowManager.html', 'extends Object A manager for a group of windows. Window managers are an optional JFace feature used in applications which create many different windows (dialogs, wizards, etc.) in addition to a main window. A window manager can be used to remember all the windows that an application has created (independent of whether they are presently open or closed). There can be several window managers, and they can be arranged into a tree. This kind of organization makes it simple to close whole subgroupings of windows. Creating a window manager is as simple as creating an instance of WindowManager. Associating a window with a window manager is done with WindowManager.add(Window). A window is automatically removed from its window manager as a side effect of closing the window. See Also: Window '
834, 'org.eclipse.jface.viewers.TreeNode', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/viewers/TreeNode.html', 'extends Object A simple data structure that is useful for implemented tree models. This can be returned by IStructuredContentProvider.getElements(Object). It allows simple delegation of methods from ITreeContentProvider such as ITreeContentProvider.getChildren(Object), ITreeContentProvider.getParent(Object) and ITreeContentProvider.hasChildren(Object) Since: 3.2 '
835, 'org.eclipse.jface.viewers.TreeViewerRow', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/viewers/TreeViewerRow.html', 'extends ViewerRow TreeViewerRow is the Tree implementation of ViewerRow. Since: 3.3 '
836, 'org.eclipse.jface.viewers.FocusCellHighlighter', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/viewers/FocusCellHighlighter.html', 'extends Object Since: 3.3 '
837, 'org.eclipse.jface.viewers.CellEditor.LayoutData', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/viewers/CellEditor.LayoutData.html', 'extends Object Struct-like layout data for cell editors, with reasonable defaults for all fields. Restriction: This class is not intended to be subclassed by clients. '
838, 'org.eclipse.jface.viewers.IDecorationContext', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/viewers/IDecorationContext.html', 'A decoration context provides additional information to a label decorator. This interface is not intended to be implemented by clients Since: 3.2 See Also: LabelDecorator '
839, 'org.eclipse.jface.viewers.LabelDecorator', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/viewers/LabelDecorator.html', 'A label provider maps an element of the viewer\'s model to an optional image and optional text string used to display the element in the viewer\'s control. Certain label providers may allow multiple labels per element. This is an \"abstract interface\", defining methods common to all label providers, but does not actually define the methods to get the label(s) for an element. This interface should never be directly implemented. Most viewers will take either an ILabelProvider or an ITableLabelProvider. A label provider must not be shared between viewers since a label provider generally manages SWT resources (images), which must be disposed when the viewer is disposed. To simplify life cycle management, the current label provider of a viewer is disposed when the viewer is disposed. Label providers can be used outside the context of viewers wherever images are needed. When label providers are used in this fashion it is the responsibility of the user to ensure dispose is called when the provider is no longer needed. See Also: ILabelProvider, ITableLabelProvider A label provider maps an element of the viewer\'s model to an optional image and optional text string used to display the element in the viewer\'s control. Certain label providers may allow multiple labels per element. This is an \"abstract interface\", defining methods common to all label providers, but does not actually define the methods to get the label(s) for an element. This interface should never be directly implemented. Most viewers will take either an ILabelProvider or an ITableLabelProvider. A label provider must not be shared between viewers since a label provider generally manages SWT resources (images), which must be disposed when the viewer is disposed. To simplify life cycle management, the current label provider of a viewer is disposed when the viewer is disposed. Label providers can be used outside the context of viewers wherever images are needed. When label providers are used in this fashion it is the responsibility of the user to ensure dispose is called when the provider is no longer needed. See Also: ILabelProvider, ITableLabelProvider extends IBaseLabelProvider A label decorator decorates the label text and image for some element. The original label text and image are obtained by some other means, for example by a label provider. See Also: ILabelProvider extends Object implements ILabelDecorator The LabelDecorator is an abstract superclass of ILabelDecorators that support IDecorationContext. Since: 3.2 See Also: IDecorationContext '
840, 'org.eclipse.jface.viewers.IColorDecorator', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/viewers/IColorDecorator.html', 'The IColorDecorator is an interface for objects that return a color to decorate either the foreground and background colors for displaying an an object. If an IColorDecorator decorates a foreground or background in an object that also has an IColorProvider the IColorDecorator will take precedence. Since: 3.1 See Also: IColorProvider '
841, 'org.eclipse.jface.viewers.IFontDecorator', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/viewers/IFontDecorator.html', 'The IFontDecorator is an interface for objects that return a font to decorate an object. If an IFontDecorator decorates a font in an object that also has an IFontProvider the IFontDecorator will take precedence. Since: 3.1 See Also: IFontProvider '
842, 'org.eclipse.jface.viewers.DialogCellEditor', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/viewers/DialogCellEditor.html', 'extends CellEditor An abstract cell editor that uses a dialog. Dialog cell editors usually have a label control on the left and a button on the right. Pressing the button opens a dialog window (for example, a color dialog or a file dialog) to change the cell editor\'s value. The cell editor\'s value is the value of the dialog. Subclasses may override the following methods: createButton: creates the cell editor\'s button control createContents: creates the cell editor\'s \'display value\' control updateContents: updates the cell editor\'s \'display value\' control after its value has changed openDialogBox: opens the dialog box when the end user presses the button '
843, 'org.eclipse.core.commands.common.NamedHandleObject', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/commands/common/NamedHandleObject.html', ' An object that is unique identifiable based on the combination of its class and its identifier. Since: 3.2 See Also: HandleObject extends HandleObject A handle object that carries with it a name and a description. This type of handle object is quite common across the commands code base. For example, Command, Context and Scheme. Since: 3.1 '
844, 'org.eclipse.swt.custom.TableEditor', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/custom/TableEditor.html', 'extends ControlEditor A TableEditor is a manager for a Control that appears above a cell in a Table and tracks with the moving and resizing of that cell. It can be used to display a text widget above a cell in a Table so that the user can edit the contents of that cell. It can also be used to display a button that can launch a dialog for modifying the contents of the associated cell. Here is an example of using a TableEditor: final Table table = new Table(shell, SWT.FULL_SELECTION | SWT.HIDE_SELECTION); TableColumn column1 = new TableColumn(table, SWT.NONE); TableColumn column2 = new TableColumn(table, SWT.NONE); for (int i = 0; i < 10; i++) { TableItem item = new TableItem(table, SWT.NONE); item.setText(new String[] {\"item \" + i, \"edit this value\"}); } column1.pack(); column2.pack(); final TableEditor editor = new TableEditor(table); //The editor must have the same size as the cell and must //not be any smaller than 50 pixels. editor.horizontalAlignment = SWT.LEFT; editor.grabHorizontal = true; editor.minimumWidth = 50; // editing the second column final int EDITABLECOLUMN = 1; table.addSelectionListener(new SelectionAdapter() { public void widgetSelected(SelectionEvent e) { // Clean up any previous editor control Control oldEditor = editor.getEditor(); if (oldEditor != null) oldEditor.dispose(); // Identify the selected row TableItem item = (TableItem)e.item; if (item == null) return; // The control that will be the editor must be a child of the Table Text newEditor = new Text(table, SWT.NONE); newEditor.setText(item.getText(EDITABLECOLUMN)); newEditor.addModifyListener(new ModifyListener() { public void modifyText(ModifyEvent e) { Text text = (Text)editor.getEditor(); editor.getItem().setText(EDITABLECOLUMN, text.getText()); } }); newEditor.selectAll(); newEditor.setFocus(); editor.setEditor(newEditor, item, EDITABLECOLUMN); } }); See Also: TableEditor snippets, Sample code and further information '
845, 'org.eclipse.jface.viewers.IFilter', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/viewers/IFilter.html', 'Interface for filters. Can accept or reject items. Since: 3.1 '
846, 'org.eclipse.jface.viewers.AcceptAllFilter', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/viewers/AcceptAllFilter.html', 'Interface for filters. Can accept or reject items. Since: 3.1 extends Object implements IFilter Filter that accepts everything. Available as a singleton since having more than one instance would be wasteful. Since: 3.1 '
847, 'org.eclipse.jface.window.DefaultToolTip', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/window/DefaultToolTip.html', 'extends ToolTip Default implementation of ToolTip that provides an iconofied label with font and color controls by subclass. Since: 3.3 '
848, 'org.eclipse.jface.viewers.deferred.IConcurrentModel', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/viewers/deferred/IConcurrentModel.html', 'Interface for a set of unordered elements that can fire change notifications. IConcurrentModel returns its contents asynchronous. Rather than implementing \"get\" methods, listeners can request an update and the model fires back information at its earliest convenience. The model is allowed to send back notifications to its listeners in any thread, and the listeners must not assume that the notifications will arrive in the UI thread. Not intended to be implemented by clients. Clients should subclass AbstractConcurrentModel instead. Since: 3.1 Restriction: This interface is not intended to be implemented by clients. '
849, 'org.eclipse.jface.viewers.deferred.IConcurrentModelListener', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/viewers/deferred/IConcurrentModelListener.html', 'Interface for objects that can listen to changes in an IConcurrentModel. Elements in an IConcurrentModel are unordered. Since: 3.1 '
850, 'org.eclipse.jface.viewers.deferred.LazySortedCollection', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/viewers/deferred/LazySortedCollection.html', 'extends Object This object maintains a collection of elements, sorted by a comparator given in the constructor. The collection is lazily sorted, allowing more efficient runtimes for most methods. There are several methods on this object that allow objects to be queried by their position in the sorted collection. This is a modified binary search tree. Each subtree has a value, a left and right subtree, a count of the number of children, and a set of unsorted children. Insertion happens lazily. When a new node N is inserted into a subtree T, it is initially added to the set of unsorted children for T without actually comparing it with the value for T. The unsorted children will remain in the unsorted set until some subsequent operation requires us to know the exact set of elements in one of the subtrees. At that time, we partition T by comparing all of its unsorted children with T\'s value and moving them into the left or right subtrees. Since: 3.1 '
851, 'org.eclipse.jface.resource.CompositeImageDescriptor', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/resource/CompositeImageDescriptor.html', 'extends ImageDescriptor Abstract base class for image descriptors that synthesize an image from other images in order to simulate the effect of custom drawing. For example, this could be used to superimpose a red bar dexter symbol across an image to indicate that something was disallowed. Subclasses must implement the getSize and fill methods. Little or no work happens until the image descriptor\'s image is actually requested by a call to createImage (or to getImageData directly). '
852, 'org.eclipse.jface.viewers.DecorationOverlayIcon', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/viewers/DecorationOverlayIcon.html', 'extends CompositeImageDescriptor A DecorationOverlayIcon is an image descriptor that can be used to overlay decoration images on to the 4 corner quadrants of a base image. The four quadrants are IDecoration.TOP_LEFT, IDecoration.TOP_RIGHT, IDecoration.BOTTOM_LEFT and IDecoration.BOTTOM_RIGHT. Additionally, the overlay can be used to provide an underlay corresponding to IDecoration.UNDERLAY. Since: 3.3 See Also: IDecoration '
853, 'org.eclipse.jface.action.StatusLineLayoutData', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/action/StatusLineLayoutData.html', 'extends Object Represents the layout data object for Control within the status line. To set a StatusLineLayoutData object into a Control, use the setLayoutData() method. NOTE: Do not reuse StatusLineLayoutData objects. Every control in the status line must have a unique StatusLineLayoutData instance or null. Since: 2.1 '
854, 'org.eclipse.jface.action.ExternalActionManager.IExecuteCallback', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/action/ExternalActionManager.IExecuteCallback.html', ' A callback for executing execution events. Allows ActionContributionItems to fire useful events. Clients must not implement this interface and must not extend. Since: 3.4 '
855, 'org.eclipse.jface.bindings.keys.IKeyLookup', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/bindings/keys/IKeyLookup.html', ' A facilitiy for converting the formal representation for key strokes (i.e., used in persistence) into real key stroke instances. Since: 3.1 '
856, 'org.eclipse.jface.bindings.Trigger', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/bindings/Trigger.html', 'extends Object implements Comparable The abstract class for any object that can be used as a trigger for a binding. This ensures that trigger conform to certain minimum requirements. Namely, triggers need to be hashable. Since: 3.1 '
857, 'org.eclipse.jface.bindings.keys.KeyLookupFactory', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/bindings/keys/KeyLookupFactory.html', 'extends Object A factory class for ILookup instances. This factory can be used to retrieve instances of look-ups defined by this package. It also allows you to define your own look-up for use in the classes. Since: 3.1 '
858, 'org.eclipse.jface.action.AbstractAction', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/action/AbstractAction.html', 'An action represents the non-UI side of a command which can be triggered by the end user. Actions are typically associated with buttons, menu items, and items in tool bars. The controls for a command are built by some container, which furnished the context where these controls appear and configures them with data from properties declared by the action. When the end user triggers the command via its control, the action\'s run method is invoked to do the real work. Actions support a predefined set of properties (and possibly others as well). Clients of an action may register property change listeners so that they get notified whenever the value of a property changes. Clients should subclass the abstract base class Action to define concrete actions rather than implementing IAction from scratch. This interface exists only to define the API for actions. It is not intended to be implemented by clients. See Also: Action Restriction: This interface is not intended to be implemented by clients. extends EventManager implements IAction Some common functionality to share between implementations of IAction. This functionality deals with the property change event mechanism. Clients may neither instantiate nor extend this class. Since: 3.2 '
859, 'org.eclipse.jface.action.SubContributionManager', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/action/SubContributionManager.html', 'A contribution manager organizes contributions to such UI components as menus, toolbars and status lines. A contribution manager keeps track of a list of contribution items. Each contribution item may has an optional identifier, which can be used to retrieve items from a manager, and for positioning items relative to each other. The list of contribution items can be subdivided into named groups using special contribution items that serve as group markers. The IContributionManager interface provides general protocol for adding, removing, and retrieving contribution items. It also provides convenience methods that make it convenient to contribute actions. This interface should be implemented by all objects that wish to manage contributions. There are several implementions of this interface in this package, including ones for menus (MenuManager), tool bars (ToolBarManager), and status lines (StatusLineManager). extends Object implements IContributionManager A SubContributionManager is used to define a set of contribution items within a parent manager. Once defined, the visibility of the entire set can be changed as a unit. '
860, 'org.eclipse.jface.action.SubMenuManager', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/action/SubMenuManager.html', 'A contribution item represents a contribution to a shared UI resource such as a menu or tool bar. More generally, contribution items are managed by a contribution manager. For instance, in a tool bar a contribution item is a tool bar button or a separator. In a menu bar a contribution item is a menu, and in a menu a contribution item is a menu item or separator. A contribution item can realize itself in different SWT widgets, using the different fill methods. The same type of contribution item can be used with a MenuBarManager, ToolBarManager, CoolBarManager, or a StatusLineManager. This interface is internal to the framework; it should not be implemented outside the framework. See Also: IContributionManager Restriction: This interface is not intended to be implemented by clients. A contribution manager organizes contributions to such UI components as menus, toolbars and status lines. A contribution manager keeps track of a list of contribution items. Each contribution item may has an optional identifier, which can be used to retrieve items from a manager, and for positioning items relative to each other. The list of contribution items can be subdivided into named groups using special contribution items that serve as group markers. The IContributionManager interface provides general protocol for adding, removing, and retrieving contribution items. It also provides convenience methods that make it convenient to contribute actions. This interface should be implemented by all objects that wish to manage contributions. There are several implementions of this interface in this package, including ones for menus (MenuManager), tool bars (ToolBarManager), and status lines (StatusLineManager). A contribution item represents a contribution to a shared UI resource such as a menu or tool bar. More generally, contribution items are managed by a contribution manager. For instance, in a tool bar a contribution item is a tool bar button or a separator. In a menu bar a contribution item is a menu, and in a menu a contribution item is a menu item or separator. A contribution item can realize itself in different SWT widgets, using the different fill methods. The same type of contribution item can be used with a MenuBarManager, ToolBarManager, CoolBarManager, or a StatusLineManager. This interface is internal to the framework; it should not be implemented outside the framework. See Also: IContributionManager Restriction: This interface is not intended to be implemented by clients. A contribution manager organizes contributions to such UI components as menus, toolbars and status lines. A contribution manager keeps track of a list of contribution items. Each contribution item may has an optional identifier, which can be used to retrieve items from a manager, and for positioning items relative to each other. The list of contribution items can be subdivided into named groups using special contribution items that serve as group markers. The IContributionManager interface provides general protocol for adding, removing, and retrieving contribution items. It also provides convenience methods that make it convenient to contribute actions. This interface should be implemented by all objects that wish to manage contributions. There are several implementions of this interface in this package, including ones for menus (MenuManager), tool bars (ToolBarManager), and status lines (StatusLineManager). extends IContributionManager, IContributionItem The IMenuManager interface provides protocol for managing contributions to a menu bar and its sub menus. An IMenuManager is also an IContributionItem, allowing sub-menus to be nested in parent menus. This interface is internal to the framework; it should not be implemented outside the framework. This package provides a concrete menu manager implementation, MenuManager. Restriction: This interface is not intended to be implemented by clients. extends SubContributionManager implements IMenuManager A SubMenuManager is used to define a set of contribution items within a parent manager. Once defined, the visibility of the entire set can be changed as a unit. A client may ask for and make additions to a submenu. The visibility of these items is also controlled by the visibility of the SubMenuManager. '
861, 'org.eclipse.core.runtime.IProgressMonitorWithBlocking', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/runtime/IProgressMonitorWithBlocking.html', 'The IProgressMonitor interface is implemented by objects that monitor the progress of an activity; the methods in this interface are invoked by code that performs the activity. All activity is broken down into a linear sequence of tasks against which progress is reported. When a task begins, a beginTask(String, int) notification is reported, followed by any number and mixture of progress reports (worked()) and subtask notifications (subTask(String)). When the task is eventually completed, a done() notification is reported. After the done() notification, the progress monitor cannot be reused; i.e., beginTask(String, int) cannot be called again after the call to done(). A request to cancel an operation can be signaled using the setCanceled method. Operations taking a progress monitor are expected to poll the monitor (using isCanceled) periodically and abort at their earliest convenience. Operation can however choose to ignore cancelation requests. Since notification is synchronous with the activity itself, the listener should provide a fast and robust implementation. If the handling of notifications would involve blocking operations, or operations which might throw uncaught exceptions, the notifications should be queued, and the actual processing deferred (or perhaps delegated to a separate thread). This interface can be used without OSGi running. Clients may implement this interface. extends IProgressMonitor An extension to the IProgressMonitor interface for monitors that want to support feedback when an activity is blocked due to concurrent activity in another thread. When a monitor that supports this extension is passed to an operation, the operation should call setBlocked whenever it knows that it must wait for a lock that is currently held by another thread. The operation should continue to check for and respond to cancelation requests while blocked. When the operation is no longer blocked, it must call clearBlocked to clear the blocked state. This interface can be used without OSGi running. Clients may implement this interface. Since: 3.0 See Also: IProgressMonitor '
862, 'org.eclipse.jface.viewers.ColumnLayoutData', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/viewers/ColumnLayoutData.html', 'extends Object An abstract column layout data describing the information needed (by TableLayout) to properly lay out a table. This class is not intended to be subclassed outside the framework. Restriction: This class is not intended to be subclassed by clients. '
863, 'org.eclipse.jface.layout.AbstractColumnLayout', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/layout/AbstractColumnLayout.html', 'extends Layout The AbstractColumnLayout is a Layout used to set the size of a table in a consistent way even during a resize unlike a TableLayout which only sets initial sizes. You can only add the layout to a container whose only child is the table/tree control you want the layouts applied to. Since: 3.4 '
864, 'org.eclipse.jface.preference.StringButtonFieldEditor', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/preference/StringButtonFieldEditor.html', 'extends StringFieldEditor An abstract field editor for a string type preference that presents a string input field with a change button to its right to edit the input field\'s content. When the user presses the change button, the abstract framework method changePressed() gets called to compute a new string. '
865, 'org.eclipse.swt.widgets.Scale', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/widgets/Scale.html', 'Implementers of Drawable can have a graphics context (GC) created for them, and then they can be drawn on by sending messages to their associated GC. SWT images, and device objects such as the Display device and the Printer device, are drawables. IMPORTANT: This interface is not part of the SWT public API. It is marked public only so that it can be shared within the packages provided by SWT. It should never be referenced from application code. See Also: Device, Image, GC extends Control Instances of the receiver represent a selectable user interface object that present a range of continuous numeric values. Styles: HORIZONTAL, VERTICAL Events: Selection Note: Only one of the styles HORIZONTAL and VERTICAL may be specified. IMPORTANT: This class is not intended to be subclassed. See Also: Scale snippets, SWT Example: ControlExample, Sample code and further information Restriction: This class is not intended to be subclassed by clients. '
866, 'org.eclipse.jface.preference.ColorSelector', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/preference/ColorSelector.html', 'extends EventManager The ColorSelector is a wrapper for a button that displays a selected Color and allows the user to change the selection. '
867, 'org.eclipse.jface.commands.ToggleState', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/commands/ToggleState.html', 'extends PersistentState A piece of state storing a Boolean. If this state is registered using IMenuStateIds.STYLE, then it will control the presentation of the command if displayed in the menus, tool bars or status line. Clients may instantiate this class, but must not extend. Since: 3.2 '
868, 'org.eclipse.core.commands.IHandlerListener', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/commands/IHandlerListener.html', 'An instance of this interface can be used by clients to receive notification of changes to one or more instances of IHandler. This interface may be implemented by clients. Since: 3.1 See Also: IHandler.addHandlerListener(IHandlerListener), IHandler.removeHandlerListener(IHandlerListener) '
869, 'org.eclipse.core.runtime.ProgressMonitorWrapper', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/runtime/ProgressMonitorWrapper.html', 'The IProgressMonitor interface is implemented by objects that monitor the progress of an activity; the methods in this interface are invoked by code that performs the activity. All activity is broken down into a linear sequence of tasks against which progress is reported. When a task begins, a beginTask(String, int) notification is reported, followed by any number and mixture of progress reports (worked()) and subtask notifications (subTask(String)). When the task is eventually completed, a done() notification is reported. After the done() notification, the progress monitor cannot be reused; i.e., beginTask(String, int) cannot be called again after the call to done(). A request to cancel an operation can be signaled using the setCanceled method. Operations taking a progress monitor are expected to poll the monitor (using isCanceled) periodically and abort at their earliest convenience. Operation can however choose to ignore cancelation requests. Since notification is synchronous with the activity itself, the listener should provide a fast and robust implementation. If the handling of notifications would involve blocking operations, or operations which might throw uncaught exceptions, the notifications should be queued, and the actual processing deferred (or perhaps delegated to a separate thread). This interface can be used without OSGi running. Clients may implement this interface. The IProgressMonitor interface is implemented by objects that monitor the progress of an activity; the methods in this interface are invoked by code that performs the activity. All activity is broken down into a linear sequence of tasks against which progress is reported. When a task begins, a beginTask(String, int) notification is reported, followed by any number and mixture of progress reports (worked()) and subtask notifications (subTask(String)). When the task is eventually completed, a done() notification is reported. After the done() notification, the progress monitor cannot be reused; i.e., beginTask(String, int) cannot be called again after the call to done(). A request to cancel an operation can be signaled using the setCanceled method. Operations taking a progress monitor are expected to poll the monitor (using isCanceled) periodically and abort at their earliest convenience. Operation can however choose to ignore cancelation requests. Since notification is synchronous with the activity itself, the listener should provide a fast and robust implementation. If the handling of notifications would involve blocking operations, or operations which might throw uncaught exceptions, the notifications should be queued, and the actual processing deferred (or perhaps delegated to a separate thread). This interface can be used without OSGi running. Clients may implement this interface. extends IProgressMonitor An extension to the IProgressMonitor interface for monitors that want to support feedback when an activity is blocked due to concurrent activity in another thread. When a monitor that supports this extension is passed to an operation, the operation should call setBlocked whenever it knows that it must wait for a lock that is currently held by another thread. The operation should continue to check for and respond to cancelation requests while blocked. When the operation is no longer blocked, it must call clearBlocked to clear the blocked state. This interface can be used without OSGi running. Clients may implement this interface. Since: 3.0 See Also: IProgressMonitor extends Object implements IProgressMonitor, IProgressMonitorWithBlocking An abstract wrapper around a progress monitor which, unless overridden, forwards IProgressMonitor and IProgressMonitorWithBlocking methods to the wrapped progress monitor. This class can be used without OSGi running. Clients may subclass. '
870, 'org.eclipse.jface.operation.IThreadListener', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/operation/IThreadListener.html', 'A thread listener is an object that is interested in receiving notifications of thread changes. For example, a thread listener can be used to notify a runnable of the thread that will execute it, allowing the runnable to transfer thread-local state from the calling thread before control passes to the new thread. Since: 3.1 '
871, 'org.eclipse.jface.bindings.ISchemeListener', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/bindings/ISchemeListener.html', ' An instance of ISchemeListener can be used by clients to receive notification of changes to one or more instances of IScheme. This interface may be implemented by clients. Since: 3.1 See Also: Scheme.addSchemeListener(ISchemeListener), Scheme.removeSchemeListener(ISchemeListener), SchemeEvent '
872, 'org.eclipse.jface.bindings.SchemeEvent', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/bindings/SchemeEvent.html', 'extends AbstractNamedHandleEvent An instance of this class describes changes to an instance of IScheme. This class is not intended to be extended by clients. Since: 3.1 See Also: ISchemeListener.schemeChanged(SchemeEvent) '
873, 'org.eclipse.jface.bindings.keys.formatting.AbstractKeyFormatter', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/bindings/keys/formatting/AbstractKeyFormatter.html', ' Any formatter capable of taking a key sequence or a key stroke and converting it into a string. These formatters are used to produce the strings that the user sees in the keys preference page and the menus, as well as the strings that are used for persistent storage. Since: 3.1 extends Object implements IKeyFormatter An abstract implementation of a key formatter that provides a lot of common key formatting functionality. It is recommended that implementations of IKeyFormatter subclass from here, rather than implementing IKeyFormatter directly. Since: 3.1 '
874, 'org.eclipse.swt.dnd.ByteArrayTransfer', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/dnd/ByteArrayTransfer.html', 'provides a platform specific mechanism for converting a java byte[] to a platform specific representation of the byte array and vice versa. ByteArrayTransfer is never used directly but is sub-classed by transfer agents that convert between data in a java format such as a String and a platform specific byte array. If the data you are converting does not map to a byte[], you should sub-class Transfer directly and do your own mapping to a platform data type. The following snippet shows a subclass of ByteArrayTransfer that transfers data defined by the class MyType. public class MyType { public String fileName; public long fileLength; public long lastModified; } public class MyTypeTransfer extends ByteArrayTransfer { private static final String MYTYPENAME = \"my_type_name\"; private static final int MYTYPEID = registerType(MYTYPENAME); private static MyTypeTransfer _instance = new MyTypeTransfer(); private MyTypeTransfer() {} public static MyTypeTransfer getInstance () { return _instance; } public void javaToNative (Object object, TransferData transferData) { if (object == null || !(object instanceof MyType[])) return; if (isSupportedType(transferData)) { MyType[] myTypes = (MyType[]) object; try { // write data to a byte array and then ask super to convert to pMedium ByteArrayOutputStream out = new ByteArrayOutputStream(); DataOutputStream writeOut = new DataOutputStream(out); for (int i = 0, length = myTypes.length; i < length; i++){ byte[] buffer = myTypes[i].fileName.getBytes(); writeOut.writeInt(buffer.length); writeOut.write(buffer); writeOut.writeLong(myTypes[i].fileLength); writeOut.writeLong(myTypes[i].lastModified); } byte[] buffer = out.toByteArray(); writeOut.close(); super.javaToNative(buffer, transferData); } catch (IOException e) { } } } public Object nativeToJava(TransferData transferData){ if (isSupportedType(transferData)) { byte[] buffer = (byte[])super.nativeToJava(transferData); if (buffer == null) return null; MyType[] myData = new MyType[0]; try { ByteArrayInputStream in = new ByteArrayInputStream(buffer); DataInputStream readIn = new DataInputStream(in); while(readIn.available() > 20) { MyType datum = new MyType(); int size = readIn.readInt(); byte[] name = new byte[size]; readIn.read(name); datum.fileName = new String(name); datum.fileLength = readIn.readLong(); datum.lastModified = readIn.readLong(); MyType[] newMyData = new MyType[myData.length + 1]; System.arraycopy(myData, 0, newMyData, 0, myData.length); newMyData[myData.length] = datum; myData = newMyData; } readIn.close(); } catch (IOException ex) { return null; } return myData; } return null; } protected String[] getTypeNames(){ return new String[]{MYTYPENAME}; } protected int[] getTypeIds(){ return new int[] {MYTYPEID}; } } See Also: Transfer '
875, 'org.eclipse.jface.util.LocalSelectionTransfer', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/util/LocalSelectionTransfer.html', 'extends ByteArrayTransfer A LocalSelectionTransfer may be used for drag and drop operations within the same instance of Eclipse. The selection is made available directly for use in the DropTargetListener. dropAccept method. The DropTargetEvent passed to dropAccept does not contain the drop data. The selection may be used for validation purposes so that the drop can be aborted if appropriate. This class is not intended to be subclassed. Since: 3.2 '
876, 'org.eclipse.jface.bindings.keys.KeySequenceText', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/bindings/keys/KeySequenceText.html', 'extends Object A wrapper around the SWT text widget that traps literal key presses and converts them into key sequences for display. There are two types of key strokes that are displayed: complete and incomplete. A complete key stroke is one with a natural key, while an incomplete one has no natural key. Incomplete key strokes are only displayed until they are made complete or their component key presses are released. Since: 3.1 '
877, 'org.eclipse.swt.graphics.TextLayout', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/graphics/TextLayout.html', 'extends Resource TextLayout is a graphic object that represents styled text. Instances of this class provide support for drawing, cursor navigation, hit testing, text wrapping, alignment, tab expansion line breaking, etc. These are aspects required for rendering internationalized text. Application code must explicitly invoke the TextLayout#dispose() method to release the operating system resources managed by each instance when those instances are no longer required. Since: 3.0 See Also: TextLayout, TextStyle snippets, SWT Example: CustomControlExample, StyledText tab, Sample code and further information '
878, 'org.eclipse.swt.graphics.TextStyle', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/graphics/TextStyle.html', 'extends Object TextStyle defines a set of styles that can be applied to a range of text. The hashCode() method in this class uses the values of the public fields to compute the hash value. When storing instances of the class in hashed collections, do not modify these fields after the object has been inserted. Application code does not need to explicitly release the resources managed by each instance when those instances are no longer required, and thus no dispose() method is provided. Since: 3.0 See Also: TextLayout, Font, Color, TextLayout, TextStyle snippets, Sample code and further information '
879, 'org.eclipse.ui.ide.dialogs.AbstractEncodingFieldEditor', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/ide/dialogs/AbstractEncodingFieldEditor.html', 'extends FieldEditor The abstract superclass of field editors used to set an encoding. Any user entered encodings will be added to the list of encodings available via IDEEncoding. Subclasses may extend, but must call createEncodingGroup during doFillIntoGrid. Since: 3.1 See Also: IDEEncoding '
880, 'org.eclipse.core.resources.ProjectScope', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/resources/ProjectScope.html', 'Clients implement this interface to provide context to a particular scope. Instances of implementations of this interface are passed to the IPreferencesService for use in preference searching. Clients may implement this interface. Since: 3.0 See Also: IPreferencesService extends Object implements IScopeContext Object representing the project scope in the Eclipse preferences hierarchy. Can be used as a context for searching for preference values (in the org.eclipse.core.runtime.IPreferencesService APIs) or for determining the correct preference node to set values in the store. Project preferences are stored on a per project basis in the project\'s content area as specified by IProject#getLocation. The path for preferences defined in the project scope hierarchy is as follows: /project/<projectName>/<qualifier> This class is not intended to be subclassed. This class may be instantiated. Since: 3.0 See Also: IResource.getLocation() '
881, 'org.eclipse.core.runtime.content.IContentDescription', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/runtime/content/IContentDescription.html', 'A content description object contains information about the nature of arbitrary data. A content description object will always include the content type for the examined contents, and may also include information on: charset; byte order mark; other custom properties provided by third-party plug-ins. Content describers provided by plug-ins will fill in most of the properties in a content description object, except for the content type, what is done by the platform. After a content description is filled in by a content interpreter, it is marked as immutable by the platform, so calling any of the mutator methods defined in this interface will cause an IllegalStateException to be thrown. Default values for properties can be contributed by plug-ins as part of the content type definition markup. This interface is not intended to be implemented by clients. Since: 3.0 See Also: IContentDescriber '
882, 'org.eclipse.core.runtime.content.IContentType', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/runtime/content/IContentType.html', 'Gives access to the user settings for a content type. This interface is not intended to be implemented by clients. Since: 3.1 See Also: IContentType, IContentType.getSettings(IScopeContext) extends IContentTypeSettings Content types represent and provide information on file types, such as associated file names/extensions, default charset, etc. This interface is not intended to be implemented by clients. Since: 3.0 '
883, 'org.eclipse.ui.navigator.CommonNavigator', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/navigator/CommonNavigator.html', 'An interface for an adaptable object. Adaptable objects can be dynamically extended to provide different interfaces (or \"adapters\"). Adapters are created by adapter factories, which are in turn managed by type by adapter managers. For example, IAdaptable a = [some adaptable]; IFoo x = (IFoo)a.getAdapter(IFoo.class); if (x != null) [do IFoo things with x] This interface can be used without OSGi running. Clients may implement this interface, or obtain a default implementation of this interface by subclassing PlatformObject. See Also: IAdapterFactory, IAdapterManager, PlatformObject Interface for executable extension classes that require access to their configuration element, or implement an extension adapter. Extension adapters are typically required in cases where the extension implementation does not follow the interface rules specified by the provider of the extension point. In these cases, the role of the adapter is to map between the extension point interface, and the actual extension implementation. In general, adapters are used when attempting to plug-in existing Java implementations, or non-Java implementations (e.g., external executables). This interface can be used without OSGi running. Clients may implement this interface. See Also: IConfigurationElement.createExecutableExtension(String) Objects implementing this interface are capable of saving their state in an IMemento. Since: 3.1 Workbench parts implement or adapt to this interface to participate in the enablement and execution of the Save and Save As actions. Since: 2.1 See Also: IEditorPart Represents a source of Saveable objects (units of saveability). Workbench parts that show more than one unit of saveability, or whose units of saveability change over time, should implement this interface in order to provide better integration with workbench facilities like the Save command, prompts to save on part close or shutdown, etc. IMPORTANT: As of 3.2, implementers of ISaveablesSource must satisfy the following conditions: If ISaveablesSource is implemented by an IWorkbenchPart: the part must implement ISaveablePart if any of its Saveable objects are dirty, the part must return true from ISaveablePart.isDirty() the part must return true from ISaveablePart.isSaveOnCloseNeeded() if it is dirty (the default behaviour implemented by EditorPart) the part must not implement ISaveablePart2 If ISaveablesSource is implemented by a non-part (possible as of 3.2.1 and 3.3): the Workbench\'s ISaveablesLifecycleListener (obtained from the Workbench by calling workbench.getService(ISaveablesLifecycleListener.class)) must be notified of any change to the result of getSaveables() getActiveSaveables() should be implemented to return an empty array If any of these conditions are not met, it is undefined whether the Workbench will prompt to save dirty Saveables when closing parts or the Workbench. These conditions may be relaxed in future releases. Since: 3.2 An interface for an adaptable object. Adaptable objects can be dynamically extended to provide different interfaces (or \"adapters\"). Adapters are created by adapter factories, which are in turn managed by type by adapter managers. For example, IAdaptable a = [some adaptable]; IFoo x = (IFoo)a.getAdapter(IFoo.class); if (x != null) [do IFoo things with x] This interface can be used without OSGi running. Clients may implement this interface, or obtain a default implementation of this interface by subclassing PlatformObject. See Also: IAdapterFactory, IAdapterManager, PlatformObject Objects implementing this interface are capable of saving their state in an IMemento. Since: 3.1 An interface for an adaptable object. Adaptable objects can be dynamically extended to provide different interfaces (or \"adapters\"). Adapters are created by adapter factories, which are in turn managed by type by adapter managers. For example, IAdaptable a = [some adaptable]; IFoo x = (IFoo)a.getAdapter(IFoo.class); if (x != null) [do IFoo things with x] This interface can be used without OSGi running. Clients may implement this interface, or obtain a default implementation of this interface by subclassing PlatformObject. See Also: IAdapterFactory, IAdapterManager, PlatformObject extends IAdaptable A workbench part is a visual component within a workbench page. There are two subtypes: view and editor, as defined by IViewPart and IEditorPart. A view is typically used to navigate a hierarchy of information (like the workspace), open an editor, or display properties for the active editor. Modifications made in a view are saved immediately. An editor is typically used to edit or browse a document or input object. The input is identified using an IEditorInput. Modifications made in an editor part follow an open-save-close lifecycle model. This interface may be implemented directly. For convenience, a base implementation is defined in WorkbenchPart. The lifecycle of a workbench part is as follows: When a part extension is created: instantiate the part create a part site call part.init(site) When a part becomes visible in the workbench: add part to presentation by calling part.createPartControl(parent) to create actual widgets fire partOpened event to all listeners When a part is activated or gets focus: call part.setFocus() fire partActivated event to all listeners When a part is closed: if save is needed, do save; if it fails or is canceled return if part is active, deactivate part fire partClosed event to all listeners remove part from presentation; part controls are disposed as part of the SWT widget tree call part.dispose() After createPartControl has been called, the implementor may safely reference the controls created. When the part is closed these controls will be disposed as part of an SWT composite. This occurs before the IWorkbenchPart.dispose method is called. If there is a need to free SWT resources the part should define a dispose listener for its own control and free those resources from the dispose listener. If the part invokes any method on the disposed SWT controls after this point an SWTError will be thrown. The last method called on IWorkbenchPart is dispose. This signals the end of the part lifecycle. An important point to note about this lifecycle is that following a call to init, createPartControl may never be called. Thus in the dispose method, implementors must not assume controls were created. Workbench parts implement the IAdaptable interface; extensions are managed by the platform\'s adapter manager. See Also: IViewPart, IEditorPart extends IWorkbenchPart, IPersistable A view is a visual component within a workbench page. It is typically used to navigate a hierarchy of information (like the workspace), open an editor, or display properties for the active editor. Modifications made in a view are saved immediately (in contrast to an editor part, which conforms to a more elaborate open-save-close lifecycle). Only one instance of a particular view type may exist within a workbench page. This policy is designed to simplify part management for a user. This interface may be implemented directly. For convenience, a base implementation is defined in ViewPart. A view is added to the workbench in two steps: A view extension is contributed to the workbench registry. This extension defines the extension id and extension class. The view is included in the default layout for a perspective. Alternatively, the user may open the view from the Perspective menu. Views implement the IAdaptable interface; extensions are managed by the platform\'s adapter manager. As of 3.4, views may optionally adapt to ISizeProvider if they have a preferred size. The default presentation will make a best effort to allocate the preferred size to a view if it is the only part in a stack. If there is more than one part in the stack, the constraints will be disabled for that stack. The size constraints are adjusted for the size of the tab and border trim. Note that this is considered to be a hint to the presentation, and not all presentations may honor size constraints. See Also: IWorkbenchPage.showView(java.lang.String), ViewPart, ISizeProvider An interface for an adaptable object. Adaptable objects can be dynamically extended to provide different interfaces (or \"adapters\"). Adapters are created by adapter factories, which are in turn managed by type by adapter managers. For example, IAdaptable a = [some adaptable]; IFoo x = (IFoo)a.getAdapter(IFoo.class); if (x != null) [do IFoo things with x] This interface can be used without OSGi running. Clients may implement this interface, or obtain a default implementation of this interface by subclassing PlatformObject. See Also: IAdapterFactory, IAdapterManager, PlatformObject extends IAdaptable A workbench part is a visual component within a workbench page. There are two subtypes: view and editor, as defined by IViewPart and IEditorPart. A view is typically used to navigate a hierarchy of information (like the workspace), open an editor, or display properties for the active editor. Modifications made in a view are saved immediately. An editor is typically used to edit or browse a document or input object. The input is identified using an IEditorInput. Modifications made in an editor part follow an open-save-close lifecycle model. This interface may be implemented directly. For convenience, a base implementation is defined in WorkbenchPart. The lifecycle of a workbench part is as follows: When a part extension is created: instantiate the part create a part site call part.init(site) When a part becomes visible in the workbench: add part to presentation by calling part.createPartControl(parent) to create actual widgets fire partOpened event to all listeners When a part is activated or gets focus: call part.setFocus() fire partActivated event to all listeners When a part is closed: if save is needed, do save; if it fails or is canceled return if part is active, deactivate part fire partClosed event to all listeners remove part from presentation; part controls are disposed as part of the SWT widget tree call part.dispose() After createPartControl has been called, the implementor may safely reference the controls created. When the part is closed these controls will be disposed as part of an SWT composite. This occurs before the IWorkbenchPart.dispose method is called. If there is a need to free SWT resources the part should define a dispose listener for its own control and free those resources from the dispose listener. If the part invokes any method on the disposed SWT controls after this point an SWTError will be thrown. The last method called on IWorkbenchPart is dispose. This signals the end of the part lifecycle. An important point to note about this lifecycle is that following a call to init, createPartControl may never be called. Thus in the dispose method, implementors must not assume controls were created. Workbench parts implement the IAdaptable interface; extensions are managed by the platform\'s adapter manager. See Also: IViewPart, IEditorPart An interface for an adaptable object. Adaptable objects can be dynamically extended to provide different interfaces (or \"adapters\"). Adapters are created by adapter factories, which are in turn managed by type by adapter managers. For example, IAdaptable a = [some adaptable]; IFoo x = (IFoo)a.getAdapter(IFoo.class); if (x != null) [do IFoo things with x] This interface can be used without OSGi running. Clients may implement this interface, or obtain a default implementation of this interface by subclassing PlatformObject. See Also: IAdapterFactory, IAdapterManager, PlatformObject An interface for an adaptable object. Adaptable objects can be dynamically extended to provide different interfaces (or \"adapters\"). Adapters are created by adapter factories, which are in turn managed by type by adapter managers. For example, IAdaptable a = [some adaptable]; IFoo x = (IFoo)a.getAdapter(IFoo.class); if (x != null) [do IFoo things with x] This interface can be used without OSGi running. Clients may implement this interface, or obtain a default implementation of this interface by subclassing PlatformObject. See Also: IAdapterFactory, IAdapterManager, PlatformObject extends IAdaptable A workbench part is a visual component within a workbench page. There are two subtypes: view and editor, as defined by IViewPart and IEditorPart. A view is typically used to navigate a hierarchy of information (like the workspace), open an editor, or display properties for the active editor. Modifications made in a view are saved immediately. An editor is typically used to edit or browse a document or input object. The input is identified using an IEditorInput. Modifications made in an editor part follow an open-save-close lifecycle model. This interface may be implemented directly. For convenience, a base implementation is defined in WorkbenchPart. The lifecycle of a workbench part is as follows: When a part extension is created: instantiate the part create a part site call part.init(site) When a part becomes visible in the workbench: add part to presentation by calling part.createPartControl(parent) to create actual widgets fire partOpened event to all listeners When a part is activated or gets focus: call part.setFocus() fire partActivated event to all listeners When a part is closed: if save is needed, do save; if it fails or is canceled return if part is active, deactivate part fire partClosed event to all listeners remove part from presentation; part controls are disposed as part of the SWT widget tree call part.dispose() After createPartControl has been called, the implementor may safely reference the controls created. When the part is closed these controls will be disposed as part of an SWT composite. This occurs before the IWorkbenchPart.dispose method is called. If there is a need to free SWT resources the part should define a dispose listener for its own control and free those resources from the dispose listener. If the part invokes any method on the disposed SWT controls after this point an SWTError will be thrown. The last method called on IWorkbenchPart is dispose. This signals the end of the part lifecycle. An important point to note about this lifecycle is that following a call to init, createPartControl may never be called. Thus in the dispose method, implementors must not assume controls were created. Workbench parts implement the IAdaptable interface; extensions are managed by the platform\'s adapter manager. See Also: IViewPart, IEditorPart extends IWorkbenchPart Extends IWorkbenchPart, adding the name and status text properties. Prior to 3.0, a view\'s title was often modified to show both the part name and extra status text. With this interface, the distinction is made more explicit. Since: 3.0 An interface for an adaptable object. Adaptable objects can be dynamically extended to provide different interfaces (or \"adapters\"). Adapters are created by adapter factories, which are in turn managed by type by adapter managers. For example, IAdaptable a = [some adaptable]; IFoo x = (IFoo)a.getAdapter(IFoo.class); if (x != null) [do IFoo things with x] This interface can be used without OSGi running. Clients may implement this interface, or obtain a default implementation of this interface by subclassing PlatformObject. See Also: IAdapterFactory, IAdapterManager, PlatformObject An interface for an adaptable object. Adaptable objects can be dynamically extended to provide different interfaces (or \"adapters\"). Adapters are created by adapter factories, which are in turn managed by type by adapter managers. For example, IAdaptable a = [some adaptable]; IFoo x = (IFoo)a.getAdapter(IFoo.class); if (x != null) [do IFoo things with x] This interface can be used without OSGi running. Clients may implement this interface, or obtain a default implementation of this interface by subclassing PlatformObject. See Also: IAdapterFactory, IAdapterManager, PlatformObject extends IAdaptable A workbench part is a visual component within a workbench page. There are two subtypes: view and editor, as defined by IViewPart and IEditorPart. A view is typically used to navigate a hierarchy of information (like the workspace), open an editor, or display properties for the active editor. Modifications made in a view are saved immediately. An editor is typically used to edit or browse a document or input object. The input is identified using an IEditorInput. Modifications made in an editor part follow an open-save-close lifecycle model. This interface may be implemented directly. For convenience, a base implementation is defined in WorkbenchPart. The lifecycle of a workbench part is as follows: When a part extension is created: instantiate the part create a part site call part.init(site) When a part becomes visible in the workbench: add part to presentation by calling part.createPartControl(parent) to create actual widgets fire partOpened event to all listeners When a part is activated or gets focus: call part.setFocus() fire partActivated event to all listeners When a part is closed: if save is needed, do save; if it fails or is canceled return if part is active, deactivate part fire partClosed event to all listeners remove part from presentation; part controls are disposed as part of the SWT widget tree call part.dispose() After createPartControl has been called, the implementor may safely reference the controls created. When the part is closed these controls will be disposed as part of an SWT composite. This occurs before the IWorkbenchPart.dispose method is called. If there is a need to free SWT resources the part should define a dispose listener for its own control and free those resources from the dispose listener. If the part invokes any method on the disposed SWT controls after this point an SWTError will be thrown. The last method called on IWorkbenchPart is dispose. This signals the end of the part lifecycle. An important point to note about this lifecycle is that following a call to init, createPartControl may never be called. Thus in the dispose method, implementors must not assume controls were created. Workbench parts implement the IAdaptable interface; extensions are managed by the platform\'s adapter manager. See Also: IViewPart, IEditorPart extends IWorkbenchPart Extends IWorkbenchPart, adding the name and status text properties. Prior to 3.0, a view\'s title was often modified to show both the part name and extra status text. With this interface, the distinction is made more explicit. Since: 3.0 extends IWorkbenchPart2 A part can provide arbitrary properties. The properties will be persisted between sessions by the part reference, and will be available from the part reference as well as the part. The properties can only be set on a part, not on the reference. The properties will be available to the IPresentablePart. Setting a property must fire a PropertyChangeEvent. Since: 3.3 Interface for views which support reveal and select. This interface may be implemented by subclasses of ViewPart. This interface is commonly used by a New wizard to reveal and select a resource in a workbench part which it has just created. See Also: IViewPart, ViewPart This interface must be provided by Show In targets (parts listed in the Show In prompter). The part can either directly implement this interface, or provide it via IAdaptable.getAdapter(IShowInTarget.class). Since: 2.1 See Also: IPageLayout.addShowInPart(java.lang.String) The IWorkbenchPartOrientation is the interface that defines the orientation of the part. If a type does not implement this interface an orientation of SWT.NONE will be assumed. Since: 3.1 See Also: SWT.RIGHT_TO_LEFT, SWT.LEFT_TO_RIGHT, SWT.NONE, Window.getDefaultOrientation() extends ViewPart implements ISetSelectionTarget, ISaveablePart, ISaveablesSource, IShowInTarget This class provides the IViewPart for the Common Navigator framework in the Eclipse workbench. This class also serves as the backbone for navigational viewers. The following types are used by this class to render the Common Navigator: CommonViewer: The viewer that renders the extensible tree. Creates and manages the lifecycle of the Navigator Content Service (described below). NavigatorActionService: Manages instances of CommonActionProviders provided by individual extensions and content extensions. INavigatorContentService: Manages instances of Navigator Content Extensions. Instances are created as needed, and disposed of upon the disposal of the Navigator Content Service. Clients that wish to define their own custom extensible navigator view using CommonNavigator need to specify an instance of the org.eclipse.ui.views extension point: <extension point=\"org.eclipse.ui.views\"> <view name=\"My Custom View\" icon=\"relative/path/to/icon.gif\" category=\"org.acme.mycategory\" class=\"org.eclipse.ui.navigator.CommonNavigator\" id=\"org.acme.MyCustomNavigatorID\"> </view> </extension> CommonNavigator gets its initial input (during initialization) from the Workbench by calling getSite().getPage().getInput(). This is done in getInitialInput(). Clients may create a subclass of CommonNavigator to provide their own means of getting the initial input. Or they may access the CommonViewer and set its input directly after startup. In the IDE scenario, the default page input is IWorkspaceRoot, in the RCP scenario it is null and can be configured in the WorkbenchAdvisor. Clients that wish to extend the view menu provided via the org.eclipse.ui.popupMenus extension may specify the the popupMenuId specified by org.eclipse.ui.navigator.viewer (or a nested popupMenu element) of their target viewer as their target menu id. This class may be instantiated or subclassed Since: 3.2 '
884, 'org.eclipse.ui.IAggregateWorkingSet', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/IAggregateWorkingSet.html', 'An interface for an adaptable object. Adaptable objects can be dynamically extended to provide different interfaces (or \"adapters\"). Adapters are created by adapter factories, which are in turn managed by type by adapter managers. For example, IAdaptable a = [some adaptable]; IFoo x = (IFoo)a.getAdapter(IFoo.class); if (x != null) [do IFoo things with x] This interface can be used without OSGi running. Clients may implement this interface, or obtain a default implementation of this interface by subclassing PlatformObject. See Also: IAdapterFactory, IAdapterManager, PlatformObject Objects implementing this interface are capable of saving their state in an IMemento. Since: 3.1 Objects implementing this interface are capable of saving their state in an IMemento. Since: 3.1 extends IPersistable Interface for asking an object to store its state in a memento. This interface is typically included in interfaces where persistance is required. When the workbench is shutdown objects which implement this interface will be persisted. At this time the getFactoryId method is invoked to discover the id of the element factory that will be used to re-create the object from a memento. Then the saveState method is invoked to store the element data into a newly created memento. The resulting mementos are collected up and written out to a single file. During workbench startup these mementos are read from the file. The factory Id for each is retrieved and mapped to an IElementFactory which has been registered in the element factory extension point. If a factory exists for the Id it will be engaged to re-create the original object. See Also: IAdaptable, IMemento, IElementFactory An interface for an adaptable object. Adaptable objects can be dynamically extended to provide different interfaces (or \"adapters\"). Adapters are created by adapter factories, which are in turn managed by type by adapter managers. For example, IAdaptable a = [some adaptable]; IFoo x = (IFoo)a.getAdapter(IFoo.class); if (x != null) [do IFoo things with x] This interface can be used without OSGi running. Clients may implement this interface, or obtain a default implementation of this interface by subclassing PlatformObject. See Also: IAdapterFactory, IAdapterManager, PlatformObject Objects implementing this interface are capable of saving their state in an IMemento. Since: 3.1 Objects implementing this interface are capable of saving their state in an IMemento. Since: 3.1 extends IPersistable Interface for asking an object to store its state in a memento. This interface is typically included in interfaces where persistance is required. When the workbench is shutdown objects which implement this interface will be persisted. At this time the getFactoryId method is invoked to discover the id of the element factory that will be used to re-create the object from a memento. Then the saveState method is invoked to store the element data into a newly created memento. The resulting mementos are collected up and written out to a single file. During workbench startup these mementos are read from the file. The factory Id for each is retrieved and mapped to an IElementFactory which has been registered in the element factory extension point. If a factory exists for the Id it will be engaged to re-create the original object. See Also: IAdaptable, IMemento, IElementFactory extends IPersistableElement, IAdaptable A working set holds a number of IAdaptable elements. A working set is intended to group elements for presentation to the user or for operations on a set of elements. Since: 2.0 initial version, 3.0 now extends IPersistableElement, 3.2 now extends IAdaptable Restriction: This interface is not intended to be implemented by clients. extends IWorkingSet Contains a set of IWorkingSet. Sets of working sets are used by viewers to contain all of the working sets being shown. Sets can also be nested. In classes that implement this, the IWorkingSet.getElements() returns all of the elements of each of the working sets in this set. Instances of IWorkingSet can be cast to IAggregateWorkingSet if IWorkingSet.isAggregateWorkingSet() is true. Since: 3.5 initial version Restriction: This interface is not intended to be implemented by clients. '
885, 'org.eclipse.ui.forms.widgets.ToggleHyperlink', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/forms/widgets/ToggleHyperlink.html', 'Implementers of Drawable can have a graphics context (GC) created for them, and then they can be drawn on by sending messages to their associated GC. SWT images, and device objects such as the Display device and the Printer device, are drawables. IMPORTANT: This interface is not part of the SWT public API. It is marked public only so that it can be shared within the packages provided by SWT. It should never be referenced from application code. See Also: Device, Image, GC extends AbstractHyperlink A custom selectable control that can be used to control areas that can be expanded or collapsed. This is an abstract class. Subclasses are responsible for rendering the control using decoration and hover decoration color. Control should be rendered based on the current expansion state. Styles: None Since: 3.0 '
886, 'org.eclipse.ui.forms.widgets.Twistie', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/forms/widgets/Twistie.html', 'Implementers of Drawable can have a graphics context (GC) created for them, and then they can be drawn on by sending messages to their associated GC. SWT images, and device objects such as the Display device and the Printer device, are drawables. IMPORTANT: This interface is not part of the SWT public API. It is marked public only so that it can be shared within the packages provided by SWT. It should never be referenced from application code. See Also: Device, Image, GC extends ToggleHyperlink A custom selectable control that can be used to control areas that can be expanded or collapsed. The control control can be toggled between selected and deselected state with a mouse or by pressing \'Enter\' while the control has focus. The control is rendered as a triangle that points to the right in the collapsed and down in the expanded state. Triangle color can be changed. Styles: None Since: 3.0 See Also: TreeNode '
887, 'org.eclipse.ui.forms.widgets.TreeNode', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/forms/widgets/TreeNode.html', 'Implementers of Drawable can have a graphics context (GC) created for them, and then they can be drawn on by sending messages to their associated GC. SWT images, and device objects such as the Display device and the Printer device, are drawables. IMPORTANT: This interface is not part of the SWT public API. It is marked public only so that it can be shared within the packages provided by SWT. It should never be referenced from application code. See Also: Device, Image, GC extends ToggleHyperlink A custom selectable control that can be used to control areas that can be expanded or collapsed. The control control can be toggled between selected and deselected state with a mouse or by pressing \'Enter\' while the control has focus. The control is rendered as box with a \'+\' or \'-\' sign, depending on the expansion state. Focus indication is rendered around the box when the control has keyboard focus. Styles: None Since: 3.0 See Also: Twistie '
888, 'org.eclipse.ui.forms.events.HyperlinkAdapter', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/forms/events/HyperlinkAdapter.html', 'Classes that implement this interface will be notified when hyperlinks are entered, exited and activated. Since: 3.0 See Also: Hyperlink, ImageHyperlink, FormText extends Object implements IHyperlinkListener This adapter class provides default implementations for the methods described by the HyperlinkListener interface. Classes that wish to deal with HyperlinkEvent s can extend this class and override only the methods which they are interested in. Since: 3.0 See Also: IHyperlinkListener, HyperlinkEvent '
889, 'org.eclipse.ui.forms.widgets.Hyperlink', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/forms/widgets/Hyperlink.html', 'Implementers of Drawable can have a graphics context (GC) created for them, and then they can be drawn on by sending messages to their associated GC. SWT images, and device objects such as the Display device and the Printer device, are drawables. IMPORTANT: This interface is not part of the SWT public API. It is marked public only so that it can be shared within the packages provided by SWT. It should never be referenced from application code. See Also: Device, Image, GC extends AbstractHyperlink Hyperlink is a concrete implementation of the abstract base class that draws text in the client area. Text can be wrapped and underlined. Hyperlink is typically added to the hyperlink group so that certain properties are managed for all the hyperlinks that belong to it. Hyperlink can be extended. Styles: SWT.WRAP Since: 3.0 See Also: HyperlinkGroup '
890, 'org.eclipse.ui.forms.events.HyperlinkEvent', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/forms/events/HyperlinkEvent.html', 'extends TypedEvent Notifies listeners about a hyperlink change. Since: 3.0 See Also: Serialized Form '
891, 'org.eclipse.ui.forms.events.IExpansionListener', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/forms/events/IExpansionListener.html', 'Classes that implement this interface will be notified before and after the expandable control\'s expansion state changes. Since: 3.0 '
892, 'org.eclipse.ui.forms.events.ExpansionEvent', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/forms/events/ExpansionEvent.html', 'extends TypedEvent Notifies listeners when expandable controls change expansion state. Since: 3.0 See Also: Serialized Form '
893, 'org.eclipse.ui.forms.widgets.ExpandableComposite', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/forms/widgets/ExpandableComposite.html', 'Implementers of Drawable can have a graphics context (GC) created for them, and then they can be drawn on by sending messages to their associated GC. SWT images, and device objects such as the Display device and the Printer device, are drawables. IMPORTANT: This interface is not part of the SWT public API. It is marked public only so that it can be shared within the packages provided by SWT. It should never be referenced from application code. See Also: Device, Image, GC extends Canvas This composite is capable of expanding or collapsing a single client that is its direct child. The composite renders an expansion toggle affordance (according to the chosen style), and a title that also acts as a hyperlink (can be selected and is traversable). The client is layed out below the title when expanded, or hidden when collapsed. The widget can be instantiated as-is, or subclassed to modify some aspects of it. * Since 3.1, left/right arrow keys can be used to control the expansion state. If several expandable composites are created in the same parent, up/down arrow keys can be used to traverse between them. Expandable text accepts mnemonics and mnemonic activation will toggle the expansion state. While expandable composite recognize that different styles can be used to render the title bar, and even defines the constants for these styles (TITLE_BAR and SHORT_TITLE_BAR the actual painting is done in the subclasses. Since: 3.0 See Also: Section '
894, 'org.eclipse.jface.viewers.ILazyTreePathContentProvider', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/viewers/ILazyTreePathContentProvider.html', 'A content provider mediates between the viewer\'s model and the viewer itself. See Also: ContentViewer.setContentProvider(IContentProvider) extends IContentProvider The ILazyTreePathContentProvider is a tree path-based content provider for tree viewers created using the SWT.VIRTUAL flag that only wish to return their contents as they are queried. Since: 3.3 '
895, 'org.eclipse.ui.contexts.IContextActivation', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/contexts/IContextActivation.html', 'extends org.eclipse.ui.internal.services.IEvaluationResultCache A token representing the activation of a context. This token can later be used to cancel that activation. Without this token, then context will only become inactive if the component in which the context was activated is destroyed. This interface is not intended to be implemented or extended by clients. Since: 3.1 See Also: ISources, ISourceProvider '
896, 'org.eclipse.ui.browser.AbstractWebBrowser', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/browser/AbstractWebBrowser.html', 'An opened Web browser instance (either internal or external). This interface is not intended to be implemented by clients. Since: 3.1 See Also: IWorkbenchBrowserSupport Restriction: This interface is not intended to be implemented by clients. extends Object implements IWebBrowser Clients that supply implementation of the workbench browser support should extend this class for web browser instances they manage. Clients should not implement the IWebBrowser interface. Since: 3.1 '
897, 'org.eclipse.ui.browser.AbstractWorkbenchBrowserSupport', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/browser/AbstractWorkbenchBrowserSupport.html', 'Web browser support. This class allows you to open URLs using internal or external Web browsers. Implementers may provide varying levels of support. The most rudimentary support that must be provided is to open URLs in an external web browser window. Everything else is a hint that browser support implementation may choose to honor but is not required (although a good implementation should aspire to support all the styles if possible on the given platform). The support has a two-phase approach to opening URLs. A browser instance is created first, then openURL is called on it. This provides for browser instance reuse for as long as needed. The step of creating the browser instance encourages reuse itself by not creating new instances of browsers if one with the same id is already open. It also makes it possible to reuse browser instances restored after workbench is restarted. The simplest way to open a URL is: IWorkbenchSupport.createBrowser(\"myId\").openURL(url); The call above will show the provided URL by reusing the browser instance with the matching id, or creating a new one if one does not exist already. When more advanced control over the behavior of a browser instance is required, it is recommended to create the instance first, then reuse it as needed. This interface is not intended to be implemented by clients. Since: 3.1 See Also: IWebBrowser Restriction: This interface is not intended to be implemented by clients. Restriction: This interface is not intended to be extended by clients. extends Object implements IWorkbenchBrowserSupport Implements IWorkbenchBrowserSupport while leaving some methods to the implementors. Classes that extend this abstract class are meant to be contributed via \'org.eclipse.ui.browserSupport\' extension point. Since: 3.1 '
898, 'org.eclipse.e4.ui.model.application.ui.menu.MRenderedToolBar', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/e4/ui/model/application/ui/menu/MRenderedToolBar.html', ' A representation of the model object \'Element\'. This is the root element for all UI Model elements, defining attribtues common to every element; the element\'s id as well as three general storage elements: Tags: This is a set of strings which can be used to stereotype a particular element. Tags may be specified in element searches and can also be referred to in the CSS styling definition. PersistedState: A string to string map used to store information that nneds to be persisted between sessions. TransientData: A string to object map which can be used to store runtime data relevant to a particular model element. Since: 1.0 The following features are supported: Element Id Persisted State Tags Contributor URI Transient Data A representation of the model object \'Element\'. This is the root element for all UI Model elements, defining attribtues common to every element; the element\'s id as well as three general storage elements: Tags: This is a set of strings which can be used to stereotype a particular element. Tags may be specified in element searches and can also be referred to in the CSS styling definition. PersistedState: A string to string map used to store information that nneds to be persisted between sessions. TransientData: A string to object map which can be used to store runtime data relevant to a particular model element. Since: 1.0 The following features are supported: Element Id Persisted State Tags Contributor URI Transient Data extends MUIElement A representation of the model object \'Trim Element\'. A class to be mixed in to any element that should be allowed to be added to a TrimBar. Since: 1.0 extends MApplicationElement A representation of the model object \'UI Element\'. This is the base mix-in shared by all model elements that can be rendered into the UI presentation of the application. Its main job is to manage the bindings between the concrete element and the UI \'widget\' representing it in the UI. Since: 1.0 The following features are supported: Widget Renderer To Be Rendered On Top Visible Parent Container Data Cur Shared Ref Visible When Accessibility Phrase extends MElementContainer<MToolBarElement>, MTrimElement A representation of the model object \'Tool Bar\'. This is the concrete class representing a Toolbar in the UI Model. Since: 1.0 A representation of the model object \'Element\'. This is the root element for all UI Model elements, defining attribtues common to every element; the element\'s id as well as three general storage elements: Tags: This is a set of strings which can be used to stereotype a particular element. Tags may be specified in element searches and can also be referred to in the CSS styling definition. PersistedState: A string to string map used to store information that nneds to be persisted between sessions. TransientData: A string to object map which can be used to store runtime data relevant to a particular model element. Since: 1.0 The following features are supported: Element Id Persisted State Tags Contributor URI Transient Data A representation of the model object \'Element\'. This is the root element for all UI Model elements, defining attribtues common to every element; the element\'s id as well as three general storage elements: Tags: This is a set of strings which can be used to stereotype a particular element. Tags may be specified in element searches and can also be referred to in the CSS styling definition. PersistedState: A string to string map used to store information that nneds to be persisted between sessions. TransientData: A string to object map which can be used to store runtime data relevant to a particular model element. Since: 1.0 The following features are supported: Element Id Persisted State Tags Contributor URI Transient Data extends MApplicationElement A representation of the model object \'UI Element\'. This is the base mix-in shared by all model elements that can be rendered into the UI presentation of the application. Its main job is to manage the bindings between the concrete element and the UI \'widget\' representing it in the UI. Since: 1.0 The following features are supported: Widget Renderer To Be Rendered On Top Visible Parent Container Data Cur Shared Ref Visible When Accessibility Phrase extends MUIElement A representation of the model object \'Trim Element\'. A class to be mixed in to any element that should be allowed to be added to a TrimBar. Since: 1.0 extends MToolBar A representation of the model object \'Rendered Tool Bar\'. Do no use! This class will be removed at the beginning of Luna (4.4) development. Since: 1.0 The following features are supported: Contribution Manager Restriction: '
899, 'org.eclipse.swt.custom.VerifyKeyListener', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/custom/VerifyKeyListener.html', 'extends org.eclipse.swt.internal.SWTEventListener Classes which implement this interface provide a method that deals with the event that is generated when a key is pressed. See Also: VerifyEvent, Sample code and further information '
900, 'org.eclipse.swt.events.VerifyEvent', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/events/VerifyEvent.html', 'extends KeyEvent Instances of this class are sent as a result of widgets handling keyboard events See Also: VerifyListener, Sample code and further information, Serialized Form '
901, 'org.eclipse.ui.part.ISetSelectionTarget', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/part/ISetSelectionTarget.html', 'Interface for views which support reveal and select. This interface may be implemented by subclasses of ViewPart. This interface is commonly used by a New wizard to reveal and select a resource in a workbench part which it has just created. See Also: IViewPart, ViewPart '
902, 'org.eclipse.swt.dnd.FileTransfer', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/dnd/FileTransfer.html', 'provides a platform specific mechanism for converting a list of files represented as a java String[] to a platform specific representation of the data and vice versa. Each String in the array contains the absolute path for a single file or directory. An example of a java String[] containing a list of files is shown below: File file1 = new File(\"C:\\temp\\file1\"); File file2 = new File(\"C:\\temp\\file2\"); String[] fileData = new String[2]; fileData[0] = file1.getAbsolutePath(); fileData[1] = file2.getAbsolutePath(); See Also: Transfer '
903, 'org.eclipse.core.databinding.ValidationStatusProvider', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/databinding/ValidationStatusProvider.html', 'extends Object A validation status provider tracks the state of zero or more target observables and zero or more model observables and produces a validation result. Since: 1.1 '
904, 'org.eclipse.core.databinding.observable.value.IObservableValue', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/databinding/observable/value/IObservableValue.html', 'An object with state that allows to listen for state changes. Implementations must not manage listeners themselves, listener management must be delegated to a private instance of type ChangeSupport if it is not inherited from AbstractObservable. Since: 1.0 Restriction: This interface is not intended to be implemented by clients. Clients should instead subclass one of the classes in the framework that implement this interface. Note that direct implementers of this interface outside of the framework will be broken in future releases when methods are added to this interface. extends IObservable A value whose changes can be tracked by value change listeners. Since: 1.0 See Also: AbstractObservableValue Restriction: This interface is not intended to be implemented by clients. Clients should instead subclass one of the classes that implement this interface. Note that direct implementers of this interface outside of the framework will be broken in future releases when methods are added to this interface. '
905, 'org.eclipse.core.databinding.observable.list.IListChangeListener', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/databinding/observable/list/IListChangeListener.html', 'extends IObservablesListener Listener for changes to observable lists. Since: 1.0 '
906, 'org.eclipse.core.databinding.observable.Observables', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/databinding/observable/Observables.html', 'extends Object Contains static methods to operate on or return Observables. Since: 1.0 '
907, 'org.eclipse.core.databinding.validation.ValidationStatus', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/databinding/validation/ValidationStatus.html', 'A status object represents the outcome of an operation. All CoreExceptions carry a status object to indicate what went wrong. Status objects are also returned by methods needing to provide details of failures (e.g., validation methods). A status carries the following information: plug-in identifier (required) severity (required) status code (required) message (required) - localized to current locale exception (optional) - for problems stemming from a failure at a lower level Some status objects, known as multi-statuses, have other status objects as children. The class Status is the standard public implementation of status objects; the subclass MultiStatus is the implements multi-status objects. This interface can be used without OSGi running. See Also: MultiStatus, Status extends Status Convenience class for creating status objects. Since: 3.3 '
908, 'org.eclipse.core.databinding.observable.set.IObservableSet', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/databinding/observable/set/IObservableSet.html', 'An object with state that allows to listen for state changes. Implementations must not manage listeners themselves, listener management must be delegated to a private instance of type ChangeSupport if it is not inherited from AbstractObservable. Since: 1.0 Restriction: This interface is not intended to be implemented by clients. Clients should instead subclass one of the classes in the framework that implement this interface. Note that direct implementers of this interface outside of the framework will be broken in future releases when methods are added to this interface. extends IObservable, Collection Interface for observable collections. Only general change listeners can be added to an observable collection. Listeners interested in incremental changes have to be added using more concrete subtypes such as IObservableList or IObservableSet. Since: 1.0 Restriction: This interface is not intended to be implemented by clients. Clients should instead subclass one of the classes that implement this interface. Note that direct implementers of this interface outside of the framework will be broken in future releases when methods are added to this interface. Restriction: This interface is not intended to be extended by clients. extends Set, IObservableCollection A set whose changes can be tracked by set change listeners. Since: 1.0 See Also: AbstractObservableSet, ObservableSet Restriction: This interface is not intended to be implemented by clients. Clients should instead subclass one of the classes that implement this interface. Note that direct implementers of this interface outside of the framework will be broken in future releases when methods are added to this interface. '
909, 'org.eclipse.core.databinding.property.list.IListProperty', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/databinding/property/list/IListProperty.html', 'extends IProperty Interface for list-typed properties. Since: 1.2 See Also: ListProperty, SimpleListProperty Restriction: This interface is not intended to be implemented by clients. Clients should instead subclass one of the classes that implement this interface. Note that direct implementers of this interface outside of the framework will be broken in future releases when methods are added to this interface. '
910, 'org.eclipse.core.databinding.property.value.IValueProperty', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/databinding/property/value/IValueProperty.html', 'extends IProperty Interface for value-typed properties Since: 1.2 See Also: ValueProperty, SimpleValueProperty Restriction: This interface is not intended to be implemented by clients. Clients should instead subclass one of the classes that implement this interface. Note that direct implementers of this interface outside of the framework will be broken in future releases when methods are added to this interface. '
911, 'org.eclipse.core.databinding.conversion.IConverter', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/databinding/conversion/IConverter.html', 'A one-way converter. Since: 1.0 Restriction: This interface is not intended to be implemented by clients. Clients should subclass Converter. Restriction: This interface is not intended to be extended by clients. '
912, 'org.eclipse.ui.navigator.INavigatorSorterService', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/navigator/INavigatorSorterService.html', 'Provides an interface to extensions declared in org.eclipse.ui.navigator.navigatorContent/commonSorter. Like other extensions to the Common Navigator framework, sorters defined by the above extension point must be bound to the associated INavigatorContentService through a org.eclipse.ui.navigator.viewer/viewerContentBinding extension. Since: 3.2 See Also: INavigatorContentService.getSorterService(), ViewerSorter Restriction: This interface is not intended to be implemented by clients. Restriction: This interface is not intended to be extended by clients. '
913, 'org.eclipse.ui.navigator.INavigatorContentService', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/navigator/INavigatorContentService.html', 'Manages content extensions for extensible viewers and provides reusable services for filters, sorting, the activation of content extensions, and DND. The service can locate the appropriate providers (for contents or labels) for an element and provide a ready-to-go ITreeContentProvider and ILabelProvider for viewers that wish to take advantage of the org.eclipse.ui.navigator.navigatorContent extensions defined for a particular viewerId. Clients can get the instance of this associated with the CommonNavigator using CommonNavigator.getNavigatorContentService(). Clients may contribute logical extensions using org.eclipse.ui.navigator.navigatorContent. Each extension has three states which determine whether the extension is used by the content service: visible: If a content extension id matches a viewerContentBinding for the viewerId of this content service, then the extension is visible. Visible extensions may only be configured through viewerContentBindings. active: The active state may be set to a default using the activeByDefault attribute of navigatorContent. Users may toggle the active state through the \"Available customizations\" dialog. Clients may also configure the active extensions using INavigatorActivationService.activateExtensions(String[], boolean) or INavigatorActivationService.deactivateExtensions(String[], boolean) from the Activation Service enabled: An extension is enabled for an element if the extension contributed that element or if the element is described in the triggerPoints element of the navigatorContent extension. The findXXX() methods search for enabled extensions. A new instance of the content service should be created for each viewer. Clients should use createCommonContentProvider() and createCommonLabelProvider() for the viewer. Each content service tracks the viewer it is attached to. Clients may create the content service with a viewer using (NavigatorContentServiceFactory.createContentService(String)). Alternatively, when the content provider is created and set on a viewer, IContentProvider.inputChanged(org.eclipse.jface.viewers.Viewer, Object, Object) will be called and the content provider will update the viewer used by its backing content service. Therefore, only each content service has exactly one content provider and one label provider. Extensions may also coordinate their behavior through a state model. The state model holds properties and supports property change listeners. Actions can toggle the setting of properties and the corresponding content/label providers will respond to property change event. Each navigatorContent extension has its own contained state model keyed off of the content extension id. Clients may respond when content extensions are loaded by attaching a INavigatorContentServiceListener to the content service. Some extensions may provide content or label providers which implement IMemento. Clients must call restoreState(IMemento) and saveState(IMemento) at the appropriate times for these extensions to prepare themselves with the memento. Since: 3.2 Restriction: This interface is not intended to be implemented by clients. Restriction: This interface is not intended to be extended by clients. '
914, 'org.eclipse.ui.navigator.INavigatorContentDescriptor', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/navigator/INavigatorContentDescriptor.html', 'The descriptor provides a the low-level handle to a content extension. Information such as the Id, the name, the priority, and whether the descriptor provides one or more root elements is provided. This descriptor is used to form the INavigatorContentExtension. There is a one-to-many correspondence between the INavigatorContentDescriptor and INavigatorContentExtension. An instance of the INavigatorContentExtension is created for each INavigatorContentDescriptor used by a INavigatorContentService. Since: 3.2 Restriction: This interface is not intended to be implemented by clients. Restriction: This interface is not intended to be extended by clients. '
915, 'org.eclipse.ui.navigator.INavigatorSaveablesService', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/navigator/INavigatorSaveablesService.html', ' Since: 3.2 Restriction: This interface is not intended to be implemented by clients. Restriction: This interface is not intended to be extended by clients. '
916, 'org.eclipse.ui.navigator.SaveablesProvider', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/navigator/SaveablesProvider.html', ' The interface that should be implemented by services that make themselves available through the IAdaptable mechanism. This is the interface that drives the majority of services provided at the workbench level. A service has life-cycle. When the constructor completes, the service must be fully functional. When it comes time for the service to go away, then the service will receive a dispose() call. At this point, the service must release all resources and detach all listeners. A service can only be disposed once; it cannot be reused. This interface has nothing to do with OSGi services. This interface can be extended or implemented by clients. Since: 3.2 extends Object implements IDisposable Provides Saveable objects to the common navigator, and allows to map between elements in the tree and models. This class is intended to be subclassed by clients. Instances of subclasses will be returned from content extensions that implement IAdaptable. Since: 3.2 '
917, 'org.eclipse.ui.SaveablesLifecycleEvent', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/SaveablesLifecycleEvent.html', 'extends EventObject Event object describing a change to a set of Saveable objects. Since: 3.2 See Also: Serialized Form '
918, 'org.eclipse.ui.navigator.IDescriptionProvider', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/navigator/IDescriptionProvider.html', 'Label providers (as specified by the labelProvider attribute of the org.eclipse.ui.navigator.navigatorContent extension point) may choose to also implement this interface in order to provide text for the status bar at the bottom of the Eclipse window. Since: 3.2 '
919, 'org.eclipse.ui.navigator.ICommonLabelProvider', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/navigator/ICommonLabelProvider.html', 'A label provider maps an element of the viewer\'s model to an optional image and optional text string used to display the element in the viewer\'s control. Certain label providers may allow multiple labels per element. This is an \"abstract interface\", defining methods common to all label providers, but does not actually define the methods to get the label(s) for an element. This interface should never be directly implemented. Most viewers will take either an ILabelProvider or an ITableLabelProvider. A label provider must not be shared between viewers since a label provider generally manages SWT resources (images), which must be disposed when the viewer is disposed. To simplify life cycle management, the current label provider of a viewer is disposed when the viewer is disposed. Label providers can be used outside the context of viewers wherever images are needed. When label providers are used in this fashion it is the responsibility of the user to ensure dispose is called when the provider is no longer needed. See Also: ILabelProvider, ITableLabelProvider Label providers (as specified by the labelProvider attribute of the org.eclipse.ui.navigator.navigatorContent extension point) may choose to also implement this interface in order to provide text for the status bar at the bottom of the Eclipse window. Since: 3.2 A label provider maps an element of the viewer\'s model to an optional image and optional text string used to display the element in the viewer\'s control. Certain label providers may allow multiple labels per element. This is an \"abstract interface\", defining methods common to all label providers, but does not actually define the methods to get the label(s) for an element. This interface should never be directly implemented. Most viewers will take either an ILabelProvider or an ITableLabelProvider. A label provider must not be shared between viewers since a label provider generally manages SWT resources (images), which must be disposed when the viewer is disposed. To simplify life cycle management, the current label provider of a viewer is disposed when the viewer is disposed. Label providers can be used outside the context of viewers wherever images are needed. When label providers are used in this fashion it is the responsibility of the user to ensure dispose is called when the provider is no longer needed. See Also: ILabelProvider, ITableLabelProvider extends IBaseLabelProvider Extends IBaseLabelProvider with the methods to provide the text and/or image for the label of a given element. Used by most structured viewers, except table viewers. Clients may use mementos to persist interesting state between sessions. Clients should ensure that the memento keys are unique; generally by using the id of the content extension as a prefix. Since: 3.2 extends ILabelProvider, IMementoAware, IDescriptionProvider Allows extensions to vary their behavior based on properties in the extension model and the given memento. Clients should refer to the org.eclipse.ui.navigator.navigatorContent extension point for more information on building a content extension. Clients should not dispose of any Image Resources that might be shared by other extensions when their Label Provider is disposed. When a content extension is deactivated, both its content and label providers are disposed, but the viewer remains visible to the user. If clients dispose of Image Resources used by other extensions, then it will cause problems for those extensions and the viewer in general. Clients may implement this interface if they require the methods provided here. ILabelProvider is respected by the Common Navigator. Since: 3.2 '
920, 'org.eclipse.core.commands.ICommandListener', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/commands/ICommandListener.html', 'An instance of this interface can be used by clients to receive notification of changes to one or more instances of Command. This interface may be implemented by clients. Since: 3.1 See Also: Command.addCommandListener(ICommandListener), Command.removeCommandListener(ICommandListener) '
921, 'org.eclipse.core.commands.IExecutionListener', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/commands/IExecutionListener.html', ' A listener to the execution of commands. This listener will be notified if a command is about to execute, and when that execution completes. It is not possible for the listener to prevent the execution, only to respond to it in some way. Since: 3.1 '
922, 'org.eclipse.core.commands.IObjectWithState', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/commands/IObjectWithState.html', ' An object that holds zero or more state objects. This state information can be shared between different instances of IObjectWithState. Clients may implement, but must not extend this interface. Since: 3.2 See Also: AbstractHandlerWithState '
923, 'org.eclipse.core.commands.CommandEvent', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/commands/CommandEvent.html', 'extends AbstractNamedHandleEvent An instance of this class describes changes to an instance of Command. This class is not intended to be extended by clients. Since: 3.1 See Also: ICommandListener.commandChanged(CommandEvent) '
924, 'org.eclipse.core.commands.IExecutionListenerWithChecks', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/commands/IExecutionListenerWithChecks.html', ' A listener to the execution of commands. This listener will be notified if a command is about to execute, and when that execution completes. It is not possible for the listener to prevent the execution, only to respond to it in some way. Since: 3.1 extends IExecutionListener A listener to the execution of commands. This listener will be notified if someone tries to execute a command and it is not enabled or not defined. The listener also be notified if a command is about to execute, and when that execution completes. It is not possible for the listener to prevent the execution, only to respond to it in some way. Clients may implement, but must not extend. Since: 3.2 '
925, 'org.eclipse.core.commands.ITypedParameter', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/commands/ITypedParameter.html', 'A command parameter that has a declared type. This interface is intended to be implemented by implementors of IParameter that will support parameter types. Since: 3.2 '
926, 'org.eclipse.core.commands.IHandler2', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/commands/IHandler2.html', 'A handler is the pluggable piece of a command that handles execution. Each command can have zero or more handlers associated with it (in general), of which only one will be active at any given moment in time. When the command is asked to execute, it will simply pass that request on to its active handler, if any. Since: 3.1 See Also: AbstractHandler extends IHandler Extend the IHandler interface to provide some context for isEnabled() requests. Clients should use AbstractHandler unless they need to provide their own listener mechanism. Since: 3.4 See Also: AbstractHandler '
927, 'org.eclipse.core.commands.contexts.IContextListener', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/commands/contexts/IContextListener.html', 'An instance of this interface can be used by clients to receive notification of changes to one or more instances of IContext. This interface may be implemented by clients. Since: 3.1 See Also: Context.addContextListener(IContextListener), Context.removeContextListener(IContextListener) '
928, 'org.eclipse.core.commands.contexts.ContextEvent', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/commands/contexts/ContextEvent.html', 'extends AbstractNamedHandleEvent An instance of this class describes changes to an instance of IContext. This class is not intended to be extended by clients. Since: 3.1 See Also: IContextListener.contextChanged(ContextEvent) '
929, 'org.eclipse.core.commands.common.HandleObjectManager', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/commands/common/HandleObjectManager.html', 'extends EventManager A manager of HandleObject instances. This has some common behaviour which is shared between all such managers. Clients may extend. Since: 3.2 '
930, 'org.eclipse.core.commands.ICategoryListener', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/commands/ICategoryListener.html', 'An instance of this interface can be used by clients to receive notification of changes to one or more instances of Category. This interface may be implemented by clients. Since: 3.1 See Also: Category.addCategoryListener(ICategoryListener), Category.removeCategoryListener(ICategoryListener) '
931, 'org.eclipse.core.commands.IParameterTypeListener', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/commands/IParameterTypeListener.html', 'An instance of this interface can be used by clients to receive notification of changes to one or more instances of ParameterType. This interface may be implemented by clients. Since: 3.2 See Also: ParameterType.addListener(IParameterTypeListener), ParameterType.removeListener(IParameterTypeListener) '
932, 'org.eclipse.core.commands.ICommandManagerListener', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/commands/ICommandManagerListener.html', 'An instance of this interface can be used by clients to receive notification of changes to one or more instances of ICommandManager. This interface may be implemented by clients. Since: 3.1 See Also: CommandManager.addCommandManagerListener(ICommandManagerListener), CommandManager.removeCommandManagerListener(ICommandManagerListener) '
933, 'org.eclipse.core.commands.CommandManagerEvent', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/commands/CommandManagerEvent.html', 'extends Object An event indicating that the set of defined command identifiers has changed. Since: 3.1 See Also: ICommandManagerListener.commandManagerChanged(CommandManagerEvent) '
934, 'org.eclipse.core.commands.CategoryEvent', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/commands/CategoryEvent.html', 'extends AbstractNamedHandleEvent An instance of this class describes changes to an instance of Category. This class is not intended to be extended by clients. Since: 3.1 See Also: ICategoryListener.categoryChanged(CategoryEvent) '
935, 'org.eclipse.core.commands.Parameterization', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/commands/Parameterization.html', 'extends Object A parameter with a specific value. This is usually a part of a ParameterizedCommand, which is used to refer to a command with a collection of parameterizations. Since: 3.1 '
936, 'org.eclipse.core.commands.ParameterTypeEvent', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/commands/ParameterTypeEvent.html', 'extends AbstractHandleObjectEvent An instance of this class describes changes to an instance of ParameterType. This class is not intended to be extended by clients. Since: 3.2 See Also: IParameterTypeListener.parameterTypeChanged(ParameterTypeEvent) '
937, 'org.eclipse.core.commands.IParameterValues', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/commands/IParameterValues.html', ' The parameters for a command. This interface will only be consulted if the parameters need to be displayed to the user. Otherwise, they will be ignored. Since: 3.1 '
938, 'org.eclipse.core.runtime.preferences.IScopeContext', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/runtime/preferences/IScopeContext.html', 'Clients implement this interface to provide context to a particular scope. Instances of implementations of this interface are passed to the IPreferencesService for use in preference searching. Clients may implement this interface. Since: 3.0 See Also: IPreferencesService '
939, 'org.eclipse.jface.databinding.swt.ISWTObservableValue', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/databinding/swt/ISWTObservableValue.html', 'An object with state that allows to listen for state changes. Implementations must not manage listeners themselves, listener management must be delegated to a private instance of type ChangeSupport if it is not inherited from AbstractObservable. Since: 1.0 Restriction: This interface is not intended to be implemented by clients. Clients should instead subclass one of the classes in the framework that implement this interface. Note that direct implementers of this interface outside of the framework will be broken in future releases when methods are added to this interface. An object with state that allows to listen for state changes. Implementations must not manage listeners themselves, listener management must be delegated to a private instance of type ChangeSupport if it is not inherited from AbstractObservable. Since: 1.0 Restriction: This interface is not intended to be implemented by clients. Clients should instead subclass one of the classes in the framework that implement this interface. Note that direct implementers of this interface outside of the framework will be broken in future releases when methods are added to this interface. extends IObservable A value whose changes can be tracked by value change listeners. Since: 1.0 See Also: AbstractObservableValue Restriction: This interface is not intended to be implemented by clients. Clients should instead subclass one of the classes that implement this interface. Note that direct implementers of this interface outside of the framework will be broken in future releases when methods are added to this interface. extends IObservable IObservable observing an SWT widget. Since: 1.1 extends ISWTObservable, IObservableValue IObservableValue observing an SWT widget. Since: 1.1 '
940, 'org.eclipse.jface.databinding.swt.WidgetProperties', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/databinding/swt/WidgetProperties.html', 'extends Object A factory for creating properties of SWT widgets. Since: 1.3 '
941, 'org.eclipse.jface.databinding.swt.IWidgetValueProperty', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/databinding/swt/IWidgetValueProperty.html', 'extends IProperty Interface for value-typed properties Since: 1.2 See Also: ValueProperty, SimpleValueProperty Restriction: This interface is not intended to be implemented by clients. Clients should instead subclass one of the classes that implement this interface. Note that direct implementers of this interface outside of the framework will be broken in future releases when methods are added to this interface. extends IValueProperty IValueProperty for observing an SWT Widget Since: 1.3 Restriction: This interface is not intended to be implemented by clients. '
942, 'org.eclipse.jface.databinding.swt.IWidgetListProperty', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/databinding/swt/IWidgetListProperty.html', 'extends IProperty Interface for list-typed properties. Since: 1.2 See Also: ListProperty, SimpleListProperty Restriction: This interface is not intended to be implemented by clients. Clients should instead subclass one of the classes that implement this interface. Note that direct implementers of this interface outside of the framework will be broken in future releases when methods are added to this interface. extends IListProperty IListProperty for observing an SWT Widget Since: 1.3 Restriction: This interface is not intended to be implemented by clients. '
943, 'org.eclipse.jface.databinding.viewers.IViewerUpdater', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/databinding/viewers/IViewerUpdater.html', 'A strategy interface for updating the elements in a StructuredViewer. Many structured viewer classes have similar methods for adding and removing elements, few of which are defined in common ancestor classes. This interface serves as a universal adapter for updating the elements in a viewer Since: 1.3 See Also: ObservableListContentProvider.ObservableListContentProvider(IViewerUpdater), ObservableSetContentProvider.ObservableSetContentProvider(IViewerUpdater) '
944, 'org.eclipse.core.databinding.observable.masterdetail.IObservableFactory', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/databinding/observable/masterdetail/IObservableFactory.html', 'Generates an IObservable when passed a target instance. Since: 1.0 '
945, 'org.eclipse.jface.databinding.viewers.TreeStructureAdvisor', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/databinding/viewers/TreeStructureAdvisor.html', 'extends Object Instances of this class can be used to improve accuracy and performance of an ObservableListTreeContentProvider or an ObservableSetTreeContentProvider. This class is intended to be subclassed by clients. Since: 1.2 '
946, 'org.eclipse.swt.widgets.TrayItem', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/widgets/TrayItem.html', 'extends Item Instances of this class represent icons that can be placed on the system tray or task bar status area. Styles: (none) Events: DefaultSelection, MenuDetect, Selection IMPORTANT: This class is not intended to be subclassed. Since: 3.0 See Also: Tray, TrayItem snippets, Sample code and further information Restriction: This class is not intended to be subclassed by clients. '
947, 'org.eclipse.swt.widgets.Slider', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/widgets/Slider.html', 'Implementers of Drawable can have a graphics context (GC) created for them, and then they can be drawn on by sending messages to their associated GC. SWT images, and device objects such as the Display device and the Printer device, are drawables. IMPORTANT: This interface is not part of the SWT public API. It is marked public only so that it can be shared within the packages provided by SWT. It should never be referenced from application code. See Also: Device, Image, GC extends Control Instances of this class are selectable user interface objects that represent a range of positive, numeric values. At any given moment, a given slider will have a single \'selection\' that is considered to be its value, which is constrained to be within the range of values the slider represents (that is, between its minimum and maximum values). Typically, sliders will be made up of five areas: an arrow button for decrementing the value a page decrement area for decrementing the value by a larger amount a thumb for modifying the value by mouse dragging a page increment area for incrementing the value by a larger amount an arrow button for incrementing the value Based on their style, sliders are either HORIZONTAL (which have a left facing button for decrementing the value and a right facing button for incrementing it) or VERTICAL (which have an upward facing button for decrementing the value and a downward facing buttons for incrementing it). On some platforms, the size of the slider\'s thumb can be varied relative to the magnitude of the range of values it represents (that is, relative to the difference between its maximum and minimum values). Typically, this is used to indicate some proportional value such as the ratio of the visible area of a document to the total amount of space that it would take to display it. SWT supports setting the thumb size even if the underlying platform does not, but in this case the appearance of the slider will not change. Styles: HORIZONTAL, VERTICAL Events: Selection Note: Only one of the styles HORIZONTAL and VERTICAL may be specified. IMPORTANT: This class is not intended to be subclassed. See Also: ScrollBar, Slider snippets, SWT Example: ControlExample, Sample code and further information Restriction: This class is not intended to be subclassed by clients. '
948, 'org.eclipse.swt.widgets.Spinner', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/widgets/Spinner.html', 'Implementers of Drawable can have a graphics context (GC) created for them, and then they can be drawn on by sending messages to their associated GC. SWT images, and device objects such as the Display device and the Printer device, are drawables. IMPORTANT: This interface is not part of the SWT public API. It is marked public only so that it can be shared within the packages provided by SWT. It should never be referenced from application code. See Also: Device, Image, GC extends Composite Instances of this class are selectable user interface objects that allow the user to enter and modify numeric values. Note that although this class is a subclass of Composite, it does not make sense to add children to it, or set a layout on it. Styles: READ_ONLY, WRAP Events: Selection, Modify, Verify IMPORTANT: This class is not intended to be subclassed. Since: 3.1 See Also: Spinner snippets, SWT Example: ControlExample, Sample code and further information Restriction: This class is not intended to be subclassed by clients. '
949, 'org.eclipse.swt.widgets.ScrollBar', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/widgets/ScrollBar.html', 'extends Widget Instances of this class are selectable user interface objects that represent a range of positive, numeric values. At any given moment, a given scroll bar will have a single \'selection\' that is considered to be its value, which is constrained to be within the range of values the scroll bar represents (that is, between its minimum and maximum values). Typically, scroll bars will be made up of five areas: an arrow button for decrementing the value a page decrement area for decrementing the value by a larger amount a thumb for modifying the value by mouse dragging a page increment area for incrementing the value by a larger amount an arrow button for incrementing the value Based on their style, scroll bars are either HORIZONTAL (which have a left facing button for decrementing the value and a right facing button for incrementing it) or VERTICAL (which have an upward facing button for decrementing the value and a downward facing buttons for incrementing it). On some platforms, the size of the scroll bar\'s thumb can be varied relative to the magnitude of the range of values it represents (that is, relative to the difference between its maximum and minimum values). Typically, this is used to indicate some proportional value such as the ratio of the visible area of a document to the total amount of space that it would take to display it. SWT supports setting the thumb size even if the underlying platform does not, but in this case the appearance of the scroll bar will not change. Scroll bars are created by specifying either H_SCROLL, V_SCROLL or both when creating a Scrollable. They are accessed from the Scrollable using getHorizontalBar and getVerticalBar. Note: Scroll bars are not Controls. On some platforms, scroll bars that appear as part of some standard controls such as a text or list have no operating system resources and are not children of the control. For this reason, scroll bars are treated specially. To create a control that looks like a scroll bar but has operating system resources, use Slider. Styles: HORIZONTAL, VERTICAL Events: Selection Note: Only one of the styles HORIZONTAL and VERTICAL may be specified. IMPORTANT: This class is not intended to be subclassed. See Also: Slider, Scrollable, Scrollable.getHorizontalBar(), Scrollable.getVerticalBar(), SWT Example: ControlExample, Sample code and further information Restriction: This class is not intended to be subclassed by clients. '
950, 'org.eclipse.swt.widgets.DateTime', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/widgets/DateTime.html', 'Implementers of Drawable can have a graphics context (GC) created for them, and then they can be drawn on by sending messages to their associated GC. SWT images, and device objects such as the Display device and the Printer device, are drawables. IMPORTANT: This interface is not part of the SWT public API. It is marked public only so that it can be shared within the packages provided by SWT. It should never be referenced from application code. See Also: Device, Image, GC extends Composite Instances of this class are selectable user interface objects that allow the user to enter and modify date or time values. Note that although this class is a subclass of Composite, it does not make sense to add children to it, or set a layout on it. Styles: DATE, TIME, CALENDAR, SHORT, MEDIUM, LONG, DROP_DOWN Events: DefaultSelection, Selection Note: Only one of the styles DATE, TIME, or CALENDAR may be specified, and only one of the styles SHORT, MEDIUM, or LONG may be specified. The DROP_DOWN style is a HINT, and it is only valid with the DATE style. IMPORTANT: This class is not intended to be subclassed. Since: 3.3 See Also: DateTime snippets, SWT Example: ControlExample, Sample code and further information Restriction: This class is not intended to be subclassed by clients. '
951, 'org.eclipse.ui.navigator.ICommonContentProvider', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/navigator/ICommonContentProvider.html', 'A content provider mediates between the viewer\'s model and the viewer itself. See Also: ContentViewer.setContentProvider(IContentProvider) Clients may use mementos to persist interesting state between sessions. Clients should ensure that the memento keys are unique; generally by using the id of the content extension as a prefix. Since: 3.2 A content provider mediates between the viewer\'s model and the viewer itself. See Also: ContentViewer.setContentProvider(IContentProvider) extends IContentProvider An interface to content providers for structured viewers. See Also: StructuredViewer A content provider mediates between the viewer\'s model and the viewer itself. See Also: ContentViewer.setContentProvider(IContentProvider) extends IContentProvider An interface to content providers for structured viewers. See Also: StructuredViewer extends IStructuredContentProvider An interface to content providers for tree-structure-oriented viewers. See Also: AbstractTreeViewer extends ITreeContentProvider, IMementoAware Allows extensions to vary their behavior based on properties in the extension model and the given memento. The state model should be initialized from values in the memento if necessary. Clients should refer to the org.eclipse.ui.navigator.navigatorContent extension point for more information on building a content extension. Clients may implement this interface if they require the methods defined here. ITreeContentProvider is respected by the Common Navigator. Since: 3.2 '
952, 'org.eclipse.ui.navigator.IExtensionStateModel', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/navigator/IExtensionStateModel.html', 'Allows clients to coordinate state across components that are part of the same logical extension. That is, a content provider might vary how it exposes its content based on the state of a specific property in the model. Interested parties may add themselves as IPropertyChangeListeners to track changes in the state model. Since: 3.2 Restriction: This interface is not intended to be implemented by clients. Restriction: This interface is not intended to be extended by clients. '
953, 'org.eclipse.ui.navigator.CommonViewer', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/navigator/CommonViewer.html', 'Interface common to all objects that provide an input. Interface common to all objects that provide an input. Interface common to all objects that provide a selection. See Also: ISelection, ISelectionChangedListener, SelectionChangedEvent extends IInputProvider, ISelectionProvider Interface common to all objects that provide both an input and a selection. Interface common to all objects that provide a selection. See Also: ISelection, ISelectionChangedListener, SelectionChangedEvent extends ISelectionProvider Selection provider extension interface to allow providers to notify about post selection changed events. A post selection changed event is equivalent to selection changed event if the selection change was triggered by the mouse, but it has a delay if the selection change is triggered by keyboard navigation. Since: 3.0 See Also: ISelectionProvider Interface common to all objects that provide a selection. See Also: ISelection, ISelectionChangedListener, SelectionChangedEvent extends TreeViewer Provides the Tree Viewer for the Common Navigator. Content and labels are provided by an instance of INavigatorContentService which uses the ID supplied in the constructor CommonViewer(String, Composite, int) or through NavigatorContentServiceFactory.createContentService(String, org.eclipse.jface.viewers.StructuredViewer). Clients may extend this class. Note that as of 3.2.1 and 3.3, the common viewer caches its selection. Clients must not set the selection of the viewer\'s tree control directly. Since: 3.2 '
954, 'org.eclipse.ui.navigator.ICommonContentExtensionSite', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/navigator/ICommonContentExtensionSite.html', 'Provides initialization data for a content extension. Supplied in the init() methods of various interfaces allowed by the framework. Since: 3.2 See Also: ICommonLabelProvider, ICommonContentProvider Restriction: This interface is not intended to be implemented by clients. Restriction: This interface is not intended to be extended by clients. '
955, 'org.eclipse.ui.views.properties.tabbed.TabbedPropertySheetWidgetFactory', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/views/properties/tabbed/TabbedPropertySheetWidgetFactory.html', 'extends FormToolkit A FormToolkit customized for use by tabbed property sheet page. '
956, 'org.eclipse.ui.views.properties.tabbed.ITabItem', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/views/properties/tabbed/ITabItem.html', 'Represents a tab to be displayed in the tab list in the tabbed property sheet page. '
957, 'org.eclipse.ui.part.Page', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/part/Page.html', 'extends IPage Interface for a page in a pagebook view. Pages should implement this interface. See Also: PageBookView, Page extends Object implements IPageBookViewPage Abstract base superclass for pages in a pagebook view. This class should be subclassed by clients wishing to define new types of pages for multi-page views. Subclasses must implement the following methods: createControl - to create the page\'s control getControl - to retrieve the page\'s control Subclasses may extend or reimplement the following methods as required: dispose - extend to provide additional cleanup setFocus - reimplement to accept focus setActionBars - reimplement to make contributions makeContributions - this method exists to support previous versions setActionBars - this method exists to support previous versions init - extend to provide additional setup See Also: PageBookView '
958, 'org.eclipse.ui.views.properties.IPropertySheetPage', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/views/properties/IPropertySheetPage.html', 'extends EventListener Interface for listening to selection changes. This interface may be implemented by clients. See Also: ISelectionService.addSelectionListener(ISelectionListener), ISelectionService.addSelectionListener(String, ISelectionListener), INullSelectionListener extends IPage, ISelectionListener Interface for a property sheet page that appears in a property sheet view. This interface defines the minimum requirement for pages within the property sheet view, namely they must be pages (implement IPage) be prepared to contribute actions to the property sheet view\'s tool bar and status line, and listen for selection changes in the active part. Clients may implement this interface from scratch if the property sheet viewer\'s default page is unsuitable for displaying a part\'s properties. See Also: PropertySheetPage '
959, 'org.eclipse.ui.views.properties.tabbed.ITabbedPropertySheetPageContributor', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/views/properties/tabbed/ITabbedPropertySheetPageContributor.html', 'Interface for a workbench part to contribute content to the tabbed property view. It is expected that the contributor ID is unique for a configuration of tabs and sections. Editors and views can share a configuration by sharing a contributor ID. Editors and views cannot share tabs and sections from multiple contributors. As a workaround, if all the elements in a structured selection implement ITabbedPropertySheetPageContributor and they all return the same unique contributor ID, then that configuration of tabs and sections will be used by the tabbed property view for that selection. '
960, 'org.eclipse.ui.views.properties.tabbed.TabContents', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/views/properties/tabbed/TabContents.html', 'extends Object A property tab is composed by one or more property sections and is used to categorize sections. Since: 3.4 '
961, 'org.eclipse.ui.views.properties.PropertySheet', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/views/properties/PropertySheet.html', 'An interface for an adaptable object. Adaptable objects can be dynamically extended to provide different interfaces (or \"adapters\"). Adapters are created by adapter factories, which are in turn managed by type by adapter managers. For example, IAdaptable a = [some adaptable]; IFoo x = (IFoo)a.getAdapter(IFoo.class); if (x != null) [do IFoo things with x] This interface can be used without OSGi running. Clients may implement this interface, or obtain a default implementation of this interface by subclassing PlatformObject. See Also: IAdapterFactory, IAdapterManager, PlatformObject Interface for executable extension classes that require access to their configuration element, or implement an extension adapter. Extension adapters are typically required in cases where the extension implementation does not follow the interface rules specified by the provider of the extension point. In these cases, the role of the adapter is to map between the extension point interface, and the actual extension implementation. In general, adapters are used when attempting to plug-in existing Java implementations, or non-Java implementations (e.g., external executables). This interface can be used without OSGi running. Clients may implement this interface. See Also: IConfigurationElement.createExecutableExtension(String) extends EventListener A registry event listener is notified of changes to extension points. Changes include modifications of extension points and their extensions. Listeners will only receive a notification if the extension point they are registered for is modified. (Which includes modifications of extensions under the extension point.) This interface can be used without OSGi running. Clients may implement this interface. Since: 3.4 See Also: IExtensionRegistry.addListener(IRegistryEventListener, String) Interface for listening to part lifecycle events. This interface may be implemented by clients. See Also: IPartService.addPartListener(IPartListener) Objects implementing this interface are capable of saving their state in an IMemento. Since: 3.1 extends EventListener Interface for listening to selection changes. This interface may be implemented by clients. See Also: ISelectionService.addSelectionListener(ISelectionListener), ISelectionService.addSelectionListener(String, ISelectionListener), INullSelectionListener An interface for an adaptable object. Adaptable objects can be dynamically extended to provide different interfaces (or \"adapters\"). Adapters are created by adapter factories, which are in turn managed by type by adapter managers. For example, IAdaptable a = [some adaptable]; IFoo x = (IFoo)a.getAdapter(IFoo.class); if (x != null) [do IFoo things with x] This interface can be used without OSGi running. Clients may implement this interface, or obtain a default implementation of this interface by subclassing PlatformObject. See Also: IAdapterFactory, IAdapterManager, PlatformObject Objects implementing this interface are capable of saving their state in an IMemento. Since: 3.1 An interface for an adaptable object. Adaptable objects can be dynamically extended to provide different interfaces (or \"adapters\"). Adapters are created by adapter factories, which are in turn managed by type by adapter managers. For example, IAdaptable a = [some adaptable]; IFoo x = (IFoo)a.getAdapter(IFoo.class); if (x != null) [do IFoo things with x] This interface can be used without OSGi running. Clients may implement this interface, or obtain a default implementation of this interface by subclassing PlatformObject. See Also: IAdapterFactory, IAdapterManager, PlatformObject extends IAdaptable A workbench part is a visual component within a workbench page. There are two subtypes: view and editor, as defined by IViewPart and IEditorPart. A view is typically used to navigate a hierarchy of information (like the workspace), open an editor, or display properties for the active editor. Modifications made in a view are saved immediately. An editor is typically used to edit or browse a document or input object. The input is identified using an IEditorInput. Modifications made in an editor part follow an open-save-close lifecycle model. This interface may be implemented directly. For convenience, a base implementation is defined in WorkbenchPart. The lifecycle of a workbench part is as follows: When a part extension is created: instantiate the part create a part site call part.init(site) When a part becomes visible in the workbench: add part to presentation by calling part.createPartControl(parent) to create actual widgets fire partOpened event to all listeners When a part is activated or gets focus: call part.setFocus() fire partActivated event to all listeners When a part is closed: if save is needed, do save; if it fails or is canceled return if part is active, deactivate part fire partClosed event to all listeners remove part from presentation; part controls are disposed as part of the SWT widget tree call part.dispose() After createPartControl has been called, the implementor may safely reference the controls created. When the part is closed these controls will be disposed as part of an SWT composite. This occurs before the IWorkbenchPart.dispose method is called. If there is a need to free SWT resources the part should define a dispose listener for its own control and free those resources from the dispose listener. If the part invokes any method on the disposed SWT controls after this point an SWTError will be thrown. The last method called on IWorkbenchPart is dispose. This signals the end of the part lifecycle. An important point to note about this lifecycle is that following a call to init, createPartControl may never be called. Thus in the dispose method, implementors must not assume controls were created. Workbench parts implement the IAdaptable interface; extensions are managed by the platform\'s adapter manager. See Also: IViewPart, IEditorPart extends IWorkbenchPart, IPersistable A view is a visual component within a workbench page. It is typically used to navigate a hierarchy of information (like the workspace), open an editor, or display properties for the active editor. Modifications made in a view are saved immediately (in contrast to an editor part, which conforms to a more elaborate open-save-close lifecycle). Only one instance of a particular view type may exist within a workbench page. This policy is designed to simplify part management for a user. This interface may be implemented directly. For convenience, a base implementation is defined in ViewPart. A view is added to the workbench in two steps: A view extension is contributed to the workbench registry. This extension defines the extension id and extension class. The view is included in the default layout for a perspective. Alternatively, the user may open the view from the Perspective menu. Views implement the IAdaptable interface; extensions are managed by the platform\'s adapter manager. As of 3.4, views may optionally adapt to ISizeProvider if they have a preferred size. The default presentation will make a best effort to allocate the preferred size to a view if it is the only part in a stack. If there is more than one part in the stack, the constraints will be disabled for that stack. The size constraints are adjusted for the size of the tab and border trim. Note that this is considered to be a hint to the presentation, and not all presentations may honor size constraints. See Also: IWorkbenchPage.showView(java.lang.String), ViewPart, ISizeProvider An interface for an adaptable object. Adaptable objects can be dynamically extended to provide different interfaces (or \"adapters\"). Adapters are created by adapter factories, which are in turn managed by type by adapter managers. For example, IAdaptable a = [some adaptable]; IFoo x = (IFoo)a.getAdapter(IFoo.class); if (x != null) [do IFoo things with x] This interface can be used without OSGi running. Clients may implement this interface, or obtain a default implementation of this interface by subclassing PlatformObject. See Also: IAdapterFactory, IAdapterManager, PlatformObject extends IAdaptable A workbench part is a visual component within a workbench page. There are two subtypes: view and editor, as defined by IViewPart and IEditorPart. A view is typically used to navigate a hierarchy of information (like the workspace), open an editor, or display properties for the active editor. Modifications made in a view are saved immediately. An editor is typically used to edit or browse a document or input object. The input is identified using an IEditorInput. Modifications made in an editor part follow an open-save-close lifecycle model. This interface may be implemented directly. For convenience, a base implementation is defined in WorkbenchPart. The lifecycle of a workbench part is as follows: When a part extension is created: instantiate the part create a part site call part.init(site) When a part becomes visible in the workbench: add part to presentation by calling part.createPartControl(parent) to create actual widgets fire partOpened event to all listeners When a part is activated or gets focus: call part.setFocus() fire partActivated event to all listeners When a part is closed: if save is needed, do save; if it fails or is canceled return if part is active, deactivate part fire partClosed event to all listeners remove part from presentation; part controls are disposed as part of the SWT widget tree call part.dispose() After createPartControl has been called, the implementor may safely reference the controls created. When the part is closed these controls will be disposed as part of an SWT composite. This occurs before the IWorkbenchPart.dispose method is called. If there is a need to free SWT resources the part should define a dispose listener for its own control and free those resources from the dispose listener. If the part invokes any method on the disposed SWT controls after this point an SWTError will be thrown. The last method called on IWorkbenchPart is dispose. This signals the end of the part lifecycle. An important point to note about this lifecycle is that following a call to init, createPartControl may never be called. Thus in the dispose method, implementors must not assume controls were created. Workbench parts implement the IAdaptable interface; extensions are managed by the platform\'s adapter manager. See Also: IViewPart, IEditorPart An interface for an adaptable object. Adaptable objects can be dynamically extended to provide different interfaces (or \"adapters\"). Adapters are created by adapter factories, which are in turn managed by type by adapter managers. For example, IAdaptable a = [some adaptable]; IFoo x = (IFoo)a.getAdapter(IFoo.class); if (x != null) [do IFoo things with x] This interface can be used without OSGi running. Clients may implement this interface, or obtain a default implementation of this interface by subclassing PlatformObject. See Also: IAdapterFactory, IAdapterManager, PlatformObject An interface for an adaptable object. Adaptable objects can be dynamically extended to provide different interfaces (or \"adapters\"). Adapters are created by adapter factories, which are in turn managed by type by adapter managers. For example, IAdaptable a = [some adaptable]; IFoo x = (IFoo)a.getAdapter(IFoo.class); if (x != null) [do IFoo things with x] This interface can be used without OSGi running. Clients may implement this interface, or obtain a default implementation of this interface by subclassing PlatformObject. See Also: IAdapterFactory, IAdapterManager, PlatformObject extends IAdaptable A workbench part is a visual component within a workbench page. There are two subtypes: view and editor, as defined by IViewPart and IEditorPart. A view is typically used to navigate a hierarchy of information (like the workspace), open an editor, or display properties for the active editor. Modifications made in a view are saved immediately. An editor is typically used to edit or browse a document or input object. The input is identified using an IEditorInput. Modifications made in an editor part follow an open-save-close lifecycle model. This interface may be implemented directly. For convenience, a base implementation is defined in WorkbenchPart. The lifecycle of a workbench part is as follows: When a part extension is created: instantiate the part create a part site call part.init(site) When a part becomes visible in the workbench: add part to presentation by calling part.createPartControl(parent) to create actual widgets fire partOpened event to all listeners When a part is activated or gets focus: call part.setFocus() fire partActivated event to all listeners When a part is closed: if save is needed, do save; if it fails or is canceled return if part is active, deactivate part fire partClosed event to all listeners remove part from presentation; part controls are disposed as part of the SWT widget tree call part.dispose() After createPartControl has been called, the implementor may safely reference the controls created. When the part is closed these controls will be disposed as part of an SWT composite. This occurs before the IWorkbenchPart.dispose method is called. If there is a need to free SWT resources the part should define a dispose listener for its own control and free those resources from the dispose listener. If the part invokes any method on the disposed SWT controls after this point an SWTError will be thrown. The last method called on IWorkbenchPart is dispose. This signals the end of the part lifecycle. An important point to note about this lifecycle is that following a call to init, createPartControl may never be called. Thus in the dispose method, implementors must not assume controls were created. Workbench parts implement the IAdaptable interface; extensions are managed by the platform\'s adapter manager. See Also: IViewPart, IEditorPart extends IWorkbenchPart Extends IWorkbenchPart, adding the name and status text properties. Prior to 3.0, a view\'s title was often modified to show both the part name and extra status text. With this interface, the distinction is made more explicit. Since: 3.0 An interface for an adaptable object. Adaptable objects can be dynamically extended to provide different interfaces (or \"adapters\"). Adapters are created by adapter factories, which are in turn managed by type by adapter managers. For example, IAdaptable a = [some adaptable]; IFoo x = (IFoo)a.getAdapter(IFoo.class); if (x != null) [do IFoo things with x] This interface can be used without OSGi running. Clients may implement this interface, or obtain a default implementation of this interface by subclassing PlatformObject. See Also: IAdapterFactory, IAdapterManager, PlatformObject An interface for an adaptable object. Adaptable objects can be dynamically extended to provide different interfaces (or \"adapters\"). Adapters are created by adapter factories, which are in turn managed by type by adapter managers. For example, IAdaptable a = [some adaptable]; IFoo x = (IFoo)a.getAdapter(IFoo.class); if (x != null) [do IFoo things with x] This interface can be used without OSGi running. Clients may implement this interface, or obtain a default implementation of this interface by subclassing PlatformObject. See Also: IAdapterFactory, IAdapterManager, PlatformObject extends IAdaptable A workbench part is a visual component within a workbench page. There are two subtypes: view and editor, as defined by IViewPart and IEditorPart. A view is typically used to navigate a hierarchy of information (like the workspace), open an editor, or display properties for the active editor. Modifications made in a view are saved immediately. An editor is typically used to edit or browse a document or input object. The input is identified using an IEditorInput. Modifications made in an editor part follow an open-save-close lifecycle model. This interface may be implemented directly. For convenience, a base implementation is defined in WorkbenchPart. The lifecycle of a workbench part is as follows: When a part extension is created: instantiate the part create a part site call part.init(site) When a part becomes visible in the workbench: add part to presentation by calling part.createPartControl(parent) to create actual widgets fire partOpened event to all listeners When a part is activated or gets focus: call part.setFocus() fire partActivated event to all listeners When a part is closed: if save is needed, do save; if it fails or is canceled return if part is active, deactivate part fire partClosed event to all listeners remove part from presentation; part controls are disposed as part of the SWT widget tree call part.dispose() After createPartControl has been called, the implementor may safely reference the controls created. When the part is closed these controls will be disposed as part of an SWT composite. This occurs before the IWorkbenchPart.dispose method is called. If there is a need to free SWT resources the part should define a dispose listener for its own control and free those resources from the dispose listener. If the part invokes any method on the disposed SWT controls after this point an SWTError will be thrown. The last method called on IWorkbenchPart is dispose. This signals the end of the part lifecycle. An important point to note about this lifecycle is that following a call to init, createPartControl may never be called. Thus in the dispose method, implementors must not assume controls were created. Workbench parts implement the IAdaptable interface; extensions are managed by the platform\'s adapter manager. See Also: IViewPart, IEditorPart extends IWorkbenchPart Extends IWorkbenchPart, adding the name and status text properties. Prior to 3.0, a view\'s title was often modified to show both the part name and extra status text. With this interface, the distinction is made more explicit. Since: 3.0 extends IWorkbenchPart2 A part can provide arbitrary properties. The properties will be persisted between sessions by the part reference, and will be available from the part reference as well as the part. The properties can only be set on a part, not on the reference. The properties will be available to the IPresentablePart. Setting a property must fire a PropertyChangeEvent. Since: 3.3 Parts which need to provide a particular context to a Show In... target can provide this interface. The part can either directly implement this interface, or provide it via IAdaptable.getAdapter(IShowInSource.class). Since: 2.1 See Also: IShowInTarget This interface must be provided by Show In targets (parts listed in the Show In prompter). The part can either directly implement this interface, or provide it via IAdaptable.getAdapter(IShowInTarget.class). Since: 2.1 See Also: IPageLayout.addShowInPart(java.lang.String) The IWorkbenchPartOrientation is the interface that defines the orientation of the part. If a type does not implement this interface an orientation of SWT.NONE will be assumed. Since: 3.1 See Also: SWT.RIGHT_TO_LEFT, SWT.LEFT_TO_RIGHT, SWT.NONE, Window.getDefaultOrientation() extends PageBookView implements ISelectionListener, IShowInTarget, IShowInSource, IRegistryEventListener Main class for the Property Sheet View. This standard view has id \"org.eclipse.ui.views.PropertySheet\". Note that property sheets and property sheet pages are not the same thing as property dialogs and their property pages (the property pages extension point is for contributing property pages to property dialogs). Within the property sheet view, all pages are IPropertySheetPages. Property sheet pages are discovered by the property sheet view automatically when a part is first activated. The property sheet view asks the active part for its property sheet page; this is done by invoking getAdapter(IPropertySheetPage.class) on the part. If the part returns a page, the property sheet view then creates the controls for that property sheet page (using createControl), and adds the page to the property sheet view. Whenever this part becomes active, its corresponding property sheet page is shown in the property sheet view (which may or may not be visible at the time). A part\'s property sheet page is discarded when the part closes. The property sheet view has a default page (an instance of PropertySheetPage) which services all parts without a property sheet page of their own. The workbench will automatically instantiates this class when a Property Sheet view is needed for a workbench window. This class is not intended to be instantiated or subclassed by clients. See Also: IPropertySheetPage, PropertySheetPage Restriction: This class is not intended to be subclassed by clients. Restriction: This class is not intended to be instantiated by clients. '
962, 'org.eclipse.ui.part.IContributedContentsView', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/part/IContributedContentsView.html', 'This interface is used to identify workbench views which allow other parts (typically the active part) to supply their contents. The interface allows access to the part which contributed the current contents. '
963, 'org.eclipse.ui.views.properties.tabbed.ITabDescriptor', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/views/properties/tabbed/ITabDescriptor.html', 'Represents a tab to be displayed in the tab list in the tabbed property sheet page. extends ITabItem Represents a tab descriptor for the tabbed property view. This interface should not be extended or implemented. New instances should be created using AbstractTabDescriptor. Since: 3.4 '
964, 'org.eclipse.ui.views.properties.tabbed.ITabSelectionListener', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/views/properties/tabbed/ITabSelectionListener.html', 'A listener interested in tab selection events that occur for the tabbed property sheet page. '
965, 'org.eclipse.ui.views.properties.tabbed.IOverridableTabListContentProvider', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/views/properties/tabbed/IOverridableTabListContentProvider.html', 'A content provider mediates between the viewer\'s model and the viewer itself. See Also: ContentViewer.setContentProvider(IContentProvider) A content provider mediates between the viewer\'s model and the viewer itself. See Also: ContentViewer.setContentProvider(IContentProvider) extends IContentProvider An interface to content providers for structured viewers. See Also: StructuredViewer extends IStructuredContentProvider A content provider for the tabbed property sheet page\'s list of tabs. Used by a section that overrides the tabs that are provided by the tabbed property registry with a new list of tabs. The overridable tab list is a content provider that provides both the sections and the tab labels. Since: 3.4 '
966, 'org.eclipse.ui.views.properties.tabbed.IActionProvider', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/views/properties/tabbed/IActionProvider.html', 'Allows a tabbed properties view to make contributions to action bars. An action provider is called when the tabbed properties view becomes the active view. It is at this point where the action provider can override the action bars. Normally TabbedPropertySheetPage.setActionBars(IActionBars) is sufficient, but this is only called once and is not sufficient for a contributor that is selection based. An example is the Project Explorer where different providers contribute different action sets and properties configurations. The most frequent use of setActionBars() is to retarget the global actions for undo and redo based on the active tabbed properties view contributor. Since: 3.2.1 '
967, 'org.eclipse.jface.contexts.IContextIds', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/contexts/IContextIds.html', ' A list of well-known context identifiers. The context identifiers use the prefix \"org.eclipse.ui\" for historical reasons. These contexts exist as part of JFace. This interface should not be implemented or extended by clients. Since: 3.1 '
968, 'org.eclipse.jface.bindings.BindingManagerEvent', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/bindings/BindingManagerEvent.html', 'extends AbstractBitSetEvent An instance of this class describes changes to an instance of BindingManager. This class is not intended to be extended by clients. Since: 3.1 See Also: IBindingManagerListener.bindingManagerChanged(BindingManagerEvent) '
969, 'org.eclipse.core.commands.common.AbstractBitSetEvent', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/commands/common/AbstractBitSetEvent.html', 'extends Object An event that carries with it two or more boolean values. This provides a single integer value which can then be used as a bit set. Since: 3.1 '
970, 'org.eclipse.ui.forms.widgets.SizeCache', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/forms/widgets/SizeCache.html', 'extends Object Caches the preferred size of an SWT control Since: 3.0 '
971, 'org.eclipse.ui.testing.ITestHarness', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/testing/ITestHarness.html', 'Represents an arbitrary test harness. Since: 3.0 '
972, 'org.eclipse.core.databinding.util.Policy', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/databinding/util/Policy.html', 'extends Object The Policy class handles settings for behaviour, debug flags and logging within JFace Data Binding. Since: 1.1 '
973, 'org.eclipse.jface.action.ControlContribution', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/action/ControlContribution.html', 'A contribution item represents a contribution to a shared UI resource such as a menu or tool bar. More generally, contribution items are managed by a contribution manager. For instance, in a tool bar a contribution item is a tool bar button or a separator. In a menu bar a contribution item is a menu, and in a menu a contribution item is a menu item or separator. A contribution item can realize itself in different SWT widgets, using the different fill methods. The same type of contribution item can be used with a MenuBarManager, ToolBarManager, CoolBarManager, or a StatusLineManager. This interface is internal to the framework; it should not be implemented outside the framework. See Also: IContributionManager Restriction: This interface is not intended to be implemented by clients. extends ContributionItem An abstract contribution item implementation for adding an arbitrary SWT control to a tool bar. Note, however, that these items cannot be contributed to menu bars. The createControl framework method must be implemented by concrete subclasses. '
974, 'org.eclipse.jface.layout.RowLayoutFactory', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/layout/RowLayoutFactory.html', 'extends Object RowLayoutFactory creates and initializes row layouts. There are two ways to use RowLayoutFactory. Normally, it is used as a shorthand for writing \"new RowLayout()\" and initializing a bunch of fields. In this case the main benefit is a more concise syntax and the ability to create more than one identical RowLayout from the same factory. Changing a property of the factory will affect future layouts created by the factory, but has no effect on layouts that have already been created. Since: 3.5 '
975, 'org.eclipse.ui.dialogs.ContainerGenerator', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/dialogs/ContainerGenerator.html', 'extends Object For creating folder resources that currently do not exist, along a given workspace path. This class may be instantiated; it is not intended to be subclassed. Example usage: ContainerGenerator gen = new ContainerGenerator(new Path(\"/A/B\")); IContainer res = null; try { res = gen.getContainer(monitor); // creates project A and folder B if required } catch (CoreException e) { // handle failure } catch (OperationCanceledException e) { // handle cancelation } Restriction: This class is not intended to be subclassed by clients. '
976, 'org.eclipse.core.resources.IPathVariableManager', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/resources/IPathVariableManager.html', 'Manages a collection of path variables and resolves paths containing a variable reference. A path variable is a pair of non-null elements (name,value) where name is a case-sensitive string (containing only letters, digits and the underscore character, and not starting with a digit), and value is an absolute IPath object. Path variables allow for the creation of relative paths whose exact location in the file system depends on the value of a variable. A variable reference may only appear as the first segment of a relative path. Since: 2.1 See Also: IPath Restriction: This interface is not intended to be implemented by clients. Restriction: This interface is not intended to be extended by clients. '
977, 'org.eclipse.ui.IMarkerHelpRegistry', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/IMarkerHelpRegistry.html', 'Registry of F1 help contexts and resolutions for markers. The information contained in the registry is read from the org.eclipse.ui.markerhelp and org.eclipse.ui.markerresolution extension points. Since: 2.0 '
978, 'org.eclipse.ui.ide.IGotoMarker', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/ide/IGotoMarker.html', 'An adapter interface for editors, which allows the editor to reveal the position of a given marker. Since: 3.0 '
979, 'org.eclipse.ui.ide.IEditorAssociationOverride', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/ide/IEditorAssociationOverride.html', 'Allows to override editor associations for the IDE. This interface is implemented by org.eclipse.ui.ide.editorAssociationOverride extensions. Clients may implement this interface. Since: 3.8 '
980, 'org.eclipse.ui.ide.ResourceSaveableFilter', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/ide/ResourceSaveableFilter.html', 'A filter for selecting Saveables. Since: 3.3 See Also: IWorkbench.saveAll(org.eclipse.jface.window.IShellProvider, org.eclipse.jface.operation.IRunnableContext, ISaveableFilter, boolean) extends Object implements ISaveableFilter A saveable filter where the given savable must either match one of the given roots or be a direct or indirect child of one of the roots. Since: 3.9 '
981, 'org.eclipse.core.runtime.content.IContentTypeMatcher', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/runtime/content/IContentTypeMatcher.html', 'An object that performs content type matching queries. This interface is not intended to be implemented by clients. Since: 3.1 See Also: IContentTypeManager.getMatcher(IContentTypeManager.ISelectionPolicy, IScopeContext) '
982, 'org.eclipse.core.resources.mapping.ResourceChangeValidator', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/resources/mapping/ResourceChangeValidator.html', 'extends Object The resource change validator is used to validate that changes made to resources will not adversely affect the models stored in those resources. The validator is used by first creating a resource delta describing the proposed changes. A delta can be generated using a IResourceChangeDescriptionFactory. The change is then validated by calling the validateChange(IResourceDelta, IProgressMonitor) method. This example validates a change to a single file: IFile file = ..;//some file that is going to be changed ResourceChangeValidator validator = ResourceChangeValidator.getValidator(); IResourceChangeDescriptionFactory factory = validator.createDeltaFactory(); factory.change(file); IResourceDelta delta = factory.getDelta(); IStatus result = validator.validateChange(delta, null); If the result status does not have severity IStatus.OK, then the changes may cause problems for models that are built on those resources. In this case the user should be presented with the status message to determine if they want to proceed with the modification. Since: 3.2 '
983, 'org.eclipse.core.runtime.IAdapterFactory', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/runtime/IAdapterFactory.html', 'An adapter factory defines behavioral extensions for one or more classes that implements the IAdaptable interface. Adapter factories are registered with an adapter manager. This interface can be used without OSGi running. Clients may implement this interface. See Also: IAdapterManager, IAdaptable '
984, 'org.eclipse.core.resources.mapping.ModelStatus', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/resources/mapping/ModelStatus.html', 'A status object represents the outcome of an operation. All CoreExceptions carry a status object to indicate what went wrong. Status objects are also returned by methods needing to provide details of failures (e.g., validation methods). A status carries the following information: plug-in identifier (required) severity (required) status code (required) message (required) - localized to current locale exception (optional) - for problems stemming from a failure at a lower level Some status objects, known as multi-statuses, have other status objects as children. The class Status is the standard public implementation of status objects; the subclass MultiStatus is the implements multi-status objects. This interface can be used without OSGi running. See Also: MultiStatus, Status extends Status A status returned by a model from the resource operation validator. The severity indicates the severity of the possible side effects of the operation. Any severity other than OK should be shown to the user. The message should be a human readable message that will allow the user to make a decision as to whether to continue with the operation. The model provider id should indicate which model is flagging the the possible side effects. Clients may instantiate or subclass this class. Since: 3.2 '
985, 'org.eclipse.core.resources.mapping.IModelProviderDescriptor', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/resources/mapping/IModelProviderDescriptor.html', 'A model provider descriptor contains information about a model provider obtained from the plug-in manifest (plugin.xml) file. Model provider descriptors are platform-defined objects that exist independent of whether that model provider\'s plug-in has been started. In contrast, a model provider\'s runtime object (ModelProvider) generally runs plug-in-defined code. Since: 3.2 See Also: ModelProvider Restriction: This interface is not intended to be implemented by clients. Restriction: This interface is not intended to be extended by clients. '
986, 'org.eclipse.core.resources.mapping.ModelProvider', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/resources/mapping/ModelProvider.html', 'An interface for an adaptable object. Adaptable objects can be dynamically extended to provide different interfaces (or \"adapters\"). Adapters are created by adapter factories, which are in turn managed by type by adapter managers. For example, IAdaptable a = [some adaptable]; IFoo x = (IFoo)a.getAdapter(IFoo.class); if (x != null) [do IFoo things with x] This interface can be used without OSGi running. Clients may implement this interface, or obtain a default implementation of this interface by subclassing PlatformObject. See Also: IAdapterFactory, IAdapterManager, PlatformObject extends PlatformObject Represents the provider of a logical model. The main purpose of this API is to support batch operations on sets of ResourceMapping objects that are part of the same model. This class may be subclassed by clients. Since: 3.2 See Also: ResourceMapping '
987, 'org.eclipse.jface.viewers.CheckboxCellEditor', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/viewers/CheckboxCellEditor.html', 'extends CellEditor A cell editor that manages a checkbox. The cell editor\'s value is a boolean. This class may be instantiated; it is not intended to be subclassed. Note that this implementation simply fakes it and does does not create any new controls. The mere activation of this editor means that the value of the check box is being toggled by the end users; the listener method applyEditorValue is immediately called to signal the change. Restriction: This class is not intended to be subclassed by clients. '
988, 'org.eclipse.jface.layout.TreeColumnLayout', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/layout/TreeColumnLayout.html', 'extends AbstractColumnLayout The TreeColumnLayout is the Layout used to maintain TreeColumn sizes in a Tree. You can only add the Layout to a container whose only child is the Tree control you want the Layout applied to. Don\'t assign the layout directly the Tree Since: 3.3 '
989, 'org.eclipse.ui.ide.dialogs.UIResourceFilterDescription', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/ide/dialogs/UIResourceFilterDescription.html', 'extends Object Since: 3.6 '
990, 'org.eclipse.core.resources.IResourceFilterDescription', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/resources/IResourceFilterDescription.html', 'A description of a resource filter. A filter determines which file system objects will be visible when a local refresh is performed for an IContainer. Since: 3.6 See Also: IContainer.getFilters() Restriction: This interface is not intended to be implemented by clients. Restriction: This interface is not intended to be extended by clients. '
991, 'org.eclipse.core.resources.ResourceAttributes', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/resources/ResourceAttributes.html', 'extends Object This class represents platform specific attributes of files. Any attributes can be added, but only the attributes that are supported by the platform will be used. These methods do not set the attributes in the file system. Since: 3.1 See Also: IResource.getResourceAttributes(), IResource.setResourceAttributes(ResourceAttributes) Restriction: This class is not intended to be subclassed by clients. '
992, 'org.eclipse.ui.views.properties.FilePropertySource', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/views/properties/FilePropertySource.html', 'Interface to an object which is capable of supplying properties for display by the standard property sheet page implementation (PropertySheetPage). This interface should be implemented by clients. PropertySheetPage discovers the properties to display from currently selected elements. Elements that implement IPropertySource directly are included, as are elements that implement IAdaptable and have an IPropertySource adapter. Clients should implement this interface for any newly-defined elements that are to have properties displayable by PropertySheetPage. Note that in the latter case, the client will also need to register a suitable adapter factory with the platform\'s adapter manager (Platform.getAdapterManager). See Also: IAdaptable, Platform.getAdapterManager(), PropertySheetPage, IPropertySource2 extends ResourcePropertySource The FilePropertySource gives the extra information that is shown for files '
993, 'org.eclipse.ui.views.properties.ResourcePropertySource', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/views/properties/ResourcePropertySource.html', 'Interface to an object which is capable of supplying properties for display by the standard property sheet page implementation (PropertySheetPage). This interface should be implemented by clients. PropertySheetPage discovers the properties to display from currently selected elements. Elements that implement IPropertySource directly are included, as are elements that implement IAdaptable and have an IPropertySource adapter. Clients should implement this interface for any newly-defined elements that are to have properties displayable by PropertySheetPage. Note that in the latter case, the client will also need to register a suitable adapter factory with the platform\'s adapter manager (Platform.getAdapterManager). See Also: IAdaptable, Platform.getAdapterManager(), PropertySheetPage, IPropertySource2 extends Object implements IPropertySource A Resource property source. '
994, 'org.eclipse.ui.views.markers.FilterConfigurationArea', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/views/markers/FilterConfigurationArea.html', 'extends Object FilterConfigurationArea is the area that the user can configure a filter in. Since: 3.4 '
995, 'org.eclipse.ui.views.markers.MarkerViewHandler', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/views/markers/MarkerViewHandler.html', 'A handler is the pluggable piece of a command that handles execution. Each command can have zero or more handlers associated with it (in general), of which only one will be active at any given moment in time. When the command is asked to execute, it will simply pass that request on to its active handler, if any. Since: 3.1 See Also: AbstractHandler A handler is the pluggable piece of a command that handles execution. Each command can have zero or more handlers associated with it (in general), of which only one will be active at any given moment in time. When the command is asked to execute, it will simply pass that request on to its active handler, if any. Since: 3.1 See Also: AbstractHandler extends IHandler Extend the IHandler interface to provide some context for isEnabled() requests. Clients should use AbstractHandler unless they need to provide their own listener mechanism. Since: 3.4 See Also: AbstractHandler extends AbstractHandler MarkerViewHandler is the abstract class of the handlers for the MarkerSupportView Since: 3.4 '
996, 'org.eclipse.ui.actions.SelectionListenerAction', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/actions/SelectionListenerAction.html', 'An action represents the non-UI side of a command which can be triggered by the end user. Actions are typically associated with buttons, menu items, and items in tool bars. The controls for a command are built by some container, which furnished the context where these controls appear and configures them with data from properties declared by the action. When the end user triggers the command via its control, the action\'s run method is invoked to do the real work. Actions support a predefined set of properties (and possibly others as well). Clients of an action may register property change listeners so that they get notified whenever the value of a property changes. Clients should subclass the abstract base class Action to define concrete actions rather than implementing IAction from scratch. This interface exists only to define the API for actions. It is not intended to be implemented by clients. See Also: Action Restriction: This interface is not intended to be implemented by clients. A listener which is notified when a viewer\'s selection changes. See Also: ISelection, ISelectionProvider, SelectionChangedEvent extends BaseSelectionListenerAction The abstract superclass for resource-based actions that listen to selection change events. This implementation tracks the current selection (see getStructuredSelection) and provides a convenient place to monitor selection changes that could affect the availability of the action. Subclasses must implement the following IAction method: run - to do the action\'s work Subclasses may extend the updateSelection method to update the action determine its availability based on the current selection. The object instantiating the subclass is responsible for registering the instance with a selection provider. Alternatively, the object can notify the subclass instance directly of a selection change using the methods: selectionChanged(IStructuredSelection) - passing the selection selectionChanged(ISelectionChangedEvent) - passing the selection change event '
997, 'org.eclipse.ui.actions.WorkspaceAction', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/actions/WorkspaceAction.html', 'An action represents the non-UI side of a command which can be triggered by the end user. Actions are typically associated with buttons, menu items, and items in tool bars. The controls for a command are built by some container, which furnished the context where these controls appear and configures them with data from properties declared by the action. When the end user triggers the command via its control, the action\'s run method is invoked to do the real work. Actions support a predefined set of properties (and possibly others as well). Clients of an action may register property change listeners so that they get notified whenever the value of a property changes. Clients should subclass the abstract base class Action to define concrete actions rather than implementing IAction from scratch. This interface exists only to define the API for actions. It is not intended to be implemented by clients. See Also: Action Restriction: This interface is not intended to be implemented by clients. A listener which is notified when a viewer\'s selection changes. See Also: ISelection, ISelectionProvider, SelectionChangedEvent extends SelectionListenerAction The abstract superclass for actions which invoke commands implemented in org.eclipse.core.* on a set of selected resources. It iterates over all selected resources; errors are collected and displayed to the user via a problems dialog at the end of the operation. User requests to cancel the operation are passed along to the core. Subclasses must implement the following methods: invokeOperation - to perform the operation on one of the selected resources getOperationMessage - to furnish a title for the progress dialog Subclasses may override the following methods: shouldPerformResourcePruning - reimplement to turn off updateSelection - extend to refine enablement criteria getProblemsTitle - reimplement to furnish a title for the problems dialog getProblemsMessage - reimplement to furnish a message for the problems dialog run - extend to '
998, 'org.eclipse.core.databinding.observable.masterdetail.MasterDetailObservables', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/databinding/observable/masterdetail/MasterDetailObservables.html', 'extends Object Allows for the observation of an attribute, the detail, of an observable representing selection or another transient instance, the master. Since: 1.0 '
999, 'org.eclipse.core.databinding.property.set.ISetProperty', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/databinding/property/set/ISetProperty.html', 'extends IProperty Interface for set-typed properties Since: 1.2 See Also: SetProperty, SimpleSetProperty Restriction: This interface is not intended to be implemented by clients. Clients should instead subclass one of the classes that implement this interface. Note that direct implementers of this interface outside of the framework will be broken in future releases when methods are added to this interface. '
1000, 'org.eclipse.core.databinding.property.map.IMapProperty', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/databinding/property/map/IMapProperty.html', 'extends IProperty Interface for map-typed properties Since: 1.2 See Also: MapProperty, SimpleMapProperty Restriction: This interface is not intended to be implemented by clients. Clients should instead subclass one of the classes that implement this interface. Note that direct implementers of this interface outside of the framework will be broken in future releases when methods are added to this interface. '
1001, 'org.eclipse.core.databinding.observable.map.AbstractObservableMap', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/databinding/observable/map/AbstractObservableMap.html', 'An object with state that allows to listen for state changes. Implementations must not manage listeners themselves, listener management must be delegated to a private instance of type ChangeSupport if it is not inherited from AbstractObservable. Since: 1.0 Restriction: This interface is not intended to be implemented by clients. Clients should instead subclass one of the classes in the framework that implement this interface. Note that direct implementers of this interface outside of the framework will be broken in future releases when methods are added to this interface. An object with state that allows to listen for state changes. Implementations must not manage listeners themselves, listener management must be delegated to a private instance of type ChangeSupport if it is not inherited from AbstractObservable. Since: 1.0 Restriction: This interface is not intended to be implemented by clients. Clients should instead subclass one of the classes in the framework that implement this interface. Note that direct implementers of this interface outside of the framework will be broken in future releases when methods are added to this interface. extends Map, IObservable Observable Map. Since: 1.1 See Also: AbstractObservableMap, ObservableMap Restriction: This interface is not intended to be implemented by clients. Clients should instead subclass one of the classes that implement this interface. Note that direct implementers of this interface outside of the framework will be broken in future releases when methods are added to this interface. extends AbstractMap implements IObservableMap This class is thread safe. All state accessing methods must be invoked from the current realm. Methods for adding and removing listeners may be invoked from any thread. Since: 1.0 '
1002, 'org.eclipse.core.databinding.property.IPropertyObservable', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/databinding/property/IPropertyObservable.html', 'Mixin interface for IObservables that observe other objects. Since: 1.0 extends IObserving Provides access to the details of property observables Since: 1.2 '
1003, 'org.eclipse.core.databinding.property.map.SimpleMapProperty', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/databinding/property/map/SimpleMapProperty.html', 'extends IProperty Interface for map-typed properties Since: 1.2 See Also: MapProperty, SimpleMapProperty Restriction: This interface is not intended to be implemented by clients. Clients should instead subclass one of the classes that implement this interface. Note that direct implementers of this interface outside of the framework will be broken in future releases when methods are added to this interface. extends MapProperty Simplified abstract implementation of IMapProperty. This class takes care of most of the functional requirements for an IMapProperty implementation, leaving only the property-specific details to subclasses. Subclasses must implement these methods: IMapProperty.getKeyType() IMapProperty.getValueType() doGetMap(Object) doSetMap(Object, Map, MapDiff) adaptListener(ISimplePropertyListener) In addition, we recommended overriding Object.toString() to return a description suitable for debugging purposes. Since: 1.2 '
1004, 'org.eclipse.core.databinding.property.INativePropertyListener', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/databinding/property/INativePropertyListener.html', 'A listener capable of adding or removing itself as a listener on a source object using the source\'s \"native\" listener API. Events received from the source objects are parlayed to the ISimplePropertyListener provided to the method that constructed this native listener instance. Since: 1.2 See Also: NativePropertyListener, SimpleValueProperty.adaptListener(ISimplePropertyListener), SimpleListProperty.adaptListener(ISimplePropertyListener), SimpleSetProperty.adaptListener(ISimplePropertyListener), SimpleMapProperty.adaptListener(ISimplePropertyListener) '
1005, 'org.eclipse.core.databinding.property.ISimplePropertyListener', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/databinding/property/ISimplePropertyListener.html', 'Listener for changes to properties on a particular source object Since: 1.2 Restriction: This interface is not intended to be implemented by clients. Restriction: This interface is not intended to be extended by clients. '
1006, 'org.eclipse.core.databinding.property.SimplePropertyEvent', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/databinding/property/SimplePropertyEvent.html', 'extends EventObject Event object events in the properties API Since: 1.2 See Also: Serialized Form '
1007, 'org.eclipse.core.databinding.observable.map.MapDiff', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/databinding/observable/map/MapDiff.html', 'extends Object implements IDiff Since: 1.1 '
1008, 'org.eclipse.core.databinding.observable.Diffs', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/databinding/observable/Diffs.html', 'extends Object Since: 1.0 '
1009, 'org.eclipse.core.databinding.observable.DecoratingObservable', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/databinding/observable/DecoratingObservable.html', 'extends IObservable Interface for observables which decorate other observables. Since: 1.2 Restriction: This interface is not intended to be implemented by clients. Clients should instead subclass one of the classes in the framework that implement this interface. Note that direct implementers of this interface outside of the framework will be broken in future releases when methods are added to this interface. An object with state that allows to listen for state changes. Implementations must not manage listeners themselves, listener management must be delegated to a private instance of type ChangeSupport if it is not inherited from AbstractObservable. Since: 1.0 Restriction: This interface is not intended to be implemented by clients. Clients should instead subclass one of the classes in the framework that implement this interface. Note that direct implementers of this interface outside of the framework will be broken in future releases when methods are added to this interface. extends AbstractObservable implements IDecoratingObservable An observable which decorates another observable Since: 1.2 '
1010, 'org.eclipse.core.databinding.observable.map.IMapChangeListener', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/databinding/observable/map/IMapChangeListener.html', 'extends IObservablesListener Listener for changes to observable maps. Since: 1.0 '
1011, 'org.eclipse.core.databinding.observable.map.MapChangeEvent', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/databinding/observable/map/MapChangeEvent.html', 'extends ObservableEvent Map change event describing an incremental change of an IObservableMap object. Since: 1.0 See Also: Serialized Form '
1012, 'org.eclipse.core.databinding.observable.map.DecoratingObservableMap', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/databinding/observable/map/DecoratingObservableMap.html', 'extends IObservable Interface for observables which decorate other observables. Since: 1.2 Restriction: This interface is not intended to be implemented by clients. Clients should instead subclass one of the classes in the framework that implement this interface. Note that direct implementers of this interface outside of the framework will be broken in future releases when methods are added to this interface. An object with state that allows to listen for state changes. Implementations must not manage listeners themselves, listener management must be delegated to a private instance of type ChangeSupport if it is not inherited from AbstractObservable. Since: 1.0 Restriction: This interface is not intended to be implemented by clients. Clients should instead subclass one of the classes in the framework that implement this interface. Note that direct implementers of this interface outside of the framework will be broken in future releases when methods are added to this interface. An object with state that allows to listen for state changes. Implementations must not manage listeners themselves, listener management must be delegated to a private instance of type ChangeSupport if it is not inherited from AbstractObservable. Since: 1.0 Restriction: This interface is not intended to be implemented by clients. Clients should instead subclass one of the classes in the framework that implement this interface. Note that direct implementers of this interface outside of the framework will be broken in future releases when methods are added to this interface. extends Map, IObservable Observable Map. Since: 1.1 See Also: AbstractObservableMap, ObservableMap Restriction: This interface is not intended to be implemented by clients. Clients should instead subclass one of the classes that implement this interface. Note that direct implementers of this interface outside of the framework will be broken in future releases when methods are added to this interface. extends DecoratingObservable implements IObservableMap An observable map which decorates another observable map. Since: 1.2 '
1013, 'org.eclipse.core.databinding.observable.IStaleListener', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/databinding/observable/IStaleListener.html', 'extends IObservablesListener Listener for staleness events. An observable object is stale if its state will change eventually. Since: 1.0 '
1014, 'org.eclipse.core.databinding.observable.IDisposeListener', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/databinding/observable/IDisposeListener.html', 'extends IObservablesListener Listener for dispose events. An observable object is disposed if its IObservable.dispose() method has been called. Since: 1.2 '
1015, 'org.eclipse.core.databinding.observable.DisposeEvent', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/databinding/observable/DisposeEvent.html', 'extends ObservableEvent Event denoting that an IObservable object was disposed. Since: 1.2 See Also: Serialized Form '
1016, 'org.eclipse.core.databinding.observable.StaleEvent', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/databinding/observable/StaleEvent.html', 'extends ObservableEvent Generic event denoting that the state of an IObservable object is about to change. Note that this event is only fired when an observable becomes stale, not when it becomes unstale; an observable that becomes unstale should always fire a change event. Staleness can be used (for example) to notify listeners when an observable has started a background thread for updating its state. Clients can safely ignore staleness. Since: 1.0 See Also: IObservable.isStale(), Serialized Form '
1017, 'org.eclipse.core.databinding.observable.ChangeEvent', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/databinding/observable/ChangeEvent.html', 'extends ObservableEvent Generic change event denoting that the state of an IObservable object has changed. This event does not carry information about the kind of change that occurred. Since: 1.0 See Also: Serialized Form '
1018, 'org.eclipse.core.databinding.observable.list.ObservableList', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/databinding/observable/list/ObservableList.html', 'An object with state that allows to listen for state changes. Implementations must not manage listeners themselves, listener management must be delegated to a private instance of type ChangeSupport if it is not inherited from AbstractObservable. Since: 1.0 Restriction: This interface is not intended to be implemented by clients. Clients should instead subclass one of the classes in the framework that implement this interface. Note that direct implementers of this interface outside of the framework will be broken in future releases when methods are added to this interface. extends IObservable, Collection Interface for observable collections. Only general change listeners can be added to an observable collection. Listeners interested in incremental changes have to be added using more concrete subtypes such as IObservableList or IObservableSet. Since: 1.0 Restriction: This interface is not intended to be implemented by clients. Clients should instead subclass one of the classes that implement this interface. Note that direct implementers of this interface outside of the framework will be broken in future releases when methods are added to this interface. Restriction: This interface is not intended to be extended by clients. An object with state that allows to listen for state changes. Implementations must not manage listeners themselves, listener management must be delegated to a private instance of type ChangeSupport if it is not inherited from AbstractObservable. Since: 1.0 Restriction: This interface is not intended to be implemented by clients. Clients should instead subclass one of the classes in the framework that implement this interface. Note that direct implementers of this interface outside of the framework will be broken in future releases when methods are added to this interface. extends IObservable, Collection Interface for observable collections. Only general change listeners can be added to an observable collection. Listeners interested in incremental changes have to be added using more concrete subtypes such as IObservableList or IObservableSet. Since: 1.0 Restriction: This interface is not intended to be implemented by clients. Clients should instead subclass one of the classes that implement this interface. Note that direct implementers of this interface outside of the framework will be broken in future releases when methods are added to this interface. Restriction: This interface is not intended to be extended by clients. extends List, IObservableCollection A list whose changes can be tracked by list change listeners. Since: 1.0 See Also: AbstractObservableList, ObservableList Restriction: This interface is not intended to be implemented by clients. Clients should instead subclass one of the framework classes that implement this interface. Note that direct implementers of this interface outside of the framework will be broken in future releases when methods are added to this interface. extends AbstractObservable implements IObservableList Abstract implementation of IObservableList, based on an underlying regular list. This class is thread safe. All state accessing methods must be invoked from the current realm. Methods for adding and removing listeners may be invoked from any thread. Since: 1.0 '
1019, 'org.eclipse.core.databinding.observable.list.ListDiffEntry', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/databinding/observable/list/ListDiffEntry.html', 'extends Object A single addition of an element to a list or removal of an element from a list. Since: 1.0 '
1020, 'org.eclipse.core.databinding.observable.list.ListChangeEvent', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/databinding/observable/list/ListChangeEvent.html', 'extends ObservableEvent List change event describing an incremental change of an IObservableList object. Since: 1.0 See Also: Serialized Form '
1021, 'org.eclipse.core.databinding.observable.list.ListDiff', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/databinding/observable/list/ListDiff.html', 'extends Object implements IDiff Object describing a diff between two lists. Since: 1.0 '
1022, 'org.eclipse.core.databinding.observable.map.ComputedObservableMap', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/databinding/observable/map/ComputedObservableMap.html', 'An object with state that allows to listen for state changes. Implementations must not manage listeners themselves, listener management must be delegated to a private instance of type ChangeSupport if it is not inherited from AbstractObservable. Since: 1.0 Restriction: This interface is not intended to be implemented by clients. Clients should instead subclass one of the classes in the framework that implement this interface. Note that direct implementers of this interface outside of the framework will be broken in future releases when methods are added to this interface. An object with state that allows to listen for state changes. Implementations must not manage listeners themselves, listener management must be delegated to a private instance of type ChangeSupport if it is not inherited from AbstractObservable. Since: 1.0 Restriction: This interface is not intended to be implemented by clients. Clients should instead subclass one of the classes in the framework that implement this interface. Note that direct implementers of this interface outside of the framework will be broken in future releases when methods are added to this interface. extends Map, IObservable Observable Map. Since: 1.1 See Also: AbstractObservableMap, ObservableMap Restriction: This interface is not intended to be implemented by clients. Clients should instead subclass one of the classes that implement this interface. Note that direct implementers of this interface outside of the framework will be broken in future releases when methods are added to this interface. extends AbstractObservableMap Maps objects to one of their attributes. Tracks changes to the underlying observable set of objects (keys), as well as changes to attribute values. '
1023, 'org.eclipse.core.databinding.observable.value.IValueChangeListener', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/databinding/observable/value/IValueChangeListener.html', 'extends IObservablesListener Listener for changes to observable values. Since: 1.0 '
1024, 'org.eclipse.core.databinding.observable.value.ValueChangeEvent', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/databinding/observable/value/ValueChangeEvent.html', 'extends ObservableEvent Value change event describing a change of an IObservableValue object\'s current value. Since: 1.0 See Also: Serialized Form '
1025, 'org.eclipse.core.databinding.observable.list.AbstractObservableList', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/databinding/observable/list/AbstractObservableList.html', 'An object with state that allows to listen for state changes. Implementations must not manage listeners themselves, listener management must be delegated to a private instance of type ChangeSupport if it is not inherited from AbstractObservable. Since: 1.0 Restriction: This interface is not intended to be implemented by clients. Clients should instead subclass one of the classes in the framework that implement this interface. Note that direct implementers of this interface outside of the framework will be broken in future releases when methods are added to this interface. extends IObservable, Collection Interface for observable collections. Only general change listeners can be added to an observable collection. Listeners interested in incremental changes have to be added using more concrete subtypes such as IObservableList or IObservableSet. Since: 1.0 Restriction: This interface is not intended to be implemented by clients. Clients should instead subclass one of the classes that implement this interface. Note that direct implementers of this interface outside of the framework will be broken in future releases when methods are added to this interface. Restriction: This interface is not intended to be extended by clients. An object with state that allows to listen for state changes. Implementations must not manage listeners themselves, listener management must be delegated to a private instance of type ChangeSupport if it is not inherited from AbstractObservable. Since: 1.0 Restriction: This interface is not intended to be implemented by clients. Clients should instead subclass one of the classes in the framework that implement this interface. Note that direct implementers of this interface outside of the framework will be broken in future releases when methods are added to this interface. extends IObservable, Collection Interface for observable collections. Only general change listeners can be added to an observable collection. Listeners interested in incremental changes have to be added using more concrete subtypes such as IObservableList or IObservableSet. Since: 1.0 Restriction: This interface is not intended to be implemented by clients. Clients should instead subclass one of the classes that implement this interface. Note that direct implementers of this interface outside of the framework will be broken in future releases when methods are added to this interface. Restriction: This interface is not intended to be extended by clients. extends List, IObservableCollection A list whose changes can be tracked by list change listeners. Since: 1.0 See Also: AbstractObservableList, ObservableList Restriction: This interface is not intended to be implemented by clients. Clients should instead subclass one of the framework classes that implement this interface. Note that direct implementers of this interface outside of the framework will be broken in future releases when methods are added to this interface. extends AbstractList implements IObservableList Subclasses should override at least get(int index) and size(). This class is thread safe. All state accessing methods must be invoked from the current realm. Methods for adding and removing listeners may be invoked from any thread. Since: 1.0 '
1026, 'org.eclipse.e4.ui.workbench.IExceptionHandler', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/e4/ui/workbench/IExceptionHandler.html', 'This handler allows clients to be notified when an exception occurs Since: 1.0 Restriction: This interface is not intended to be implemented by clients. '
1027, 'org.eclipse.e4.ui.workbench.modeling.ModelHandlerBase', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/e4/ui/workbench/modeling/ModelHandlerBase.html', 'extends Object Since: 1.0 Restriction: This class is not intended to be referenced by clients. '
1028, 'org.eclipse.e4.ui.workbench.modeling.IDelta', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/e4/ui/workbench/modeling/IDelta.html', ' Since: 1.0 Restriction: This interface is not intended to be referenced by clients. '
1029, 'org.eclipse.osgi.service.debug.DebugTrace', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/osgi/service/debug/DebugTrace.html', 'A DebugTrace is used to record debug trace statements, based on the current option settings in a corresponding DebugOptions class. The trace implementation will automatically insert additional contextual information such as the bundle, class, and method performing the tracing. Trace statements may be written to a file, or onto standard output, depending on how the DebugOptions is configured. All methods on this class have an optional option argument. When specified, this argument will cause the tracing to be conditional on the value of DebugOptions.getBooleanOption(String, boolean), where the bundle\'s symbolic name will automatically be prepended to the provided option string. For example, if your bundle symbolic name is \"com.acme.bundle\", and you provide an option argument of \"/debug/parser\", the trace will only be printed if the option \"com.acme.bundle/debug/parser\" has a value of \"true\". Note that the pipe character (\"|\") is reserved for internal use. If this character happens to occur in any of the thread name, the option, the message or an Exception message, it will be escaped to the corresponding HTML representation (\"&#124;\"). Since: 3.5 Restriction: This interface is not intended to be implemented by clients. Restriction: This interface is not intended to be extended by clients. '
1030, 'org.eclipse.osgi.framework.log.FrameworkLog', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/osgi/framework/log/FrameworkLog.html', 'The FramworkLog interface. A FrameworkLog implementation is provided by the FrameworkAdaptor and used by the Framework to log any error messages and FrameworkEvents of type ERROR. The FrameworkLog may persist the log messages to the filesystem or allow other ways of accessing the log information. Since: 3.1 Restriction: This interface is not intended to be implemented by clients. '
1031, 'org.eclipse.osgi.framework.log.FrameworkLogEntry', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/osgi/framework/log/FrameworkLogEntry.html', 'extends Object A framework log entry used to log information to a FrameworkLog Since: 3.1 Restriction: This class is not intended to be subclassed by clients. '
1032, 'org.eclipse.osgi.service.debug.DebugOptions', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/osgi/service/debug/DebugOptions.html', 'Used to get debug options settings and creating a new DebugTrace instance for a bundle to use for dynamic tracing. Since: 3.1 Restriction: This interface is not intended to be implemented by clients. Restriction: This interface is not intended to be extended by clients. '
1033, 'org.eclipse.swt.events.VerifyListener', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/events/VerifyListener.html', 'extends org.eclipse.swt.internal.SWTEventListener Classes which implement this interface provide a method that deals with the events that are generated when text is about to be modified. After creating an instance of a class that implements this interface it can be added to a text control using the addVerifyListener method and removed using the removeVerifyListener method. When the text is about to be modified, the verifyText method will be invoked. See Also: VerifyEvent '
1034, 'org.eclipse.ui.navigator.CommonDropAdapter', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/navigator/CommonDropAdapter.html', 'extends org.eclipse.swt.internal.SWTEventListener The DropTargetListener class provides event notification to the application for DropTarget events. As the user moves the cursor into, over and out of a Control that has been designated as a DropTarget, events indicate what operation can be performed and what data can be transferred if a drop where to occur at that point. The application can respond to these events and change the type of data that will be dropped by modifying event.currentDataType, or change the operation that will be performed by modifying the event.detail field or stop any drop from happening on the current target by setting the event.detail field to DND_DROP_NONE. When the user causes a drop to happen by releasing the mouse over a valid drop target, the application has one last chance to change the data type of the drop through the DropAccept event. If the drop is still allowed, the DropAccept event is immediately followed by the Drop event. In the Drop event, the application can still change the operation that is performed but the data type is fixed. See Also: DropTargetEvent extends PluginDropAdapter Provides an implementation of PluginDropAdapter which uses the extensions provided by the associated INavigatorContentService. Clients should not need to create an instance of this class unless they are creating their own custom viewer. Otherwise, CommonViewer configures its drop adapter automatically. Since: 3.2 See Also: INavigatorDnDService, CommonDragAdapter, CommonDragAdapterAssistant, CommonDropAdapterAssistant, CommonViewer '
1035, 'org.eclipse.ui.IWorkbenchPropertyPage', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/IWorkbenchPropertyPage.html', 'Interface for a page in a multi-page dialog. Interface for a page in a multi-page dialog. extends IDialogPage An interface for a preference page. This interface is used primarily by the page\'s container extends IPreferencePage Interface for workbench property pages. Property pages generally show up in the workbench\'s Property Pages dialog. Clients should implement this interface and include the name of their class in an extension contributed to the workbench\'s property page extension point (named \"org.eclipse.ui.propertyPages\"). For example, the plug-in\'s XML markup might contain: <extension point=\"org.eclipse.ui.propertyPages\"> <page id=\"com.example.myplugin.props\" name=\"Knobs\" objectClass=\"org.eclipse.core.resources.IResource\" class=\"com.example.myplugin.MyPropertyPage\" /> </extension> Property pages that support multiple selected objects should implement IWorkbenchPropertyPageMulti instead. See Also: IWorkbenchPropertyPageMulti '
1036, 'org.eclipse.ui.dialogs.ContainerCheckedTreeViewer', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/dialogs/ContainerCheckedTreeViewer.html', 'Interface for objects that support elements with a checked state. See Also: ICheckStateListener, CheckStateChangedEvent Interface common to all objects that provide an input. Interface common to all objects that provide an input. Interface common to all objects that provide a selection. See Also: ISelection, ISelectionChangedListener, SelectionChangedEvent extends IInputProvider, ISelectionProvider Interface common to all objects that provide both an input and a selection. Interface common to all objects that provide a selection. See Also: ISelection, ISelectionChangedListener, SelectionChangedEvent extends ISelectionProvider Selection provider extension interface to allow providers to notify about post selection changed events. A post selection changed event is equivalent to selection changed event if the selection change was triggered by the mouse, but it has a delay if the selection change is triggered by keyboard navigation. Since: 3.0 See Also: ISelectionProvider Interface common to all objects that provide a selection. See Also: ISelection, ISelectionChangedListener, SelectionChangedEvent extends CheckboxTreeViewer CheckboxTreeViewer with special behaviour of the checked / gray state on container (non-leaf) nodes: The grayed state is used to visualize the checked state of its children. Containers are checked and non-gray if all contained leafs are checked. The container is grayed if some but not all leafs are checked. Since: 3.1 '
1037, 'org.eclipse.ui.actions.SelectionProviderAction', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/actions/SelectionProviderAction.html', 'An action represents the non-UI side of a command which can be triggered by the end user. Actions are typically associated with buttons, menu items, and items in tool bars. The controls for a command are built by some container, which furnished the context where these controls appear and configures them with data from properties declared by the action. When the end user triggers the command via its control, the action\'s run method is invoked to do the real work. Actions support a predefined set of properties (and possibly others as well). Clients of an action may register property change listeners so that they get notified whenever the value of a property changes. Clients should subclass the abstract base class Action to define concrete actions rather than implementing IAction from scratch. This interface exists only to define the API for actions. It is not intended to be implemented by clients. See Also: Action Restriction: This interface is not intended to be implemented by clients. A listener which is notified when a viewer\'s selection changes. See Also: ISelection, ISelectionProvider, SelectionChangedEvent extends Action implements ISelectionChangedListener The abstract superclass for actions that listen to selection changes from a particular selection provider. This implementation splits the current selection along structured/unstructured lines, providing a convenient place to monitor selection changes that require adjusting action state. Subclasses must implement the following IAction method: run - to do the action\'s work Subclasses may reimplement either of the following methods: selectionChanged(IStructuredSelection) selectionChanged(ISelection) '
1038, 'org.eclipse.ui.commands.IElementReference', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/commands/IElementReference.html', 'the ICommandService will return a reference for all callbacks that are registered. This reference can be used to unregister the specific callback. Similar in functionality to an IHandlerActivation. This interface should not be implemented or extended by clients. Since: 3.3 '
1039, 'org.eclipse.ui.commands.IElementUpdater', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/commands/IElementUpdater.html', 'An IHandler for a command that expects to provide feedback through the registered element mechanism must implement this interface. Since: 3.3 '
1040, 'org.eclipse.ui.menus.UIElement', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/menus/UIElement.html', 'extends Object Allow a command or application to provide feedback to a user through updating a MenuItem or ToolItem. Initially used to update properties for UI elements created by the CommandContributionItem. This class may be extended by clients. Since: 3.3 '
1041, 'org.eclipse.ui.menus.IContributionRoot', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/menus/IContributionRoot.html', 'Instances of this interface represent a position in the contribution hierarchy into which AbstractContributionFactory instances may insert elements. Instances of this interface are provided by the platform and this interface should NOT be implemented by clients. Since: 3.3 '
1042, 'org.eclipse.ui.menus.AbstractContributionFactory', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/menus/AbstractContributionFactory.html', 'extends Object ContributionFactories are used by the IMenuService to populate ContributionManagers. In createContributionItems(IServiceLocator, IContributionRoot) you fill in the additions List with IContributionItem to be inserted at this factory\'s location. For example: AbstractContributionFactory contributions = new AbstractContributionFactory( \"menu:org.eclipse.ui.tests.api.MenuTestHarness?after=additions\") { public void createContributionItems(IMenuService menuService, List additions) { CommandContributionItem item = new CommandContributionItem( \"org.eclipse.ui.tests.menus.helloWorld\", \"org.eclipse.ui.tests.commands.enabledHelloWorld\", null, null, \"Say Hello\", null); additions.add(item); item = new CommandContributionItem( \"org.eclipse.ui.tests.menus.refresh\", \"org.eclipse.ui.tests.commands.refreshView\", null, null, \"Refresh\", null); menuService.registerVisibleWhen(item, new MyActiveContextExpression( \"org.eclipse.ui.tests.myview.context\")); additions.add(item); } public void releaseContributionItems(IMenuService menuService, List items) { // we have nothing to do } }; IMenuService service = (IMenuService) PlatformUI.getWorkbench().getService( IMenuService.class); service.addContributionFactory(contributions); Clients who are providing factories via the org.eclipse.ui.menus extension point should subclass ExtensionContributionFactory instead. Only the abstract methods may be implemented. Since: 3.3 See Also: IMenuService, MenuManager, ToolBarManager '
1043, 'org.eclipse.ui.actions.RetargetAction', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/actions/RetargetAction.html', 'An action represents the non-UI side of a command which can be triggered by the end user. Actions are typically associated with buttons, menu items, and items in tool bars. The controls for a command are built by some container, which furnished the context where these controls appear and configures them with data from properties declared by the action. When the end user triggers the command via its control, the action\'s run method is invoked to do the real work. Actions support a predefined set of properties (and possibly others as well). Clients of an action may register property change listeners so that they get notified whenever the value of a property changes. Clients should subclass the abstract base class Action to define concrete actions rather than implementing IAction from scratch. This interface exists only to define the API for actions. It is not intended to be implemented by clients. See Also: Action Restriction: This interface is not intended to be implemented by clients. extends IAction Interface for a workbench action. Interface for listening to part lifecycle events. This interface may be implemented by clients. See Also: IPartService.addPartListener(IPartListener) extends PartEventAction implements ActionFactory.IWorkbenchAction A RetargetAction tracks the active part in the workbench. Each RetargetAction has an ID. If the active part provides an action handler for the ID the enable and check state of the RetargetAction is determined from the enable and check state of the handler. If the active part does not provide an action handler then this action is disabled. Note: instances of this class add themselves as listeners to their action handler. It is important for the creator of a retarget action to call dispose when the action is no longer needed. This will ensure that the listener is removed. This class may be instantiated. It is not intented to be subclassed. Since: 2.0 Restriction: This class is not intended to be subclassed by clients. '
1044, 'org.eclipse.core.expressions.EvaluationContext', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/expressions/EvaluationContext.html', 'An evaluation context is used to manage a set of objects needed during XML expression evaluation. A context has a parent context, can manage a set of named variables and has a default variable. The default variable is used during XML expression evaluation if no explicit variable is referenced. This interface is not intended to be implemented by clients. Clients are allowed to instantiate EvaluationContext. Since: 3.0 Restriction: This interface is not intended to be implemented by clients. Restriction: This interface is not intended to be extended by clients. extends Object implements IEvaluationContext A default implementation of an evaluation context. Clients may instantiate this default context. The class is not intended to be subclassed by clients. Since: 3.0 Restriction: This class is not intended to be subclassed by clients. '
1045, 'org.eclipse.ui.part.MultiPageEditorSite', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/part/MultiPageEditorSite.html', 'An interface for an adaptable object. Adaptable objects can be dynamically extended to provide different interfaces (or \"adapters\"). Adapters are created by adapter factories, which are in turn managed by type by adapter managers. For example, IAdaptable a = [some adaptable]; IFoo x = (IFoo)a.getAdapter(IFoo.class); if (x != null) [do IFoo things with x] This interface can be used without OSGi running. Clients may implement this interface, or obtain a default implementation of this interface by subclassing PlatformObject. See Also: IAdapterFactory, IAdapterManager, PlatformObject Interface for objects that can return a shell. This is normally used for opening child windows. An object that wants to open child shells can take an IShellProvider in its constructor, and the object that implements IShellProvider can dynamically choose where child shells should be opened. Since: 3.1 An interface for an adaptable object. Adaptable objects can be dynamically extended to provide different interfaces (or \"adapters\"). Adapters are created by adapter factories, which are in turn managed by type by adapter managers. For example, IAdaptable a = [some adaptable]; IFoo x = (IFoo)a.getAdapter(IFoo.class); if (x != null) [do IFoo things with x] This interface can be used without OSGi running. Clients may implement this interface, or obtain a default implementation of this interface by subclassing PlatformObject. See Also: IAdapterFactory, IAdapterManager, PlatformObject A component with which one or more services are registered. The services can be retrieved from this locator using some key -- typically the class representing the interface the service must implement. For example: IHandlerService service = (IHandlerService) workbenchWindow .getService(IHandlerService.class); This interface is not to be implemented or extended by clients. Since: 3.2 Interface for objects that can return a shell. This is normally used for opening child windows. An object that wants to open child shells can take an IShellProvider in its constructor, and the object that implements IShellProvider can dynamically choose where child shells should be opened. Since: 3.1 extends IWorkbenchSite The primary interface between a workbench part and the workbench. This interface is not intended to be implemented or extended by clients. Restriction: This interface is not intended to be implemented by clients. extends IAdaptable, IShellProvider, IServiceLocator The common interface between the workbench and its parts, including pages within parts. The workbench site supports a few services by default. If these services are used to allocate resources, it is important to remember to clean up those resources after you are done with them. Otherwise, the resources will exist until the workbench site is disposed. The supported services are: ICommandService IContextService IHandlerService IBindingService. Resources allocated through this service will not be cleaned up until the workbench shuts down. This interface is not intended to be implemented or extended by clients. Since: 2.0 See Also: IWorkbenchPartSite, IPageSite Restriction: This interface is not intended to be implemented by clients. extends IWorkbenchPartSite The primary interface between an editor part and the workbench. The workbench exposes its implemention of editor part sites via this interface, which is not intended to be implemented or extended by clients. Restriction: This interface is not intended to be implemented by clients. An interface for an adaptable object. Adaptable objects can be dynamically extended to provide different interfaces (or \"adapters\"). Adapters are created by adapter factories, which are in turn managed by type by adapter managers. For example, IAdaptable a = [some adaptable]; IFoo x = (IFoo)a.getAdapter(IFoo.class); if (x != null) [do IFoo things with x] This interface can be used without OSGi running. Clients may implement this interface, or obtain a default implementation of this interface by subclassing PlatformObject. See Also: IAdapterFactory, IAdapterManager, PlatformObject A component with which one or more services are registered. The services can be retrieved from this locator using some key -- typically the class representing the interface the service must implement. For example: IHandlerService service = (IHandlerService) workbenchWindow .getService(IHandlerService.class); This interface is not to be implemented or extended by clients. Since: 3.2 Interface for objects that can return a shell. This is normally used for opening child windows. An object that wants to open child shells can take an IShellProvider in its constructor, and the object that implements IShellProvider can dynamically choose where child shells should be opened. Since: 3.1 extends IAdaptable, IShellProvider, IServiceLocator The common interface between the workbench and its parts, including pages within parts. The workbench site supports a few services by default. If these services are used to allocate resources, it is important to remember to clean up those resources after you are done with them. Otherwise, the resources will exist until the workbench site is disposed. The supported services are: ICommandService IContextService IHandlerService IBindingService. Resources allocated through this service will not be cleaned up until the workbench shuts down. This interface is not intended to be implemented or extended by clients. Since: 2.0 See Also: IWorkbenchPartSite, IPageSite Restriction: This interface is not intended to be implemented by clients. extends IWorkbenchSite The primary interface between a workbench part and the workbench. This interface is not intended to be implemented or extended by clients. Restriction: This interface is not intended to be implemented by clients. extends IAdaptable, IShellProvider, IServiceLocator The common interface between the workbench and its parts, including pages within parts. The workbench site supports a few services by default. If these services are used to allocate resources, it is important to remember to clean up those resources after you are done with them. Otherwise, the resources will exist until the workbench site is disposed. The supported services are: ICommandService IContextService IHandlerService IBindingService. Resources allocated through this service will not be cleaned up until the workbench shuts down. This interface is not intended to be implemented or extended by clients. Since: 2.0 See Also: IWorkbenchPartSite, IPageSite Restriction: This interface is not intended to be implemented by clients. A component with which one or more services are registered. The services can be retrieved from this locator using some key -- typically the class representing the interface the service must implement. For example: IHandlerService service = (IHandlerService) workbenchWindow .getService(IHandlerService.class); This interface is not to be implemented or extended by clients. Since: 3.2 extends Object implements IEditorSite, org.eclipse.ui.internal.services.INestable Site for a nested editor within a multi-page editor. Selection is handled by forwarding the event to the multi-page editor\'s selection listeners; most other methods are forwarded to the multi-page editor\'s site. The base implementation of MultiPageEditor.createSite creates an instance of this class. This class may be instantiated or subclassed. '
1046, 'org.eclipse.ui.actions.ContributedAction', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/actions/ContributedAction.html', 'An action represents the non-UI side of a command which can be triggered by the end user. Actions are typically associated with buttons, menu items, and items in tool bars. The controls for a command are built by some container, which furnished the context where these controls appear and configures them with data from properties declared by the action. When the end user triggers the command via its control, the action\'s run method is invoked to do the real work. Actions support a predefined set of properties (and possibly others as well). Clients of an action may register property change listeners so that they get notified whenever the value of a property changes. Clients should subclass the abstract base class Action to define concrete actions rather than implementing IAction from scratch. This interface exists only to define the API for actions. It is not intended to be implemented by clients. See Also: Action Restriction: This interface is not intended to be implemented by clients. extends org.eclipse.ui.internal.actions.CommandAction For a declarative editor action, see if we can link it to a command. This is a legacy bridge class, and should not be used outside of the Eclipse SDK. Please use menu contributions to display a command in a menu or toolbar. Note: Clients may instantiate. Since: 3.3 '
1047, 'org.eclipse.ui.actions.ActionGroup', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/actions/ActionGroup.html', 'extends Object An ActionGroup represents a group of actions which are added to a context menu, or the action bars of a part, together. The group is given a context which can be used to determine which actions are added, and what their enabled state should be. This class is intended only as a convenience for managing groups of actions. Clients are not required to use this class in order to add actions to context menus or action bars. Clients should subclass this class and extend or override the appropriate fill methods. Since: 2.0 '
1048, 'org.eclipse.ui.actions.CompoundContributionItem', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/actions/CompoundContributionItem.html', 'A contribution item represents a contribution to a shared UI resource such as a menu or tool bar. More generally, contribution items are managed by a contribution manager. For instance, in a tool bar a contribution item is a tool bar button or a separator. In a menu bar a contribution item is a menu, and in a menu a contribution item is a menu item or separator. A contribution item can realize itself in different SWT widgets, using the different fill methods. The same type of contribution item can be used with a MenuBarManager, ToolBarManager, CoolBarManager, or a StatusLineManager. This interface is internal to the framework; it should not be implemented outside the framework. See Also: IContributionManager Restriction: This interface is not intended to be implemented by clients. extends ContributionItem A compound contribution is a contribution item consisting of a dynamic list of contribution items. Since: 3.1 '
1049, 'org.eclipse.ui.WorkbenchException', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/WorkbenchException.html', 'extends CoreException A checked exception indicating a recoverable error occured internal to the workbench. The status provides a further description of the problem. This exception class is not intended to be subclassed by clients. See Also: Serialized Form Restriction: This class is not intended to be subclassed by clients. '
1050, 'org.eclipse.jface.action.SubStatusLineManager', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/action/SubStatusLineManager.html', 'A contribution manager organizes contributions to such UI components as menus, toolbars and status lines. A contribution manager keeps track of a list of contribution items. Each contribution item may has an optional identifier, which can be used to retrieve items from a manager, and for positioning items relative to each other. The list of contribution items can be subdivided into named groups using special contribution items that serve as group markers. The IContributionManager interface provides general protocol for adding, removing, and retrieving contribution items. It also provides convenience methods that make it convenient to contribute actions. This interface should be implemented by all objects that wish to manage contributions. There are several implementions of this interface in this package, including ones for menus (MenuManager), tool bars (ToolBarManager), and status lines (StatusLineManager). A contribution manager organizes contributions to such UI components as menus, toolbars and status lines. A contribution manager keeps track of a list of contribution items. Each contribution item may has an optional identifier, which can be used to retrieve items from a manager, and for positioning items relative to each other. The list of contribution items can be subdivided into named groups using special contribution items that serve as group markers. The IContributionManager interface provides general protocol for adding, removing, and retrieving contribution items. It also provides convenience methods that make it convenient to contribute actions. This interface should be implemented by all objects that wish to manage contributions. There are several implementions of this interface in this package, including ones for menus (MenuManager), tool bars (ToolBarManager), and status lines (StatusLineManager). extends IContributionManager The IStatusLineManager interface provides protocol for displaying messages on a status line, for monitoring progress, and for managing contributions to the status line. Note: An error message overrides the current message until the error message is cleared. This package also provides a concrete status line manager implementation, StatusLineManager. extends SubContributionManager implements IStatusLineManager A SubStatusLineManager is used to define a set of contribution items within a parent manager. Once defined, the visibility of the entire set can be changed as a unit. '
1051, 'org.eclipse.jface.action.SubToolBarManager', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/action/SubToolBarManager.html', 'A contribution manager organizes contributions to such UI components as menus, toolbars and status lines. A contribution manager keeps track of a list of contribution items. Each contribution item may has an optional identifier, which can be used to retrieve items from a manager, and for positioning items relative to each other. The list of contribution items can be subdivided into named groups using special contribution items that serve as group markers. The IContributionManager interface provides general protocol for adding, removing, and retrieving contribution items. It also provides convenience methods that make it convenient to contribute actions. This interface should be implemented by all objects that wish to manage contributions. There are several implementions of this interface in this package, including ones for menus (MenuManager), tool bars (ToolBarManager), and status lines (StatusLineManager). A contribution manager organizes contributions to such UI components as menus, toolbars and status lines. A contribution manager keeps track of a list of contribution items. Each contribution item may has an optional identifier, which can be used to retrieve items from a manager, and for positioning items relative to each other. The list of contribution items can be subdivided into named groups using special contribution items that serve as group markers. The IContributionManager interface provides general protocol for adding, removing, and retrieving contribution items. It also provides convenience methods that make it convenient to contribute actions. This interface should be implemented by all objects that wish to manage contributions. There are several implementions of this interface in this package, including ones for menus (MenuManager), tool bars (ToolBarManager), and status lines (StatusLineManager). extends IContributionManager The IToolBarManager interface provides protocol for managing contributions to a tool bar. It extends IContributionManager but does not declare any new members; it exists only to increase the readability of code using tool bars. This package also provides a concrete tool bar manager implementation, ToolBarManager. extends SubContributionManager implements IToolBarManager A SubToolBarManager monitors the additional and removal of items from a parent manager so that visibility of the entire set can be changed as a unit. '
1052, 'org.eclipse.ui.preferences.ScopedPreferenceStore', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/preferences/ScopedPreferenceStore.html', 'The IPreferenceStore interface represents a table mapping named preferences to values. If there is no value for a given name, then that preferences\'s default value is returned; and if there is no default value for that preference, then a default-default value is returned. The default-default values for the primitive types are as follows: boolean = false double = 0.0 float = 0.0f int = 0 long = 0 String = \"\" (the empty string) Thus a preference store maintains two values for each of a set of names: a current value and a default value. The typical usage is to establish the defaults for all known preferences and then restore previously stored values for preferences whose values were different from their defaults. After the current values of the preferences have been modified, it is a simple matter to write out only those preferences whose values are different from their defaults. This two-tiered approach to saving and restoring preference setting minimized the number of preferences that need to be persisted; indeed, the normal starting state does not require storing any preferences at all. A property change event is reported whenever a preferences current value actually changes (whether through setValue, setToDefault, or other unspecified means). Note, however, that manipulating default values (with setDefault) does not cause such events to be reported. Clients who need a preference store may implement this interface or instantiate the standard implementation PreferenceStore. See Also: PreferenceStore extends IPreferenceStore IPersistentPreferenceStore is a preference store that can be saved. The IPreferenceStore interface represents a table mapping named preferences to values. If there is no value for a given name, then that preferences\'s default value is returned; and if there is no default value for that preference, then a default-default value is returned. The default-default values for the primitive types are as follows: boolean = false double = 0.0 float = 0.0f int = 0 long = 0 String = \"\" (the empty string) Thus a preference store maintains two values for each of a set of names: a current value and a default value. The typical usage is to establish the defaults for all known preferences and then restore previously stored values for preferences whose values were different from their defaults. After the current values of the preferences have been modified, it is a simple matter to write out only those preferences whose values are different from their defaults. This two-tiered approach to saving and restoring preference setting minimized the number of preferences that need to be persisted; indeed, the normal starting state does not require storing any preferences at all. A property change event is reported whenever a preferences current value actually changes (whether through setValue, setToDefault, or other unspecified means). Note, however, that manipulating default values (with setDefault) does not cause such events to be reported. Clients who need a preference store may implement this interface or instantiate the standard implementation PreferenceStore. See Also: PreferenceStore extends EventManager implements IPreferenceStore, IPersistentPreferenceStore The ScopedPreferenceStore is an IPreferenceStore that uses the scopes provided in org.eclipse.core.runtime.preferences. A ScopedPreferenceStore does the lookup of a preference based on it\'s search scopes and sets the value of the preference based on its store scope. The default scope is always included in the search scopes when searching for preference values. Since: 3.1 See Also: org.eclipse.core.runtime.preferences '
1053, 'org.eclipse.core.runtime.IPluginDescriptor', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/runtime/IPluginDescriptor.html', 'A plug-in descriptor contains information about a plug-in obtained from the plug-in\'s manifest (plugin.xml) file. Plug-in descriptors are platform-defined objects that exist in the plug-in registry independent of whether a plug-in has been started. In contrast, a plug-in\'s runtime object (getPlugin) generally runs plug-in-defined code. See Also: getPlugin() Restriction: This interface is not intended to be implemented by clients. '
1054, 'org.eclipse.swt.SWTError', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/SWTError.html', 'extends Error This error is thrown whenever an unrecoverable error occurs internally in SWT. The message text and error code provide a further description of the problem. The exception has a throwable field which holds the underlying throwable that caused the problem (if this information is available (i.e. it may be null)). SWTErrors are thrown when something fails internally which either leaves SWT in an unknown state (eg. the o/s call to remove an item from a list returns an error code) or when SWT is left in a known-to-be-unrecoverable state (eg. it runs out of callback resources). SWTErrors should not occur in typical programs, although \"high reliability\" applications should still catch them. This class also provides support methods used by SWT to match error codes to the appropriate exception class (SWTError, SWTException, or IllegalArgumentException) and to provide human readable strings for SWT error codes. See Also: SWTException, SWT.error(int), Sample code and further information, Serialized Form '
1055, 'org.eclipse.ui.IPersistable', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/IPersistable.html', 'Objects implementing this interface are capable of saving their state in an IMemento. Since: 3.1 '
1056, 'org.eclipse.ui.IPerspectiveListener', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/IPerspectiveListener.html', 'Interface for listening to perspective lifecycle events. This interface may be implemented by clients. See Also: IPageService.addPerspectiveListener(IPerspectiveListener), PerspectiveAdapter '
1057, 'org.eclipse.ui.IKeyBindingService', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/IKeyBindingService.html', 'The key binding service allows one to query or set the scope of Eclipse for the purposes of resolving key assignments to commands, and to register actions to handle specific commands. See the org.eclipse.ui.commands extension point for details. A participating workbench part is responsible to register all its actions with this service. The part is also responsible to set the current scope. This interface is not intended to be implemented or extended by clients. Since: 2.0 Restriction: This interface is not intended to be implemented by clients. '
1058, 'org.eclipse.jface.viewers.DecoratingLabelProvider', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/viewers/DecoratingLabelProvider.html', 'A label provider maps an element of the viewer\'s model to an optional image and optional text string used to display the element in the viewer\'s control. Certain label providers may allow multiple labels per element. This is an \"abstract interface\", defining methods common to all label providers, but does not actually define the methods to get the label(s) for an element. This interface should never be directly implemented. Most viewers will take either an ILabelProvider or an ITableLabelProvider. A label provider must not be shared between viewers since a label provider generally manages SWT resources (images), which must be disposed when the viewer is disposed. To simplify life cycle management, the current label provider of a viewer is disposed when the viewer is disposed. Label providers can be used outside the context of viewers wherever images are needed. When label providers are used in this fashion it is the responsibility of the user to ensure dispose is called when the provider is no longer needed. See Also: ILabelProvider, ITableLabelProvider Interface to provide color representation for a given element. See Also: IColorDecorator Interface to provide font representation for a given element. Since: 3.0 See Also: IFontDecorator A label provider maps an element of the viewer\'s model to an optional image and optional text string used to display the element in the viewer\'s control. Certain label providers may allow multiple labels per element. This is an \"abstract interface\", defining methods common to all label providers, but does not actually define the methods to get the label(s) for an element. This interface should never be directly implemented. Most viewers will take either an ILabelProvider or an ITableLabelProvider. A label provider must not be shared between viewers since a label provider generally manages SWT resources (images), which must be disposed when the viewer is disposed. To simplify life cycle management, the current label provider of a viewer is disposed when the viewer is disposed. Label providers can be used outside the context of viewers wherever images are needed. When label providers are used in this fashion it is the responsibility of the user to ensure dispose is called when the provider is no longer needed. See Also: ILabelProvider, ITableLabelProvider extends IBaseLabelProvider Extends IBaseLabelProvider with the methods to provide the text and/or image for the label of a given element. Used by most structured viewers, except table viewers. A label provider maps an element of the viewer\'s model to an optional image and optional text string used to display the element in the viewer\'s control. Certain label providers may allow multiple labels per element. This is an \"abstract interface\", defining methods common to all label providers, but does not actually define the methods to get the label(s) for an element. This interface should never be directly implemented. Most viewers will take either an ILabelProvider or an ITableLabelProvider. A label provider must not be shared between viewers since a label provider generally manages SWT resources (images), which must be disposed when the viewer is disposed. To simplify life cycle management, the current label provider of a viewer is disposed when the viewer is disposed. Label providers can be used outside the context of viewers wherever images are needed. When label providers are used in this fashion it is the responsibility of the user to ensure dispose is called when the provider is no longer needed. See Also: ILabelProvider, ITableLabelProvider extends IBaseLabelProvider An extension to ILabelProvider that is given the path of the element being decorated, when it is available. Since: 3.2 A label provider maps an element of the viewer\'s model to an optional image and optional text string used to display the element in the viewer\'s control. Certain label providers may allow multiple labels per element. This is an \"abstract interface\", defining methods common to all label providers, but does not actually define the methods to get the label(s) for an element. This interface should never be directly implemented. Most viewers will take either an ILabelProvider or an ITableLabelProvider. A label provider must not be shared between viewers since a label provider generally manages SWT resources (images), which must be disposed when the viewer is disposed. To simplify life cycle management, the current label provider of a viewer is disposed when the viewer is disposed. Label providers can be used outside the context of viewers wherever images are needed. When label providers are used in this fashion it is the responsibility of the user to ensure dispose is called when the provider is no longer needed. See Also: ILabelProvider, ITableLabelProvider extends IBaseLabelProvider Extends IBaseLabelProvider with the methods to update the label for a given element. The label is represented by a ViewerLabel. Unlike ILabelProvider, this allows the text and image to be set in the same request, rather than via separate requests. It also allows the current values for the text and image to be considered by the label provider, allowing for potential optimizations. For example, decorating label providers that run in the background can hold off applying an update to a previously populated label until the decoration is ready, thereby reducing flicker. Since: 3.0 See Also: IDelayedLabelDecorator extends LabelProvider implements ILabelProvider, IViewerLabelProvider, IColorProvider, IFontProvider, ITreePathLabelProvider A decorating label provider is a label provider which combines a nested label provider and an optional decorator. The decorator decorates the label text, image, font and colors provided by the nested label provider. '
1059, 'org.eclipse.ui.model.IWorkbenchAdapter2', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/model/IWorkbenchAdapter2.html', 'Extension interface for IWorkbenchAdapter that allows for color and font support. There is an associate label provider and content provider for showing elements with a registered workbench adapter in JFace structured viewers. Since: 3.0 See Also: IWorkbenchAdapter, WorkbenchLabelProvider, BaseWorkbenchContentProvider '
1060, 'org.eclipse.ui.model.IWorkbenchAdapter3', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/model/IWorkbenchAdapter3.html', 'Extension interface for IWorkbenchAdapter that allows for StyledString support. Since: 3.7 See Also: IWorkbenchAdapter, WorkbenchLabelProvider, BaseWorkbenchContentProvider, DelegatingStyledCellLabelProvider.IStyledLabelProvider '
1061, 'org.eclipse.ui.keys.IKeyFormatter', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/keys/IKeyFormatter.html', 'Any formatter capable of taking key sequence or a key stroke and converting it into a string. These formatters are used to produce the strings that the user sees in the keys preference page and the menus, as well as the strings that are used for persistent storage. Since: 3.0 '
1062, 'org.eclipse.ui.keys.KeyStroke', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/keys/KeyStroke.html', 'extends Object implements Comparable A KeyStroke is defined as an optional set of modifier keys followed optionally by a natural key. A KeyStroke is said to be complete if it contains a natural key. A natural key is any Unicode character (e.g., \"backspace\", etc.), any character belonging to a natural language (e.g., \"A\", \"1\", \"[\", etc.), or any special control character specific to computers (e.g., \"F10\", \"PageUp\", etc.). All KeyStroke objects have a formal string representation available via the toString() method. There are a number of methods to get instances of KeyStroke objects, including one which can parse this formal string representation. All KeyStroke objects, via the format() method, provide a version of their formal string representation translated by platform and locale, suitable for display to a user. KeyStroke objects are immutable. Clients are not permitted to extend this class. Since: 3.0 See Also: ModifierKey, NaturalKey '
1063, 'org.eclipse.ui.keys.NaturalKey', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/keys/NaturalKey.html', 'extends Key Instances of NaturalKey represent all keys on the keyboard not known by convention as \'modifier keys\'. These can either be keys that belong to a natural language of some kind(e.g., \"A\", \"1\"), any Unicode character (e.g., \"backspace\"), or they can be special controls keys used by computers (e.g., \"F10\", \"PageUp\"). NaturalKey objects are immutable. Clients are not permitted to extend this class. Since: 3.0 Restriction: This class is not intended to be subclassed by clients. '
1064, 'org.eclipse.ui.keys.CharacterKey', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/keys/CharacterKey.html', 'extends NaturalKey Instances of CharacterKey represent keys on the keyboard which represent unicode characters. CharacterKey objects are immutable. Clients are not permitted to extend this class. Since: 3.0 '
1065, 'org.eclipse.ui.keys.ModifierKey', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/keys/ModifierKey.html', 'extends Key Instances of ModifierKey represent the four keys on the keyboard recognized by convention as \'modifier keys\', those keys typically pressed in combination with themselves and/or a NaturalKey. ModifierKey objects are immutable. Clients are not permitted to extend this class. Since: 3.0 See Also: NaturalKey '
1066, 'org.eclipse.ui.keys.SpecialKey', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/keys/SpecialKey.html', 'extends NaturalKey Instances of SpecialKey represent the keys on keyboard recognized as neither modifier keys nor character keys. These are special control keys specific to computers (e.g., \"left arrow\", \"page down\", \"F10\", etc.). They do not include keys representing letters, numbers or punctuation from a natural language, nor do they include any key that can be represented by a Unicode character (e.g., \"backspace\"). SpecialKey objects are immutable. Clients are not permitted to extend this class. Since: 3.0 '
1067, 'org.eclipse.ui.branding.IProductConstants', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/branding/IProductConstants.html', 'These constants define the set of properties that the UI expects to be available via IProduct.getProperty(String). Since: 3.0 See Also: IProduct.getProperty(String) '
1068, 'org.eclipse.ui.model.IComparableContribution', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/model/IComparableContribution.html', 'An interface for an adaptable object. Adaptable objects can be dynamically extended to provide different interfaces (or \"adapters\"). Adapters are created by adapter factories, which are in turn managed by type by adapter managers. For example, IAdaptable a = [some adaptable]; IFoo x = (IFoo)a.getAdapter(IFoo.class); if (x != null) [do IFoo things with x] This interface can be used without OSGi running. Clients may implement this interface, or obtain a default implementation of this interface by subclassing PlatformObject. See Also: IAdapterFactory, IAdapterManager, PlatformObject extends IAdaptable Instances of this interface represent a contribution within the workbench. This interface is typically implemented by the workbench itself although extension developers may wish to implement it as well for their own extensions. Since: 3.4 '
1069, 'org.eclipse.ui.IWorkbenchPropertyPageMulti', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/IWorkbenchPropertyPageMulti.html', 'Interface for a page in a multi-page dialog. Interface for a page in a multi-page dialog. extends IDialogPage An interface for a preference page. This interface is used primarily by the page\'s container extends IPreferencePage This interface is similar to IWorkbenchPropertyPage with the addition of support for multiple selection. Since: 3.7 See Also: IWorkbenchPropertyPage '
1070, 'org.eclipse.ui.IActionFilter', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/IActionFilter.html', 'An adapter which performs action filtering. Within the workbench a plugin may extend the actions which appear in the context menu for any object. The visibility of each action extension is controlled by action filtering. By default, the workbench will filter each action extension using the objectClass and optional nameFilter attributes defined in xml. If the action extension passes this test the action will be added to the context menu for the object. In some situations the object class and name are not enough to describe the intended target action. In those situations an action extension may define one or more filter sub-elements. Each one of these elements describes one attribute of the action target using a name value pair. The attributes for an object are type specific and beyond the domain of the workbench itself, so the workbench will delegate filtering at this level to an IActionFilter. This is a filtering strategy which is provided by the selection itself and may perform type specific filtering. The workbench will retrieve the filter from the selected object by testing to see if it implements IActionFilter. If that fails, the workbench will ask for a filter through through the IAdaptable mechanism. If a filter is found the workbench will pass each name value pair to the filter to determine if it matches the state of the selected object. If so, or there is no filter, the action will be added to the context menu for the object. Clients that implement this filter mechanism are strongly encouraged to extend this interface to provide a list of attribute names and possible values that are considered public for other clients to reference. See Also: IAdaptable '
1071, 'org.eclipse.ui.SelectionEnabler', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/SelectionEnabler.html', 'extends Object Determines the enablement status given a selection. This calculation is done based on the definition of the enablesFor attribute, enablement element, and the selection element found in the IConfigurationElement provided. This class can be instantiated by clients. It is not intended to be extended. Since: 3.0 Note: The dependency on org.eclipse.jface.text for ITextSelection must be severed It may be possible to do with IActionFilter generic workbench registers IActionFilter for \"size\" property against IStructuredSelection workbench text registers IActionFilter for \"size\" property against ITextSelection code here: sel.getAdapter(IActionFilter.class) As an interim solution, use reflection to access selections implementing ITextSelection '
1072, 'org.eclipse.core.runtime.IBundleGroupProvider', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/runtime/IBundleGroupProvider.html', 'Bundle group providers define groups of plug-ins which have been installed in the current system. Typically, a configuration agent (i.e., plug-in installer) will define a bundle group provider so that it can report to the system the list of plug-ins it has installed. Since: 3.0 See Also: IBundleGroup '
1073, 'org.eclipse.core.runtime.IBundleGroup', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/runtime/IBundleGroup.html', 'Bundle groups represent a logical collection of plug-ins (aka bundles). Bundle groups do not contain their constituents but rather collect them together under a common label. The main role of a bundle group is to report to the system (e.g., the About dialog) what bundles have been installed. They are not intended for use in managing the set of bundles they represent. Since the bulk of the branding related information is specific to the consumer, bundle groups also carry an arbitrary set of properties. The valid set of key-value pairs and their interpretation defined by the consumer in the target environment. The Eclipse UI is the typical consumer of bundle groups and defines various property keys that it will use, for example, to display About information. See org.eclipse.ui.branding.IBundleGroupConstants. Since: 3.0 See Also: IBundleGroupProvider '
1074, 'org.eclipse.ui.IFileEditorMapping', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/IFileEditorMapping.html', 'An association between a file name/extension and a list of known editors for files of that type. The name and extension can never empty or null. The name may contain the single wild card character (*) to indicate the editor applies to all files with the same extension (e.g. *.doc). The name can never embed the wild card character within itself (i.e. rep*) This interface is not intended to be implemented by clients. See Also: IEditorRegistry.getFileEditorMappings() Restriction: This interface is not intended to be implemented by clients. '
1075, 'org.eclipse.ui.dialogs.EditorSelectionDialog', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/dialogs/EditorSelectionDialog.html', 'Interface for objects that can return a shell. This is normally used for opening child windows. An object that wants to open child shells can take an IShellProvider in its constructor, and the object that implements IShellProvider can dynamically choose where child shells should be opened. Since: 3.1 extends Dialog This class is used to allow the user to select a dialog from the set of internal and external editors. Since: 3.3 '
1076, 'org.eclipse.ui.model.PerspectiveLabelProvider', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/model/PerspectiveLabelProvider.html', 'A label provider maps an element of the viewer\'s model to an optional image and optional text string used to display the element in the viewer\'s control. Certain label providers may allow multiple labels per element. This is an \"abstract interface\", defining methods common to all label providers, but does not actually define the methods to get the label(s) for an element. This interface should never be directly implemented. Most viewers will take either an ILabelProvider or an ITableLabelProvider. A label provider must not be shared between viewers since a label provider generally manages SWT resources (images), which must be disposed when the viewer is disposed. To simplify life cycle management, the current label provider of a viewer is disposed when the viewer is disposed. Label providers can be used outside the context of viewers wherever images are needed. When label providers are used in this fashion it is the responsibility of the user to ensure dispose is called when the provider is no longer needed. See Also: ILabelProvider, ITableLabelProvider A label provider maps an element of the viewer\'s model to an optional image and optional text string used to display the element in the viewer\'s control. Certain label providers may allow multiple labels per element. This is an \"abstract interface\", defining methods common to all label providers, but does not actually define the methods to get the label(s) for an element. This interface should never be directly implemented. Most viewers will take either an ILabelProvider or an ITableLabelProvider. A label provider must not be shared between viewers since a label provider generally manages SWT resources (images), which must be disposed when the viewer is disposed. To simplify life cycle management, the current label provider of a viewer is disposed when the viewer is disposed. Label providers can be used outside the context of viewers wherever images are needed. When label providers are used in this fashion it is the responsibility of the user to ensure dispose is called when the provider is no longer needed. See Also: ILabelProvider, ITableLabelProvider extends IBaseLabelProvider Extends IBaseLabelProvider with the methods to provide the text and/or image for the label of a given element. Used by most structured viewers, except table viewers. A label provider maps an element of the viewer\'s model to an optional image and optional text string used to display the element in the viewer\'s control. Certain label providers may allow multiple labels per element. This is an \"abstract interface\", defining methods common to all label providers, but does not actually define the methods to get the label(s) for an element. This interface should never be directly implemented. Most viewers will take either an ILabelProvider or an ITableLabelProvider. A label provider must not be shared between viewers since a label provider generally manages SWT resources (images), which must be disposed when the viewer is disposed. To simplify life cycle management, the current label provider of a viewer is disposed when the viewer is disposed. Label providers can be used outside the context of viewers wherever images are needed. When label providers are used in this fashion it is the responsibility of the user to ensure dispose is called when the provider is no longer needed. See Also: ILabelProvider, ITableLabelProvider extends IBaseLabelProvider Extends IBaseLabelProvider with the methods to provide the text and/or image for each column of a given element. Used by table viewers. See Also: TableViewer extends LabelProvider implements ITableLabelProvider A table label provider implementation for showing workbench perspectives (objects of type IPerspectiveDescriptor) in table- and tree-structured viewers. Clients may instantiate this class. It is not intended to be subclassed. Since: 3.0 '
1077, 'org.eclipse.ui.activities.ITriggerPoint', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/activities/ITriggerPoint.html', 'A trigger point represents a place within the Workbench that has the potential to enable activities. Instances of this class may be obtained from ITriggerPointManager.getTriggerPoint(String). Instances of this interface are passed as a parameter to ITriggerPointAdvisor.allow(ITriggerPoint, IIdentifier) and may be used by the advisor to determine policy. This interface is not intended to be extended or implemented by clients. Since: 3.1 See Also: ITriggerPointAdvisor, ITriggerPointManager Restriction: This interface is not intended to be implemented by clients. '
1078, 'org.eclipse.core.runtime.dynamichelpers.ExtensionTracker', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/runtime/dynamichelpers/ExtensionTracker.html', 'An extension tracker keeps associations between extensions and their derived objects on an extension basis. All extensions being added in a tracker will automatically be removed when the extension is uninstalled from the registry. Users interested in extension removal can register a handler that will let them know when an object is being removed. This interface can be used without OSGi running. This interface is not intended to be implemented by clients. Since: 3.1 Restriction: This interface is not intended to be implemented by clients. extends EventListener Note: for new implementations consider using IRegistryEventListener. A registry change listener is notified of changes to extensions points in the registry. These changes arise from subsequent manipulation of the registry after it was initially created. This interface can be used without OSGi running. Clients may implement this interface. Since: 3.0 See Also: IExtensionRegistry, IRegistryChangeEvent extends Object implements IExtensionTracker, IRegistryChangeListener Implementation of the IExtensionTracker. This class can be used without OSGi running. Since: 3.1 See Also: IExtensionTracker '
1079, 'org.eclipse.ui.statushandlers.AbstractStatusAreaProvider', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/statushandlers/AbstractStatusAreaProvider.html', 'extends ErrorSupportProvider A status area provider creates an area that displays detailed information about StatusAdapter or IStatus. The area provider can be set in WorkbenchStatusDialogManager as well as in JFace Policy since its extends ErrorSupportProvider. Since: 3.4 See Also: Policy.setErrorSupportProvider(ErrorSupportProvider), WorkbenchStatusDialogManager.setSupportAreaProvider(AbstractStatusAreaProvider), WorkbenchStatusDialogManager.setDetailsAreaProvider(AbstractStatusAreaProvider) '
1080, 'org.eclipse.ui.browser.IWebBrowser', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/browser/IWebBrowser.html', 'An opened Web browser instance (either internal or external). This interface is not intended to be implemented by clients. Since: 3.1 See Also: IWorkbenchBrowserSupport Restriction: This interface is not intended to be implemented by clients. '
1081, 'org.eclipse.core.runtime.preferences.IPreferenceFilter', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/runtime/preferences/IPreferenceFilter.html', 'Preference filters are used to describe the relationship between the preference tree and a data set when importing/exporting preferences. For instance, a client is able to create a preference filter describing which preference nodes/keys should be used when exporting the \"Key Bindings\" preferences. When the export happens, the tree is trimmed and only the applicable preferences will be exported. Clients may implement this interface. Since: 3.1 '
1082, 'org.eclipse.core.runtime.preferences.IPreferencesService', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/runtime/preferences/IPreferencesService.html', 'The preference service provides facilities for dealing with the default scope precedence lookup order, querying the preference store for values using this order, accessing the root of the preference store node hierarchy, and importing/exporting preferences. The default-default preference search look-up order as defined by the platform is: project, instance, configuration, default. This interface is not intended to be implemented by clients. Since: 3.0 Restriction: This interface is not intended to be implemented by clients. Restriction: This interface is not intended to be extended by clients. '
1083, 'org.eclipse.core.runtime.preferences.IExportedPreferences', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/runtime/preferences/IExportedPreferences.html', 'extends org.osgi.service.prefs.Preferences This interface describes Eclipse extensions to the preference story. It provides means for both preference and node change listeners. Clients may implement this interface. Since: 3.0 See Also: Preferences extends IEclipsePreferences Represents a node in the preference hierarchy which is used in the import/export mechanism. This interface is not intended to be implemented by clients. Since: 3.0 Restriction: This interface is not intended to be implemented by clients. Restriction: This interface is not intended to be extended by clients. '
1084, 'org.eclipse.ui.splash.BasicSplashHandler', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/splash/BasicSplashHandler.html', 'extends AbstractSplashHandler Basic splash implementation that provides an absolute positioned progress bar and message string that is hooked up to a progress monitor. Since: 3.3 '
1085, 'org.eclipse.ui.activities.IIdentifierListener', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/activities/IIdentifierListener.html', 'An instance of this interface can be used by clients to receive notification of changes to one or more instances of IIdentifier. This interface may be implemented by clients. Since: 3.0 See Also: IIdentifier.addIdentifierListener(IIdentifierListener), IIdentifier.removeIdentifierListener(IIdentifierListener) '
1086, 'org.eclipse.ui.activities.IActivityManagerListener', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/activities/IActivityManagerListener.html', 'An instance of this interface can be used by clients to receive notification of changes to one or more instances of IActivityManager. This interface may be implemented by clients. Since: 3.0 See Also: IActivityManager.addActivityManagerListener(IActivityManagerListener), IActivityManager.removeActivityManagerListener(IActivityManagerListener) '
1087, 'org.eclipse.ui.activities.IdentifierEvent', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/activities/IdentifierEvent.html', 'extends Object An instance of this class describes changes to an instance of IIdentifier. This class does not give details as to the specifics of a change, only that the given property on the source object has changed. This class is not intended to be extended by clients. Since: 3.0 See Also: IIdentifierListener.identifierChanged(IdentifierEvent) '
1088, 'org.eclipse.ui.activities.ActivityManagerEvent', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/activities/ActivityManagerEvent.html', 'extends Object An instance of this class describes changes to an instance of IActivityManager. This class does not give details as to the specifics of a change, only that the given property on the source object has changed. This class is not intended to be extended by clients. Since: 3.0 See Also: IActivityManagerListener.activityManagerChanged(ActivityManagerEvent) '
1089, 'org.eclipse.ui.testing.IWorkbenchPartTestable', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/testing/IWorkbenchPartTestable.html', 'This interface provides methods that allow introspection of workbench parts. Instances may be obtained by calling IAdaptable.getAdapter(Class) on IWorkbenchPartSite. This interface is not intended to be implemented or extended by clients. Since: 3.3 '
1090, 'org.eclipse.ui.INavigationLocation', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/INavigationLocation.html', 'Represents the context marked for the user in the navigation history. Not intended to be implemented by clients. Clients should subclass NavigationLocation instead. Since: 2.1 Restriction: This interface is not intended to be implemented by clients. '
1091, 'org.eclipse.ui.INavigationLocationProvider', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/INavigationLocationProvider.html', 'Should be implemented by editors that wish to contribute to the navigation history. The message createNavigationLocation will be sent when a new location is marked in the history. Since: 2.1 '
1092, 'org.eclipse.swt.custom.CBanner', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/custom/CBanner.html', 'Implementers of Drawable can have a graphics context (GC) created for them, and then they can be drawn on by sending messages to their associated GC. SWT images, and device objects such as the Display device and the Printer device, are drawables. IMPORTANT: This interface is not part of the SWT public API. It is marked public only so that it can be shared within the packages provided by SWT. It should never be referenced from application code. See Also: Device, Image, GC extends Composite Instances of this class implement a Composite that lays out its children and allows programmatic control of the layout. It draws a separator between the left and right children which can be dragged to resize the right control. CBanner is used in the workbench to layout the toolbar area and perspective switching toolbar. Note that although this class is a subclass of Composite, it does not make sense to set a layout on it. Styles: NONE Events: (None) IMPORTANT: This class is not intended to be subclassed. Since: 3.0 See Also: Sample code and further information Restriction: This class is not intended to be subclassed by clients. '
1093, 'org.eclipse.ui.INestableKeyBindingService', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/INestableKeyBindingService.html', 'extends IKeyBindingService A service that is capable of nesting other services within itself. This allows lower level components to query for a service provider in a hierarchical fashion, and for information to be resolved in a hierarchical manner This interface is not intended to be implemented or extended by clients. Since: 2.1.3 Restriction: This interface is not intended to be implemented by clients. '
1094, 'org.eclipse.ui.LegacyHandlerSubmissionExpression', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/LegacyHandlerSubmissionExpression.html', 'extends Expression An expression encapsulating all of the information from legacy handler submissions. Since: 3.1 '
1095, 'org.eclipse.ui.intro.IIntroPart', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/intro/IIntroPart.html', 'An interface for an adaptable object. Adaptable objects can be dynamically extended to provide different interfaces (or \"adapters\"). Adapters are created by adapter factories, which are in turn managed by type by adapter managers. For example, IAdaptable a = [some adaptable]; IFoo x = (IFoo)a.getAdapter(IFoo.class); if (x != null) [do IFoo things with x] This interface can be used without OSGi running. Clients may implement this interface, or obtain a default implementation of this interface by subclassing PlatformObject. See Also: IAdapterFactory, IAdapterManager, PlatformObject extends IAdaptable The intro part is a visual component within the workbench responsible for introducing the product to new users. The intro part is typically shown the first time a product is started up. The intro part implementation is contributed to the workbench via the org.eclipse.ui.intro extension point. There can be several intro part implementations, and associations between intro part implementations and products. The workbench will only make use of the intro part implementation for the current product (as given by Platform.getProduct(). There is at most one intro part instance in the entire workbench, and it resides in exactly one workbench window at a time. This interface in not intended to be directly implemented. Rather, clients providing a intro part implementation should subclass IntroPart. Since: 3.0 See Also: IIntroManager.showIntro(org.eclipse.ui.IWorkbenchWindow, boolean) Restriction: This interface is not intended to be implemented by clients. '
1096, 'org.eclipse.ui.intro.IntroContentDetector', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/intro/IntroContentDetector.html', 'extends Object An intro content detector is used when starting the Workbench to determine if new intro content is available. Since calling this method is part of the Workbench start sequence, subclasses should be implemented with care as not to introduce noticeable delay at startup. If an intro content detector reports new available content, the view part showing the content will be opened again even if the user had closed it in a previous session. Because of this, the intro view part should draw the user\'s attention to the new content to avoid confusion about why the intro view part was opened again without the user requesting it. Since: 3.3 '
1097, 'org.eclipse.core.runtime.jobs.LockListener', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/runtime/jobs/LockListener.html', 'extends Object A lock listener is notified whenever a thread is about to wait on a lock, and when a thread is about to release a lock. This class is for internal use by the platform-related plug-ins. Clients outside of the base platform should not reference or subclass this class. Since: 3.0 See Also: IJobManager.setLockListener(LockListener) '
1098, 'org.eclipse.ui.intro.IIntroSite', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/intro/IIntroSite.html', 'An interface for an adaptable object. Adaptable objects can be dynamically extended to provide different interfaces (or \"adapters\"). Adapters are created by adapter factories, which are in turn managed by type by adapter managers. For example, IAdaptable a = [some adaptable]; IFoo x = (IFoo)a.getAdapter(IFoo.class); if (x != null) [do IFoo things with x] This interface can be used without OSGi running. Clients may implement this interface, or obtain a default implementation of this interface by subclassing PlatformObject. See Also: IAdapterFactory, IAdapterManager, PlatformObject A component with which one or more services are registered. The services can be retrieved from this locator using some key -- typically the class representing the interface the service must implement. For example: IHandlerService service = (IHandlerService) workbenchWindow .getService(IHandlerService.class); This interface is not to be implemented or extended by clients. Since: 3.2 Interface for objects that can return a shell. This is normally used for opening child windows. An object that wants to open child shells can take an IShellProvider in its constructor, and the object that implements IShellProvider can dynamically choose where child shells should be opened. Since: 3.1 extends IAdaptable, IShellProvider, IServiceLocator The common interface between the workbench and its parts, including pages within parts. The workbench site supports a few services by default. If these services are used to allocate resources, it is important to remember to clean up those resources after you are done with them. Otherwise, the resources will exist until the workbench site is disposed. The supported services are: ICommandService IContextService IHandlerService IBindingService. Resources allocated through this service will not be cleaned up until the workbench shuts down. This interface is not intended to be implemented or extended by clients. Since: 2.0 See Also: IWorkbenchPartSite, IPageSite Restriction: This interface is not intended to be implemented by clients. extends IWorkbenchSite The primary interface between an intro part and the workbench. The workbench exposes its implemention of intro part sites via this interface, which is not intended to be implemented or extended by clients. Since: 3.0 Restriction: This interface is not intended to be implemented by clients. '
1099, 'org.eclipse.ui.part.IShowInTarget', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/part/IShowInTarget.html', 'This interface must be provided by Show In targets (parts listed in the Show In prompter). The part can either directly implement this interface, or provide it via IAdaptable.getAdapter(IShowInTarget.class). Since: 2.1 See Also: IPageLayout.addShowInPart(java.lang.String) '
1100, 'org.eclipse.ui.commands.ICommand', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/commands/ICommand.html', 'extends Comparable An instance of ICommand is a handle representing a command as defined by the extension point org.eclipse.ui.commands. The identifier of the handle is identifier of the command being represented. An instance of ICommand can be obtained from an instance of ICommandManager for any identifier, whether or not a command with that identifier defined in the plugin registry. The handle-based nature of this API allows it to work well with runtime plugin activation and deactivation. If a command is defined, that means that its corresponding plug-in is active. If the plug-in is then deactivated, the command will still exist but it will be undefined. An attempts to use an undefined command will result in a NotDefinedException being thrown. This interface is not intended to be extended or implemented by clients. Since: 3.0 See Also: ICommandListener, ICommandManager, Command Restriction: This interface is not intended to be implemented by clients. '
1101, 'org.eclipse.ui.commands.ICommandListener', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/commands/ICommandListener.html', 'An instance of this interface can be used by clients to receive notification of changes to one or more instances of ICommand. This interface may be implemented by clients. Since: 3.0 See Also: ICommand.addCommandListener(ICommandListener), ICommand.removeCommandListener(ICommandListener), ICommandListener '
1102, 'org.eclipse.ui.commands.ICommandManager', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/commands/ICommandManager.html', ' An instance of ICommandManager can be used to obtain instances of ICommand, as well as manage whether or not those instances are active or inactive, enabled or disabled. This interface is not intended to be extended or implemented by clients. Since: 3.0 See Also: ICommand, ICommandManagerListener, CommandManager Restriction: This interface is not intended to be implemented by clients. '
1103, 'org.eclipse.ui.commands.ICommandManagerListener', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/commands/ICommandManagerListener.html', 'An instance of this interface can be used by clients to receive notification of changes to one or more instances of ICommandManager. This interface may be implemented by clients. Since: 3.0 See Also: ICommandManager.addCommandManagerListener(ICommandManagerListener), ICommandManager.removeCommandManagerListener(ICommandManagerListener), ICommandManagerListener '
1104, 'org.eclipse.ui.keys.KeySequence', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/keys/KeySequence.html', 'extends Object implements Comparable A KeySequence is defined as a list of zero or more KeyStrokes, with the stipulation that all KeyStroke objects must be complete, save for the last one, whose completeness is optional. A KeySequence is said to be complete if all of its KeyStroke objects are complete. All KeySequence objects have a formal string representation available via the toString() method. There are a number of methods to get instances of KeySequence objects, including one which can parse this formal string representation. All KeySequence objects, via the format() method, provide a version of their formal string representation translated by platform and locale, suitable for display to a user. KeySequence objects are immutable. Clients are not permitted to extend this class. Since: 3.0 '
1105, 'org.eclipse.ui.commands.CommandManagerEvent', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/commands/CommandManagerEvent.html', 'extends Object An instance of this class describes changes to an instance of ICommandManager. This class is not intended to be extended by clients. Since: 3.0 See Also: ICommandManagerListener.commandManagerChanged(CommandManagerEvent), CommandManagerEvent '
1106, 'org.eclipse.ui.commands.ICategory', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/commands/ICategory.html', 'extends Comparable A category is a grouping of commands by functional area. For example, in the Eclipse workbench, \"Text Editing\" is a category containing various commands related to text editing. A category\'s primary functionality is to control the display of commands to the user. When appropriate, commands displayed to the user (e.g., keys preference page) will be grouped by category. An instance of ICategory is a handle representing a category as defined by the extension point org.eclipse.ui.commands. The identifier of the handle is identifier of the category being represented. An instance of ICategory can be obtained from an instance of ICommandManager for any identifier, whether or not a category with that identifier defined in the plugin registry. The handle-based nature of this API allows it to work well with runtime plugin activation and deactivation, which causes dynamic changes to the plugin registry, and therefore, potentially, dynamic changes to the set of category definitions. This interface is not intended to be extended or implemented by clients. Since: 3.0 See Also: ICategoryListener, ICommandManager, Category Restriction: This interface is not intended to be implemented by clients. '
1107, 'org.eclipse.ui.commands.IKeyConfiguration', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/commands/IKeyConfiguration.html', 'extends Comparable An instance of IKeyConfiguration is a handle representing a key configuration as defined by the extension point org.eclipse.ui.commands. The identifier of the handle is identifier of the key configuration being represented. An instance of IKeyConfiguration can be obtained from an instance of ICommandManager for any identifier, whether or not a key configuration with that identifier defined in the plugin registry. The handle-based nature of this API allows it to work well with runtime plugin activation and deactivation. If a key configuration is defined, that means that its corresponding plug-in is active. If the plug-in is then deactivated, the configuration will still exist but it will be undefined. An attempt to use an undefined key configuration will result in a NotDefinedException being thrown. This interface is not intended to be extended or implemented by clients. Since: 3.0 See Also: IKeyConfigurationListener, ICommandManager, Scheme Restriction: This interface is not intended to be implemented by clients. '
1108, 'org.eclipse.ui.services.AbstractServiceFactory', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/services/AbstractServiceFactory.html', 'extends Object A factory for creating services for use with the org.eclipse.ui.services extension point. You are given a service locator to look up other services, and can retrieve your parent service (if one has already been created). Since: 3.4 '
1109, 'org.eclipse.ui.actions.PerspectiveMenu', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/actions/PerspectiveMenu.html', 'A contribution item represents a contribution to a shared UI resource such as a menu or tool bar. More generally, contribution items are managed by a contribution manager. For instance, in a tool bar a contribution item is a tool bar button or a separator. In a menu bar a contribution item is a menu, and in a menu a contribution item is a menu item or separator. A contribution item can realize itself in different SWT widgets, using the different fill methods. The same type of contribution item can be used with a MenuBarManager, ToolBarManager, CoolBarManager, or a StatusLineManager. This interface is internal to the framework; it should not be implemented outside the framework. See Also: IContributionManager Restriction: This interface is not intended to be implemented by clients. extends ContributionItem A menu for perspective selection. A PerspectiveMenu is used to populate a menu with perspective shortcut items. If the user selects one of these items an action is performed for the selected perspective. The visible perspective items within the menu are dynamic and reflect the available set generated by each subclass. The default available set consists of the perspective shortcut list of the current perspective. This class is abstract. Subclasses must implement the run method, which performs a specialized action for the selected perspective. '
1110, 'org.eclipse.osgi.signedcontent.SignedContentFactory', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/osgi/signedcontent/SignedContentFactory.html', 'A factory used to create SignedContent objects. The framework will register a factory implementation as an OSGi service. This service can be used to get SignedContent for a bundle. It can also be used to get SignedContent for a repository file. The supported formats for file repositories are jar files and directories containing the content of an extracted jar. This interface is not intended to be implemented by clients. Since: 3.4 Restriction: This interface is not intended to be implemented by clients. '
1111, 'org.eclipse.osgi.signedcontent.SignedContent', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/osgi/signedcontent/SignedContent.html', 'A SignedContent object represents content which may be signed. A SignedContentFactory is used to create signed content objects. A SignedContent object is intended to provide information about the signers of the content, and cannot be used to access the actual data of the content. This interface is not intended to be implemented by clients. Since: 3.4 Restriction: This interface is not intended to be implemented by clients. '
1112, 'org.eclipse.osgi.signedcontent.SignerInfo', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/osgi/signedcontent/SignerInfo.html', 'A SignerInfo object represents a single signer chain. This interface is not intended to be implemented by clients. Since: 3.4 Restriction: This interface is not intended to be implemented by clients. '
1113, 'org.eclipse.osgi.util.TextProcessor', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/osgi/util/TextProcessor.html', 'extends Object This class is used to process strings that have special semantic meaning (such as file paths) in RTL-oriented locales so that they render in a way that does not corrupt the semantic meaning of the string but also maintains compliance with the Unicode BiDi algorithm of rendering Bidirectional text. Processing of the string is done by breaking it down into segments that are specified by a set of user provided delimiters. Directional punctuation characters are injected into the string in order to ensure the string retains its semantic meaning and conforms with the Unicode BiDi algorithm within each segment. Since: 3.2 Restriction: This class is not intended to be subclassed by clients. '
1114, 'org.eclipse.ui.keys.Key', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/keys/Key.html', 'extends Object implements Comparable Key is the abstract base class for all objects representing keys on the keyboard. All Key objects have a formal string representation, called the \'name\' of the key, available via the toString() method. All Key objects, via the format() method, provide a version of their formal string representation translated by platform and locale, suitable for display to a user. Key objects are immutable. Clients are not permitted to extend this class. Since: 3.0 Restriction: This class is not intended to be subclassed by clients. '
1115, 'org.eclipse.ui.preferences.ViewSettingsDialog', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/preferences/ViewSettingsDialog.html', 'Interface for objects that can return a shell. This is normally used for opening child windows. An object that wants to open child shells can take an IShellProvider in its constructor, and the object that implements IShellProvider can dynamically choose where child shells should be opened. Since: 3.1 extends Dialog The ViewSettingsDialog is an abstract class that provides some common functionality for view preferences. Since: 3.1 '
1116, 'org.eclipse.ui.activities.ITriggerPointAdvisor', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/activities/ITriggerPointAdvisor.html', 'The trigger point advisor is a mechanism provided by the workbench that is consulted whenever code that is considered a trigger point is hit. It is the role of the advisor to determine what, if any, activities should be enabled as a consequence of this action. The advisor also has the option of vetoing the operation. Since: 3.1 See Also: ITriggerPoint Restriction: This interface is not intended to be implemented by clients. Restriction: This interface is not intended to be extended by clients. '
1117, 'org.eclipse.ui.activities.IActivityRequirementBinding', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/activities/IActivityRequirementBinding.html', 'extends Comparable An instance of this interface represents a binding between two activities. The relationship can be interpreted as \'activity needs requiredActivity to be enabled\'. Enablement of the activity requires enablement of the required activity. This interface is not intended to be extended or implemented by clients. Since: 3.0 See Also: IActivity Restriction: This interface is not intended to be implemented by clients. '
1118, 'org.eclipse.ui.activities.ActivityEvent', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/activities/ActivityEvent.html', 'extends Object An instance of this class describes changes to an instance of IActivity. This class does not give details as to the specifics of a change, only that the given property on the source object has changed. This class is not intended to be extended by clients. Since: 3.0 See Also: IActivityListener.activityChanged(ActivityEvent) '
1119, 'org.eclipse.ui.activities.CategoryEvent', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/activities/CategoryEvent.html', 'extends Object An instance of this class describes changes to an instance of ICategory. This class does not give details as to the specifics of a change, only that the given property on the source object has changed. This class is not intended to be extended by clients. Since: 3.0 See Also: ICategoryListener.categoryChanged(CategoryEvent) '
1120, 'org.eclipse.ui.activities.IActivityPatternBinding', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/activities/IActivityPatternBinding.html', 'extends Comparable An instance of this interface represents a binding between an activity and a regular expression pattern. It\'s typically unnecessary to use this interface directly. Rather, clients wishing to test strings against activity patterns should use instances of IIdentifier. This interface is not intended to be extended or implemented by clients. Since: 3.0 See Also: IActivity, IIdentifier, IActivityManager.getIdentifier(String) Restriction: This interface is not intended to be implemented by clients. '
1121, 'org.eclipse.ui.activities.ICategoryActivityBinding', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/activities/ICategoryActivityBinding.html', 'extends Comparable An instance of this interface represents a binding between a category and an activity. This interface is not intended to be extended or implemented by clients. Since: 3.0 See Also: IActivity, ICategory Restriction: This interface is not intended to be implemented by clients. '
1122, 'org.eclipse.ui.part.PageSwitcher', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/part/PageSwitcher.html', 'extends Object Provides the implementation for switching pages in a view. A view may track pages however it wishes. The view should subclass PageSwitcher to provide the abstract methods, and then instantiate their page switcher once. Since: 3.4 '
1123, 'org.eclipse.ui.part.WorkbenchPart', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/part/WorkbenchPart.html', 'An interface for an adaptable object. Adaptable objects can be dynamically extended to provide different interfaces (or \"adapters\"). Adapters are created by adapter factories, which are in turn managed by type by adapter managers. For example, IAdaptable a = [some adaptable]; IFoo x = (IFoo)a.getAdapter(IFoo.class); if (x != null) [do IFoo things with x] This interface can be used without OSGi running. Clients may implement this interface, or obtain a default implementation of this interface by subclassing PlatformObject. See Also: IAdapterFactory, IAdapterManager, PlatformObject Interface for executable extension classes that require access to their configuration element, or implement an extension adapter. Extension adapters are typically required in cases where the extension implementation does not follow the interface rules specified by the provider of the extension point. In these cases, the role of the adapter is to map between the extension point interface, and the actual extension implementation. In general, adapters are used when attempting to plug-in existing Java implementations, or non-Java implementations (e.g., external executables). This interface can be used without OSGi running. Clients may implement this interface. See Also: IConfigurationElement.createExecutableExtension(String) An interface for an adaptable object. Adaptable objects can be dynamically extended to provide different interfaces (or \"adapters\"). Adapters are created by adapter factories, which are in turn managed by type by adapter managers. For example, IAdaptable a = [some adaptable]; IFoo x = (IFoo)a.getAdapter(IFoo.class); if (x != null) [do IFoo things with x] This interface can be used without OSGi running. Clients may implement this interface, or obtain a default implementation of this interface by subclassing PlatformObject. See Also: IAdapterFactory, IAdapterManager, PlatformObject extends IAdaptable A workbench part is a visual component within a workbench page. There are two subtypes: view and editor, as defined by IViewPart and IEditorPart. A view is typically used to navigate a hierarchy of information (like the workspace), open an editor, or display properties for the active editor. Modifications made in a view are saved immediately. An editor is typically used to edit or browse a document or input object. The input is identified using an IEditorInput. Modifications made in an editor part follow an open-save-close lifecycle model. This interface may be implemented directly. For convenience, a base implementation is defined in WorkbenchPart. The lifecycle of a workbench part is as follows: When a part extension is created: instantiate the part create a part site call part.init(site) When a part becomes visible in the workbench: add part to presentation by calling part.createPartControl(parent) to create actual widgets fire partOpened event to all listeners When a part is activated or gets focus: call part.setFocus() fire partActivated event to all listeners When a part is closed: if save is needed, do save; if it fails or is canceled return if part is active, deactivate part fire partClosed event to all listeners remove part from presentation; part controls are disposed as part of the SWT widget tree call part.dispose() After createPartControl has been called, the implementor may safely reference the controls created. When the part is closed these controls will be disposed as part of an SWT composite. This occurs before the IWorkbenchPart.dispose method is called. If there is a need to free SWT resources the part should define a dispose listener for its own control and free those resources from the dispose listener. If the part invokes any method on the disposed SWT controls after this point an SWTError will be thrown. The last method called on IWorkbenchPart is dispose. This signals the end of the part lifecycle. An important point to note about this lifecycle is that following a call to init, createPartControl may never be called. Thus in the dispose method, implementors must not assume controls were created. Workbench parts implement the IAdaptable interface; extensions are managed by the platform\'s adapter manager. See Also: IViewPart, IEditorPart An interface for an adaptable object. Adaptable objects can be dynamically extended to provide different interfaces (or \"adapters\"). Adapters are created by adapter factories, which are in turn managed by type by adapter managers. For example, IAdaptable a = [some adaptable]; IFoo x = (IFoo)a.getAdapter(IFoo.class); if (x != null) [do IFoo things with x] This interface can be used without OSGi running. Clients may implement this interface, or obtain a default implementation of this interface by subclassing PlatformObject. See Also: IAdapterFactory, IAdapterManager, PlatformObject An interface for an adaptable object. Adaptable objects can be dynamically extended to provide different interfaces (or \"adapters\"). Adapters are created by adapter factories, which are in turn managed by type by adapter managers. For example, IAdaptable a = [some adaptable]; IFoo x = (IFoo)a.getAdapter(IFoo.class); if (x != null) [do IFoo things with x] This interface can be used without OSGi running. Clients may implement this interface, or obtain a default implementation of this interface by subclassing PlatformObject. See Also: IAdapterFactory, IAdapterManager, PlatformObject extends IAdaptable A workbench part is a visual component within a workbench page. There are two subtypes: view and editor, as defined by IViewPart and IEditorPart. A view is typically used to navigate a hierarchy of information (like the workspace), open an editor, or display properties for the active editor. Modifications made in a view are saved immediately. An editor is typically used to edit or browse a document or input object. The input is identified using an IEditorInput. Modifications made in an editor part follow an open-save-close lifecycle model. This interface may be implemented directly. For convenience, a base implementation is defined in WorkbenchPart. The lifecycle of a workbench part is as follows: When a part extension is created: instantiate the part create a part site call part.init(site) When a part becomes visible in the workbench: add part to presentation by calling part.createPartControl(parent) to create actual widgets fire partOpened event to all listeners When a part is activated or gets focus: call part.setFocus() fire partActivated event to all listeners When a part is closed: if save is needed, do save; if it fails or is canceled return if part is active, deactivate part fire partClosed event to all listeners remove part from presentation; part controls are disposed as part of the SWT widget tree call part.dispose() After createPartControl has been called, the implementor may safely reference the controls created. When the part is closed these controls will be disposed as part of an SWT composite. This occurs before the IWorkbenchPart.dispose method is called. If there is a need to free SWT resources the part should define a dispose listener for its own control and free those resources from the dispose listener. If the part invokes any method on the disposed SWT controls after this point an SWTError will be thrown. The last method called on IWorkbenchPart is dispose. This signals the end of the part lifecycle. An important point to note about this lifecycle is that following a call to init, createPartControl may never be called. Thus in the dispose method, implementors must not assume controls were created. Workbench parts implement the IAdaptable interface; extensions are managed by the platform\'s adapter manager. See Also: IViewPart, IEditorPart extends IWorkbenchPart Extends IWorkbenchPart, adding the name and status text properties. Prior to 3.0, a view\'s title was often modified to show both the part name and extra status text. With this interface, the distinction is made more explicit. Since: 3.0 An interface for an adaptable object. Adaptable objects can be dynamically extended to provide different interfaces (or \"adapters\"). Adapters are created by adapter factories, which are in turn managed by type by adapter managers. For example, IAdaptable a = [some adaptable]; IFoo x = (IFoo)a.getAdapter(IFoo.class); if (x != null) [do IFoo things with x] This interface can be used without OSGi running. Clients may implement this interface, or obtain a default implementation of this interface by subclassing PlatformObject. See Also: IAdapterFactory, IAdapterManager, PlatformObject An interface for an adaptable object. Adaptable objects can be dynamically extended to provide different interfaces (or \"adapters\"). Adapters are created by adapter factories, which are in turn managed by type by adapter managers. For example, IAdaptable a = [some adaptable]; IFoo x = (IFoo)a.getAdapter(IFoo.class); if (x != null) [do IFoo things with x] This interface can be used without OSGi running. Clients may implement this interface, or obtain a default implementation of this interface by subclassing PlatformObject. See Also: IAdapterFactory, IAdapterManager, PlatformObject extends IAdaptable A workbench part is a visual component within a workbench page. There are two subtypes: view and editor, as defined by IViewPart and IEditorPart. A view is typically used to navigate a hierarchy of information (like the workspace), open an editor, or display properties for the active editor. Modifications made in a view are saved immediately. An editor is typically used to edit or browse a document or input object. The input is identified using an IEditorInput. Modifications made in an editor part follow an open-save-close lifecycle model. This interface may be implemented directly. For convenience, a base implementation is defined in WorkbenchPart. The lifecycle of a workbench part is as follows: When a part extension is created: instantiate the part create a part site call part.init(site) When a part becomes visible in the workbench: add part to presentation by calling part.createPartControl(parent) to create actual widgets fire partOpened event to all listeners When a part is activated or gets focus: call part.setFocus() fire partActivated event to all listeners When a part is closed: if save is needed, do save; if it fails or is canceled return if part is active, deactivate part fire partClosed event to all listeners remove part from presentation; part controls are disposed as part of the SWT widget tree call part.dispose() After createPartControl has been called, the implementor may safely reference the controls created. When the part is closed these controls will be disposed as part of an SWT composite. This occurs before the IWorkbenchPart.dispose method is called. If there is a need to free SWT resources the part should define a dispose listener for its own control and free those resources from the dispose listener. If the part invokes any method on the disposed SWT controls after this point an SWTError will be thrown. The last method called on IWorkbenchPart is dispose. This signals the end of the part lifecycle. An important point to note about this lifecycle is that following a call to init, createPartControl may never be called. Thus in the dispose method, implementors must not assume controls were created. Workbench parts implement the IAdaptable interface; extensions are managed by the platform\'s adapter manager. See Also: IViewPart, IEditorPart extends IWorkbenchPart Extends IWorkbenchPart, adding the name and status text properties. Prior to 3.0, a view\'s title was often modified to show both the part name and extra status text. With this interface, the distinction is made more explicit. Since: 3.0 extends IWorkbenchPart2 A part can provide arbitrary properties. The properties will be persisted between sessions by the part reference, and will be available from the part reference as well as the part. The properties can only be set on a part, not on the reference. The properties will be available to the IPresentablePart. Setting a property must fire a PropertyChangeEvent. Since: 3.3 The IWorkbenchPartOrientation is the interface that defines the orientation of the part. If a type does not implement this interface an orientation of SWT.NONE will be assumed. Since: 3.1 See Also: SWT.RIGHT_TO_LEFT, SWT.LEFT_TO_RIGHT, SWT.NONE, Window.getDefaultOrientation() extends EventManager implements IWorkbenchPart3, IExecutableExtension, IWorkbenchPartOrientation Abstract base implementation of all workbench parts. This class is not intended to be subclassed by clients outside this package; clients should instead subclass ViewPart or EditorPart. See Also: ViewPart, EditorPart Restriction: This class is not intended to be subclassed by clients. '
1124, 'org.eclipse.core.expressions.ElementHandler', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/expressions/ElementHandler.html', 'extends Object An element handler converts an IConfigurationElement into a corresponding expression object. The class should be subclassed by clients wishing to provide an element handler for special expressions. Since: 3.0 '
1125, 'org.eclipse.core.expressions.PropertyTester', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/expressions/PropertyTester.html', 'A property tester can be used to add additional properties to test to an existing type. This interface is not intended to be implemented by clients. Clients should subclass type PropertyTester. Since: 3.0 Restriction: This interface is not intended to be implemented by clients. Restriction: This interface is not intended to be extended by clients. extends Object implements IPropertyTester Abstract superclass of all property testers. Implementation classes of the extension point org.eclipse.core.expresssions.propertyTesters must extend PropertyTester. A property tester implements the property tests enumerated in the property tester extension point. For the following property test extension <propertyTester namespace=\"org.eclipse.jdt.core\" id=\"org.eclipse.jdt.core.IPackageFragmentTester\" properties=\"isDefaultPackage\" type=\"org.eclipse.jdt.core.IPackageFragment\" class=\"org.eclipse.demo.MyPackageFragmentTester\"> </propertyTester> the corresponding implementation class looks like: public class MyPackageFragmentTester extends PropertyTester { public boolean test(Object receiver, String property, Object[] args, Object expectedValue) { IPackageFragment fragment= (IPackageFragment)receiver; if (\"isDefaultPackage\".equals(property)) { return expectedValue == null ? fragment.isDefaultPackage() : fragment.isDefaultPackage() == ((Boolean)expectedValue).booleanValue(); } Assert.isTrue(false); return false; } } The property can then be used in a test expression as follows: <instanceof value=\"org.eclipse.core.IPackageFragment\"/> <test property=\"org.eclipse.jdt.core.isDefaultPackage\"/> There is no guarantee that the same instance of a property tester is used to handle <test property=\"...\"/> requests. So property testers should always be implemented in a stateless fashion. Since: 3.0 '
1126, 'org.eclipse.ui.dialogs.PreferencesUtil', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/dialogs/PreferencesUtil.html', 'extends Object The PreferencesUtil class is the class that opens a properties or preference dialog on a set of ids. Since: 3.1 '
1127, 'org.eclipse.ui.testing.ContributionInfo', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/testing/ContributionInfo.html', 'extends Object Instances of this class describe a contribution of an element of a certain type to the UI. Since: 3.6 '
1128, 'org.eclipse.jface.commands.RadioState', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/commands/RadioState.html', 'extends ToggleState A piece of boolean state grouped with other boolean states. Of these states, only one may have a value of Boolean.TRUE at any given point in time. The values of all other states must be Boolean.FALSE. If this state is registered using IMenuStateIds.STYLE, then it will control the presentation of the command if displayed in the menus, tool bars or status line. Clients may instantiate or extend this interface. Since: 3.2 '
1129, 'org.eclipse.jface.menus.TextState', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/menus/TextState.html', 'extends PersistentState A piece of state carrying a single String. If this state is registered using INamedHandleStateIds.NAME or INamedHandleStateIds.DESCRIPTION, then this allows the handler to communicate a textual change for a given command. This is typically used by graphical applications to allow more specific text to be displayed in the menus. For example, \"Undo\" might become \"Undo Typing\" through the use of a TextState. Clients may instantiate this class, but must not extend. Since: 3.2 See Also: INamedHandleStateIds '
1130, 'org.eclipse.jface.wizard.WizardDialog', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/wizard/WizardDialog.html', 'Minimal interface to a page change provider. Used for dialogs which can switch between multiple pages. Since: 3.1 Interface for UI components which can execute a long-running operation in the form of an IRunnableWithProgress. The context is responsible for displaying a progress indicator and Cancel button to the end user while the operation is in progress; the context supplies a progress monitor to be used from code running inside the operation. Note that an IRunnableContext is not a runnable itself. For examples of UI components which implement this interface, see ApplicationWindow, ProgressMonitorDialog, and WizardDialog. See Also: IRunnableWithProgress, ApplicationWindow, ProgressMonitorDialog, WizardDialog Interface for objects that can return a shell. This is normally used for opening child windows. An object that wants to open child shells can take an IShellProvider in its constructor, and the object that implements IShellProvider can dynamically choose where child shells should be opened. Since: 3.1 Interface for UI components which can execute a long-running operation in the form of an IRunnableWithProgress. The context is responsible for displaying a progress indicator and Cancel button to the end user while the operation is in progress; the context supplies a progress monitor to be used from code running inside the operation. Note that an IRunnableContext is not a runnable itself. For examples of UI components which implement this interface, see ApplicationWindow, ProgressMonitorDialog, and WizardDialog. See Also: IRunnableWithProgress, ApplicationWindow, ProgressMonitorDialog, WizardDialog extends IRunnableContext Interface for containers that can host a wizard. It displays wizard pages, at most one of which is considered the current page. getCurrentPage returns the current page; showPage programmatically changes the the current page. Note that the pages need not all belong to the same wizard. The class WizardDialog provides a fully functional implementation of this interface which will meet the needs of most clients. However, clients are also free to implement this interface if WizardDialog does not suit their needs. Implementors are responsible for disposing of their wizards. See Also: IWizardContainer2 Interface for UI components which can execute a long-running operation in the form of an IRunnableWithProgress. The context is responsible for displaying a progress indicator and Cancel button to the end user while the operation is in progress; the context supplies a progress monitor to be used from code running inside the operation. Note that an IRunnableContext is not a runnable itself. For examples of UI components which implement this interface, see ApplicationWindow, ProgressMonitorDialog, and WizardDialog. See Also: IRunnableWithProgress, ApplicationWindow, ProgressMonitorDialog, WizardDialog extends IRunnableContext Interface for containers that can host a wizard. It displays wizard pages, at most one of which is considered the current page. getCurrentPage returns the current page; showPage programmatically changes the the current page. Note that the pages need not all belong to the same wizard. The class WizardDialog provides a fully functional implementation of this interface which will meet the needs of most clients. However, clients are also free to implement this interface if WizardDialog does not suit their needs. Implementors are responsible for disposing of their wizards. See Also: IWizardContainer2 extends IWizardContainer IWizardContainer2 is a supplement to IWizardContainer that adds a method for updating the size of the wizard shell based on the contents of the current page. The class WizardDialog provides a fully functional implementation of this interface which will meet the needs of most clients. However, clients are also free to implement this interface if WizardDialog does not suit their needs. Since: 3.0 See Also: IWizardContainer extends TitleAreaDialog implements IWizardContainer2, IPageChangeProvider A dialog to show a wizard to the end user. In typical usage, the client instantiates this class with a particular wizard. The dialog serves as the wizard container and orchestrates the presentation of its pages. The standard layout is roughly as follows: it has an area at the top containing both the wizard\'s title, description, and image; the actual wizard page appears in the middle; below that is a progress indicator (which is made visible if needed); and at the bottom of the page is message line and a button bar containing Help, Next, Back, Finish, and Cancel buttons (or some subset). Clients may subclass WizardDialog, although this is rarely required. '
1131, 'org.eclipse.ui.IWorkbenchWizard', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/IWorkbenchWizard.html', 'Interface for a wizard. A wizard maintains a list of wizard pages, stacked on top of each other in card layout fashion. The class Wizard provides an abstract implementation of this interface. However, clients are also free to implement this interface if Wizard does not suit their needs. See Also: Wizard extends IWizard Implementors represent creation wizards that are to be contributed to the workbench\'s creation wizard extension point. See Also: IWizard '
1132, 'org.eclipse.core.runtime.PlatformObject', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/runtime/PlatformObject.html', 'An interface for an adaptable object. Adaptable objects can be dynamically extended to provide different interfaces (or \"adapters\"). Adapters are created by adapter factories, which are in turn managed by type by adapter managers. For example, IAdaptable a = [some adaptable]; IFoo x = (IFoo)a.getAdapter(IFoo.class); if (x != null) [do IFoo things with x] This interface can be used without OSGi running. Clients may implement this interface, or obtain a default implementation of this interface by subclassing PlatformObject. See Also: IAdapterFactory, IAdapterManager, PlatformObject extends Object implements IAdaptable An abstract superclass implementing the IAdaptable interface. getAdapter invocations are directed to the platform\'s adapter manager. Note: In situations where it would be awkward to subclass this class, the same effect can be achieved simply by implementing the IAdaptable interface and explicitly forwarding the getAdapter request to an implementation of the IAdapterManager service. The method would look like: public Object getAdapter(Class adapter) { IAdapterManager manager = ...;//lookup the IAdapterManager service return manager.getAdapter(this, adapter); } This class can be used without OSGi running. Clients may subclass. See Also: IAdapterManager, IAdaptable '
1133, 'org.eclipse.ui.themes.IColorFactory', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/themes/IColorFactory.html', 'A factory interface that may be used to specify a color value. This is (optionally) used by the themes extension point for color value definitions. Example usage: <colorDefinition label=\"Custom Color\" id=\"example.customColor\" colorFactory=\"some.implementor.of.IColorFactory\"> </colorDefinition> Since: 3.0 '
1134, 'org.eclipse.core.commands.operations.IOperationHistoryListener', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/commands/operations/IOperationHistoryListener.html', ' This interface is used to listen to notifications from an IOperationHistory. The supplied OperationHistoryEvent describes the particular notification. Operation history listeners must be prepared to receive notifications from a background thread. Any UI access occurring inside the implementation must be properly synchronized using the techniques specified by the client\'s widget library. Since: 3.1 '
1135, 'org.eclipse.core.commands.operations.IOperationHistory', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/commands/operations/IOperationHistory.html', ' IOperationHistory tracks a history of operations that can be undone or redone. Operations are added to the history once they have been initially executed. Clients may choose whether to have the operations history perform the initial execution or to simply add an already-executed operation to the history. Once operations are added to the history, the methods canRedo(IUndoContext) and canUndo(IUndoContext) are used to determine whether there is an operation available for undo and redo in a given undo context. The context-based protocol implies that there is only one operation that can be undone or redone at a given time in a given context. This is typical of a linear undo model, when only the most recently executed operation is available for undo. When this protocol is used, a linear model is enforced by the history. It is up to clients to determine how to maintain a history that is invalid or stale. For example, when the most recent operation for a context cannot be performed, clients may wish to dispose the history for that context. Additional protocol allows direct undo and redo of a specified operation, regardless of its position in the history. When a more flexible undo model is supported, these methods can be implemented to undo and redo directly specified operations. If an implementer of IOperationHistory does not allow direct undo and redo, these methods can return a status indicating that it is not allowed. Listeners (IOperationHistoryListener) can listen for notifications about changes in the history (operations added or removed), and for notification before and after any operation is executed, undone or redone. Notification of operation execution only occurs when clients direct the history to execute the operation. If the operation is added after it is executed, there can be no notification of its execution. IOperationApprover defines an interface for approving an undo or redo before it occurs. This is useful for injecting policy-decisions into the undo model - whether direct undo and redo are supported, or warning the user about certain kinds of operations. It can also be used when clients maintain state related to an operation and need to determine whether an undo or redo will cause any conflicts with their local state. Since: 3.1 '
1136, 'org.eclipse.core.commands.operations.IUndoableOperation', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/commands/operations/IUndoableOperation.html', ' IUndoableOperation defines an operation that can be executed, undone, and redone. Operations typically have fully defined parameters. That is, they are usually created after the user has been queried for any input needed to define the operation. Operations determine their ability to execute, undo, or redo according to the current state of the application. They do not make decisions about their validity based on where they occur in the operation history. That is left to the particular operation history. Since: 3.1 '
1137, 'org.eclipse.core.commands.operations.IAdvancedUndoableOperation2', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/commands/operations/IAdvancedUndoableOperation2.html', ' IAdvancedUndoableOperation2 defines a method for computing the validity of executing an operation before attempting to execute it. It also defines a way for clients to specify that computing status should be done quietly, without consulting the user. This interface is useful when implementing IOperationApprover2, or any other object that performs validation of the undo history. It also allows operations to specify whether they should be run in the UI thread. Since: 3.3 '
1138, 'org.eclipse.ui.activities.IActivityManager', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/activities/IActivityManager.html', 'An instance of this interface allows clients to manage activities, as defined by the extension point org.eclipse.ui.activities. This interface is not intended to be extended or implemented by clients. Since: 3.0 Restriction: This interface is not intended to be implemented by clients. '
1139, 'org.eclipse.ui.statushandlers.AbstractStatusHandler', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/statushandlers/AbstractStatusHandler.html', 'extends Object Status handlers are part of the status handling facility. The facility is responsible for handling errors and other important issues in Eclipse based applications. The handlers are responsible for presenting this errors by logging or showing error dialogs. All status handlers extends org.eclipse.ui.statushandlers.AbstractStatusHandler. Each handler implements handle(StatusAdapter status, int style). This method handles statuses due to handling style. The style indicates how status handler should handle a status. For acceptable styles check StatusManager. Handlers shoudn\'t be used directly but through the StatusManager. It chooses which handler should be used for handling. There are two ways for adding handlers to the handling flow. First using extension point org.eclipse.ui.statusHandlers, second by the workbench advisor and its method WorkbenchAdvisor.getWorkbenchErrorHandler(). If a handler is associated with a product, it is used instead of this defined in advisor. A status handler has the id and a set of parameters. The handler can use them during handling. If the handler is added as an extension, both are set during initialization of the handler using elements and attributes of statusHandler element. Since: 3.3 '
1140, 'org.eclipse.ui.statushandlers.WorkbenchErrorHandler', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/statushandlers/WorkbenchErrorHandler.html', 'extends AbstractStatusHandler This is a default workbench error handler. Since: 3.3 See Also: WorkbenchAdvisor.getWorkbenchErrorHandler() '
1141, 'org.eclipse.ui.model.ContributionComparator', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/model/ContributionComparator.html', 'extends ViewerComparator implements Comparator A ContributionComparator is capable of ordering IComparableContribution instances, either as a ViewerComparator (for StructuredViewers) or as a traditional Comparator. This class orders contributions by first grouping by priority (IComparableContribution.getPriority()) and then by utilizing the JFace policy comparator to order by label (IComparableContribution.getLabel()). Since: 3.4 See Also: IComparableContribution '
1142, 'org.eclipse.ui.part.MultiPageEditorPart', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/part/MultiPageEditorPart.html', 'An interface for an adaptable object. Adaptable objects can be dynamically extended to provide different interfaces (or \"adapters\"). Adapters are created by adapter factories, which are in turn managed by type by adapter managers. For example, IAdaptable a = [some adaptable]; IFoo x = (IFoo)a.getAdapter(IFoo.class); if (x != null) [do IFoo things with x] This interface can be used without OSGi running. Clients may implement this interface, or obtain a default implementation of this interface by subclassing PlatformObject. See Also: IAdapterFactory, IAdapterManager, PlatformObject Interface for executable extension classes that require access to their configuration element, or implement an extension adapter. Extension adapters are typically required in cases where the extension implementation does not follow the interface rules specified by the provider of the extension point. In these cases, the role of the adapter is to map between the extension point interface, and the actual extension implementation. In general, adapters are used when attempting to plug-in existing Java implementations, or non-Java implementations (e.g., external executables). This interface can be used without OSGi running. Clients may implement this interface. See Also: IConfigurationElement.createExecutableExtension(String) Minimal interface to a page change provider. Used for dialogs which can switch between multiple pages. Since: 3.1 An interface for an adaptable object. Adaptable objects can be dynamically extended to provide different interfaces (or \"adapters\"). Adapters are created by adapter factories, which are in turn managed by type by adapter managers. For example, IAdaptable a = [some adaptable]; IFoo x = (IFoo)a.getAdapter(IFoo.class); if (x != null) [do IFoo things with x] This interface can be used without OSGi running. Clients may implement this interface, or obtain a default implementation of this interface by subclassing PlatformObject. See Also: IAdapterFactory, IAdapterManager, PlatformObject Workbench parts implement or adapt to this interface to participate in the enablement and execution of the Save and Save As actions. Since: 2.1 See Also: IEditorPart An interface for an adaptable object. Adaptable objects can be dynamically extended to provide different interfaces (or \"adapters\"). Adapters are created by adapter factories, which are in turn managed by type by adapter managers. For example, IAdaptable a = [some adaptable]; IFoo x = (IFoo)a.getAdapter(IFoo.class); if (x != null) [do IFoo things with x] This interface can be used without OSGi running. Clients may implement this interface, or obtain a default implementation of this interface by subclassing PlatformObject. See Also: IAdapterFactory, IAdapterManager, PlatformObject extends IAdaptable A workbench part is a visual component within a workbench page. There are two subtypes: view and editor, as defined by IViewPart and IEditorPart. A view is typically used to navigate a hierarchy of information (like the workspace), open an editor, or display properties for the active editor. Modifications made in a view are saved immediately. An editor is typically used to edit or browse a document or input object. The input is identified using an IEditorInput. Modifications made in an editor part follow an open-save-close lifecycle model. This interface may be implemented directly. For convenience, a base implementation is defined in WorkbenchPart. The lifecycle of a workbench part is as follows: When a part extension is created: instantiate the part create a part site call part.init(site) When a part becomes visible in the workbench: add part to presentation by calling part.createPartControl(parent) to create actual widgets fire partOpened event to all listeners When a part is activated or gets focus: call part.setFocus() fire partActivated event to all listeners When a part is closed: if save is needed, do save; if it fails or is canceled return if part is active, deactivate part fire partClosed event to all listeners remove part from presentation; part controls are disposed as part of the SWT widget tree call part.dispose() After createPartControl has been called, the implementor may safely reference the controls created. When the part is closed these controls will be disposed as part of an SWT composite. This occurs before the IWorkbenchPart.dispose method is called. If there is a need to free SWT resources the part should define a dispose listener for its own control and free those resources from the dispose listener. If the part invokes any method on the disposed SWT controls after this point an SWTError will be thrown. The last method called on IWorkbenchPart is dispose. This signals the end of the part lifecycle. An important point to note about this lifecycle is that following a call to init, createPartControl may never be called. Thus in the dispose method, implementors must not assume controls were created. Workbench parts implement the IAdaptable interface; extensions are managed by the platform\'s adapter manager. See Also: IViewPart, IEditorPart extends IWorkbenchPart, ISaveablePart An editor is a visual component within a workbench page. It is typically used to edit or browse a document or input object. The input is identified using an IEditorInput. Modifications made in an editor part follow an open-save-close lifecycle model (in contrast to a view part, where modifications are saved to the workbench immediately). An editor is document or input-centric. Each editor has an input, and only one editor can exist for each editor input within a page. This policy has been designed to simplify part management. An editor should be used in place of a view whenever more than one instance of a document type can exist. This interface may be implemented directly. For convenience, a base implementation is defined in EditorPart. An editor part is added to the workbench in two stages: An editor extension is contributed to the workbench registry. This extension defines the extension id, extension class, and the file extensions which are supported by the editor. An editor part based upon the extension is created and added to the workbench when the user opens a file with one of the supported file extensions (or some other suitable form of editor input). All editor parts implement the IAdaptable interface; extensions are managed by the platform\'s adapter manager. See Also: IWorkbenchPage.openEditor(IEditorInput, String), EditorPart Workbench parts implement or adapt to this interface to participate in the enablement and execution of the Save and Save As actions. Since: 2.1 See Also: IEditorPart An interface for an adaptable object. Adaptable objects can be dynamically extended to provide different interfaces (or \"adapters\"). Adapters are created by adapter factories, which are in turn managed by type by adapter managers. For example, IAdaptable a = [some adaptable]; IFoo x = (IFoo)a.getAdapter(IFoo.class); if (x != null) [do IFoo things with x] This interface can be used without OSGi running. Clients may implement this interface, or obtain a default implementation of this interface by subclassing PlatformObject. See Also: IAdapterFactory, IAdapterManager, PlatformObject extends IAdaptable A workbench part is a visual component within a workbench page. There are two subtypes: view and editor, as defined by IViewPart and IEditorPart. A view is typically used to navigate a hierarchy of information (like the workspace), open an editor, or display properties for the active editor. Modifications made in a view are saved immediately. An editor is typically used to edit or browse a document or input object. The input is identified using an IEditorInput. Modifications made in an editor part follow an open-save-close lifecycle model. This interface may be implemented directly. For convenience, a base implementation is defined in WorkbenchPart. The lifecycle of a workbench part is as follows: When a part extension is created: instantiate the part create a part site call part.init(site) When a part becomes visible in the workbench: add part to presentation by calling part.createPartControl(parent) to create actual widgets fire partOpened event to all listeners When a part is activated or gets focus: call part.setFocus() fire partActivated event to all listeners When a part is closed: if save is needed, do save; if it fails or is canceled return if part is active, deactivate part fire partClosed event to all listeners remove part from presentation; part controls are disposed as part of the SWT widget tree call part.dispose() After createPartControl has been called, the implementor may safely reference the controls created. When the part is closed these controls will be disposed as part of an SWT composite. This occurs before the IWorkbenchPart.dispose method is called. If there is a need to free SWT resources the part should define a dispose listener for its own control and free those resources from the dispose listener. If the part invokes any method on the disposed SWT controls after this point an SWTError will be thrown. The last method called on IWorkbenchPart is dispose. This signals the end of the part lifecycle. An important point to note about this lifecycle is that following a call to init, createPartControl may never be called. Thus in the dispose method, implementors must not assume controls were created. Workbench parts implement the IAdaptable interface; extensions are managed by the platform\'s adapter manager. See Also: IViewPart, IEditorPart An interface for an adaptable object. Adaptable objects can be dynamically extended to provide different interfaces (or \"adapters\"). Adapters are created by adapter factories, which are in turn managed by type by adapter managers. For example, IAdaptable a = [some adaptable]; IFoo x = (IFoo)a.getAdapter(IFoo.class); if (x != null) [do IFoo things with x] This interface can be used without OSGi running. Clients may implement this interface, or obtain a default implementation of this interface by subclassing PlatformObject. See Also: IAdapterFactory, IAdapterManager, PlatformObject An interface for an adaptable object. Adaptable objects can be dynamically extended to provide different interfaces (or \"adapters\"). Adapters are created by adapter factories, which are in turn managed by type by adapter managers. For example, IAdaptable a = [some adaptable]; IFoo x = (IFoo)a.getAdapter(IFoo.class); if (x != null) [do IFoo things with x] This interface can be used without OSGi running. Clients may implement this interface, or obtain a default implementation of this interface by subclassing PlatformObject. See Also: IAdapterFactory, IAdapterManager, PlatformObject extends IAdaptable A workbench part is a visual component within a workbench page. There are two subtypes: view and editor, as defined by IViewPart and IEditorPart. A view is typically used to navigate a hierarchy of information (like the workspace), open an editor, or display properties for the active editor. Modifications made in a view are saved immediately. An editor is typically used to edit or browse a document or input object. The input is identified using an IEditorInput. Modifications made in an editor part follow an open-save-close lifecycle model. This interface may be implemented directly. For convenience, a base implementation is defined in WorkbenchPart. The lifecycle of a workbench part is as follows: When a part extension is created: instantiate the part create a part site call part.init(site) When a part becomes visible in the workbench: add part to presentation by calling part.createPartControl(parent) to create actual widgets fire partOpened event to all listeners When a part is activated or gets focus: call part.setFocus() fire partActivated event to all listeners When a part is closed: if save is needed, do save; if it fails or is canceled return if part is active, deactivate part fire partClosed event to all listeners remove part from presentation; part controls are disposed as part of the SWT widget tree call part.dispose() After createPartControl has been called, the implementor may safely reference the controls created. When the part is closed these controls will be disposed as part of an SWT composite. This occurs before the IWorkbenchPart.dispose method is called. If there is a need to free SWT resources the part should define a dispose listener for its own control and free those resources from the dispose listener. If the part invokes any method on the disposed SWT controls after this point an SWTError will be thrown. The last method called on IWorkbenchPart is dispose. This signals the end of the part lifecycle. An important point to note about this lifecycle is that following a call to init, createPartControl may never be called. Thus in the dispose method, implementors must not assume controls were created. Workbench parts implement the IAdaptable interface; extensions are managed by the platform\'s adapter manager. See Also: IViewPart, IEditorPart extends IWorkbenchPart Extends IWorkbenchPart, adding the name and status text properties. Prior to 3.0, a view\'s title was often modified to show both the part name and extra status text. With this interface, the distinction is made more explicit. Since: 3.0 An interface for an adaptable object. Adaptable objects can be dynamically extended to provide different interfaces (or \"adapters\"). Adapters are created by adapter factories, which are in turn managed by type by adapter managers. For example, IAdaptable a = [some adaptable]; IFoo x = (IFoo)a.getAdapter(IFoo.class); if (x != null) [do IFoo things with x] This interface can be used without OSGi running. Clients may implement this interface, or obtain a default implementation of this interface by subclassing PlatformObject. See Also: IAdapterFactory, IAdapterManager, PlatformObject An interface for an adaptable object. Adaptable objects can be dynamically extended to provide different interfaces (or \"adapters\"). Adapters are created by adapter factories, which are in turn managed by type by adapter managers. For example, IAdaptable a = [some adaptable]; IFoo x = (IFoo)a.getAdapter(IFoo.class); if (x != null) [do IFoo things with x] This interface can be used without OSGi running. Clients may implement this interface, or obtain a default implementation of this interface by subclassing PlatformObject. See Also: IAdapterFactory, IAdapterManager, PlatformObject extends IAdaptable A workbench part is a visual component within a workbench page. There are two subtypes: view and editor, as defined by IViewPart and IEditorPart. A view is typically used to navigate a hierarchy of information (like the workspace), open an editor, or display properties for the active editor. Modifications made in a view are saved immediately. An editor is typically used to edit or browse a document or input object. The input is identified using an IEditorInput. Modifications made in an editor part follow an open-save-close lifecycle model. This interface may be implemented directly. For convenience, a base implementation is defined in WorkbenchPart. The lifecycle of a workbench part is as follows: When a part extension is created: instantiate the part create a part site call part.init(site) When a part becomes visible in the workbench: add part to presentation by calling part.createPartControl(parent) to create actual widgets fire partOpened event to all listeners When a part is activated or gets focus: call part.setFocus() fire partActivated event to all listeners When a part is closed: if save is needed, do save; if it fails or is canceled return if part is active, deactivate part fire partClosed event to all listeners remove part from presentation; part controls are disposed as part of the SWT widget tree call part.dispose() After createPartControl has been called, the implementor may safely reference the controls created. When the part is closed these controls will be disposed as part of an SWT composite. This occurs before the IWorkbenchPart.dispose method is called. If there is a need to free SWT resources the part should define a dispose listener for its own control and free those resources from the dispose listener. If the part invokes any method on the disposed SWT controls after this point an SWTError will be thrown. The last method called on IWorkbenchPart is dispose. This signals the end of the part lifecycle. An important point to note about this lifecycle is that following a call to init, createPartControl may never be called. Thus in the dispose method, implementors must not assume controls were created. Workbench parts implement the IAdaptable interface; extensions are managed by the platform\'s adapter manager. See Also: IViewPart, IEditorPart extends IWorkbenchPart Extends IWorkbenchPart, adding the name and status text properties. Prior to 3.0, a view\'s title was often modified to show both the part name and extra status text. With this interface, the distinction is made more explicit. Since: 3.0 extends IWorkbenchPart2 A part can provide arbitrary properties. The properties will be persisted between sessions by the part reference, and will be available from the part reference as well as the part. The properties can only be set on a part, not on the reference. The properties will be available to the IPresentablePart. Setting a property must fire a PropertyChangeEvent. Since: 3.3 The IWorkbenchPartOrientation is the interface that defines the orientation of the part. If a type does not implement this interface an orientation of SWT.NONE will be assumed. Since: 3.1 See Also: SWT.RIGHT_TO_LEFT, SWT.LEFT_TO_RIGHT, SWT.NONE, Window.getDefaultOrientation() extends EditorPart implements IPageChangeProvider A multi-page editor is an editor with multiple pages, each of which may contain an editor or an arbitrary SWT control. Subclasses must implement the following methods: createPages - to create the required pages by calling one of the addPage methods IEditorPart.doSave - to save contents of editor IEditorPart.doSaveAs - to save contents of editor IEditorPart.isSaveAsAllowed - to enable Save As IEditorPart.gotoMarker - to scroll to a marker Multi-page editors have a single action bar contributor, which manages contributions for all the pages. The contributor must be a subclass of MultiPageEditorActionBarContributor. Note that since any nested editors are created directly in code by callers of addPage(IEditorPart,IEditorInput), nested editors do not have their own contributors. As of 3.5 multi-page editors will post PageChangedEvents at the end of pageChange(int). Subclasses may override getSelectedPage() to return a page appropriate to their multi-page editor. IPartListener2 listeners registered with the IPartService can implement IPageChangedListener to be notified about all page change events within the workbench page or workbench window. See Also: MultiPageEditorActionBarContributor, IPageChangeProvider, IPageChangedListener, IPartService '
1143, 'org.eclipse.ui.part.MultiPageSelectionProvider', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/part/MultiPageSelectionProvider.html', 'Interface common to all objects that provide a selection. See Also: ISelection, ISelectionChangedListener, SelectionChangedEvent extends ISelectionProvider Selection provider extension interface to allow providers to notify about post selection changed events. A post selection changed event is equivalent to selection changed event if the selection change was triggered by the mouse, but it has a delay if the selection change is triggered by keyboard navigation. Since: 3.0 See Also: ISelectionProvider Interface common to all objects that provide a selection. See Also: ISelection, ISelectionChangedListener, SelectionChangedEvent extends Object implements IPostSelectionProvider Manages the current selection in a multi-page editor by tracking the active nested editor within the multi-page editor. When the selection changes, notifications are sent to all registered listeners. This class may be instantiated; it is not intended to be subclassed. The base implementation of MultiPageEditor.init creates an instance of this class. Restriction: This class is not intended to be subclassed by clients. '
1144, 'org.eclipse.ui.part.IPageSite', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/part/IPageSite.html', 'An interface for an adaptable object. Adaptable objects can be dynamically extended to provide different interfaces (or \"adapters\"). Adapters are created by adapter factories, which are in turn managed by type by adapter managers. For example, IAdaptable a = [some adaptable]; IFoo x = (IFoo)a.getAdapter(IFoo.class); if (x != null) [do IFoo things with x] This interface can be used without OSGi running. Clients may implement this interface, or obtain a default implementation of this interface by subclassing PlatformObject. See Also: IAdapterFactory, IAdapterManager, PlatformObject A component with which one or more services are registered. The services can be retrieved from this locator using some key -- typically the class representing the interface the service must implement. For example: IHandlerService service = (IHandlerService) workbenchWindow .getService(IHandlerService.class); This interface is not to be implemented or extended by clients. Since: 3.2 Interface for objects that can return a shell. This is normally used for opening child windows. An object that wants to open child shells can take an IShellProvider in its constructor, and the object that implements IShellProvider can dynamically choose where child shells should be opened. Since: 3.1 extends IAdaptable, IShellProvider, IServiceLocator The common interface between the workbench and its parts, including pages within parts. The workbench site supports a few services by default. If these services are used to allocate resources, it is important to remember to clean up those resources after you are done with them. Otherwise, the resources will exist until the workbench site is disposed. The supported services are: ICommandService IContextService IHandlerService IBindingService. Resources allocated through this service will not be cleaned up until the workbench shuts down. This interface is not intended to be implemented or extended by clients. Since: 2.0 See Also: IWorkbenchPartSite, IPageSite Restriction: This interface is not intended to be implemented by clients. extends IWorkbenchSite The primary interface between a page and the outside world. The workbench exposes its implemention of page sites via this interface, which is not intended to be implemented or extended by clients. Restriction: This interface is not intended to be implemented by clients. '
1145, 'org.eclipse.e4.ui.model.fragment.MFragmentFactory', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/e4/ui/model/fragment/MFragmentFactory.html', ' The Factory for the model. It provides a create method for each non-abstract class of the model. Since: 1.0 '
1146, 'org.eclipse.e4.ui.model.fragment.MStringModelFragment', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/e4/ui/model/fragment/MStringModelFragment.html', ' A representation of the model object \'Model Fragment\'. Developers: Add more detailed documentation by editing this comment in /org.eclipse.e4.ui.model.workbench/model/ModelFragment.ecore. There is a GenModel/documentation node under each type and attribute. Since: 1.0 The following features are supported: Elements extends MModelFragment A representation of the model object \'String Model Fragment\'. Developers: Add more detailed documentation by editing this comment in /org.eclipse.e4.ui.model.workbench/model/ModelFragment.ecore. There is a GenModel/documentation node under each type and attribute. Since: 1.0 The following features are supported: Featurename Parent Element Id Position In List '
1147, 'org.eclipse.core.runtime.ILogListener', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/runtime/ILogListener.html', 'extends EventListener A log listener is notified of entries added to a plug-in\'s log. This interface can be used without OSGi running. Clients may implement this interface. '
1148, 'org.eclipse.ui.IActionDelegate', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/IActionDelegate.html', 'Interface for actions contributed via an extension point. This interface should be implemented by clients who need to contribute actions via an extension point. The workbench will generate a proxy action object on behalf of the plug-in to avoid having to activate the plug-in until the user needs it. If the action is performed the workbench will load the class that implements this interface and create what is called an action delegate object. Then the request, and all subsequent ones, are forwarded through the proxy action to the action delegate, which does the real work. The proxy action is the one that appears in the UI, so the action delegate will need to talk to the proxy action in order to keep up an appropriate appearance. Once the action delegate has been created, it will be notified of all selection changes, allowing it to enable or disable the proxy action appropriately. An action delegate cannot be consulted about selection changes before the action is performed because it does not exist. For this reason, control of the action\'s enable state should also be exercised through simple XML rules contained in the extension. These rules allow enable state control before the action delegate\'s plug-in is loaded. Clients can choose to subclass the provided abstract implementation org.eclipse.ui.actions.ActionDelegate or implement the interface directly. See Also: ActionDelegate, IActionDelegate2 '
1149, 'org.eclipse.ui.dialogs.FilteredResourcesSelectionDialog', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/dialogs/FilteredResourcesSelectionDialog.html', 'Interface for objects that can return a shell. This is normally used for opening child windows. An object that wants to open child shells can take an IShellProvider in its constructor, and the object that implements IShellProvider can dynamically choose where child shells should be opened. Since: 3.1 extends FilteredItemsSelectionDialog Shows a list of resources to the user with a text entry field for a string pattern used to filter the list of resources. Since: 3.3 '
1150, 'org.eclipse.ui.actions.OpenFileAction', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/actions/OpenFileAction.html', 'An action represents the non-UI side of a command which can be triggered by the end user. Actions are typically associated with buttons, menu items, and items in tool bars. The controls for a command are built by some container, which furnished the context where these controls appear and configures them with data from properties declared by the action. When the end user triggers the command via its control, the action\'s run method is invoked to do the real work. Actions support a predefined set of properties (and possibly others as well). Clients of an action may register property change listeners so that they get notified whenever the value of a property changes. Clients should subclass the abstract base class Action to define concrete actions rather than implementing IAction from scratch. This interface exists only to define the API for actions. It is not intended to be implemented by clients. See Also: Action Restriction: This interface is not intended to be implemented by clients. A listener which is notified when a viewer\'s selection changes. See Also: ISelection, ISelectionProvider, SelectionChangedEvent extends OpenSystemEditorAction Standard action for opening an editor on the currently selected file resource(s). Note that there is a different action for opening closed projects: OpenResourceAction. This class may be instantiated; it is not intended to be subclassed. Restriction: This class is not intended to be subclassed by clients. '
1151, 'org.eclipse.ui.actions.OpenWithMenu', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/actions/OpenWithMenu.html', 'A contribution item represents a contribution to a shared UI resource such as a menu or tool bar. More generally, contribution items are managed by a contribution manager. For instance, in a tool bar a contribution item is a tool bar button or a separator. In a menu bar a contribution item is a menu, and in a menu a contribution item is a menu item or separator. A contribution item can realize itself in different SWT widgets, using the different fill methods. The same type of contribution item can be used with a MenuBarManager, ToolBarManager, CoolBarManager, or a StatusLineManager. This interface is internal to the framework; it should not be implemented outside the framework. See Also: IContributionManager Restriction: This interface is not intended to be implemented by clients. extends ContributionItem A menu for opening files in the workbench. An OpenWithMenu is used to populate a menu with \"Open With\" actions. One action is added for each editor which is applicable to the selected file. If the user selects one of these items, the corresponding editor is opened on the file. This class may be instantiated; it is not intended to be subclassed. Restriction: This class is not intended to be subclassed by clients. '
1152, 'org.eclipse.ui.editors.text.TextEditor', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/editors/text/TextEditor.html', 'An interface for an adaptable object. Adaptable objects can be dynamically extended to provide different interfaces (or \"adapters\"). Adapters are created by adapter factories, which are in turn managed by type by adapter managers. For example, IAdaptable a = [some adaptable]; IFoo x = (IFoo)a.getAdapter(IFoo.class); if (x != null) [do IFoo things with x] This interface can be used without OSGi running. Clients may implement this interface, or obtain a default implementation of this interface by subclassing PlatformObject. See Also: IAdapterFactory, IAdapterManager, PlatformObject Interface for executable extension classes that require access to their configuration element, or implement an extension adapter. Extension adapters are typically required in cases where the extension implementation does not follow the interface rules specified by the provider of the extension point. In these cases, the role of the adapter is to map between the extension point interface, and the actual extension implementation. In general, adapters are used when attempting to plug-in existing Java implementations, or non-Java implementations (e.g., external executables). This interface can be used without OSGi running. Clients may implement this interface. See Also: IConfigurationElement.createExecutableExtension(String) An interface for an adaptable object. Adaptable objects can be dynamically extended to provide different interfaces (or \"adapters\"). Adapters are created by adapter factories, which are in turn managed by type by adapter managers. For example, IAdaptable a = [some adaptable]; IFoo x = (IFoo)a.getAdapter(IFoo.class); if (x != null) [do IFoo things with x] This interface can be used without OSGi running. Clients may implement this interface, or obtain a default implementation of this interface by subclassing PlatformObject. See Also: IAdapterFactory, IAdapterManager, PlatformObject Workbench parts implement or adapt to this interface to participate in the enablement and execution of the Save and Save As actions. Since: 2.1 See Also: IEditorPart An interface for an adaptable object. Adaptable objects can be dynamically extended to provide different interfaces (or \"adapters\"). Adapters are created by adapter factories, which are in turn managed by type by adapter managers. For example, IAdaptable a = [some adaptable]; IFoo x = (IFoo)a.getAdapter(IFoo.class); if (x != null) [do IFoo things with x] This interface can be used without OSGi running. Clients may implement this interface, or obtain a default implementation of this interface by subclassing PlatformObject. See Also: IAdapterFactory, IAdapterManager, PlatformObject extends IAdaptable A workbench part is a visual component within a workbench page. There are two subtypes: view and editor, as defined by IViewPart and IEditorPart. A view is typically used to navigate a hierarchy of information (like the workspace), open an editor, or display properties for the active editor. Modifications made in a view are saved immediately. An editor is typically used to edit or browse a document or input object. The input is identified using an IEditorInput. Modifications made in an editor part follow an open-save-close lifecycle model. This interface may be implemented directly. For convenience, a base implementation is defined in WorkbenchPart. The lifecycle of a workbench part is as follows: When a part extension is created: instantiate the part create a part site call part.init(site) When a part becomes visible in the workbench: add part to presentation by calling part.createPartControl(parent) to create actual widgets fire partOpened event to all listeners When a part is activated or gets focus: call part.setFocus() fire partActivated event to all listeners When a part is closed: if save is needed, do save; if it fails or is canceled return if part is active, deactivate part fire partClosed event to all listeners remove part from presentation; part controls are disposed as part of the SWT widget tree call part.dispose() After createPartControl has been called, the implementor may safely reference the controls created. When the part is closed these controls will be disposed as part of an SWT composite. This occurs before the IWorkbenchPart.dispose method is called. If there is a need to free SWT resources the part should define a dispose listener for its own control and free those resources from the dispose listener. If the part invokes any method on the disposed SWT controls after this point an SWTError will be thrown. The last method called on IWorkbenchPart is dispose. This signals the end of the part lifecycle. An important point to note about this lifecycle is that following a call to init, createPartControl may never be called. Thus in the dispose method, implementors must not assume controls were created. Workbench parts implement the IAdaptable interface; extensions are managed by the platform\'s adapter manager. See Also: IViewPart, IEditorPart extends IWorkbenchPart, ISaveablePart An editor is a visual component within a workbench page. It is typically used to edit or browse a document or input object. The input is identified using an IEditorInput. Modifications made in an editor part follow an open-save-close lifecycle model (in contrast to a view part, where modifications are saved to the workbench immediately). An editor is document or input-centric. Each editor has an input, and only one editor can exist for each editor input within a page. This policy has been designed to simplify part management. An editor should be used in place of a view whenever more than one instance of a document type can exist. This interface may be implemented directly. For convenience, a base implementation is defined in EditorPart. An editor part is added to the workbench in two stages: An editor extension is contributed to the workbench registry. This extension defines the extension id, extension class, and the file extensions which are supported by the editor. An editor part based upon the extension is created and added to the workbench when the user opens a file with one of the supported file extensions (or some other suitable form of editor input). All editor parts implement the IAdaptable interface; extensions are managed by the platform\'s adapter manager. See Also: IWorkbenchPage.openEditor(IEditorInput, String), EditorPart Should be implemented by editors that wish to contribute to the navigation history. The message createNavigationLocation will be sent when a new location is marked in the history. Since: 2.1 Objects implementing this interface are capable of saving their state in an IMemento. Since: 3.1 Objects implementing this interface are capable of saving their state in an IMemento. Since: 3.1 extends IPersistable An editor can implement this interface and participate in the workbench session save/restore cycle using IMemento, similar to how IViewPart currently works. Refer to IWorkbenchPart for the part lifecycle. If a memento is available, restoreState(*) will be inserted into the editor startup. editor.init(site, input) editor.restoreState(memento) editor.createPartControl(parent) ... On workbench shutdown, the editor state will be persisted when the editor references are saved. Since: 3.3 An interface for an adaptable object. Adaptable objects can be dynamically extended to provide different interfaces (or \"adapters\"). Adapters are created by adapter factories, which are in turn managed by type by adapter managers. For example, IAdaptable a = [some adaptable]; IFoo x = (IFoo)a.getAdapter(IFoo.class); if (x != null) [do IFoo things with x] This interface can be used without OSGi running. Clients may implement this interface, or obtain a default implementation of this interface by subclassing PlatformObject. See Also: IAdapterFactory, IAdapterManager, PlatformObject An interface for an adaptable object. Adaptable objects can be dynamically extended to provide different interfaces (or \"adapters\"). Adapters are created by adapter factories, which are in turn managed by type by adapter managers. For example, IAdaptable a = [some adaptable]; IFoo x = (IFoo)a.getAdapter(IFoo.class); if (x != null) [do IFoo things with x] This interface can be used without OSGi running. Clients may implement this interface, or obtain a default implementation of this interface by subclassing PlatformObject. See Also: IAdapterFactory, IAdapterManager, PlatformObject Workbench parts implement or adapt to this interface to participate in the enablement and execution of the Save and Save As actions. Since: 2.1 See Also: IEditorPart An interface for an adaptable object. Adaptable objects can be dynamically extended to provide different interfaces (or \"adapters\"). Adapters are created by adapter factories, which are in turn managed by type by adapter managers. For example, IAdaptable a = [some adaptable]; IFoo x = (IFoo)a.getAdapter(IFoo.class); if (x != null) [do IFoo things with x] This interface can be used without OSGi running. Clients may implement this interface, or obtain a default implementation of this interface by subclassing PlatformObject. See Also: IAdapterFactory, IAdapterManager, PlatformObject extends IAdaptable A workbench part is a visual component within a workbench page. There are two subtypes: view and editor, as defined by IViewPart and IEditorPart. A view is typically used to navigate a hierarchy of information (like the workspace), open an editor, or display properties for the active editor. Modifications made in a view are saved immediately. An editor is typically used to edit or browse a document or input object. The input is identified using an IEditorInput. Modifications made in an editor part follow an open-save-close lifecycle model. This interface may be implemented directly. For convenience, a base implementation is defined in WorkbenchPart. The lifecycle of a workbench part is as follows: When a part extension is created: instantiate the part create a part site call part.init(site) When a part becomes visible in the workbench: add part to presentation by calling part.createPartControl(parent) to create actual widgets fire partOpened event to all listeners When a part is activated or gets focus: call part.setFocus() fire partActivated event to all listeners When a part is closed: if save is needed, do save; if it fails or is canceled return if part is active, deactivate part fire partClosed event to all listeners remove part from presentation; part controls are disposed as part of the SWT widget tree call part.dispose() After createPartControl has been called, the implementor may safely reference the controls created. When the part is closed these controls will be disposed as part of an SWT composite. This occurs before the IWorkbenchPart.dispose method is called. If there is a need to free SWT resources the part should define a dispose listener for its own control and free those resources from the dispose listener. If the part invokes any method on the disposed SWT controls after this point an SWTError will be thrown. The last method called on IWorkbenchPart is dispose. This signals the end of the part lifecycle. An important point to note about this lifecycle is that following a call to init, createPartControl may never be called. Thus in the dispose method, implementors must not assume controls were created. Workbench parts implement the IAdaptable interface; extensions are managed by the platform\'s adapter manager. See Also: IViewPart, IEditorPart extends IWorkbenchPart, ISaveablePart An editor is a visual component within a workbench page. It is typically used to edit or browse a document or input object. The input is identified using an IEditorInput. Modifications made in an editor part follow an open-save-close lifecycle model (in contrast to a view part, where modifications are saved to the workbench immediately). An editor is document or input-centric. Each editor has an input, and only one editor can exist for each editor input within a page. This policy has been designed to simplify part management. An editor should be used in place of a view whenever more than one instance of a document type can exist. This interface may be implemented directly. For convenience, a base implementation is defined in EditorPart. An editor part is added to the workbench in two stages: An editor extension is contributed to the workbench registry. This extension defines the extension id, extension class, and the file extensions which are supported by the editor. An editor part based upon the extension is created and added to the workbench when the user opens a file with one of the supported file extensions (or some other suitable form of editor input). All editor parts implement the IAdaptable interface; extensions are managed by the platform\'s adapter manager. See Also: IWorkbenchPage.openEditor(IEditorInput, String), EditorPart Workbench parts implement or adapt to this interface to participate in the enablement and execution of the Save and Save As actions. Since: 2.1 See Also: IEditorPart An interface for an adaptable object. Adaptable objects can be dynamically extended to provide different interfaces (or \"adapters\"). Adapters are created by adapter factories, which are in turn managed by type by adapter managers. For example, IAdaptable a = [some adaptable]; IFoo x = (IFoo)a.getAdapter(IFoo.class); if (x != null) [do IFoo things with x] This interface can be used without OSGi running. Clients may implement this interface, or obtain a default implementation of this interface by subclassing PlatformObject. See Also: IAdapterFactory, IAdapterManager, PlatformObject extends IAdaptable A workbench part is a visual component within a workbench page. There are two subtypes: view and editor, as defined by IViewPart and IEditorPart. A view is typically used to navigate a hierarchy of information (like the workspace), open an editor, or display properties for the active editor. Modifications made in a view are saved immediately. An editor is typically used to edit or browse a document or input object. The input is identified using an IEditorInput. Modifications made in an editor part follow an open-save-close lifecycle model. This interface may be implemented directly. For convenience, a base implementation is defined in WorkbenchPart. The lifecycle of a workbench part is as follows: When a part extension is created: instantiate the part create a part site call part.init(site) When a part becomes visible in the workbench: add part to presentation by calling part.createPartControl(parent) to create actual widgets fire partOpened event to all listeners When a part is activated or gets focus: call part.setFocus() fire partActivated event to all listeners When a part is closed: if save is needed, do save; if it fails or is canceled return if part is active, deactivate part fire partClosed event to all listeners remove part from presentation; part controls are disposed as part of the SWT widget tree call part.dispose() After createPartControl has been called, the implementor may safely reference the controls created. When the part is closed these controls will be disposed as part of an SWT composite. This occurs before the IWorkbenchPart.dispose method is called. If there is a need to free SWT resources the part should define a dispose listener for its own control and free those resources from the dispose listener. If the part invokes any method on the disposed SWT controls after this point an SWTError will be thrown. The last method called on IWorkbenchPart is dispose. This signals the end of the part lifecycle. An important point to note about this lifecycle is that following a call to init, createPartControl may never be called. Thus in the dispose method, implementors must not assume controls were created. Workbench parts implement the IAdaptable interface; extensions are managed by the platform\'s adapter manager. See Also: IViewPart, IEditorPart extends IEditorPart Interface for reusable editors. An editors may support changing its input so that the workbench may change its contents instead of opening a new editor. Workbench parts implement or adapt to this interface to participate in the enablement and execution of the Save and Save As actions. Since: 2.1 See Also: IEditorPart Represents a source of Saveable objects (units of saveability). Workbench parts that show more than one unit of saveability, or whose units of saveability change over time, should implement this interface in order to provide better integration with workbench facilities like the Save command, prompts to save on part close or shutdown, etc. IMPORTANT: As of 3.2, implementers of ISaveablesSource must satisfy the following conditions: If ISaveablesSource is implemented by an IWorkbenchPart: the part must implement ISaveablePart if any of its Saveable objects are dirty, the part must return true from ISaveablePart.isDirty() the part must return true from ISaveablePart.isSaveOnCloseNeeded() if it is dirty (the default behaviour implemented by EditorPart) the part must not implement ISaveablePart2 If ISaveablesSource is implemented by a non-part (possible as of 3.2.1 and 3.3): the Workbench\'s ISaveablesLifecycleListener (obtained from the Workbench by calling workbench.getService(ISaveablesLifecycleListener.class)) must be notified of any change to the result of getSaveables() getActiveSaveables() should be implemented to return an empty array If any of these conditions are not met, it is undefined whether the Workbench will prompt to save dirty Saveables when closing parts or the Workbench. These conditions may be relaxed in future releases. Since: 3.2 An interface for an adaptable object. Adaptable objects can be dynamically extended to provide different interfaces (or \"adapters\"). Adapters are created by adapter factories, which are in turn managed by type by adapter managers. For example, IAdaptable a = [some adaptable]; IFoo x = (IFoo)a.getAdapter(IFoo.class); if (x != null) [do IFoo things with x] This interface can be used without OSGi running. Clients may implement this interface, or obtain a default implementation of this interface by subclassing PlatformObject. See Also: IAdapterFactory, IAdapterManager, PlatformObject extends IAdaptable A workbench part is a visual component within a workbench page. There are two subtypes: view and editor, as defined by IViewPart and IEditorPart. A view is typically used to navigate a hierarchy of information (like the workspace), open an editor, or display properties for the active editor. Modifications made in a view are saved immediately. An editor is typically used to edit or browse a document or input object. The input is identified using an IEditorInput. Modifications made in an editor part follow an open-save-close lifecycle model. This interface may be implemented directly. For convenience, a base implementation is defined in WorkbenchPart. The lifecycle of a workbench part is as follows: When a part extension is created: instantiate the part create a part site call part.init(site) When a part becomes visible in the workbench: add part to presentation by calling part.createPartControl(parent) to create actual widgets fire partOpened event to all listeners When a part is activated or gets focus: call part.setFocus() fire partActivated event to all listeners When a part is closed: if save is needed, do save; if it fails or is canceled return if part is active, deactivate part fire partClosed event to all listeners remove part from presentation; part controls are disposed as part of the SWT widget tree call part.dispose() After createPartControl has been called, the implementor may safely reference the controls created. When the part is closed these controls will be disposed as part of an SWT composite. This occurs before the IWorkbenchPart.dispose method is called. If there is a need to free SWT resources the part should define a dispose listener for its own control and free those resources from the dispose listener. If the part invokes any method on the disposed SWT controls after this point an SWTError will be thrown. The last method called on IWorkbenchPart is dispose. This signals the end of the part lifecycle. An important point to note about this lifecycle is that following a call to init, createPartControl may never be called. Thus in the dispose method, implementors must not assume controls were created. Workbench parts implement the IAdaptable interface; extensions are managed by the platform\'s adapter manager. See Also: IViewPart, IEditorPart An interface for an adaptable object. Adaptable objects can be dynamically extended to provide different interfaces (or \"adapters\"). Adapters are created by adapter factories, which are in turn managed by type by adapter managers. For example, IAdaptable a = [some adaptable]; IFoo x = (IFoo)a.getAdapter(IFoo.class); if (x != null) [do IFoo things with x] This interface can be used without OSGi running. Clients may implement this interface, or obtain a default implementation of this interface by subclassing PlatformObject. See Also: IAdapterFactory, IAdapterManager, PlatformObject An interface for an adaptable object. Adaptable objects can be dynamically extended to provide different interfaces (or \"adapters\"). Adapters are created by adapter factories, which are in turn managed by type by adapter managers. For example, IAdaptable a = [some adaptable]; IFoo x = (IFoo)a.getAdapter(IFoo.class); if (x != null) [do IFoo things with x] This interface can be used without OSGi running. Clients may implement this interface, or obtain a default implementation of this interface by subclassing PlatformObject. See Also: IAdapterFactory, IAdapterManager, PlatformObject extends IAdaptable A workbench part is a visual component within a workbench page. There are two subtypes: view and editor, as defined by IViewPart and IEditorPart. A view is typically used to navigate a hierarchy of information (like the workspace), open an editor, or display properties for the active editor. Modifications made in a view are saved immediately. An editor is typically used to edit or browse a document or input object. The input is identified using an IEditorInput. Modifications made in an editor part follow an open-save-close lifecycle model. This interface may be implemented directly. For convenience, a base implementation is defined in WorkbenchPart. The lifecycle of a workbench part is as follows: When a part extension is created: instantiate the part create a part site call part.init(site) When a part becomes visible in the workbench: add part to presentation by calling part.createPartControl(parent) to create actual widgets fire partOpened event to all listeners When a part is activated or gets focus: call part.setFocus() fire partActivated event to all listeners When a part is closed: if save is needed, do save; if it fails or is canceled return if part is active, deactivate part fire partClosed event to all listeners remove part from presentation; part controls are disposed as part of the SWT widget tree call part.dispose() After createPartControl has been called, the implementor may safely reference the controls created. When the part is closed these controls will be disposed as part of an SWT composite. This occurs before the IWorkbenchPart.dispose method is called. If there is a need to free SWT resources the part should define a dispose listener for its own control and free those resources from the dispose listener. If the part invokes any method on the disposed SWT controls after this point an SWTError will be thrown. The last method called on IWorkbenchPart is dispose. This signals the end of the part lifecycle. An important point to note about this lifecycle is that following a call to init, createPartControl may never be called. Thus in the dispose method, implementors must not assume controls were created. Workbench parts implement the IAdaptable interface; extensions are managed by the platform\'s adapter manager. See Also: IViewPart, IEditorPart extends IWorkbenchPart Extends IWorkbenchPart, adding the name and status text properties. Prior to 3.0, a view\'s title was often modified to show both the part name and extra status text. With this interface, the distinction is made more explicit. Since: 3.0 An interface for an adaptable object. Adaptable objects can be dynamically extended to provide different interfaces (or \"adapters\"). Adapters are created by adapter factories, which are in turn managed by type by adapter managers. For example, IAdaptable a = [some adaptable]; IFoo x = (IFoo)a.getAdapter(IFoo.class); if (x != null) [do IFoo things with x] This interface can be used without OSGi running. Clients may implement this interface, or obtain a default implementation of this interface by subclassing PlatformObject. See Also: IAdapterFactory, IAdapterManager, PlatformObject An interface for an adaptable object. Adaptable objects can be dynamically extended to provide different interfaces (or \"adapters\"). Adapters are created by adapter factories, which are in turn managed by type by adapter managers. For example, IAdaptable a = [some adaptable]; IFoo x = (IFoo)a.getAdapter(IFoo.class); if (x != null) [do IFoo things with x] This interface can be used without OSGi running. Clients may implement this interface, or obtain a default implementation of this interface by subclassing PlatformObject. See Also: IAdapterFactory, IAdapterManager, PlatformObject extends IAdaptable A workbench part is a visual component within a workbench page. There are two subtypes: view and editor, as defined by IViewPart and IEditorPart. A view is typically used to navigate a hierarchy of information (like the workspace), open an editor, or display properties for the active editor. Modifications made in a view are saved immediately. An editor is typically used to edit or browse a document or input object. The input is identified using an IEditorInput. Modifications made in an editor part follow an open-save-close lifecycle model. This interface may be implemented directly. For convenience, a base implementation is defined in WorkbenchPart. The lifecycle of a workbench part is as follows: When a part extension is created: instantiate the part create a part site call part.init(site) When a part becomes visible in the workbench: add part to presentation by calling part.createPartControl(parent) to create actual widgets fire partOpened event to all listeners When a part is activated or gets focus: call part.setFocus() fire partActivated event to all listeners When a part is closed: if save is needed, do save; if it fails or is canceled return if part is active, deactivate part fire partClosed event to all listeners remove part from presentation; part controls are disposed as part of the SWT widget tree call part.dispose() After createPartControl has been called, the implementor may safely reference the controls created. When the part is closed these controls will be disposed as part of an SWT composite. This occurs before the IWorkbenchPart.dispose method is called. If there is a need to free SWT resources the part should define a dispose listener for its own control and free those resources from the dispose listener. If the part invokes any method on the disposed SWT controls after this point an SWTError will be thrown. The last method called on IWorkbenchPart is dispose. This signals the end of the part lifecycle. An important point to note about this lifecycle is that following a call to init, createPartControl may never be called. Thus in the dispose method, implementors must not assume controls were created. Workbench parts implement the IAdaptable interface; extensions are managed by the platform\'s adapter manager. See Also: IViewPart, IEditorPart extends IWorkbenchPart Extends IWorkbenchPart, adding the name and status text properties. Prior to 3.0, a view\'s title was often modified to show both the part name and extra status text. With this interface, the distinction is made more explicit. Since: 3.0 extends IWorkbenchPart2 A part can provide arbitrary properties. The properties will be persisted between sessions by the part reference, and will be available from the part reference as well as the part. The properties can only be set on a part, not on the reference. The properties will be available to the IPresentablePart. Setting a property must fire a PropertyChangeEvent. Since: 3.3 The IWorkbenchPartOrientation is the interface that defines the orientation of the part. If a type does not implement this interface an orientation of SWT.NONE will be assumed. Since: 3.1 See Also: SWT.RIGHT_TO_LEFT, SWT.LEFT_TO_RIGHT, SWT.NONE, Window.getDefaultOrientation() extends IEditorPart Interface to a text editor. This interface defines functional extensions to IEditorPart as well as the configuration capabilities of a text editor. Text editors are configured with an IDocumentProvider which delivers a textual presentation (IDocument) of the editor\'s input. The editor works on the document and forwards all input element related calls, such as save, to the document provider. The provider also delivers the input\'s annotation model which is used by the editor\'s vertical ruler. Clients may implement this interface from scratch, but the recommended way is to subclass the abstract base class AbstractTextEditor. In order to provided backward compatibility for clients of ITextEditor, extension interfaces are used to provide a means of evolution. The following extension interfaces exist: ITextEditorExtension since version 2.0 introducing status fields, read-only state and ruler context menu listeners. ITextEditorExtension2 since version 2.1 introducing modifiable state for the editor input and validate state handling. ITextEditorExtension3 since version 3.0 adding input state and change information control. ITextEditorExtension4 since version 3.2 adding annotation navigation and revision information display. ITextEditorExtension5 since version 3.5 adding block selection mode. See Also: IDocumentProvider, IAnnotationModel, ITextEditorExtension, ITextEditorExtension2, ITextEditorExtension3, ITextEditorExtension4, ITextEditorExtension5 Extension interface for ITextEditor. Adds the following functions: status fields read-only state of the editor\'s input ruler context menu listeners. Since: 2.0 Extension interface for ITextEditor. Adds the following functions: modifiable state of the editor\'s input validate state of editor input Since: 2.1 Extension interface for ITextEditor. Adds the following functions: insert mode management Since: 3.0 Extension interface for ITextEditor. Adds the following functions: annotation navigation revision information display This interface may be implemented by clients. Since: 3.2 Extension interface for ITextEditor. Adds the following functions: block selection mode This interface may be implemented by clients. Since: 3.5 extends AbstractDecoratedTextEditor The standard/default text editor. This editor has id \"org.eclipse.ui.DefaultTextEditor\". The editor\'s context menu has id #TextEditorContext. The editor\'s ruler context menu has id #TextRulerContext. The workbench will automatically instantiate this class when the default editor is needed for a workbench window. '
1153, 'org.eclipse.ui.views.contentoutline.ContentOutline', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/views/contentoutline/ContentOutline.html', 'An interface for an adaptable object. Adaptable objects can be dynamically extended to provide different interfaces (or \"adapters\"). Adapters are created by adapter factories, which are in turn managed by type by adapter managers. For example, IAdaptable a = [some adaptable]; IFoo x = (IFoo)a.getAdapter(IFoo.class); if (x != null) [do IFoo things with x] This interface can be used without OSGi running. Clients may implement this interface, or obtain a default implementation of this interface by subclassing PlatformObject. See Also: IAdapterFactory, IAdapterManager, PlatformObject Interface for executable extension classes that require access to their configuration element, or implement an extension adapter. Extension adapters are typically required in cases where the extension implementation does not follow the interface rules specified by the provider of the extension point. In these cases, the role of the adapter is to map between the extension point interface, and the actual extension implementation. In general, adapters are used when attempting to plug-in existing Java implementations, or non-Java implementations (e.g., external executables). This interface can be used without OSGi running. Clients may implement this interface. See Also: IConfigurationElement.createExecutableExtension(String) A listener which is notified when a viewer\'s selection changes. See Also: ISelection, ISelectionProvider, SelectionChangedEvent Interface common to all objects that provide a selection. See Also: ISelection, ISelectionChangedListener, SelectionChangedEvent Interface for listening to part lifecycle events. This interface may be implemented by clients. See Also: IPartService.addPartListener(IPartListener) Objects implementing this interface are capable of saving their state in an IMemento. Since: 3.1 An interface for an adaptable object. Adaptable objects can be dynamically extended to provide different interfaces (or \"adapters\"). Adapters are created by adapter factories, which are in turn managed by type by adapter managers. For example, IAdaptable a = [some adaptable]; IFoo x = (IFoo)a.getAdapter(IFoo.class); if (x != null) [do IFoo things with x] This interface can be used without OSGi running. Clients may implement this interface, or obtain a default implementation of this interface by subclassing PlatformObject. See Also: IAdapterFactory, IAdapterManager, PlatformObject Objects implementing this interface are capable of saving their state in an IMemento. Since: 3.1 An interface for an adaptable object. Adaptable objects can be dynamically extended to provide different interfaces (or \"adapters\"). Adapters are created by adapter factories, which are in turn managed by type by adapter managers. For example, IAdaptable a = [some adaptable]; IFoo x = (IFoo)a.getAdapter(IFoo.class); if (x != null) [do IFoo things with x] This interface can be used without OSGi running. Clients may implement this interface, or obtain a default implementation of this interface by subclassing PlatformObject. See Also: IAdapterFactory, IAdapterManager, PlatformObject extends IAdaptable A workbench part is a visual component within a workbench page. There are two subtypes: view and editor, as defined by IViewPart and IEditorPart. A view is typically used to navigate a hierarchy of information (like the workspace), open an editor, or display properties for the active editor. Modifications made in a view are saved immediately. An editor is typically used to edit or browse a document or input object. The input is identified using an IEditorInput. Modifications made in an editor part follow an open-save-close lifecycle model. This interface may be implemented directly. For convenience, a base implementation is defined in WorkbenchPart. The lifecycle of a workbench part is as follows: When a part extension is created: instantiate the part create a part site call part.init(site) When a part becomes visible in the workbench: add part to presentation by calling part.createPartControl(parent) to create actual widgets fire partOpened event to all listeners When a part is activated or gets focus: call part.setFocus() fire partActivated event to all listeners When a part is closed: if save is needed, do save; if it fails or is canceled return if part is active, deactivate part fire partClosed event to all listeners remove part from presentation; part controls are disposed as part of the SWT widget tree call part.dispose() After createPartControl has been called, the implementor may safely reference the controls created. When the part is closed these controls will be disposed as part of an SWT composite. This occurs before the IWorkbenchPart.dispose method is called. If there is a need to free SWT resources the part should define a dispose listener for its own control and free those resources from the dispose listener. If the part invokes any method on the disposed SWT controls after this point an SWTError will be thrown. The last method called on IWorkbenchPart is dispose. This signals the end of the part lifecycle. An important point to note about this lifecycle is that following a call to init, createPartControl may never be called. Thus in the dispose method, implementors must not assume controls were created. Workbench parts implement the IAdaptable interface; extensions are managed by the platform\'s adapter manager. See Also: IViewPart, IEditorPart extends IWorkbenchPart, IPersistable A view is a visual component within a workbench page. It is typically used to navigate a hierarchy of information (like the workspace), open an editor, or display properties for the active editor. Modifications made in a view are saved immediately (in contrast to an editor part, which conforms to a more elaborate open-save-close lifecycle). Only one instance of a particular view type may exist within a workbench page. This policy is designed to simplify part management for a user. This interface may be implemented directly. For convenience, a base implementation is defined in ViewPart. A view is added to the workbench in two steps: A view extension is contributed to the workbench registry. This extension defines the extension id and extension class. The view is included in the default layout for a perspective. Alternatively, the user may open the view from the Perspective menu. Views implement the IAdaptable interface; extensions are managed by the platform\'s adapter manager. As of 3.4, views may optionally adapt to ISizeProvider if they have a preferred size. The default presentation will make a best effort to allocate the preferred size to a view if it is the only part in a stack. If there is more than one part in the stack, the constraints will be disabled for that stack. The size constraints are adjusted for the size of the tab and border trim. Note that this is considered to be a hint to the presentation, and not all presentations may honor size constraints. See Also: IWorkbenchPage.showView(java.lang.String), ViewPart, ISizeProvider An interface for an adaptable object. Adaptable objects can be dynamically extended to provide different interfaces (or \"adapters\"). Adapters are created by adapter factories, which are in turn managed by type by adapter managers. For example, IAdaptable a = [some adaptable]; IFoo x = (IFoo)a.getAdapter(IFoo.class); if (x != null) [do IFoo things with x] This interface can be used without OSGi running. Clients may implement this interface, or obtain a default implementation of this interface by subclassing PlatformObject. See Also: IAdapterFactory, IAdapterManager, PlatformObject extends IAdaptable A workbench part is a visual component within a workbench page. There are two subtypes: view and editor, as defined by IViewPart and IEditorPart. A view is typically used to navigate a hierarchy of information (like the workspace), open an editor, or display properties for the active editor. Modifications made in a view are saved immediately. An editor is typically used to edit or browse a document or input object. The input is identified using an IEditorInput. Modifications made in an editor part follow an open-save-close lifecycle model. This interface may be implemented directly. For convenience, a base implementation is defined in WorkbenchPart. The lifecycle of a workbench part is as follows: When a part extension is created: instantiate the part create a part site call part.init(site) When a part becomes visible in the workbench: add part to presentation by calling part.createPartControl(parent) to create actual widgets fire partOpened event to all listeners When a part is activated or gets focus: call part.setFocus() fire partActivated event to all listeners When a part is closed: if save is needed, do save; if it fails or is canceled return if part is active, deactivate part fire partClosed event to all listeners remove part from presentation; part controls are disposed as part of the SWT widget tree call part.dispose() After createPartControl has been called, the implementor may safely reference the controls created. When the part is closed these controls will be disposed as part of an SWT composite. This occurs before the IWorkbenchPart.dispose method is called. If there is a need to free SWT resources the part should define a dispose listener for its own control and free those resources from the dispose listener. If the part invokes any method on the disposed SWT controls after this point an SWTError will be thrown. The last method called on IWorkbenchPart is dispose. This signals the end of the part lifecycle. An important point to note about this lifecycle is that following a call to init, createPartControl may never be called. Thus in the dispose method, implementors must not assume controls were created. Workbench parts implement the IAdaptable interface; extensions are managed by the platform\'s adapter manager. See Also: IViewPart, IEditorPart An interface for an adaptable object. Adaptable objects can be dynamically extended to provide different interfaces (or \"adapters\"). Adapters are created by adapter factories, which are in turn managed by type by adapter managers. For example, IAdaptable a = [some adaptable]; IFoo x = (IFoo)a.getAdapter(IFoo.class); if (x != null) [do IFoo things with x] This interface can be used without OSGi running. Clients may implement this interface, or obtain a default implementation of this interface by subclassing PlatformObject. See Also: IAdapterFactory, IAdapterManager, PlatformObject An interface for an adaptable object. Adaptable objects can be dynamically extended to provide different interfaces (or \"adapters\"). Adapters are created by adapter factories, which are in turn managed by type by adapter managers. For example, IAdaptable a = [some adaptable]; IFoo x = (IFoo)a.getAdapter(IFoo.class); if (x != null) [do IFoo things with x] This interface can be used without OSGi running. Clients may implement this interface, or obtain a default implementation of this interface by subclassing PlatformObject. See Also: IAdapterFactory, IAdapterManager, PlatformObject extends IAdaptable A workbench part is a visual component within a workbench page. There are two subtypes: view and editor, as defined by IViewPart and IEditorPart. A view is typically used to navigate a hierarchy of information (like the workspace), open an editor, or display properties for the active editor. Modifications made in a view are saved immediately. An editor is typically used to edit or browse a document or input object. The input is identified using an IEditorInput. Modifications made in an editor part follow an open-save-close lifecycle model. This interface may be implemented directly. For convenience, a base implementation is defined in WorkbenchPart. The lifecycle of a workbench part is as follows: When a part extension is created: instantiate the part create a part site call part.init(site) When a part becomes visible in the workbench: add part to presentation by calling part.createPartControl(parent) to create actual widgets fire partOpened event to all listeners When a part is activated or gets focus: call part.setFocus() fire partActivated event to all listeners When a part is closed: if save is needed, do save; if it fails or is canceled return if part is active, deactivate part fire partClosed event to all listeners remove part from presentation; part controls are disposed as part of the SWT widget tree call part.dispose() After createPartControl has been called, the implementor may safely reference the controls created. When the part is closed these controls will be disposed as part of an SWT composite. This occurs before the IWorkbenchPart.dispose method is called. If there is a need to free SWT resources the part should define a dispose listener for its own control and free those resources from the dispose listener. If the part invokes any method on the disposed SWT controls after this point an SWTError will be thrown. The last method called on IWorkbenchPart is dispose. This signals the end of the part lifecycle. An important point to note about this lifecycle is that following a call to init, createPartControl may never be called. Thus in the dispose method, implementors must not assume controls were created. Workbench parts implement the IAdaptable interface; extensions are managed by the platform\'s adapter manager. See Also: IViewPart, IEditorPart extends IWorkbenchPart Extends IWorkbenchPart, adding the name and status text properties. Prior to 3.0, a view\'s title was often modified to show both the part name and extra status text. With this interface, the distinction is made more explicit. Since: 3.0 An interface for an adaptable object. Adaptable objects can be dynamically extended to provide different interfaces (or \"adapters\"). Adapters are created by adapter factories, which are in turn managed by type by adapter managers. For example, IAdaptable a = [some adaptable]; IFoo x = (IFoo)a.getAdapter(IFoo.class); if (x != null) [do IFoo things with x] This interface can be used without OSGi running. Clients may implement this interface, or obtain a default implementation of this interface by subclassing PlatformObject. See Also: IAdapterFactory, IAdapterManager, PlatformObject An interface for an adaptable object. Adaptable objects can be dynamically extended to provide different interfaces (or \"adapters\"). Adapters are created by adapter factories, which are in turn managed by type by adapter managers. For example, IAdaptable a = [some adaptable]; IFoo x = (IFoo)a.getAdapter(IFoo.class); if (x != null) [do IFoo things with x] This interface can be used without OSGi running. Clients may implement this interface, or obtain a default implementation of this interface by subclassing PlatformObject. See Also: IAdapterFactory, IAdapterManager, PlatformObject extends IAdaptable A workbench part is a visual component within a workbench page. There are two subtypes: view and editor, as defined by IViewPart and IEditorPart. A view is typically used to navigate a hierarchy of information (like the workspace), open an editor, or display properties for the active editor. Modifications made in a view are saved immediately. An editor is typically used to edit or browse a document or input object. The input is identified using an IEditorInput. Modifications made in an editor part follow an open-save-close lifecycle model. This interface may be implemented directly. For convenience, a base implementation is defined in WorkbenchPart. The lifecycle of a workbench part is as follows: When a part extension is created: instantiate the part create a part site call part.init(site) When a part becomes visible in the workbench: add part to presentation by calling part.createPartControl(parent) to create actual widgets fire partOpened event to all listeners When a part is activated or gets focus: call part.setFocus() fire partActivated event to all listeners When a part is closed: if save is needed, do save; if it fails or is canceled return if part is active, deactivate part fire partClosed event to all listeners remove part from presentation; part controls are disposed as part of the SWT widget tree call part.dispose() After createPartControl has been called, the implementor may safely reference the controls created. When the part is closed these controls will be disposed as part of an SWT composite. This occurs before the IWorkbenchPart.dispose method is called. If there is a need to free SWT resources the part should define a dispose listener for its own control and free those resources from the dispose listener. If the part invokes any method on the disposed SWT controls after this point an SWTError will be thrown. The last method called on IWorkbenchPart is dispose. This signals the end of the part lifecycle. An important point to note about this lifecycle is that following a call to init, createPartControl may never be called. Thus in the dispose method, implementors must not assume controls were created. Workbench parts implement the IAdaptable interface; extensions are managed by the platform\'s adapter manager. See Also: IViewPart, IEditorPart extends IWorkbenchPart Extends IWorkbenchPart, adding the name and status text properties. Prior to 3.0, a view\'s title was often modified to show both the part name and extra status text. With this interface, the distinction is made more explicit. Since: 3.0 extends IWorkbenchPart2 A part can provide arbitrary properties. The properties will be persisted between sessions by the part reference, and will be available from the part reference as well as the part. The properties can only be set on a part, not on the reference. The properties will be available to the IPresentablePart. Setting a property must fire a PropertyChangeEvent. Since: 3.3 The IWorkbenchPartOrientation is the interface that defines the orientation of the part. If a type does not implement this interface an orientation of SWT.NONE will be assumed. Since: 3.1 See Also: SWT.RIGHT_TO_LEFT, SWT.LEFT_TO_RIGHT, SWT.NONE, Window.getDefaultOrientation() extends PageBookView implements ISelectionProvider, ISelectionChangedListener Main class for the Content Outline View. This standard view has id \"org.eclipse.ui.views.ContentOutline\". When a content outline view notices an editor being activated, it asks the editor whether it has a content outline page to include in the outline view. This is done using getAdapter: IEditorPart editor = ...; IContentOutlinePage outlinePage = (IContentOutlinePage) editor.getAdapter(IContentOutlinePage.class); if (outlinePage != null) { // editor wishes to contribute outlinePage to content outline view } If the editor supports a content outline page, the editor instantiates and configures the page, and returns it. This page is then added to the content outline view (a pagebook which presents one page at a time) and immediately made the current page (the content outline view need not be visible). If the editor does not support a content outline page, the content outline view shows a special default page which makes it clear to the user that the content outline view is disengaged. A content outline page is free to report selection events; the content outline view forwards these events along to interested parties. When the content outline view notices a different editor being activated, it flips to the editor\'s corresponding content outline page. When the content outline view notices an editor being closed, it destroys the editor\'s corresponding content outline page. The workbench will automatically instantiate this class when a Content Outline view is needed for a workbench window. This class was not intended to be instantiated or subclassed by clients. Restriction: This class is not intended to be subclassed by clients. Restriction: This class is not intended to be instantiated by clients. '
1154, 'org.eclipse.jface.text.IDocument', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/text/IDocument.html', 'An IDocument represents text providing support for text manipulation positions partitions line information document change listeners document partition change listeners A document allows to set its content and to manipulate it. For manipulation a document provides the replace method which substitutes a given string for a specified text range in the document. On each document change, all registered document listeners are informed exactly once. Positions are stickers to the document\'s text that are updated when the document is changed. Positions are updated by IPositionUpdaters. Position updaters are managed as a list. The list defines the sequence in which position updaters are invoked. This way, position updaters may rely on each other. Positions are grouped into categories. A category is a ordered list of positions. the document defines the order of position in a category based on the position\'s offset based on the implementation of the method computeIndexInCategory. Each document must support a default position category whose name is specified by this interface. A document can be considered consisting of a sequence of not overlapping partitions. A partition is defined by its offset, its length, and its type. Partitions are updated on every document manipulation and ensured to be up-to-date when the document listeners are informed. A document uses an IDocumentPartitioner to manage its partitions. A document may be unpartitioned which happens when there is no partitioner. In this case, the document is considered as one single partition of a default type. The default type is specified by this interface. If a document change changes the document\'s partitioning all registered partitioning listeners are informed exactly once. The extension interface IDocumentExtension3 introduced in version 3.0 extends the concept of partitions and allows a document to not only manage one but multiple partitioning. Each partitioning has an id which must be used to refer to a particular partitioning. An IDocument provides methods to map line numbers and character positions onto each other based on the document\'s line delimiters. When moving text between documents using different line delimiters, the text must be converted to use the target document\'s line delimiters. An IDocument does not care about mixed line delimiters. Clients who want to ensure a single line delimiter in their document should use the line delimiter returned by TextUtilities.getDefaultLineDelimiter(IDocument). IDocument throws BadLocationException if the parameters of queries or manipulation requests are not inside the bounds of the document. The purpose of this style of exception handling is prepare document for multi-thread access allow clients to implement backtracking recovery methods prevent clients from up-front contract checking when dealing with documents. A document support for searching has deprecated since version 3.0. The recommended way for searching is to use a FindReplaceDocumentAdapter. In order to provide backward compatibility for clients of IDocument, extension interfaces are used to provide a means of evolution. The following extension interfaces exist: IDocumentExtension since version 2.0 introducing the concept of post notification replaces in order to allow document listeners to manipulate the document while receiving a document change notification IDocumentExtension2 since version 2.1 introducing configuration methods for post notification replaces and document change notification. IDocumentExtension3 since version 3.0 replacing the original partitioning concept by allowing multiple partitionings at the same time and introducing zero- length partitions in conjunction with the distinction between open and closed partitions. IDocumentExtension4 since version 3.1 introducing the concept of rewrite sessions. A rewrite session is a sequence of document replace operations that form a semantic unit. It also introduces a modification stamp and the ability to set the initial line delimiter and to query the default line delimiter. Clients may implement this interface and its extension interfaces or use the default implementation provided by AbstractDocument and Document. See Also: IDocumentExtension, IDocumentExtension2, IDocumentExtension3, IDocumentExtension4, Position, IPositionUpdater, IDocumentPartitioner, ILineTracker, IDocumentListener, IDocumentPartitioningListener '
1155, 'org.eclipse.ui.navigator.LinkHelperService', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/navigator/LinkHelperService.html', 'extends Object Manages the link helpers which are used to define the behavior of the link with editor function. Since: 3.4 Restriction: This class is not intended to be instantiated by clients. '
1156, 'org.eclipse.jface.viewers.DecoratingStyledCellLabelProvider', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/viewers/DecoratingStyledCellLabelProvider.html', 'A label provider maps an element of the viewer\'s model to an optional image and optional text string used to display the element in the viewer\'s control. Certain label providers may allow multiple labels per element. This is an \"abstract interface\", defining methods common to all label providers, but does not actually define the methods to get the label(s) for an element. This interface should never be directly implemented. Most viewers will take either an ILabelProvider or an ITableLabelProvider. A label provider must not be shared between viewers since a label provider generally manages SWT resources (images), which must be disposed when the viewer is disposed. To simplify life cycle management, the current label provider of a viewer is disposed when the viewer is disposed. Label providers can be used outside the context of viewers wherever images are needed. When label providers are used in this fashion it is the responsibility of the user to ensure dispose is called when the provider is no longer needed. See Also: ILabelProvider, ITableLabelProvider extends DelegatingStyledCellLabelProvider A DecoratingStyledCellLabelProvider is a DelegatingStyledCellLabelProvider that uses a nested DelegatingStyledCellLabelProvider.IStyledLabelProvider to compute styled text label and image and takes a ILabelDecorator to decorate the label. Use this label provider as a replacement for the DecoratingLabelProvider when decorating styled text labels. The DecoratingStyledCellLabelProvider will try to evaluate the text decoration added by the ILabelDecorator and will apply the style returned by getDecorationStyle(Object) The ILabelDecorator can optionally implement IColorDecorator and IFontDecorator to provide foreground and background color and font decoration. Since: 3.4 '
1157, 'org.eclipse.ui.ide.dialogs.PathVariableSelectionDialog', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/ide/dialogs/PathVariableSelectionDialog.html', 'Interface for objects that can return a shell. This is normally used for opening child windows. An object that wants to open child shells can take an IShellProvider in its constructor, and the object that implements IShellProvider can dynamically choose where child shells should be opened. Since: 3.1 extends SelectionDialog A selection dialog which shows the path variables defined in the workspace. The getResult method returns the name(s) of the selected path variable(s). This class may be instantiated; it is not intended to be subclassed. Example: PathVariableSelectionDialog dialog = new PathVariableSelectionDialog(getShell(), IResource.FOLDER); dialog.open(); String[] result = (String[]) dialog.getResult(); Since: 3.1 '
1158, 'org.eclipse.ui.part.DrillDownComposite', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/part/DrillDownComposite.html', 'Implementers of Drawable can have a graphics context (GC) created for them, and then they can be drawn on by sending messages to their associated GC. SWT images, and device objects such as the Display device and the Printer device, are drawables. IMPORTANT: This interface is not part of the SWT public API. It is marked public only so that it can be shared within the packages provided by SWT. It should never be referenced from application code. See Also: Device, Image, GC extends Composite Class DrillDownComposite implements a simple web style navigation metaphor. Home, back, and \"drill into\" buttons are added to a tree viewer for easier navigation. To use the DrillDownComposite.. Create an instance of DrillDownComposite. Create a tree viewer. Pass the second tree viewer into the composite by calling setChildTree. '
1159, 'org.eclipse.ui.forms.widgets.ILayoutExtension', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/forms/widgets/ILayoutExtension.html', 'Classes that extend abstract class Layout and implement this interface can take part in layout computation of the TableWrapLayout manager. This layout uses alternative algorithm that computes columns before rows. It allows it to \'flow\' wrapped text proportionally (similar to the way web browser renders tables). Custom layout managers that implement this interface will allow TableWrapLayout to properly compute width hint to pass. Since: 3.0 See Also: TableWrapLayout, ColumnLayout '
1160, 'org.eclipse.ui.views.contentoutline.IContentOutlinePage', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/views/contentoutline/IContentOutlinePage.html', 'Interface common to all objects that provide a selection. See Also: ISelection, ISelectionChangedListener, SelectionChangedEvent extends IPage, ISelectionProvider Marker-style interface for a content outline page. This interface defines the minimum requirement for pages within the content outline view, namely they must be pages (implement IPage) and provide selections (implement ISelectionProvider). Access to a content outline page begins when an editor is activated. When activation occurs, the content outline view will ask the editor for its content outline page. This is done by invoking getAdapter(IContentOutlinePage.class) on the editor. If the editor returns a page, the view then creates the controls for that page (using createControl) and makes the page visible. Clients may implement this interface from scratch, or subclass the abstract base class ContentOutlinePage. Note that this interface extends ISelectionProvider. This is no longer required in the case of implementors who also implement IPageBookViewPage (or extend Page) as they are now passed an IPageSite during their initialization and this site can be configured with a selection provider. However to avoid a breaking change 1) this interface will continue to extend ISelectionProvider 2) if an IContentOutlinePage does not set a selection provider for its site, the ContentOutline will continue to use the page itself for this purpose. See Also: ContentOutlinePage '
1161, 'org.eclipse.ui.views.properties.tabbed.TabbedPropertySheetPage', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/views/properties/tabbed/TabbedPropertySheetPage.html', 'A listener which is notified when a label provider\'s state changes. See Also: IBaseLabelProvider.addListener(org.eclipse.jface.viewers.ILabelProviderListener), IBaseLabelProvider.removeListener(org.eclipse.jface.viewers.ILabelProviderListener) extends EventListener Interface for listening to selection changes. This interface may be implemented by clients. See Also: ISelectionService.addSelectionListener(ISelectionListener), ISelectionService.addSelectionListener(String, ISelectionListener), INullSelectionListener extends IPage Interface for a page in a pagebook view. Pages should implement this interface. See Also: PageBookView, Page extends EventListener Interface for listening to selection changes. This interface may be implemented by clients. See Also: ISelectionService.addSelectionListener(ISelectionListener), ISelectionService.addSelectionListener(String, ISelectionListener), INullSelectionListener extends IPage, ISelectionListener Interface for a property sheet page that appears in a property sheet view. This interface defines the minimum requirement for pages within the property sheet view, namely they must be pages (implement IPage) be prepared to contribute actions to the property sheet view\'s tool bar and status line, and listen for selection changes in the active part. Clients may implement this interface from scratch if the property sheet viewer\'s default page is unsuitable for displaying a part\'s properties. See Also: PropertySheetPage extends Page implements IPropertySheetPage, ILabelProviderListener A property sheet page that provides a tabbed UI. '
1162, 'org.eclipse.jface.viewers.ListViewer', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/viewers/ListViewer.html', 'Interface common to all objects that provide an input. Interface common to all objects that provide an input. Interface common to all objects that provide a selection. See Also: ISelection, ISelectionChangedListener, SelectionChangedEvent extends IInputProvider, ISelectionProvider Interface common to all objects that provide both an input and a selection. Interface common to all objects that provide a selection. See Also: ISelection, ISelectionChangedListener, SelectionChangedEvent extends ISelectionProvider Selection provider extension interface to allow providers to notify about post selection changed events. A post selection changed event is equivalent to selection changed event if the selection change was triggered by the mouse, but it has a delay if the selection change is triggered by keyboard navigation. Since: 3.0 See Also: ISelectionProvider Interface common to all objects that provide a selection. See Also: ISelection, ISelectionChangedListener, SelectionChangedEvent extends AbstractListViewer A concrete viewer based on an SWT List control. This class is not intended to be subclassed. It is designed to be instantiated with a pre-existing SWT List control and configured with a domain-specific content provider, label provider, element filter (optional), and element sorter (optional). Note that the SWT List control only supports the display of strings, not icons. If you need to show icons for items, use TableViewer instead. See Also: TableViewer Restriction: This class is not intended to be subclassed by clients. '
1163, 'org.eclipse.ui.views.contentoutline.ContentOutlinePage', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/views/contentoutline/ContentOutlinePage.html', 'A listener which is notified when a viewer\'s selection changes. See Also: ISelection, ISelectionProvider, SelectionChangedEvent Interface common to all objects that provide a selection. See Also: ISelection, ISelectionChangedListener, SelectionChangedEvent extends IPage Interface for a page in a pagebook view. Pages should implement this interface. See Also: PageBookView, Page Interface common to all objects that provide a selection. See Also: ISelection, ISelectionChangedListener, SelectionChangedEvent extends IPage, ISelectionProvider Marker-style interface for a content outline page. This interface defines the minimum requirement for pages within the content outline view, namely they must be pages (implement IPage) and provide selections (implement ISelectionProvider). Access to a content outline page begins when an editor is activated. When activation occurs, the content outline view will ask the editor for its content outline page. This is done by invoking getAdapter(IContentOutlinePage.class) on the editor. If the editor returns a page, the view then creates the controls for that page (using createControl) and makes the page visible. Clients may implement this interface from scratch, or subclass the abstract base class ContentOutlinePage. Note that this interface extends ISelectionProvider. This is no longer required in the case of implementors who also implement IPageBookViewPage (or extend Page) as they are now passed an IPageSite during their initialization and this site can be configured with a selection provider. However to avoid a breaking change 1) this interface will continue to extend ISelectionProvider 2) if an IContentOutlinePage does not set a selection provider for its site, the ContentOutline will continue to use the page itself for this purpose. See Also: ContentOutlinePage extends Page implements IContentOutlinePage, ISelectionChangedListener An abstract base class for content outline pages. Clients who are defining an editor may elect to provide a corresponding content outline page. This content outline page will be presented to the user via the standard Content Outline View (the user decides whether their workbench window contains this view) whenever that editor is active. This class should be subclassed. Internally, each content outline page consists of a standard tree viewer; selections made in the tree viewer are reported as selection change events by the page (which is a selection provider). The tree viewer is not created until createPage is called; consequently, subclasses must extend createControl to configure the tree viewer with a proper content provider, label provider, and input element. Subclasses may provide a hint for constructing the tree viewer using getTreeStyle(). Note that those wanting to use a control other than internally created TreeViewer will need to implement IContentOutlinePage directly rather than subclassing this class. '
1164, 'org.eclipse.ui.dialogs.SaveAsDialog', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/dialogs/SaveAsDialog.html', 'Interface for objects that can return a shell. This is normally used for opening child windows. An object that wants to open child shells can take an IShellProvider in its constructor, and the object that implements IShellProvider can dynamically choose where child shells should be opened. Since: 3.1 extends TitleAreaDialog A standard \"Save As\" dialog which solicits a path from the user. The getResult method returns the path. Note that the folder at the specified path might not exist and might need to be created. This class may be instantiated; it is not intended to be subclassed. See Also: ContainerGenerator Restriction: This class is not intended to be subclassed by clients. '
1165, 'org.eclipse.ui.IMarkerResolution', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/IMarkerResolution.html', 'Resolution for a marker. When run, a resolution would typically eliminate the need for the marker. Since: 2.0 '
1166, 'org.eclipse.core.commands.operations.AbstractOperation', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/commands/operations/AbstractOperation.html', ' IUndoableOperation defines an operation that can be executed, undone, and redone. Operations typically have fully defined parameters. That is, they are usually created after the user has been queried for any input needed to define the operation. Operations determine their ability to execute, undo, or redo according to the current state of the application. They do not make decisions about their validity based on where they occur in the operation history. That is left to the particular operation history. Since: 3.1 extends Object implements IUndoableOperation Abstract implementation for an undoable operation. At a minimum, subclasses should implement behavior for IUndoableOperation.execute(org.eclipse.core.runtime.IProgressMonitor, org.eclipse.core.runtime.IAdaptable), IUndoableOperation.redo(org.eclipse.core.runtime.IProgressMonitor, org.eclipse.core.runtime.IAdaptable), and IUndoableOperation.undo(org.eclipse.core.runtime.IProgressMonitor, org.eclipse.core.runtime.IAdaptable). Since: 3.1 See Also: IUndoableOperation '
1167, 'org.eclipse.ui.ide.undo.CreateFolderOperation', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/ide/undo/CreateFolderOperation.html', ' IAdvancedUndoableOperation defines an interface for undoable operations that modify one or more elements in a model and attempt to keep model listeners up to date with changes that occur in the undo and redo history involving particular model elements. It also defines methods for computing the validity of an operation for undo or redo before attempting to perform the undo or redo. This interface is intended to be used by legacy frameworks that are adapting their original undo and redo support to this framework. The methods in this interface allow legacy clients to maintain features not supported in the basic operations framework. Since: 3.1 IAdvancedUndoableOperation2 defines a method for computing the validity of executing an operation before attempting to execute it. It also defines a way for clients to specify that computing status should be done quietly, without consulting the user. This interface is useful when implementing IOperationApprover2, or any other object that performs validation of the undo history. It also allows operations to specify whether they should be run in the UI thread. Since: 3.3 IUndoableOperation defines an operation that can be executed, undone, and redone. Operations typically have fully defined parameters. That is, they are usually created after the user has been queried for any input needed to define the operation. Operations determine their ability to execute, undo, or redo according to the current state of the application. They do not make decisions about their validity based on where they occur in the operation history. That is left to the particular operation history. Since: 3.1 extends AbstractWorkspaceOperation A CreateFolderOperation represents an undoable operation for creating a folder in the workspace. If a link location is specified, the folder is considered to be linked to the specified location. If a link location is not specified, the folder will be created in the location specified by the handle, and the entire containment path of the folder will be created if it does not exist. The folder should not already exist, and the existence of the containment path should not be changed between the time this operation is created and the time it is executed. Clients may call the public API from a background thread. This class is intended to be instantiated and used by clients. It is not intended to be subclassed by clients. Since: 3.3 Restriction: This class is not intended to be subclassed by clients. '
1168, 'org.eclipse.core.runtime.preferences.ConfigurationScope', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/runtime/preferences/ConfigurationScope.html', 'Clients implement this interface to provide context to a particular scope. Instances of implementations of this interface are passed to the IPreferencesService for use in preference searching. Clients may implement this interface. Since: 3.0 See Also: IPreferencesService extends org.eclipse.core.internal.preferences.AbstractScope Object representing the configuration scope in the Eclipse preferences hierarchy. Can be used as a context for searching for preference values (in the IPreferencesService APIs) or for determining the correct preference node to set values in the store. Configuration preferences are stored on a per configuration basis in the platform\'s configuration area. (The configuration area typically contains the list of plug-ins available for use, various settings (those shared across different instances of the same configuration) and any other such data needed by plug-ins.) The path for preferences defined in the configuration scope hierarchy is as follows: /configuration/<qualifier> This class is not intended to be subclassed. This class may be instantiated. Since: 3.0 See Also: Location.CONFIGURATION_FILTER '
1169, 'org.eclipse.ui.dialogs.ElementTreeSelectionDialog', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/dialogs/ElementTreeSelectionDialog.html', 'Interface for objects that can return a shell. This is normally used for opening child windows. An object that wants to open child shells can take an IShellProvider in its constructor, and the object that implements IShellProvider can dynamically choose where child shells should be opened. Since: 3.1 extends SelectionStatusDialog A class to select elements out of a tree structure. Since: 2.0 '
1170, 'org.eclipse.ui.dialogs.PropertyPage', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/dialogs/PropertyPage.html', 'Interface for a page in a multi-page dialog. Minimal interface to a message provider. Used for dialog pages which can provide a message with an icon. Since: 2.0 Interface for a page in a multi-page dialog. extends IDialogPage An interface for a preference page. This interface is used primarily by the page\'s container Interface for a page in a multi-page dialog. Interface for a page in a multi-page dialog. extends IDialogPage An interface for a preference page. This interface is used primarily by the page\'s container extends IPreferencePage Interface for workbench property pages. Property pages generally show up in the workbench\'s Property Pages dialog. Clients should implement this interface and include the name of their class in an extension contributed to the workbench\'s property page extension point (named \"org.eclipse.ui.propertyPages\"). For example, the plug-in\'s XML markup might contain: <extension point=\"org.eclipse.ui.propertyPages\"> <page id=\"com.example.myplugin.props\" name=\"Knobs\" objectClass=\"org.eclipse.core.resources.IResource\" class=\"com.example.myplugin.MyPropertyPage\" /> </extension> Property pages that support multiple selected objects should implement IWorkbenchPropertyPageMulti instead. See Also: IWorkbenchPropertyPageMulti extends PreferencePage implements IWorkbenchPropertyPage Abstract base implementation of a workbench property page ( IWorkbenchPropertyPage). The implementation is a JFace preference page with an adaptable element. Property pages that support multiple selected objects should implement IWorkbenchPropertyPageMulti instead. Subclasses must implement the createContents framework method to supply the property page\'s main control. Subclasses should extend the doComputeSize framework method to compute the size of the page\'s control. Subclasses may override the performOk, performApply,performDefaults, performCancel, and performHelp framework methods to react to the standard button events. Subclasses may call the noDefaultAndApplyButton framework method before the page\'s control has been created to suppress the standard Apply and Defaults buttons. See Also: IWorkbenchPropertyPage, IWorkbenchPropertyPageMulti '
1171, 'org.eclipse.ui.ide.undo.UpdateMarkersOperation', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/ide/undo/UpdateMarkersOperation.html', ' IAdvancedUndoableOperation defines an interface for undoable operations that modify one or more elements in a model and attempt to keep model listeners up to date with changes that occur in the undo and redo history involving particular model elements. It also defines methods for computing the validity of an operation for undo or redo before attempting to perform the undo or redo. This interface is intended to be used by legacy frameworks that are adapting their original undo and redo support to this framework. The methods in this interface allow legacy clients to maintain features not supported in the basic operations framework. Since: 3.1 IAdvancedUndoableOperation2 defines a method for computing the validity of executing an operation before attempting to execute it. It also defines a way for clients to specify that computing status should be done quietly, without consulting the user. This interface is useful when implementing IOperationApprover2, or any other object that performs validation of the undo history. It also allows operations to specify whether they should be run in the UI thread. Since: 3.3 IUndoableOperation defines an operation that can be executed, undone, and redone. Operations typically have fully defined parameters. That is, they are usually created after the user has been queried for any input needed to define the operation. Operations determine their ability to execute, undo, or redo according to the current state of the application. They do not make decisions about their validity based on where they occur in the operation history. That is left to the particular operation history. Since: 3.1 extends AbstractWorkspaceOperation An UpdateMarkersOperation represents an undoable operation for updating one or more markers in the workspace with one or more sets of attributes. Clients may call the public API from a background thread. This class is intended to be instantiated and used by clients. It is not intended to be subclassed by clients. Since: 3.3 '
1172, 'org.eclipse.ui.texteditor.ITextEditor', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/texteditor/ITextEditor.html', 'An interface for an adaptable object. Adaptable objects can be dynamically extended to provide different interfaces (or \"adapters\"). Adapters are created by adapter factories, which are in turn managed by type by adapter managers. For example, IAdaptable a = [some adaptable]; IFoo x = (IFoo)a.getAdapter(IFoo.class); if (x != null) [do IFoo things with x] This interface can be used without OSGi running. Clients may implement this interface, or obtain a default implementation of this interface by subclassing PlatformObject. See Also: IAdapterFactory, IAdapterManager, PlatformObject An interface for an adaptable object. Adaptable objects can be dynamically extended to provide different interfaces (or \"adapters\"). Adapters are created by adapter factories, which are in turn managed by type by adapter managers. For example, IAdaptable a = [some adaptable]; IFoo x = (IFoo)a.getAdapter(IFoo.class); if (x != null) [do IFoo things with x] This interface can be used without OSGi running. Clients may implement this interface, or obtain a default implementation of this interface by subclassing PlatformObject. See Also: IAdapterFactory, IAdapterManager, PlatformObject Workbench parts implement or adapt to this interface to participate in the enablement and execution of the Save and Save As actions. Since: 2.1 See Also: IEditorPart An interface for an adaptable object. Adaptable objects can be dynamically extended to provide different interfaces (or \"adapters\"). Adapters are created by adapter factories, which are in turn managed by type by adapter managers. For example, IAdaptable a = [some adaptable]; IFoo x = (IFoo)a.getAdapter(IFoo.class); if (x != null) [do IFoo things with x] This interface can be used without OSGi running. Clients may implement this interface, or obtain a default implementation of this interface by subclassing PlatformObject. See Also: IAdapterFactory, IAdapterManager, PlatformObject extends IAdaptable A workbench part is a visual component within a workbench page. There are two subtypes: view and editor, as defined by IViewPart and IEditorPart. A view is typically used to navigate a hierarchy of information (like the workspace), open an editor, or display properties for the active editor. Modifications made in a view are saved immediately. An editor is typically used to edit or browse a document or input object. The input is identified using an IEditorInput. Modifications made in an editor part follow an open-save-close lifecycle model. This interface may be implemented directly. For convenience, a base implementation is defined in WorkbenchPart. The lifecycle of a workbench part is as follows: When a part extension is created: instantiate the part create a part site call part.init(site) When a part becomes visible in the workbench: add part to presentation by calling part.createPartControl(parent) to create actual widgets fire partOpened event to all listeners When a part is activated or gets focus: call part.setFocus() fire partActivated event to all listeners When a part is closed: if save is needed, do save; if it fails or is canceled return if part is active, deactivate part fire partClosed event to all listeners remove part from presentation; part controls are disposed as part of the SWT widget tree call part.dispose() After createPartControl has been called, the implementor may safely reference the controls created. When the part is closed these controls will be disposed as part of an SWT composite. This occurs before the IWorkbenchPart.dispose method is called. If there is a need to free SWT resources the part should define a dispose listener for its own control and free those resources from the dispose listener. If the part invokes any method on the disposed SWT controls after this point an SWTError will be thrown. The last method called on IWorkbenchPart is dispose. This signals the end of the part lifecycle. An important point to note about this lifecycle is that following a call to init, createPartControl may never be called. Thus in the dispose method, implementors must not assume controls were created. Workbench parts implement the IAdaptable interface; extensions are managed by the platform\'s adapter manager. See Also: IViewPart, IEditorPart extends IWorkbenchPart, ISaveablePart An editor is a visual component within a workbench page. It is typically used to edit or browse a document or input object. The input is identified using an IEditorInput. Modifications made in an editor part follow an open-save-close lifecycle model (in contrast to a view part, where modifications are saved to the workbench immediately). An editor is document or input-centric. Each editor has an input, and only one editor can exist for each editor input within a page. This policy has been designed to simplify part management. An editor should be used in place of a view whenever more than one instance of a document type can exist. This interface may be implemented directly. For convenience, a base implementation is defined in EditorPart. An editor part is added to the workbench in two stages: An editor extension is contributed to the workbench registry. This extension defines the extension id, extension class, and the file extensions which are supported by the editor. An editor part based upon the extension is created and added to the workbench when the user opens a file with one of the supported file extensions (or some other suitable form of editor input). All editor parts implement the IAdaptable interface; extensions are managed by the platform\'s adapter manager. See Also: IWorkbenchPage.openEditor(IEditorInput, String), EditorPart Workbench parts implement or adapt to this interface to participate in the enablement and execution of the Save and Save As actions. Since: 2.1 See Also: IEditorPart An interface for an adaptable object. Adaptable objects can be dynamically extended to provide different interfaces (or \"adapters\"). Adapters are created by adapter factories, which are in turn managed by type by adapter managers. For example, IAdaptable a = [some adaptable]; IFoo x = (IFoo)a.getAdapter(IFoo.class); if (x != null) [do IFoo things with x] This interface can be used without OSGi running. Clients may implement this interface, or obtain a default implementation of this interface by subclassing PlatformObject. See Also: IAdapterFactory, IAdapterManager, PlatformObject extends IAdaptable A workbench part is a visual component within a workbench page. There are two subtypes: view and editor, as defined by IViewPart and IEditorPart. A view is typically used to navigate a hierarchy of information (like the workspace), open an editor, or display properties for the active editor. Modifications made in a view are saved immediately. An editor is typically used to edit or browse a document or input object. The input is identified using an IEditorInput. Modifications made in an editor part follow an open-save-close lifecycle model. This interface may be implemented directly. For convenience, a base implementation is defined in WorkbenchPart. The lifecycle of a workbench part is as follows: When a part extension is created: instantiate the part create a part site call part.init(site) When a part becomes visible in the workbench: add part to presentation by calling part.createPartControl(parent) to create actual widgets fire partOpened event to all listeners When a part is activated or gets focus: call part.setFocus() fire partActivated event to all listeners When a part is closed: if save is needed, do save; if it fails or is canceled return if part is active, deactivate part fire partClosed event to all listeners remove part from presentation; part controls are disposed as part of the SWT widget tree call part.dispose() After createPartControl has been called, the implementor may safely reference the controls created. When the part is closed these controls will be disposed as part of an SWT composite. This occurs before the IWorkbenchPart.dispose method is called. If there is a need to free SWT resources the part should define a dispose listener for its own control and free those resources from the dispose listener. If the part invokes any method on the disposed SWT controls after this point an SWTError will be thrown. The last method called on IWorkbenchPart is dispose. This signals the end of the part lifecycle. An important point to note about this lifecycle is that following a call to init, createPartControl may never be called. Thus in the dispose method, implementors must not assume controls were created. Workbench parts implement the IAdaptable interface; extensions are managed by the platform\'s adapter manager. See Also: IViewPart, IEditorPart extends IEditorPart Interface to a text editor. This interface defines functional extensions to IEditorPart as well as the configuration capabilities of a text editor. Text editors are configured with an IDocumentProvider which delivers a textual presentation (IDocument) of the editor\'s input. The editor works on the document and forwards all input element related calls, such as save, to the document provider. The provider also delivers the input\'s annotation model which is used by the editor\'s vertical ruler. Clients may implement this interface from scratch, but the recommended way is to subclass the abstract base class AbstractTextEditor. In order to provided backward compatibility for clients of ITextEditor, extension interfaces are used to provide a means of evolution. The following extension interfaces exist: ITextEditorExtension since version 2.0 introducing status fields, read-only state and ruler context menu listeners. ITextEditorExtension2 since version 2.1 introducing modifiable state for the editor input and validate state handling. ITextEditorExtension3 since version 3.0 adding input state and change information control. ITextEditorExtension4 since version 3.2 adding annotation navigation and revision information display. ITextEditorExtension5 since version 3.5 adding block selection mode. See Also: IDocumentProvider, IAnnotationModel, ITextEditorExtension, ITextEditorExtension2, ITextEditorExtension3, ITextEditorExtension4, ITextEditorExtension5 '
1173, 'org.eclipse.jface.util.ConfigureColumns', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/util/ConfigureColumns.html', 'extends Object Utilities for configuring columns of trees and tables in a keyboard-accessible way. Since: 3.5 '
1174, 'org.eclipse.ui.views.markers.MarkerFieldFilter', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/views/markers/MarkerFieldFilter.html', 'extends Object A MarkerFieldFilter is a filter on a particular marker field. Since: 3.4 '
1175, 'org.eclipse.ui.views.markers.WorkbenchMarkerResolution', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/views/markers/WorkbenchMarkerResolution.html', 'Resolution for a marker. When run, a resolution would typically eliminate the need for the marker. Since: 2.0 extends IMarkerResolution Extends IMarkerResolution. This interface should be used in place of IMarkerResolution if a description and/or image are desired. Since: 3.0 extends Object implements IMarkerResolution2 WorkbenchMarkerResolution is the resolution that can be grouped with others that are similar to allow multi selection. Since: 3.2 '
1176, 'org.eclipse.ui.ide.undo.DeleteResourcesOperation', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/ide/undo/DeleteResourcesOperation.html', ' IAdvancedUndoableOperation defines an interface for undoable operations that modify one or more elements in a model and attempt to keep model listeners up to date with changes that occur in the undo and redo history involving particular model elements. It also defines methods for computing the validity of an operation for undo or redo before attempting to perform the undo or redo. This interface is intended to be used by legacy frameworks that are adapting their original undo and redo support to this framework. The methods in this interface allow legacy clients to maintain features not supported in the basic operations framework. Since: 3.1 IAdvancedUndoableOperation2 defines a method for computing the validity of executing an operation before attempting to execute it. It also defines a way for clients to specify that computing status should be done quietly, without consulting the user. This interface is useful when implementing IOperationApprover2, or any other object that performs validation of the undo history. It also allows operations to specify whether they should be run in the UI thread. Since: 3.3 IUndoableOperation defines an operation that can be executed, undone, and redone. Operations typically have fully defined parameters. That is, they are usually created after the user has been queried for any input needed to define the operation. Operations determine their ability to execute, undo, or redo according to the current state of the application. They do not make decisions about their validity based on where they occur in the operation history. That is left to the particular operation history. Since: 3.1 extends AbstractWorkspaceOperation A DeleteResourcesOperation represents an undoable operation for deleting one or more resources in the workspace. Clients may call the public API from a background thread. This class is intended to be instantiated and used by clients. It is not intended to be subclassed by clients. Since: 3.3 Restriction: This class is not intended to be subclassed by clients. '
1177, 'org.eclipse.ui.IWorkbenchSite', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/IWorkbenchSite.html', 'An interface for an adaptable object. Adaptable objects can be dynamically extended to provide different interfaces (or \"adapters\"). Adapters are created by adapter factories, which are in turn managed by type by adapter managers. For example, IAdaptable a = [some adaptable]; IFoo x = (IFoo)a.getAdapter(IFoo.class); if (x != null) [do IFoo things with x] This interface can be used without OSGi running. Clients may implement this interface, or obtain a default implementation of this interface by subclassing PlatformObject. See Also: IAdapterFactory, IAdapterManager, PlatformObject A component with which one or more services are registered. The services can be retrieved from this locator using some key -- typically the class representing the interface the service must implement. For example: IHandlerService service = (IHandlerService) workbenchWindow .getService(IHandlerService.class); This interface is not to be implemented or extended by clients. Since: 3.2 Interface for objects that can return a shell. This is normally used for opening child windows. An object that wants to open child shells can take an IShellProvider in its constructor, and the object that implements IShellProvider can dynamically choose where child shells should be opened. Since: 3.1 extends IAdaptable, IShellProvider, IServiceLocator The common interface between the workbench and its parts, including pages within parts. The workbench site supports a few services by default. If these services are used to allocate resources, it is important to remember to clean up those resources after you are done with them. Otherwise, the resources will exist until the workbench site is disposed. The supported services are: ICommandService IContextService IHandlerService IBindingService. Resources allocated through this service will not be cleaned up until the workbench shuts down. This interface is not intended to be implemented or extended by clients. Since: 2.0 See Also: IWorkbenchPartSite, IPageSite Restriction: This interface is not intended to be implemented by clients. '
1178, 'org.eclipse.ui.views.properties.tabbed.ISection', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/views/properties/tabbed/ISection.html', 'Represents a section of properties for a given input. The lifecycle of an ISection is as follows: ISection.createControls() ISection.setInput() ISection.aboutToBeShown() ISection.refresh() ISection.aboutToBeHidden() ISection.dispose() Implementors of this class should be aware that a section instance might be reused for different input objects (as long as they are valid section inputs). It means that ISection.setInput can be called at any time between ISection.createControls and ISection.dispose. When an input change event occurs, such as a tab selection or a workbench selection change, an ISection is sent: ISection.setInput() ISection.refresh() When an part activation event occurs, such as the contributor part activation event, an ISection is sent: ISection.setInput() ISection.aboutToBeShown() ISection.refresh() ISection.setInput() ISection.refresh() This is because both a tab selection event and an input selection event have occurred. This interface should not be extended or implemented. New section instances should be created using AbstractPropertySection. See Also: TabbedPropertySheetPage '
1179, 'org.eclipse.ui.wizards.datatransfer.ExternalProjectImportWizard', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/wizards/datatransfer/ExternalProjectImportWizard.html', 'Interface for a wizard. A wizard maintains a list of wizard pages, stacked on top of each other in card layout fashion. The class Wizard provides an abstract implementation of this interface. However, clients are also free to implement this interface if Wizard does not suit their needs. See Also: Wizard extends IWorkbenchWizard Interface for import wizards. Clients should implement this interface and include the name of their class in a wizard contributed to the workbench\'s import wizard extension point (named \"org.eclipse.ui.importWizards\"). For example, the plug-in\'s XML markup might contain: <extension point=\"org.eclipse.ui.importWizards\"> <wizard id=\"com.example.myplugin.blob\" name=\"Blob File\" class=\"com.example.myplugin.BlobFileImporter\" icon=\"icons/import_blob_wiz.gif\"> <description>Import resources from a BLOB file</description> <selection class=\"org.eclipse.core.resources.IResource\" /> </wizard> </extension> See Also: IWizard Interface for a wizard. A wizard maintains a list of wizard pages, stacked on top of each other in card layout fashion. The class Wizard provides an abstract implementation of this interface. However, clients are also free to implement this interface if Wizard does not suit their needs. See Also: Wizard extends IWizard Implementors represent creation wizards that are to be contributed to the workbench\'s creation wizard extension point. See Also: IWizard extends Wizard implements IImportWizard Standard workbench wizard for importing projects defined outside of the currently defined projects into Eclipse. This class may be instantiated and used without further configuration; this class is not intended to be subclassed. Example: IWizard wizard = new ExternalProjectImportWizard(); wizard.init(workbench, selection); WizardDialog dialog = new WizardDialog(shell, wizard); dialog.open(); During the call to open, the wizard dialog is presented to the user. When the user hits Finish, a project is created with the location specified by the user. Restriction: This class is not intended to be subclassed by clients. '
1180, 'org.eclipse.ui.actions.ActionFactory.IWorkbenchAction', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/actions/ActionFactory.IWorkbenchAction.html', 'An action represents the non-UI side of a command which can be triggered by the end user. Actions are typically associated with buttons, menu items, and items in tool bars. The controls for a command are built by some container, which furnished the context where these controls appear and configures them with data from properties declared by the action. When the end user triggers the command via its control, the action\'s run method is invoked to do the real work. Actions support a predefined set of properties (and possibly others as well). Clients of an action may register property change listeners so that they get notified whenever the value of a property changes. Clients should subclass the abstract base class Action to define concrete actions rather than implementing IAction from scratch. This interface exists only to define the API for actions. It is not intended to be implemented by clients. See Also: Action Restriction: This interface is not intended to be implemented by clients. extends IAction Interface for a workbench action. '
1181, 'org.eclipse.swt.events.TypedEvent', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/events/TypedEvent.html', 'extends org.eclipse.swt.internal.SWTEventObject This is the super class for all typed event classes provided by SWT. Typed events contain particular information which is applicable to the event occurrence. See Also: Event, Sample code and further information, Serialized Form '
1182, 'org.eclipse.swt.widgets.TypedListener', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/widgets/TypedListener.html', 'Implementers of Listener provide a simple handleEvent() method that is used internally by SWT to dispatch events. After creating an instance of a class that implements this interface it can be added to a widget using the addListener(int eventType, Listener handler) method and removed using the removeListener (int eventType, Listener handler) method. When the specified event occurs, handleEvent(...) will be sent to the instance. Classes which implement this interface are described within SWT as providing the untyped listener API. Typically, widgets will also provide a higher-level typed listener API, that is based on the standard java.util.EventListener pattern. Note that, since all internal SWT event dispatching is based on untyped listeners, it is simple to build subsets of SWT for use on memory constrained, small footprint devices, by removing the classes and methods which implement the typed listener API. See Also: Widget.addListener(int, org.eclipse.swt.widgets.Listener), EventListener, org.eclipse.swt.events extends Object implements Listener Instances of this class are internal SWT implementation objects which provide a mapping between the typed and untyped listener mechanisms that SWT supports. IMPORTANT: This class is not part of the SWT public API. It is marked public only so that it can be shared within the packages provided by SWT. It should never be referenced from application code. See Also: Listener, Sample code and further information '
1183, 'org.eclipse.core.filesystem.IFileSystem', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/filesystem/IFileSystem.html', 'An interface for an adaptable object. Adaptable objects can be dynamically extended to provide different interfaces (or \"adapters\"). Adapters are created by adapter factories, which are in turn managed by type by adapter managers. For example, IAdaptable a = [some adaptable]; IFoo x = (IFoo)a.getAdapter(IFoo.class); if (x != null) [do IFoo things with x] This interface can be used without OSGi running. Clients may implement this interface, or obtain a default implementation of this interface by subclassing PlatformObject. See Also: IAdapterFactory, IAdapterManager, PlatformObject extends IAdaptable This is the main interface to a single file system. Each file system instance manages interaction with all files in the backing store represented by a particular URI scheme. File systems are registered using the \"filesystems\" extension point. Since: org.eclipse.core.filesystem 1.0 See Also: EFS.getFileSystem(String) Restriction: This interface is not intended to be implemented by clients. File system implementations must subclass FileSystem rather than implementing this interface directly. '
1184, 'org.eclipse.core.resources.IResourceProxyVisitor', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/resources/IResourceProxyVisitor.html', 'This interface is implemented by objects that visit resource trees. The fast visitor is an optimized mechanism for tree traversal that creates a minimal number of objects. The visitor is provided with a callback interface, instead of a resource. Through the callback, the visitor can request information about the resource being visited. Usage: class Visitor implements IResourceProxyVisitor { public boolean visit (IResourceProxy proxy) { // your code here return true; } } ResourcesPlugin.getWorkspace().getRoot().accept(new Visitor(), IResource.NONE); Clients may implement this interface. Since: 2.1 See Also: IResource.accept(IResourceVisitor) '
1185, 'org.eclipse.core.resources.IResourceProxy', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/resources/IResourceProxy.html', 'A lightweight interface for requesting information about a resource. All of the \"get\" methods on a resource proxy have trivial performance cost. Requesting the full path or the actual resource handle will cause extra objects to be created and will thus have greater cost. When a resource proxy is used within an IResourceProxyVisitor, it is a transient object that is only valid for the duration of a single visit method. A proxy should not be referenced once the single resource visit is complete. The equals and hashCode methods should not be relied on. A proxy can also be created using IResource.createProxy(). In this case the proxy is valid indefinitely, but will not remain in sync with the state of the corresponding resource. Since: 2.1 See Also: IResourceProxyVisitor Restriction: This interface is not intended to be implemented by clients. Restriction: This interface is not intended to be extended by clients. '
1186, 'org.eclipse.ui.dialogs.FilteredItemsSelectionDialog', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/dialogs/FilteredItemsSelectionDialog.html', 'Interface for objects that can return a shell. This is normally used for opening child windows. An object that wants to open child shells can take an IShellProvider in its constructor, and the object that implements IShellProvider can dynamically choose where child shells should be opened. Since: 3.1 extends SelectionStatusDialog Shows a list of items to the user with a text entry field for a string pattern used to filter the list of items. Since: 3.3 '
1187, 'org.eclipse.ui.actions.WorkingSetFilterActionGroup', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/actions/WorkingSetFilterActionGroup.html', 'extends ActionGroup Adds working set filter actions (set / clear / edit) Since: 2.1 '
1188, 'org.eclipse.jface.text.ITextSelection', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/text/ITextSelection.html', 'Interface for a selection. See Also: ISelectionProvider, ISelectionChangedListener, SelectionChangedEvent extends ISelection This interface represents a textual selection. A text selection is a range of characters. Although a text selection is a snapshot taken at a particular point in time, it must not copy the line information and the selected text from the selection provider. If, for example, the selection provider is a text viewer ( ITextViewer), and a text selection is created for the range [5, 10], the line formation for the 5th character must not be determined and remembered at the point of creation. It can rather be determined at the point, when getStartLine is called. If the source viewer range [0, 15] has been changed in the meantime between the creation of the text selection object and the invocation of getStartLine, the returned line number may differ from the line number of the 5th character at the point of creation of the text selection object. The contract of this interface is that weak in order to allow for efficient implementations. Clients may implement this interface or use the default implementation provided by TextSelection. See Also: TextSelection '
1189, 'org.eclipse.ui.actions.BaseNewWizardMenu', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/actions/BaseNewWizardMenu.html', 'A contribution item represents a contribution to a shared UI resource such as a menu or tool bar. More generally, contribution items are managed by a contribution manager. For instance, in a tool bar a contribution item is a tool bar button or a separator. In a menu bar a contribution item is a menu, and in a menu a contribution item is a menu item or separator. A contribution item can realize itself in different SWT widgets, using the different fill methods. The same type of contribution item can be used with a MenuBarManager, ToolBarManager, CoolBarManager, or a StatusLineManager. This interface is internal to the framework; it should not be implemented outside the framework. See Also: IContributionManager Restriction: This interface is not intended to be implemented by clients. extends CompoundContributionItem A BaseNewWizardMenu is used to populate a menu manager with New Wizard actions for the current perspective\'s new wizard shortcuts, including an Other... action to open the new wizard dialog. Note: Clients must dispose this menu when it is no longer required. Since: 3.1 '
1190, 'org.eclipse.ui.actions.NewExampleAction', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/actions/NewExampleAction.html', 'An action represents the non-UI side of a command which can be triggered by the end user. Actions are typically associated with buttons, menu items, and items in tool bars. The controls for a command are built by some container, which furnished the context where these controls appear and configures them with data from properties declared by the action. When the end user triggers the command via its control, the action\'s run method is invoked to do the real work. Actions support a predefined set of properties (and possibly others as well). Clients of an action may register property change listeners so that they get notified whenever the value of a property changes. Clients should subclass the abstract base class Action to define concrete actions rather than implementing IAction from scratch. This interface exists only to define the API for actions. It is not intended to be implemented by clients. See Also: Action Restriction: This interface is not intended to be implemented by clients. extends Action Standard action for launching the create project selection wizard. This class may be instantiated; it is not intended to be subclassed. Restriction: This class is not intended to be subclassed by clients. '
1191, 'org.eclipse.ui.actions.NewProjectAction', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/actions/NewProjectAction.html', 'An action represents the non-UI side of a command which can be triggered by the end user. Actions are typically associated with buttons, menu items, and items in tool bars. The controls for a command are built by some container, which furnished the context where these controls appear and configures them with data from properties declared by the action. When the end user triggers the command via its control, the action\'s run method is invoked to do the real work. Actions support a predefined set of properties (and possibly others as well). Clients of an action may register property change listeners so that they get notified whenever the value of a property changes. Clients should subclass the abstract base class Action to define concrete actions rather than implementing IAction from scratch. This interface exists only to define the API for actions. It is not intended to be implemented by clients. See Also: Action Restriction: This interface is not intended to be implemented by clients. extends Action Standard action for launching the create project selection wizard. This class may be instantiated; it is not intended to be subclassed. Restriction: This class is not intended to be subclassed by clients. '
1192, 'org.eclipse.ui.IActionDelegate2', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/IActionDelegate2.html', 'Interface for actions contributed via an extension point. This interface should be implemented by clients who need to contribute actions via an extension point. The workbench will generate a proxy action object on behalf of the plug-in to avoid having to activate the plug-in until the user needs it. If the action is performed the workbench will load the class that implements this interface and create what is called an action delegate object. Then the request, and all subsequent ones, are forwarded through the proxy action to the action delegate, which does the real work. The proxy action is the one that appears in the UI, so the action delegate will need to talk to the proxy action in order to keep up an appropriate appearance. Once the action delegate has been created, it will be notified of all selection changes, allowing it to enable or disable the proxy action appropriately. An action delegate cannot be consulted about selection changes before the action is performed because it does not exist. For this reason, control of the action\'s enable state should also be exercised through simple XML rules contained in the extension. These rules allow enable state control before the action delegate\'s plug-in is loaded. Clients can choose to subclass the provided abstract implementation org.eclipse.ui.actions.ActionDelegate or implement the interface directly. See Also: ActionDelegate, IActionDelegate2 extends IActionDelegate Interface extension to IActionDelegate adding lifecycle methods. In addition, a runWithEvent method that includes the triggering SWT event. An action delegate that implements this interface will have its runWithEvent(IAction, Event) called instead of its run(IAction) method. Clients should implement this interface, in addition to IActionDelegate or sub-interfaces, if interested in the triggering event or in the lifecycle of the delegate object. Clients can choose to subclass the provided abstract implementation org. eclipse. ui. actions. ActionDelegate or implement the interface directly. Since: 2.1 See Also: ActionDelegate, IActionDelegate '
1193, 'org.eclipse.ui.IWorkbenchWindowActionDelegate', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/IWorkbenchWindowActionDelegate.html', 'Interface for actions contributed via an extension point. This interface should be implemented by clients who need to contribute actions via an extension point. The workbench will generate a proxy action object on behalf of the plug-in to avoid having to activate the plug-in until the user needs it. If the action is performed the workbench will load the class that implements this interface and create what is called an action delegate object. Then the request, and all subsequent ones, are forwarded through the proxy action to the action delegate, which does the real work. The proxy action is the one that appears in the UI, so the action delegate will need to talk to the proxy action in order to keep up an appropriate appearance. Once the action delegate has been created, it will be notified of all selection changes, allowing it to enable or disable the proxy action appropriately. An action delegate cannot be consulted about selection changes before the action is performed because it does not exist. For this reason, control of the action\'s enable state should also be exercised through simple XML rules contained in the extension. These rules allow enable state control before the action delegate\'s plug-in is loaded. Clients can choose to subclass the provided abstract implementation org.eclipse.ui.actions.ActionDelegate or implement the interface directly. See Also: ActionDelegate, IActionDelegate2 extends IActionDelegate Interface for an action that is contributed into the workbench window menu or tool bar. It extends IActionDelegate and adds an initialization method for connecting the delegate to the workbench window it should work with. '
1194, 'org.eclipse.ui.part.MultiPageEditorActionBarContributor', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/part/MultiPageEditorActionBarContributor.html', 'A editor action bar contributor defines the actions for one or more editors. Within the workbench there may be more than one open editor of a particular type. For instance, there may be 1 or more open Java Editors. To avoid the creation of duplicate actions and action images the editor concept has been split into two. An action contributor is responsible for the creation of actions. The editor is responsible for action implementation. Furthermore, the contributor is shared by each open editor. As a result of this design there is only 1 set of actions for 1 or more open editors. The relationship between editor and contributor is defined by the org.eclipse.ui.editors extension point in the plugin registry. This interface should not be implemented directly. An implementation of this interface has been created in EditorActionBarContributor. Implementors should subclass this and specialize as required. See Also: IEditorActionBarContributor extends EditorActionBarContributor Abstract base class for managing the installation/deinstallation of global actions for multi-page editors. Subclasses must implement setActivePage, and may reimplement any of the following methods: contributeToMenu - reimplement to contribute to menu contributeToToolBar - reimplement to contribute to tool bar contributeToStatusLine - reimplement to contribute to status line '
1195, 'org.eclipse.ui.SubActionBars2', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/SubActionBars2.html', 'Used by a part to access its menu, toolbar, and status line managers. Within the workbench each part, editor or view, has a private set of action bars. This set, which contains a menu, toolbar, and status line, appears in the local toolbar for a view and in the window for an editor. The view may provide an implementation for pre-existing actions or add new actions to the action bars. In a workbench window there are a number of actions which are applicable to all parts. Some common examples are CUT, COPY and PASTE. These actions, known as \"global actions\", are contributed to the workbench window by the window itself and shared by all parts. The presentation is owned by the window. The implementation is delegated to the active part. To participate in the global action design an IWorkbenchPart should register a handler for each global action which is implemented by the part. This can be done by calling setGlobalActionHandler. For convenience, the standard global actions are defined in org.eclipse.ui.IWorkbenchActionConstants. Additional work is required for the Delete global action. In this case the accelerator is defined in the menu item text but is not hooked on the window. This is to support text editors where the Delete key is functional even when the Delete action is disabled (no text is selected). An implementation for this accelerator must be defined locally, in each part, by listening for Delete key events. A part may also contribute new actions to the action bars as required. To do this, call getMenuManager, getToolBarManager, or getStatusLineManager as appropriate to get the action target. Add the action(s) to the target and call update to commit any changes to the underlying widgets. This interface is not intended to be implemented by clients. Restriction: This interface is not intended to be implemented by clients. extends IActionBars Interface extention to IActionBars that provides an additional cool bar manager. Since: 3.0 Restriction: This interface is not intended to be implemented by clients. extends SubActionBars implements IActionBars2 A implementation of the extended IActionBars2 interface. This sub class provides a sub cool bar manager for plugins to contribute multiple cool items. Since: 3.0 '
1196, 'org.eclipse.ui.INullSelectionListener', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/INullSelectionListener.html', 'extends EventListener Interface for listening to selection changes. This interface may be implemented by clients. See Also: ISelectionService.addSelectionListener(ISelectionListener), ISelectionService.addSelectionListener(String, ISelectionListener), INullSelectionListener extends ISelectionListener Interface for listening to null selection changes. This interface should be implemented by selection listeners that want to be notified when the selection becomes null. It has no methods. It simply indicates the desire to receive null selection events through the existing selectionChanged method. Either the part or the selection may be null. Since: 2.0 See Also: ISelectionListener.selectionChanged(org.eclipse.ui.IWorkbenchPart, org.eclipse.jface.viewers.ISelection), IActionDelegate.selectionChanged(org.eclipse.jface.action.IAction, org.eclipse.jface.viewers.ISelection), ISelectionListener '
1197, 'org.eclipse.ui.IEditorActionDelegate', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/IEditorActionDelegate.html', 'Interface for actions contributed via an extension point. This interface should be implemented by clients who need to contribute actions via an extension point. The workbench will generate a proxy action object on behalf of the plug-in to avoid having to activate the plug-in until the user needs it. If the action is performed the workbench will load the class that implements this interface and create what is called an action delegate object. Then the request, and all subsequent ones, are forwarded through the proxy action to the action delegate, which does the real work. The proxy action is the one that appears in the UI, so the action delegate will need to talk to the proxy action in order to keep up an appropriate appearance. Once the action delegate has been created, it will be notified of all selection changes, allowing it to enable or disable the proxy action appropriately. An action delegate cannot be consulted about selection changes before the action is performed because it does not exist. For this reason, control of the action\'s enable state should also be exercised through simple XML rules contained in the extension. These rules allow enable state control before the action delegate\'s plug-in is loaded. Clients can choose to subclass the provided abstract implementation org.eclipse.ui.actions.ActionDelegate or implement the interface directly. See Also: ActionDelegate, IActionDelegate2 extends IActionDelegate Interface for an action that is contributed into an editor-activated menu or tool bar. It extends IActionDelegate and adds a method for connecting the delegate to the editor it should work with. Since there is always only one action delegate per editor type, this method supplies the link to the currently active editor instance. '
1198, 'org.eclipse.ui.IViewActionDelegate', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/IViewActionDelegate.html', 'Interface for actions contributed via an extension point. This interface should be implemented by clients who need to contribute actions via an extension point. The workbench will generate a proxy action object on behalf of the plug-in to avoid having to activate the plug-in until the user needs it. If the action is performed the workbench will load the class that implements this interface and create what is called an action delegate object. Then the request, and all subsequent ones, are forwarded through the proxy action to the action delegate, which does the real work. The proxy action is the one that appears in the UI, so the action delegate will need to talk to the proxy action in order to keep up an appropriate appearance. Once the action delegate has been created, it will be notified of all selection changes, allowing it to enable or disable the proxy action appropriately. An action delegate cannot be consulted about selection changes before the action is performed because it does not exist. For this reason, control of the action\'s enable state should also be exercised through simple XML rules contained in the extension. These rules allow enable state control before the action delegate\'s plug-in is loaded. Clients can choose to subclass the provided abstract implementation org.eclipse.ui.actions.ActionDelegate or implement the interface directly. See Also: ActionDelegate, IActionDelegate2 extends IActionDelegate Interface for an action that is contributed into a view\'s local tool bar, pulldown menu, or popup menu. It extends IActionDelegate and adds an initialization method for connecting the delegate to the view it should work with. '
1199, 'org.eclipse.ui.IObjectActionDelegate', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/IObjectActionDelegate.html', 'Interface for actions contributed via an extension point. This interface should be implemented by clients who need to contribute actions via an extension point. The workbench will generate a proxy action object on behalf of the plug-in to avoid having to activate the plug-in until the user needs it. If the action is performed the workbench will load the class that implements this interface and create what is called an action delegate object. Then the request, and all subsequent ones, are forwarded through the proxy action to the action delegate, which does the real work. The proxy action is the one that appears in the UI, so the action delegate will need to talk to the proxy action in order to keep up an appropriate appearance. Once the action delegate has been created, it will be notified of all selection changes, allowing it to enable or disable the proxy action appropriately. An action delegate cannot be consulted about selection changes before the action is performed because it does not exist. For this reason, control of the action\'s enable state should also be exercised through simple XML rules contained in the extension. These rules allow enable state control before the action delegate\'s plug-in is loaded. Clients can choose to subclass the provided abstract implementation org.eclipse.ui.actions.ActionDelegate or implement the interface directly. See Also: ActionDelegate, IActionDelegate2 extends IActionDelegate Interface for an object action that is contributed into a popup menu for a view or editor. It extends IActionDelegate and adds an initialization method for connecting the delegate to the part it should work with. '
1200, 'org.eclipse.ui.IActionDelegateWithEvent', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/IActionDelegateWithEvent.html', 'This interface is a mixin interface for action delegates, adding the ability to examine the triggering SWT event when it is run. If an action delegate implements this interface, then runWithEvent(IAction, Event) is called instead of run(IAction). Clients should implement this interface, in addition to IActionDelegate (or subinterface), if they need to examine the triggering event. Otherwise, they should simply implement IActionDelegate (or subinterface). Since: 2.0 '
1201, 'org.eclipse.ui.IActionBars2', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/IActionBars2.html', 'Used by a part to access its menu, toolbar, and status line managers. Within the workbench each part, editor or view, has a private set of action bars. This set, which contains a menu, toolbar, and status line, appears in the local toolbar for a view and in the window for an editor. The view may provide an implementation for pre-existing actions or add new actions to the action bars. In a workbench window there are a number of actions which are applicable to all parts. Some common examples are CUT, COPY and PASTE. These actions, known as \"global actions\", are contributed to the workbench window by the window itself and shared by all parts. The presentation is owned by the window. The implementation is delegated to the active part. To participate in the global action design an IWorkbenchPart should register a handler for each global action which is implemented by the part. This can be done by calling setGlobalActionHandler. For convenience, the standard global actions are defined in org.eclipse.ui.IWorkbenchActionConstants. Additional work is required for the Delete global action. In this case the accelerator is defined in the menu item text but is not hooked on the window. This is to support text editors where the Delete key is functional even when the Delete action is disabled (no text is selected). An implementation for this accelerator must be defined locally, in each part, by listening for Delete key events. A part may also contribute new actions to the action bars as required. To do this, call getMenuManager, getToolBarManager, or getStatusLineManager as appropriate to get the action target. Add the action(s) to the target and call update to commit any changes to the underlying widgets. This interface is not intended to be implemented by clients. Restriction: This interface is not intended to be implemented by clients. extends IActionBars Interface extention to IActionBars that provides an additional cool bar manager. Since: 3.0 Restriction: This interface is not intended to be implemented by clients. '
1202, 'org.eclipse.swt.ole.win32.OleFrame', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/ole/win32/OleFrame.html', 'Implementers of Drawable can have a graphics context (GC) created for them, and then they can be drawn on by sending messages to their associated GC. SWT images, and device objects such as the Display device and the Printer device, are drawables. IMPORTANT: This interface is not part of the SWT public API. It is marked public only so that it can be shared within the packages provided by SWT. It should never be referenced from application code. See Also: Device, Image, GC extends Composite OleFrame is an OLE Container\'s top level frame. This object implements the OLE Interfaces IUnknown and IOleInPlaceFrame OleFrame allows the container to do the following: position and size the ActiveX Control or OLE Document within the application insert menu items from the application into the OLE Document\'s menu activate and deactivate the OLE Document\'s menus position the OLE Document\'s menu in the application translate accelerator keystrokes intended for the container\'s frame Styles BORDER Events Dispose, Move, Resize See Also: OLE and ActiveX snippets, SWT Examples: OLEExample, OleWebBrowser '
1203, 'org.eclipse.swt.ole.win32.OleClientSite', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/ole/win32/OleClientSite.html', 'Implementers of Drawable can have a graphics context (GC) created for them, and then they can be drawn on by sending messages to their associated GC. SWT images, and device objects such as the Display device and the Printer device, are drawables. IMPORTANT: This interface is not part of the SWT public API. It is marked public only so that it can be shared within the packages provided by SWT. It should never be referenced from application code. See Also: Device, Image, GC extends Composite OleClientSite provides a site to manage an embedded OLE Document within a container. The OleClientSite provides the following capabilities: creates the in-place editor for a blank document or opening an existing OLE Document lays the editor out provides a mechanism for activating and deactivating the Document provides a mechanism for saving changes made to the document This object implements the OLE Interfaces IUnknown, IOleClientSite, IAdviseSink, IOleInPlaceSite Note that although this class is a subclass of Composite, it does not make sense to add Control children to it, or set a layout on it. Styles BORDER Events Dispose, Move, Resize See Also: OLE and ActiveX snippets, SWT Examples: OLEExample, OleWebBrowser '
1204, 'org.eclipse.swt.ole.win32.OleAutomation', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/ole/win32/OleAutomation.html', 'extends Object OleAutomation provides a generic mechanism for accessing functionality that is specific to a particular ActiveX Control or OLE Document. The OLE Document or ActiveX Control must support the IDispatch interface in order to provide OleAutomation support. The additional functionality provided by the OLE Object is specified in its IDL file. The additional methods can either be to get property values (getProperty), to set property values (setProperty) or to invoke a method (invoke or invokeNoReply). Arguments are passed around in the form of Variant objects. Here is a sample IDL fragment: interface IMyControl : IDispatch { [propget, id(0)] HRESULT maxFileCount([retval, out] int *c); [propput, id(0)] HRESULT maxFileCount([in] int c); [id(1)] HRESULT AddFile([in] BSTR fileName); }; An example of how to interact with this extended functionality is shown below: OleAutomation automation = new OleAutomation(myControlSite); // Look up the ID of the maxFileCount parameter int[] rgdispid = automation.getIDsOfNames(new String[]{\"maxFileCount\"}); int maxFileCountID = rgdispid[0]; // Set the property maxFileCount to 100: if (automation.setProperty(maxFileCountID, new Variant(100))) { System.out.println(\"Max File Count was successfully set.\"); } // Get the new value of the maxFileCount parameter: Variant pVarResult = automation.getProperty(maxFileCountID); if (pVarResult != null) { System.out.println(\"Max File Count is \"+pVarResult.getInt()); } // Invoke the AddFile method // Look up the IDs of the AddFile method and its parameter rgdispid = automation.getIDsOfNames(new String[]{\"AddFile\", \"fileName\"}); int dispIdMember = rgdispid[0]; int[] rgdispidNamedArgs = new int[] {rgdispid[1]}; // Convert arguments to Variant objects Variant[] rgvarg = new Variant[1]; String fileName = \"C:\\\\testfile\"; rgvarg[0] = new Variant(fileName); // Call the method Variant pVarResult = automation.invoke(dispIdMember, rgvarg, rgdispidNamedArgs); // Check the return value if (pVarResult == null || pVarResult.getInt() != OLE.S_OK){ System.out.println(\"Failed to add file \"+fileName); } automation.dispose(); See Also: OLE and ActiveX snippets, SWT Examples: OLEExample, OleWebBrowser '
1205, 'org.eclipse.swt.ole.win32.Variant', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/ole/win32/Variant.html', 'extends Object A Variant is a generic OLE mechanism for passing data of different types via a common interface. It is used within the OleAutomation object for getting a property, setting a property or invoking a method on an OLE Control or OLE Document. '
1206, 'org.eclipse.swt.ole.win32.OLE', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/ole/win32/OLE.html', 'extends SWT OLE contains all the constants used to create an ActiveX Control or an OLE Document. Definitions for these constants can be found in MSDN. '
1207, 'org.eclipse.swt.graphics.Transform', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/graphics/Transform.html', 'extends Resource Instances of this class represent transformation matrices for points expressed as (x, y) pairs of floating point numbers. Application code must explicitly invoke the Transform.dispose() method to release the operating system resources managed by each instance when those instances are no longer required. This class requires the operating system\'s advanced graphics subsystem which may not be available on some platforms. Since: 3.1 See Also: SWT Example: GraphicsExample, Sample code and further information '
1208, 'org.eclipse.core.commands.AbstractHandlerWithState', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/commands/AbstractHandlerWithState.html', 'A handler is the pluggable piece of a command that handles execution. Each command can have zero or more handlers associated with it (in general), of which only one will be active at any given moment in time. When the command is asked to execute, it will simply pass that request on to its active handler, if any. Since: 3.1 See Also: AbstractHandler A handler is the pluggable piece of a command that handles execution. Each command can have zero or more handlers associated with it (in general), of which only one will be active at any given moment in time. When the command is asked to execute, it will simply pass that request on to its active handler, if any. Since: 3.1 See Also: AbstractHandler extends IHandler Extend the IHandler interface to provide some context for isEnabled() requests. Clients should use AbstractHandler unless they need to provide their own listener mechanism. Since: 3.4 See Also: AbstractHandler An object that holds zero or more state objects. This state information can be shared between different instances of IObjectWithState. Clients may implement, but must not extend this interface. Since: 3.2 See Also: AbstractHandlerWithState A listener to changes in some state. Clients may implement, but must not extend this interface. Since: 3.2 extends AbstractHandler implements IObjectWithState, IStateListener An abstract implementation of IObjectWithState. This provides basic handling for adding and remove state. When state is added, the handler attaches itself as a listener and fire a handleStateChange event to notify this handler. When state is removed, the handler removes itself as a listener. Clients may extend this class. Since: 3.2 '
1209, 'org.eclipse.ui.dialogs.FilteredList', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/dialogs/FilteredList.html', 'Implementers of Drawable can have a graphics context (GC) created for them, and then they can be drawn on by sending messages to their associated GC. SWT images, and device objects such as the Display device and the Printer device, are drawables. IMPORTANT: This interface is not part of the SWT public API. It is marked public only so that it can be shared within the packages provided by SWT. It should never be referenced from application code. See Also: Device, Image, GC extends Composite A composite widget which holds a list of elements for user selection. The elements are sorted alphabetically. Optionally, the elements can be filtered and duplicate entries can be hidden (folding). Since: 2.0 '
1210, 'org.eclipse.core.databinding.DataBindingContext', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/databinding/DataBindingContext.html', 'extends Object A DataBindingContext is the point of contact for the creation and management of bindings, and aggregates validation statuses of its bindings, or more generally, its validation status providers. A DataBindingContext provides the following abilities: Ability to create bindings between observable values. Ability to create bindings between observable lists. Access to the bindings created by the instance. Access to the list of validation status providers (this includes all bindings). Multiple contexts can be used at any point in time. One strategy for the management of contexts is the aggregation of validation statuses. For example an IWizardPage could use a single context and the statuses could be aggregated to set the page status and fulfillment. Each page in the IWizard would have its own context instance. Since: 1.0 '
1211, 'org.eclipse.core.databinding.observable.value.WritableValue', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/databinding/observable/value/WritableValue.html', 'An object with state that allows to listen for state changes. Implementations must not manage listeners themselves, listener management must be delegated to a private instance of type ChangeSupport if it is not inherited from AbstractObservable. Since: 1.0 Restriction: This interface is not intended to be implemented by clients. Clients should instead subclass one of the classes in the framework that implement this interface. Note that direct implementers of this interface outside of the framework will be broken in future releases when methods are added to this interface. extends IObservable A value whose changes can be tracked by value change listeners. Since: 1.0 See Also: AbstractObservableValue Restriction: This interface is not intended to be implemented by clients. Clients should instead subclass one of the classes that implement this interface. Note that direct implementers of this interface outside of the framework will be broken in future releases when methods are added to this interface. extends AbstractObservableValue Mutable (writable) implementation of IObservableValue that will maintain a value and fire change events when the value changes. This class is thread safe. All state accessing methods must be invoked from the current realm. Methods for adding and removing listeners may be invoked from any thread. Since: 1.0 '
1212, 'org.eclipse.core.databinding.observable.value.ComputedValue', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/databinding/observable/value/ComputedValue.html', 'An object with state that allows to listen for state changes. Implementations must not manage listeners themselves, listener management must be delegated to a private instance of type ChangeSupport if it is not inherited from AbstractObservable. Since: 1.0 Restriction: This interface is not intended to be implemented by clients. Clients should instead subclass one of the classes in the framework that implement this interface. Note that direct implementers of this interface outside of the framework will be broken in future releases when methods are added to this interface. An object with state that allows to listen for state changes. Implementations must not manage listeners themselves, listener management must be delegated to a private instance of type ChangeSupport if it is not inherited from AbstractObservable. Since: 1.0 Restriction: This interface is not intended to be implemented by clients. Clients should instead subclass one of the classes in the framework that implement this interface. Note that direct implementers of this interface outside of the framework will be broken in future releases when methods are added to this interface. extends IObservable A value whose changes can be tracked by value change listeners. Since: 1.0 See Also: AbstractObservableValue Restriction: This interface is not intended to be implemented by clients. Clients should instead subclass one of the classes that implement this interface. Note that direct implementers of this interface outside of the framework will be broken in future releases when methods are added to this interface. extends AbstractObservableValue A Lazily calculated value that automatically computes and registers listeners on its dependencies as long as all of its dependencies are IObservable objects. Any change to one of the observable dependencies causes the value to be recomputed. This class is thread safe. All state accessing methods must be invoked from the current realm. Methods for adding and removing listeners may be invoked from any thread. Example: compute the sum of all elements in an IObservableList < Integer >. final IObservableList addends = WritableValue.withValueType(Integer.TYPE); addends.add(new Integer(0)); addends.add(new Integer(1)); addends.add(new Integer(2)); IObservableValue sum = new ComputedValue() { protected Object calculate() { int sum = 0; for (Iterator it = addends.iterator(); it.hasNext();) { Integer addend = (Integer) it.next(); sum += addend.intValue(); } return sum; } }; System.out.println(sum.getValue()); // => 3 addends.add(new Integer(10)); System.out.println(sum.getValue()); // => 13 Since: 1.0 '
1213, 'org.eclipse.core.databinding.UpdateValueStrategy', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/databinding/UpdateValueStrategy.html', 'extends Object Customizes a Binding between two observable values. The following behaviors can be customized via the strategy: Validation Conversion Automatic processing The update phases are: Validate after get - validateAfterGet(Object) Conversion - convert(Object) Validate after conversion - validateAfterConvert(Object) Validate before set - validateBeforeSet(Object) Value set - doSet(IObservableValue, Object) Validation: Validators validate the value at multiple phases in the update process. Statuses returned from validators are aggregated into a MultiStatus until a status of ERROR or CANCEL is encountered. Either of these statuses will abort the update process. These statuses are available as the binding validation status. Conversion: A converter will convert the value from the type of the source observable into the type of the destination. The strategy has the ability to default converters for common scenarios. Automatic processing: The processing to perform when the source observable changes. This behavior is configured via policies provided on construction of the strategy (e.g. POLICY_NEVER, POLICY_CONVERT, POLICY_ON_REQUEST, POLICY_UPDATE). Since: 1.0 See Also: DataBindingContext.bindValue(IObservableValue, IObservableValue, UpdateValueStrategy, UpdateValueStrategy), ValidationStatusProvider.getValidationStatus(), IValidator, IConverter '
1214, 'org.eclipse.core.databinding.beans.PojoObservables', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/databinding/beans/PojoObservables.html', 'extends Object A factory for creating observable objects for POJOs (plain old java objects) that conform to idea of an object with getters and setters but does not provide property change events on change. This factory is identical to BeansObservables except for this fact. Since: 1.1 '
1215, 'org.eclipse.ui.IURIEditorInput', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/IURIEditorInput.html', 'An interface for an adaptable object. Adaptable objects can be dynamically extended to provide different interfaces (or \"adapters\"). Adapters are created by adapter factories, which are in turn managed by type by adapter managers. For example, IAdaptable a = [some adaptable]; IFoo x = (IFoo)a.getAdapter(IFoo.class); if (x != null) [do IFoo things with x] This interface can be used without OSGi running. Clients may implement this interface, or obtain a default implementation of this interface by subclassing PlatformObject. See Also: IAdapterFactory, IAdapterManager, PlatformObject An interface for an adaptable object. Adaptable objects can be dynamically extended to provide different interfaces (or \"adapters\"). Adapters are created by adapter factories, which are in turn managed by type by adapter managers. For example, IAdaptable a = [some adaptable]; IFoo x = (IFoo)a.getAdapter(IFoo.class); if (x != null) [do IFoo things with x] This interface can be used without OSGi running. Clients may implement this interface, or obtain a default implementation of this interface by subclassing PlatformObject. See Also: IAdapterFactory, IAdapterManager, PlatformObject extends IAdaptable IEditorInput is a light weight descriptor of editor input, like a file name but more abstract. It is not a model. It is a description of the model source for an IEditorPart. Clients implementing this editor input interface should override Object.equals(Object) to answer true for two inputs that are the same. The IWorbenchPage.openEditor APIs are dependent on this to find an editor with the same input. Clients should extend this interface to declare new types of editor inputs. An editor input is passed to an editor via the IEditorPart.init method. Due to the wide range of valid editor inputs, it is not possible to define generic methods for getting and setting bytes. Editor input must implement the IAdaptable interface; extensions are managed by the platform\'s adapter manager. Please note that it is important that the editor input be light weight. Within the workbench, the navigation history tends to hold on to editor inputs as a means of reconstructing the editor at a later time. The navigation history can hold on to quite a few inputs (i.e., the default is fifty). The actual data model should probably not be held in the input. See Also: IEditorPart, IWorkbenchPage.openEditor(IEditorInput, String), IWorkbenchPage.openEditor(IEditorInput, String, boolean) extends IEditorInput This interface defines an editor input based on a URI. Clients implementing this editor input interface should override Object.equals(Object) to answer true for two inputs that are the same. The IWorkbenchPage.openEditor APIs are dependent on this to find an editor with the same input. Path-oriented editors should support this as a valid input type, and can allow full read-write editing of its content. All editor inputs must implement the IAdaptable interface; extensions are managed by the platform\'s adapter manager. Since: 3.3 See Also: URI '
1216, 'org.eclipse.ui.ide.FileStoreEditorInputFactory', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/ide/FileStoreEditorInputFactory.html', 'A factory for re-creating objects from a previously saved memento. Clients should implement this interface and include the name of their class in an extension to the platform extension point named \"org.eclipse.ui.elementFactories\". For example, the plug-in\'s XML markup might contain: <extension point=\"org.eclipse.ui.elementFactories\"> <factory id=\"com.example.myplugin.MyFactory\" class=\"com.example.myplugin.MyFactory\" /> </extension> See Also: IPersistableElement, IMemento, IWorkbench.getElementFactory(java.lang.String) extends Object implements IElementFactory Factory for saving and restoring a FileStoreEditorInput. The stored representation of a FileStoreEditorInput remembers the path of the editor input. The workbench will automatically create instances of this class as required. It is not intended to be instantiated or subclassed by the client. Since: 3.3 '
1217, 'org.eclipse.jface.window.ApplicationWindow', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/window/ApplicationWindow.html', 'Interface for UI components which can execute a long-running operation in the form of an IRunnableWithProgress. The context is responsible for displaying a progress indicator and Cancel button to the end user while the operation is in progress; the context supplies a progress monitor to be used from code running inside the operation. Note that an IRunnableContext is not a runnable itself. For examples of UI components which implement this interface, see ApplicationWindow, ProgressMonitorDialog, and WizardDialog. See Also: IRunnableWithProgress, ApplicationWindow, ProgressMonitorDialog, WizardDialog Interface for objects that can return a shell. This is normally used for opening child windows. An object that wants to open child shells can take an IShellProvider in its constructor, and the object that implements IShellProvider can dynamically choose where child shells should be opened. Since: 3.1 extends Window implements IRunnableContext An application window is a high-level \"main window\", with built-in support for an optional menu bar with standard menus, an optional toolbar, and an optional status line. Creating an application window involves the following steps: creating an instance of ApplicationWindow assigning the window to a window manager (optional) opening the window by calling open Only on the last step, when the window is told to open, are the window\'s shell and widget tree created. When the window is closed, the shell and widget tree are disposed of and are no longer referenced, and the window is automatically removed from its window manager. Like all windows, an application window may be reopened. An application window is also a suitable context in which to perform long-running operations (that is, it implements IRunnableContext). '
1218, 'org.eclipse.swt.browser.LocationListener', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/browser/LocationListener.html', 'extends org.eclipse.swt.internal.SWTEventListener This listener interface may be implemented in order to receive a LocationEvent notification when a Browser navigates to a different URL. Since: 3.0 See Also: Browser.addLocationListener(LocationListener), Browser.removeLocationListener(LocationListener) '
1219, 'org.eclipse.swt.browser.StatusTextListener', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/browser/StatusTextListener.html', 'extends org.eclipse.swt.internal.SWTEventListener This listener interface may be implemented in order to receive a StatusTextEvent notification when the status text for a Browser is changed. Since: 3.0 See Also: Browser.addStatusTextListener(StatusTextListener), Browser.removeStatusTextListener(StatusTextListener) '
1220, 'org.eclipse.swt.browser.OpenWindowListener', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/browser/OpenWindowListener.html', 'extends org.eclipse.swt.internal.SWTEventListener This listener interface may be implemented in order to receive a WindowEvent notification when a new Browser needs to be provided by the application. Since: 3.0 See Also: Browser.addOpenWindowListener(OpenWindowListener), Browser.removeOpenWindowListener(OpenWindowListener), CloseWindowListener, VisibilityWindowListener '
1221, 'org.eclipse.swt.browser.VisibilityWindowListener', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/browser/VisibilityWindowListener.html', 'extends org.eclipse.swt.internal.SWTEventListener This listener interface may be implemented in order to receive a WindowEvent notification when a window hosting a Browser needs to be displayed or hidden. Since: 3.0 See Also: Browser.addVisibilityWindowListener(VisibilityWindowListener), Browser.removeVisibilityWindowListener(VisibilityWindowListener), OpenWindowListener, CloseWindowListener '
1222, 'org.eclipse.swt.browser.CloseWindowListener', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/browser/CloseWindowListener.html', 'extends org.eclipse.swt.internal.SWTEventListener This listener interface may be implemented in order to receive a WindowEvent notification when a Browser is about to be closed and when its host window should be closed by the application. Since: 3.0 See Also: Browser.addCloseWindowListener(CloseWindowListener), Browser.removeCloseWindowListener(CloseWindowListener), OpenWindowListener, VisibilityWindowListener '
1223, 'org.eclipse.swt.browser.ProgressListener', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/browser/ProgressListener.html', 'extends org.eclipse.swt.internal.SWTEventListener This listener interface may be implemented in order to receive a ProgressEvent notification when a Browser makes a progress in loading the current URL or when the current URL has been loaded. Since: 3.0 See Also: Browser.addProgressListener(ProgressListener), Browser.removeProgressListener(ProgressListener), Browser.getUrl() '
1224, 'org.eclipse.swt.browser.TitleListener', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/browser/TitleListener.html', 'extends org.eclipse.swt.internal.SWTEventListener This listener interface may be implemented in order to receive a TitleEvent notification when the title of the document displayed in a Browser is known or has been changed. Since: 3.0 See Also: Browser.addTitleListener(TitleListener), Browser.removeTitleListener(TitleListener) '
1225, 'org.eclipse.swt.browser.StatusTextEvent', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/browser/StatusTextEvent.html', 'extends TypedEvent A StatusTextEvent is sent by a Browser to StatusTextListener\'s when the status text is changed. The status text is typically displayed in the status bar of a browser application. Since: 3.0 See Also: Sample code and further information, Serialized Form '
1226, 'org.eclipse.swt.browser.WindowEvent', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/browser/WindowEvent.html', 'extends TypedEvent A WindowEvent is sent by a Browser when a new window needs to be created or when an existing window needs to be closed. This notification occurs when a javascript command such as window.open or window.close gets executed by a Browser. The following example shows how WindowEvent\'s are typically handled. public static void main(String[] args) { Display display = new Display(); Shell shell = new Shell(display); shell.setText(\"Main Window\"); shell.setLayout(new FillLayout()); Browser browser = new Browser(shell, SWT.NONE); initialize(display, browser); shell.open(); browser.setUrl(\"http://www.eclipse.org\"); while (!shell.isDisposed()) { if (!display.readAndDispatch()) display.sleep(); } display.dispose(); } static void initialize(final Display display, Browser browser) { browser.addOpenWindowListener(new OpenWindowListener() { public void open(WindowEvent event) { // Certain platforms can provide a default full browser. // simply return in that case if the application prefers // the default full browser to the embedded one set below. if (!event.required) return; // Embed the new window Shell shell = new Shell(display); shell.setText(\"New Window\"); shell.setLayout(new FillLayout()); Browser browser = new Browser(shell, SWT.NONE); initialize(display, browser); event.browser = browser; } }); browser.addVisibilityWindowListener(new VisibilityWindowListener() { public void hide(WindowEvent event) { Browser browser = (Browser)event.widget; Shell shell = browser.getShell(); shell.setVisible(false); } public void show(WindowEvent event) { Browser browser = (Browser)event.widget; Shell shell = browser.getShell(); if (event.location != null) shell.setLocation(event.location); if (event.size != null) { Point size = event.size; shell.setSize(shell.computeSize(size.x, size.y)); } if (event.addressBar || event.menuBar || event.statusBar || event.toolBar) { // Create widgets for the address bar, menu bar, status bar and/or tool bar // leave enough space in the Shell to accommodate a Browser of the size // given by event.size } shell.open(); } }); browser.addCloseWindowListener(new CloseWindowListener() { public void close(WindowEvent event) { Browser browser = (Browser)event.widget; Shell shell = browser.getShell(); shell.close(); } }); } The following notifications are emitted when the user selects a hyperlink that targets a new window or as the result of a javascript that executes window.open. Main Browser User selects a link that opens in a new window or javascript requests a new window OpenWindowListener.open() notified Application creates a new Shell and a second Browser inside that Shell Application registers WindowListener\'s on that second Browser, such as VisibilityWindowListener Application returns the second Browser as the host for the new window content Second Browser VisibilityWindowListener.show() notified Application sets navigation tool bar, status bar, menu bar and Shell size Application makes the Shell hosting the second Browser visible User now sees the new window Since: 3.0 See Also: CloseWindowListener, OpenWindowListener, VisibilityWindowListener, Sample code and further information, Serialized Form '
1227, 'org.eclipse.swt.browser.ProgressEvent', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/browser/ProgressEvent.html', 'extends TypedEvent A ProgressEvent is sent by a Browser to ProgressListener\'s when a progress is made during the loading of the current URL or when the loading of the current URL has been completed. Since: 3.0 See Also: Sample code and further information, Serialized Form '
1228, 'org.eclipse.swt.browser.LocationEvent', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/browser/LocationEvent.html', 'extends TypedEvent A LocationEvent is sent by a Browser to LocationListener\'s when the Browser navigates to a different URL. This notification typically occurs when the application navigates to a new location with Browser.setUrl(String) or when the user activates a hyperlink. Since: 3.0 See Also: Sample code and further information, Serialized Form '
1229, 'org.eclipse.swt.browser.TitleEvent', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/browser/TitleEvent.html', 'extends TypedEvent A TitleEvent is sent by a Browser to TitleListener\'s when the title of the current document is available or when it is modified. Since: 3.0 See Also: Sample code and further information, Serialized Form '
1230, 'org.eclipse.osgi.service.environment.Constants', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/osgi/service/environment/Constants.html', 'Constants used with the EnvironmentInfo service. Since: 3.0 This interface is not intended to be implemented by clients. Restriction: This interface is not intended to be implemented by clients. Restriction: This interface is not intended to be extended by clients. '
1231, 'org.eclipse.jface.action.SubCoolBarManager', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/action/SubCoolBarManager.html', 'A contribution manager organizes contributions to such UI components as menus, toolbars and status lines. A contribution manager keeps track of a list of contribution items. Each contribution item may has an optional identifier, which can be used to retrieve items from a manager, and for positioning items relative to each other. The list of contribution items can be subdivided into named groups using special contribution items that serve as group markers. The IContributionManager interface provides general protocol for adding, removing, and retrieving contribution items. It also provides convenience methods that make it convenient to contribute actions. This interface should be implemented by all objects that wish to manage contributions. There are several implementions of this interface in this package, including ones for menus (MenuManager), tool bars (ToolBarManager), and status lines (StatusLineManager). A contribution manager organizes contributions to such UI components as menus, toolbars and status lines. A contribution manager keeps track of a list of contribution items. Each contribution item may has an optional identifier, which can be used to retrieve items from a manager, and for positioning items relative to each other. The list of contribution items can be subdivided into named groups using special contribution items that serve as group markers. The IContributionManager interface provides general protocol for adding, removing, and retrieving contribution items. It also provides convenience methods that make it convenient to contribute actions. This interface should be implemented by all objects that wish to manage contributions. There are several implementions of this interface in this package, including ones for menus (MenuManager), tool bars (ToolBarManager), and status lines (StatusLineManager). extends IContributionManager The ICoolBarManager interface provides protocol for managing contributions to a cool bar. A cool bar manager delegates responsibility for creating child controls to its contribution items by calling IContributionItem.fill(CoolBar, int). This interface is internal to the framework; it should not be implemented outside the framework. This package provides a concrete cool bar manager implementation, CoolBarManager, which clients may instantiate or subclass. Since: 3.0 See Also: ToolBarContributionItem extends SubContributionManager implements ICoolBarManager A SubCoolBarManager monitors the additional and removal of items from a parent manager so that visibility of the entire set can be changed as a unit. Since: 3.0 '
1232, 'org.eclipse.ui.actions.TextActionHandler', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/actions/TextActionHandler.html', 'extends Object Handles the redirection of the global Cut, Copy, Paste, and Select All actions to either the current inline text control or the part\'s supplied action handler. This class may be instantiated; it is not intended to be subclassed. Example usage: textActionHandler = new TextActionHandler(this.getViewSite().getActionBars()); textActionHandler.addText((Text)textCellEditor1.getControl()); textActionHandler.addText((Text)textCellEditor2.getControl()); textActionHandler.setSelectAllAction(selectAllAction); Restriction: This class is not intended to be subclassed by clients. '
1233, 'org.eclipse.ui.statushandlers.WorkbenchStatusDialogManager', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/statushandlers/WorkbenchStatusDialogManager.html', 'extends Object The WorkbenchStatusDialogManager is a utility class for displaying one or more messages (errors, warnings or infos) to the user. The dialog supplied has a Details button that opens/closes the details area. The default AbstractStatusAreaProvider displays a tree of StatusAdapters related to the selected item on the messages list. The dialog also hasa Support button that opens/closes the support area which contains the provided AbstractStatusAreaProvider. The Support button is disabled and not visible unless enableDefaultSupportArea(boolean) is invoked. The default details area can be replaced using setDetailsAreaProvider(AbstractStatusAreaProvider) The default support area can be replaced using setSupportAreaProvider(AbstractStatusAreaProvider) or Policy.setErrorSupportProvider(ErrorSupportProvider). The manager can switch from a non-modal dialog to a modal dialog. See addStatusAdapter(StatusAdapter, boolean) Since: 3.4 See Also: Policy.setErrorSupportProvider(ErrorSupportProvider), ErrorSupportProvider, AbstractStatusAreaProvider Restriction: This class is not intended to be subclassed by clients. '
1234, 'org.eclipse.ui.IStartup', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/IStartup.html', 'Plug-ins that register a startup extension will be activated after the Workbench initializes and have an opportunity to run code that can\'t be implemented using the normal contribution mechanisms. Since: 2.0 '
1235, 'org.eclipse.ui.commands.AbstractHandler', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/commands/AbstractHandler.html', 'A handler is the pluggable piece of a command that handles execution. Each command can have zero or more handlers associated with it (in general), of which only one will be active at any given moment in time. When the command is asked to execute, it will simply pass that request on to its active handler, if any. This interface is not intended to be extended by clients. Since: 3.0 See Also: IHandler A handler is the pluggable piece of a command that handles execution. Each command can have zero or more handlers associated with it (in general), of which only one will be active at any given moment in time. When the command is asked to execute, it will simply pass that request on to its active handler, if any. Since: 3.1 See Also: AbstractHandler extends IHandler Extend the IHandler interface to provide some context for isEnabled() requests. Clients should use AbstractHandler unless they need to provide their own listener mechanism. Since: 3.4 See Also: AbstractHandler extends AbstractHandler implements IHandler This class is a partial implementation of IHandler. This abstract implementation provides support for handler listeners. You should subclass from this method unless you want to implement your own listener support. Subclasses should call fireHandlerChanged(HandlerEvent)when the handler changes. Subclasses should also override getAttributeValuesByName()if they have any attributes. Since: 3.0 See Also: AbstractHandler '
1236, 'org.eclipse.ui.commands.HandlerSubmission', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/commands/HandlerSubmission.html', 'extends Object implements Comparable An instance of this class represents a request to handle a command. A handler submission specifies a list of conditions under which it would be appropriate for a particular command to have a particular handler. These conditions include things like the active part or the active shell. So, it is possible to say things like: \"when my part is active, please consider calling these classes when you want to perform a cut, copy or paste\". The workbench considers all of the submissions it has received and choses the ones it views as the best possible match. This class is not intended to be extended by clients. Note: this class has a natural ordering that is inconsistent with equals. Since: 3.0 See Also: IWorkbenchCommandSupport, IHandlerService '
1237, 'org.eclipse.ui.commands.IHandler', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/commands/IHandler.html', 'A handler is the pluggable piece of a command that handles execution. Each command can have zero or more handlers associated with it (in general), of which only one will be active at any given moment in time. When the command is asked to execute, it will simply pass that request on to its active handler, if any. This interface is not intended to be extended by clients. Since: 3.0 See Also: IHandler '
1238, 'org.eclipse.ui.menus.IWorkbenchWidget', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/menus/IWorkbenchWidget.html', ' Provides a hook by which third-party code can contribute SWT widgets to a menu, tool bar or status line. This can be used, for example, to add a combo box to the status line, or a \"Location\" bar to the tool bar. It is possible for fill and dispose to be called multiple times for a single instance of IWidget. Clients may implement, but must not extend. Since: 3.2 extends IWidget Interface used for IWidget\'s contributed to the Workbench. Allows the contributed widget to be informed as to which WorkbenchWindow it\'s being hosted in. Since: 3.2 See Also: IWidget '
1239, 'org.eclipse.jface.util.Assert', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/util/Assert.html', 'extends Object Assert is useful for for embedding runtime sanity checks in code. The static predicate methods all test a condition and throw some type of unchecked exception if the condition does not hold. Assertion failure exceptions, like most runtime exceptions, are thrown when something is misbehaving. Assertion failures are invariably unspecified behavior; consequently, clients should never rely on these being thrown (or not thrown). If you find yourself in the position where you need to catch an assertion failure, you have most certainly written your program incorrectly. Note that an assert statement is slated to be added to the Java language in JDK 1.4, rending this class obsolete. '
1240, 'org.eclipse.ui.dialogs.ProjectLocationSelectionDialog', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/dialogs/ProjectLocationSelectionDialog.html', 'Interface for objects that can return a shell. This is normally used for opening child windows. An object that wants to open child shells can take an IShellProvider in its constructor, and the object that implements IShellProvider can dynamically choose where child shells should be opened. Since: 3.1 extends SelectionStatusDialog The ProjectLocationSelectionDialog is the dialog used to select the name and location of a project for copying. '
1241, 'org.eclipse.ui.dialogs.ContainerSelectionDialog', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/dialogs/ContainerSelectionDialog.html', 'Interface for objects that can return a shell. This is normally used for opening child windows. An object that wants to open child shells can take an IShellProvider in its constructor, and the object that implements IShellProvider can dynamically choose where child shells should be opened. Since: 3.1 extends SelectionDialog A standard selection dialog which solicits a container resource from the user. The getResult method returns the selected container resource. This class may be instantiated; it is not intended to be subclassed. Example: ContainerSelectionDialog dialog = new ContainerSelectionDialog(getShell(), initialSelection, allowNewContainerName(), msg); dialog.open(); Object[] result = dialog.getResult(); Restriction: This class is not intended to be subclassed by clients. '
1242, 'org.eclipse.jface.text.TextSelection', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/text/TextSelection.html', 'Interface for a selection. See Also: ISelectionProvider, ISelectionChangedListener, SelectionChangedEvent extends ISelection This interface represents a textual selection. A text selection is a range of characters. Although a text selection is a snapshot taken at a particular point in time, it must not copy the line information and the selected text from the selection provider. If, for example, the selection provider is a text viewer ( ITextViewer), and a text selection is created for the range [5, 10], the line formation for the 5th character must not be determined and remembered at the point of creation. It can rather be determined at the point, when getStartLine is called. If the source viewer range [0, 15] has been changed in the meantime between the creation of the text selection object and the invocation of getStartLine, the returned line number may differ from the line number of the 5th character at the point of creation of the text selection object. The contract of this interface is that weak in order to allow for efficient implementations. Clients may implement this interface or use the default implementation provided by TextSelection. See Also: TextSelection Interface for a selection. See Also: ISelectionProvider, ISelectionChangedListener, SelectionChangedEvent extends Object implements ITextSelection Standard implementation of ITextSelection. Takes advantage of the weak contract of correctness of its interface. If generated from a selection provider, it only remembers its offset and length and computes the remaining information on request. '
1243, 'org.eclipse.ui.part.PageBookView', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/part/PageBookView.html', 'An interface for an adaptable object. Adaptable objects can be dynamically extended to provide different interfaces (or \"adapters\"). Adapters are created by adapter factories, which are in turn managed by type by adapter managers. For example, IAdaptable a = [some adaptable]; IFoo x = (IFoo)a.getAdapter(IFoo.class); if (x != null) [do IFoo things with x] This interface can be used without OSGi running. Clients may implement this interface, or obtain a default implementation of this interface by subclassing PlatformObject. See Also: IAdapterFactory, IAdapterManager, PlatformObject Interface for executable extension classes that require access to their configuration element, or implement an extension adapter. Extension adapters are typically required in cases where the extension implementation does not follow the interface rules specified by the provider of the extension point. In these cases, the role of the adapter is to map between the extension point interface, and the actual extension implementation. In general, adapters are used when attempting to plug-in existing Java implementations, or non-Java implementations (e.g., external executables). This interface can be used without OSGi running. Clients may implement this interface. See Also: IConfigurationElement.createExecutableExtension(String) Interface for listening to part lifecycle events. This interface may be implemented by clients. See Also: IPartService.addPartListener(IPartListener) Objects implementing this interface are capable of saving their state in an IMemento. Since: 3.1 An interface for an adaptable object. Adaptable objects can be dynamically extended to provide different interfaces (or \"adapters\"). Adapters are created by adapter factories, which are in turn managed by type by adapter managers. For example, IAdaptable a = [some adaptable]; IFoo x = (IFoo)a.getAdapter(IFoo.class); if (x != null) [do IFoo things with x] This interface can be used without OSGi running. Clients may implement this interface, or obtain a default implementation of this interface by subclassing PlatformObject. See Also: IAdapterFactory, IAdapterManager, PlatformObject Objects implementing this interface are capable of saving their state in an IMemento. Since: 3.1 An interface for an adaptable object. Adaptable objects can be dynamically extended to provide different interfaces (or \"adapters\"). Adapters are created by adapter factories, which are in turn managed by type by adapter managers. For example, IAdaptable a = [some adaptable]; IFoo x = (IFoo)a.getAdapter(IFoo.class); if (x != null) [do IFoo things with x] This interface can be used without OSGi running. Clients may implement this interface, or obtain a default implementation of this interface by subclassing PlatformObject. See Also: IAdapterFactory, IAdapterManager, PlatformObject extends IAdaptable A workbench part is a visual component within a workbench page. There are two subtypes: view and editor, as defined by IViewPart and IEditorPart. A view is typically used to navigate a hierarchy of information (like the workspace), open an editor, or display properties for the active editor. Modifications made in a view are saved immediately. An editor is typically used to edit or browse a document or input object. The input is identified using an IEditorInput. Modifications made in an editor part follow an open-save-close lifecycle model. This interface may be implemented directly. For convenience, a base implementation is defined in WorkbenchPart. The lifecycle of a workbench part is as follows: When a part extension is created: instantiate the part create a part site call part.init(site) When a part becomes visible in the workbench: add part to presentation by calling part.createPartControl(parent) to create actual widgets fire partOpened event to all listeners When a part is activated or gets focus: call part.setFocus() fire partActivated event to all listeners When a part is closed: if save is needed, do save; if it fails or is canceled return if part is active, deactivate part fire partClosed event to all listeners remove part from presentation; part controls are disposed as part of the SWT widget tree call part.dispose() After createPartControl has been called, the implementor may safely reference the controls created. When the part is closed these controls will be disposed as part of an SWT composite. This occurs before the IWorkbenchPart.dispose method is called. If there is a need to free SWT resources the part should define a dispose listener for its own control and free those resources from the dispose listener. If the part invokes any method on the disposed SWT controls after this point an SWTError will be thrown. The last method called on IWorkbenchPart is dispose. This signals the end of the part lifecycle. An important point to note about this lifecycle is that following a call to init, createPartControl may never be called. Thus in the dispose method, implementors must not assume controls were created. Workbench parts implement the IAdaptable interface; extensions are managed by the platform\'s adapter manager. See Also: IViewPart, IEditorPart extends IWorkbenchPart, IPersistable A view is a visual component within a workbench page. It is typically used to navigate a hierarchy of information (like the workspace), open an editor, or display properties for the active editor. Modifications made in a view are saved immediately (in contrast to an editor part, which conforms to a more elaborate open-save-close lifecycle). Only one instance of a particular view type may exist within a workbench page. This policy is designed to simplify part management for a user. This interface may be implemented directly. For convenience, a base implementation is defined in ViewPart. A view is added to the workbench in two steps: A view extension is contributed to the workbench registry. This extension defines the extension id and extension class. The view is included in the default layout for a perspective. Alternatively, the user may open the view from the Perspective menu. Views implement the IAdaptable interface; extensions are managed by the platform\'s adapter manager. As of 3.4, views may optionally adapt to ISizeProvider if they have a preferred size. The default presentation will make a best effort to allocate the preferred size to a view if it is the only part in a stack. If there is more than one part in the stack, the constraints will be disabled for that stack. The size constraints are adjusted for the size of the tab and border trim. Note that this is considered to be a hint to the presentation, and not all presentations may honor size constraints. See Also: IWorkbenchPage.showView(java.lang.String), ViewPart, ISizeProvider An interface for an adaptable object. Adaptable objects can be dynamically extended to provide different interfaces (or \"adapters\"). Adapters are created by adapter factories, which are in turn managed by type by adapter managers. For example, IAdaptable a = [some adaptable]; IFoo x = (IFoo)a.getAdapter(IFoo.class); if (x != null) [do IFoo things with x] This interface can be used without OSGi running. Clients may implement this interface, or obtain a default implementation of this interface by subclassing PlatformObject. See Also: IAdapterFactory, IAdapterManager, PlatformObject extends IAdaptable A workbench part is a visual component within a workbench page. There are two subtypes: view and editor, as defined by IViewPart and IEditorPart. A view is typically used to navigate a hierarchy of information (like the workspace), open an editor, or display properties for the active editor. Modifications made in a view are saved immediately. An editor is typically used to edit or browse a document or input object. The input is identified using an IEditorInput. Modifications made in an editor part follow an open-save-close lifecycle model. This interface may be implemented directly. For convenience, a base implementation is defined in WorkbenchPart. The lifecycle of a workbench part is as follows: When a part extension is created: instantiate the part create a part site call part.init(site) When a part becomes visible in the workbench: add part to presentation by calling part.createPartControl(parent) to create actual widgets fire partOpened event to all listeners When a part is activated or gets focus: call part.setFocus() fire partActivated event to all listeners When a part is closed: if save is needed, do save; if it fails or is canceled return if part is active, deactivate part fire partClosed event to all listeners remove part from presentation; part controls are disposed as part of the SWT widget tree call part.dispose() After createPartControl has been called, the implementor may safely reference the controls created. When the part is closed these controls will be disposed as part of an SWT composite. This occurs before the IWorkbenchPart.dispose method is called. If there is a need to free SWT resources the part should define a dispose listener for its own control and free those resources from the dispose listener. If the part invokes any method on the disposed SWT controls after this point an SWTError will be thrown. The last method called on IWorkbenchPart is dispose. This signals the end of the part lifecycle. An important point to note about this lifecycle is that following a call to init, createPartControl may never be called. Thus in the dispose method, implementors must not assume controls were created. Workbench parts implement the IAdaptable interface; extensions are managed by the platform\'s adapter manager. See Also: IViewPart, IEditorPart An interface for an adaptable object. Adaptable objects can be dynamically extended to provide different interfaces (or \"adapters\"). Adapters are created by adapter factories, which are in turn managed by type by adapter managers. For example, IAdaptable a = [some adaptable]; IFoo x = (IFoo)a.getAdapter(IFoo.class); if (x != null) [do IFoo things with x] This interface can be used without OSGi running. Clients may implement this interface, or obtain a default implementation of this interface by subclassing PlatformObject. See Also: IAdapterFactory, IAdapterManager, PlatformObject An interface for an adaptable object. Adaptable objects can be dynamically extended to provide different interfaces (or \"adapters\"). Adapters are created by adapter factories, which are in turn managed by type by adapter managers. For example, IAdaptable a = [some adaptable]; IFoo x = (IFoo)a.getAdapter(IFoo.class); if (x != null) [do IFoo things with x] This interface can be used without OSGi running. Clients may implement this interface, or obtain a default implementation of this interface by subclassing PlatformObject. See Also: IAdapterFactory, IAdapterManager, PlatformObject extends IAdaptable A workbench part is a visual component within a workbench page. There are two subtypes: view and editor, as defined by IViewPart and IEditorPart. A view is typically used to navigate a hierarchy of information (like the workspace), open an editor, or display properties for the active editor. Modifications made in a view are saved immediately. An editor is typically used to edit or browse a document or input object. The input is identified using an IEditorInput. Modifications made in an editor part follow an open-save-close lifecycle model. This interface may be implemented directly. For convenience, a base implementation is defined in WorkbenchPart. The lifecycle of a workbench part is as follows: When a part extension is created: instantiate the part create a part site call part.init(site) When a part becomes visible in the workbench: add part to presentation by calling part.createPartControl(parent) to create actual widgets fire partOpened event to all listeners When a part is activated or gets focus: call part.setFocus() fire partActivated event to all listeners When a part is closed: if save is needed, do save; if it fails or is canceled return if part is active, deactivate part fire partClosed event to all listeners remove part from presentation; part controls are disposed as part of the SWT widget tree call part.dispose() After createPartControl has been called, the implementor may safely reference the controls created. When the part is closed these controls will be disposed as part of an SWT composite. This occurs before the IWorkbenchPart.dispose method is called. If there is a need to free SWT resources the part should define a dispose listener for its own control and free those resources from the dispose listener. If the part invokes any method on the disposed SWT controls after this point an SWTError will be thrown. The last method called on IWorkbenchPart is dispose. This signals the end of the part lifecycle. An important point to note about this lifecycle is that following a call to init, createPartControl may never be called. Thus in the dispose method, implementors must not assume controls were created. Workbench parts implement the IAdaptable interface; extensions are managed by the platform\'s adapter manager. See Also: IViewPart, IEditorPart extends IWorkbenchPart Extends IWorkbenchPart, adding the name and status text properties. Prior to 3.0, a view\'s title was often modified to show both the part name and extra status text. With this interface, the distinction is made more explicit. Since: 3.0 An interface for an adaptable object. Adaptable objects can be dynamically extended to provide different interfaces (or \"adapters\"). Adapters are created by adapter factories, which are in turn managed by type by adapter managers. For example, IAdaptable a = [some adaptable]; IFoo x = (IFoo)a.getAdapter(IFoo.class); if (x != null) [do IFoo things with x] This interface can be used without OSGi running. Clients may implement this interface, or obtain a default implementation of this interface by subclassing PlatformObject. See Also: IAdapterFactory, IAdapterManager, PlatformObject An interface for an adaptable object. Adaptable objects can be dynamically extended to provide different interfaces (or \"adapters\"). Adapters are created by adapter factories, which are in turn managed by type by adapter managers. For example, IAdaptable a = [some adaptable]; IFoo x = (IFoo)a.getAdapter(IFoo.class); if (x != null) [do IFoo things with x] This interface can be used without OSGi running. Clients may implement this interface, or obtain a default implementation of this interface by subclassing PlatformObject. See Also: IAdapterFactory, IAdapterManager, PlatformObject extends IAdaptable A workbench part is a visual component within a workbench page. There are two subtypes: view and editor, as defined by IViewPart and IEditorPart. A view is typically used to navigate a hierarchy of information (like the workspace), open an editor, or display properties for the active editor. Modifications made in a view are saved immediately. An editor is typically used to edit or browse a document or input object. The input is identified using an IEditorInput. Modifications made in an editor part follow an open-save-close lifecycle model. This interface may be implemented directly. For convenience, a base implementation is defined in WorkbenchPart. The lifecycle of a workbench part is as follows: When a part extension is created: instantiate the part create a part site call part.init(site) When a part becomes visible in the workbench: add part to presentation by calling part.createPartControl(parent) to create actual widgets fire partOpened event to all listeners When a part is activated or gets focus: call part.setFocus() fire partActivated event to all listeners When a part is closed: if save is needed, do save; if it fails or is canceled return if part is active, deactivate part fire partClosed event to all listeners remove part from presentation; part controls are disposed as part of the SWT widget tree call part.dispose() After createPartControl has been called, the implementor may safely reference the controls created. When the part is closed these controls will be disposed as part of an SWT composite. This occurs before the IWorkbenchPart.dispose method is called. If there is a need to free SWT resources the part should define a dispose listener for its own control and free those resources from the dispose listener. If the part invokes any method on the disposed SWT controls after this point an SWTError will be thrown. The last method called on IWorkbenchPart is dispose. This signals the end of the part lifecycle. An important point to note about this lifecycle is that following a call to init, createPartControl may never be called. Thus in the dispose method, implementors must not assume controls were created. Workbench parts implement the IAdaptable interface; extensions are managed by the platform\'s adapter manager. See Also: IViewPart, IEditorPart extends IWorkbenchPart Extends IWorkbenchPart, adding the name and status text properties. Prior to 3.0, a view\'s title was often modified to show both the part name and extra status text. With this interface, the distinction is made more explicit. Since: 3.0 extends IWorkbenchPart2 A part can provide arbitrary properties. The properties will be persisted between sessions by the part reference, and will be available from the part reference as well as the part. The properties can only be set on a part, not on the reference. The properties will be available to the IPresentablePart. Setting a property must fire a PropertyChangeEvent. Since: 3.3 The IWorkbenchPartOrientation is the interface that defines the orientation of the part. If a type does not implement this interface an orientation of SWT.NONE will be assumed. Since: 3.1 See Also: SWT.RIGHT_TO_LEFT, SWT.LEFT_TO_RIGHT, SWT.NONE, Window.getDefaultOrientation() extends ViewPart implements IPartListener Abstract superclass of all multi-page workbench views. Within the workbench there are many views which track the active part. If a part is activated these views display some properties for the active part. A simple example is the Outline View, which displays the outline for the active editor. To avoid loss of context when part activation changes, these views may implement a multi-page approach. A separate page is maintained within the view for each source view. If a part is activated the associated page for the part is brought to top. If a part is closed the associated page is disposed. PageBookView is a base implementation for multi page views. PageBookViews provide an IPageSite for each of their pages. This site is supplied during the page\'s initialization. The page may supply a selection provider for this site. PageBookViews deal with these selection providers in a similar way to a workbench page\'s SelectionService. When a page is made visible, if its site has a selection provider, then changes in the selection are listened for and the current selection is obtained and fired as a selection change event. Selection changes are no longer listened for when a page is made invisible. This class should be subclassed by clients wishing to define new multi-page views. When a PageBookView is created the following methods are invoked. Subclasses must implement these. createDefaultPage - called to create a default page for the view. This page is displayed when the active part in the workbench does not have a page. getBootstrapPart - called to determine the active part in the workbench. A page will be created for this part When a part is activated the base implementation does not know if a page should be created for the part. Therefore, it delegates creation to the subclass. isImportant - called when a workbench part is activated. Subclasses return whether a page should be created for the new part. doCreatePage - called to create a page for a particular part in the workbench. This is only invoked when isImportant returns true. When a part is closed the base implementation will destroy the page associated with the particular part. The page was created by a subclass, so the subclass must also destroy it. Subclasses must implement these. doDestroyPage - called to destroy a page for a particular part in the workbench. '
1244, 'org.eclipse.core.runtime.IRegistryEventListener', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/runtime/IRegistryEventListener.html', 'extends EventListener A registry event listener is notified of changes to extension points. Changes include modifications of extension points and their extensions. Listeners will only receive a notification if the extension point they are registered for is modified. (Which includes modifications of extensions under the extension point.) This interface can be used without OSGi running. Clients may implement this interface. Since: 3.4 See Also: IExtensionRegistry.addListener(IRegistryEventListener, String) '
1245, 'org.eclipse.ui.views.properties.PinPropertySheetAction', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/views/properties/PinPropertySheetAction.html', 'An action represents the non-UI side of a command which can be triggered by the end user. Actions are typically associated with buttons, menu items, and items in tool bars. The controls for a command are built by some container, which furnished the context where these controls appear and configures them with data from properties declared by the action. When the end user triggers the command via its control, the action\'s run method is invoked to do the real work. Actions support a predefined set of properties (and possibly others as well). Clients of an action may register property change listeners so that they get notified whenever the value of a property changes. Clients should subclass the abstract base class Action to define concrete actions rather than implementing IAction from scratch. This interface exists only to define the API for actions. It is not intended to be implemented by clients. See Also: Action Restriction: This interface is not intended to be implemented by clients. extends Action Pins the properties view instance to the current selection. Since: 3.4 '
1246, 'org.eclipse.ui.views.properties.PropertySheetPage', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/views/properties/PropertySheetPage.html', 'An interface for an adaptable object. Adaptable objects can be dynamically extended to provide different interfaces (or \"adapters\"). Adapters are created by adapter factories, which are in turn managed by type by adapter managers. For example, IAdaptable a = [some adaptable]; IFoo x = (IFoo)a.getAdapter(IFoo.class); if (x != null) [do IFoo things with x] This interface can be used without OSGi running. Clients may implement this interface, or obtain a default implementation of this interface by subclassing PlatformObject. See Also: IAdapterFactory, IAdapterManager, PlatformObject extends EventListener Interface for listening to selection changes. This interface may be implemented by clients. See Also: ISelectionService.addSelectionListener(ISelectionListener), ISelectionService.addSelectionListener(String, ISelectionListener), INullSelectionListener extends IPage Interface for a page in a pagebook view. Pages should implement this interface. See Also: PageBookView, Page extends EventListener Interface for listening to selection changes. This interface may be implemented by clients. See Also: ISelectionService.addSelectionListener(ISelectionListener), ISelectionService.addSelectionListener(String, ISelectionListener), INullSelectionListener extends IPage, ISelectionListener Interface for a property sheet page that appears in a property sheet view. This interface defines the minimum requirement for pages within the property sheet view, namely they must be pages (implement IPage) be prepared to contribute actions to the property sheet view\'s tool bar and status line, and listen for selection changes in the active part. Clients may implement this interface from scratch if the property sheet viewer\'s default page is unsuitable for displaying a part\'s properties. See Also: PropertySheetPage extends Page implements IPropertySheetPage, IAdaptable The standard implementation of property sheet page which presents a table of property names and values obtained from the current selection in the active workbench part. This page obtains the information about what properties to display from the current selection (which it tracks). The model for this page is a hierarchy of IPropertySheetEntry. The page may be configured with a custom model by setting the root entry. If no root entry is set then a default model is created which uses the IPropertySource interface to obtain the properties of the current selection. This requires that the selected objects provide an IPropertySource adapter (or implement IPropertySource directly). This restiction can be overcome by providing this page with an IPropertySourceProvider. If supplied, this provider will be used by the default model to obtain a property source for the current selection This class may be instantiated; it is not intended to be subclassed. See Also: IPropertySource Restriction: This class is not intended to be subclassed by clients. '
1247, 'org.eclipse.ui.views.properties.PropertyShowInContext', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/views/properties/PropertyShowInContext.html', 'extends ShowInContext Since: 3.4 '
1248, 'org.eclipse.ui.preferences.IWorkingCopyManager', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/preferences/IWorkingCopyManager.html', 'IWorkingCopyManager is the interface for the working copy support for references to shared preference nodes. Since: 3.1 '
1249, 'org.eclipse.ui.preferences.WorkingCopyManager', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/preferences/WorkingCopyManager.html', 'IWorkingCopyManager is the interface for the working copy support for references to shared preference nodes. Since: 3.1 extends Object implements IWorkingCopyManager WorkingCopyManager is a concrete implementation of an IWorkingCopyManager. This class is not intended to be sub-classed by clients. Since: 3.2 '
1250, 'org.eclipse.core.databinding.validation.MultiValidator', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/databinding/validation/MultiValidator.html', 'extends ValidationStatusProvider A validator for cross-constraints between observables. Some practical examples of cross-constraints: A start date cannot be later than an end date A list of percentages should add up to 100% Example: require two integer fields to contain either both even or both odd numbers. DataBindingContext dbc = new DataBindingContext(); IObservableValue target0 = SWTObservables.observeText(text0, SWT.Modify); IObservableValue target1 = SWTObservables.observeText(text1, SWT.Modify); // Binding in two stages (from target to middle, then from middle to model) // simplifies the validation logic. Using the middle observables saves // the trouble of converting the target values (Strings) to the model type // (integers) manually during validation. final IObservableValue middle0 = new WritableValue(null, Integer.TYPE); final IObservableValue middle1 = new WritableValue(null, Integer.TYPE); dbc.bind(target0, middle0, null, null); dbc.bind(target1, middle1, null, null); // Create the multi-validator MultiValidator validator = new MultiValidator() { protected IStatus validate() { // Calculate the validation status Integer value0 = (Integer) middle0.getValue(); Integer value1 = (Integer) middle1.getValue(); if (Math.abs(value0.intValue()) % 2 != Math.abs(value1.intValue()) % 2) return ValidationStatus .error(\"Values must be both even or both odd\"); return ValidationStatus.ok(); } }; dbc.addValidationStatusProvider(validator); // Bind the middle observables to the model observables. IObservableValue model0 = new WritableValue(new Integer(2), Integer.TYPE); IObservableValue model1 = new WritableValue(new Integer(4), Integer.TYPE); dbc.bind(middle0, model0, null, null); dbc.bind(middle1, model1, null, null); MultiValidator can also prevent invalid data from being copied to model. This is done by wrapping each target observable in a validated observable, and then binding the validated observable to the model. ... // Validated observables do not change value until the validator passes. IObservableValue validated0 = validator.observeValidatedValue(middle0); IObservableValue validated1 = validator.observeValidatedValue(middle1); IObservableValue model0 = new WritableValue(new Integer(2), Integer.TYPE); IObservableValue model1 = new WritableValue(new Integer(4), Integer.TYPE); // Bind to the validated value, not the middle/target dbc.bind(validated0, model0, null, null); dbc.bind(validated1, model1, null, null); Note: No guarantee is made as to the order of updates when multiple validated observables change value at once (i.e. multiple updates pending when the status becomes valid). Therefore the model may be in an invalid state after the first but before the last pending update. Since: 1.1 '
1251, 'org.eclipse.core.databinding.observable.IObservable', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/databinding/observable/IObservable.html', 'An object with state that allows to listen for state changes. Implementations must not manage listeners themselves, listener management must be delegated to a private instance of type ChangeSupport if it is not inherited from AbstractObservable. Since: 1.0 Restriction: This interface is not intended to be implemented by clients. Clients should instead subclass one of the classes in the framework that implement this interface. Note that direct implementers of this interface outside of the framework will be broken in future releases when methods are added to this interface. '
1252, 'org.eclipse.swt.widgets.Tray', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/widgets/Tray.html', 'extends Widget Instances of this class represent the system tray that is part of the task bar status area on some operating systems. Styles: (none) Events: (none) IMPORTANT: This class is not intended to be subclassed. Since: 3.0 See Also: Display.getSystemTray(), Tray, TrayItem snippets, Sample code and further information Restriction: This class is not intended to be subclassed by clients. '
1253, 'org.eclipse.jface.databinding.swt.SWTObservables', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/databinding/swt/SWTObservables.html', 'extends Object A factory for creating observables for SWT widgets Since: 1.1 '
1254, 'org.eclipse.jface.databinding.swt.ISWTObservable', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/databinding/swt/ISWTObservable.html', 'An object with state that allows to listen for state changes. Implementations must not manage listeners themselves, listener management must be delegated to a private instance of type ChangeSupport if it is not inherited from AbstractObservable. Since: 1.0 Restriction: This interface is not intended to be implemented by clients. Clients should instead subclass one of the classes in the framework that implement this interface. Note that direct implementers of this interface outside of the framework will be broken in future releases when methods are added to this interface. extends IObservable IObservable observing an SWT widget. Since: 1.1 '
1255, 'org.eclipse.core.databinding.observable.IDecoratingObservable', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/databinding/observable/IDecoratingObservable.html', 'An object with state that allows to listen for state changes. Implementations must not manage listeners themselves, listener management must be delegated to a private instance of type ChangeSupport if it is not inherited from AbstractObservable. Since: 1.0 Restriction: This interface is not intended to be implemented by clients. Clients should instead subclass one of the classes in the framework that implement this interface. Note that direct implementers of this interface outside of the framework will be broken in future releases when methods are added to this interface. extends IObservable Interface for observables which decorate other observables. Since: 1.2 Restriction: This interface is not intended to be implemented by clients. Clients should instead subclass one of the classes in the framework that implement this interface. Note that direct implementers of this interface outside of the framework will be broken in future releases when methods are added to this interface. '
1256, 'org.eclipse.swt.widgets.ToolTip', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/widgets/ToolTip.html', 'extends Widget Instances of this class represent popup windows that are used to inform or warn the user. Styles: BALLOON, ICON_ERROR, ICON_INFORMATION, ICON_WARNING Events: Selection Note: Only one of the styles ICON_ERROR, ICON_INFORMATION, and ICON_WARNING may be specified. IMPORTANT: This class is not intended to be subclassed. Since: 3.2 See Also: Tool Tips snippets, SWT Example: ControlExample, Sample code and further information Restriction: This class is not intended to be subclassed by clients. '
1257, 'org.eclipse.jface.databinding.swt.ISWTObservableList', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/databinding/swt/ISWTObservableList.html', 'An object with state that allows to listen for state changes. Implementations must not manage listeners themselves, listener management must be delegated to a private instance of type ChangeSupport if it is not inherited from AbstractObservable. Since: 1.0 Restriction: This interface is not intended to be implemented by clients. Clients should instead subclass one of the classes in the framework that implement this interface. Note that direct implementers of this interface outside of the framework will be broken in future releases when methods are added to this interface. extends IObservable, Collection Interface for observable collections. Only general change listeners can be added to an observable collection. Listeners interested in incremental changes have to be added using more concrete subtypes such as IObservableList or IObservableSet. Since: 1.0 Restriction: This interface is not intended to be implemented by clients. Clients should instead subclass one of the classes that implement this interface. Note that direct implementers of this interface outside of the framework will be broken in future releases when methods are added to this interface. Restriction: This interface is not intended to be extended by clients. An object with state that allows to listen for state changes. Implementations must not manage listeners themselves, listener management must be delegated to a private instance of type ChangeSupport if it is not inherited from AbstractObservable. Since: 1.0 Restriction: This interface is not intended to be implemented by clients. Clients should instead subclass one of the classes in the framework that implement this interface. Note that direct implementers of this interface outside of the framework will be broken in future releases when methods are added to this interface. extends IObservable, Collection Interface for observable collections. Only general change listeners can be added to an observable collection. Listeners interested in incremental changes have to be added using more concrete subtypes such as IObservableList or IObservableSet. Since: 1.0 Restriction: This interface is not intended to be implemented by clients. Clients should instead subclass one of the classes that implement this interface. Note that direct implementers of this interface outside of the framework will be broken in future releases when methods are added to this interface. Restriction: This interface is not intended to be extended by clients. extends List, IObservableCollection A list whose changes can be tracked by list change listeners. Since: 1.0 See Also: AbstractObservableList, ObservableList Restriction: This interface is not intended to be implemented by clients. Clients should instead subclass one of the framework classes that implement this interface. Note that direct implementers of this interface outside of the framework will be broken in future releases when methods are added to this interface. An object with state that allows to listen for state changes. Implementations must not manage listeners themselves, listener management must be delegated to a private instance of type ChangeSupport if it is not inherited from AbstractObservable. Since: 1.0 Restriction: This interface is not intended to be implemented by clients. Clients should instead subclass one of the classes in the framework that implement this interface. Note that direct implementers of this interface outside of the framework will be broken in future releases when methods are added to this interface. extends IObservable IObservable observing an SWT widget. Since: 1.1 extends ISWTObservable, IObservableList IObservableList observing an SWT widget. Since: 1.3 '
1258, 'org.eclipse.ui.dialogs.SelectionDialog', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/dialogs/SelectionDialog.html', 'Interface for objects that can return a shell. This is normally used for opening child windows. An object that wants to open child shells can take an IShellProvider in its constructor, and the object that implements IShellProvider can dynamically choose where child shells should be opened. Since: 3.1 extends TrayDialog The abstract implementation of a selection dialog. It can be primed with initial selections (setInitialSelections), and returns the final selection (via getResult) after completion. Clients may subclass this dialog to inherit its selection facilities. '
1259, 'org.eclipse.ui.IMarkerResolution2', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/IMarkerResolution2.html', 'Resolution for a marker. When run, a resolution would typically eliminate the need for the marker. Since: 2.0 extends IMarkerResolution Extends IMarkerResolution. This interface should be used in place of IMarkerResolution if a description and/or image are desired. Since: 3.0 '
1260, 'org.eclipse.ui.forms.events.IHyperlinkListener', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/forms/events/IHyperlinkListener.html', 'Classes that implement this interface will be notified when hyperlinks are entered, exited and activated. Since: 3.0 See Also: Hyperlink, ImageHyperlink, FormText '
1261, 'org.eclipse.ui.forms.IMessage', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/forms/IMessage.html', 'Minimal interface to a message provider. Used for dialog pages which can provide a message with an icon. Since: 2.0 extends IMessageProvider This interface encapsulates a single message that can be shown in a form. Messages can be associated with controls, or be of a general nature. Since: 3.3 See Also: IMessageManager '
1262, 'org.eclipse.ui.forms.widgets.FormToolkit', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/forms/widgets/FormToolkit.html', 'extends Object The toolkit is responsible for creating SWT controls adapted to work in Eclipse forms. In addition to changing their presentation properties (fonts, colors etc.), various listeners are attached to make them behave correctly in the form context. In addition to being the control factory, the toolkit is also responsible for painting flat borders for select controls, managing hyperlink groups and control colors. The toolkit creates some of the most common controls used to populate Eclipse forms. Controls that must be created using their constructors, adapt() method is available to change its properties in the same way as with the supported toolkit controls. Typically, one toolkit object is created per workbench part (for example, an editor or a form wizard). The toolkit is disposed when the part is disposed. To conserve resources, it is possible to create one color object for the entire plug-in and share it between several toolkits. The plug-in is responsible for disposing the colors (disposing the toolkit that uses shared color object will not dispose the colors). FormToolkit is normally instantiated, but can also be subclassed if some of the methods needs to be modified. In those cases, super must be called to preserve normal behaviour. Since: 3.0 '
1263, 'org.eclipse.ui.forms.widgets.ScrolledForm', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/forms/widgets/ScrolledForm.html', 'Implementers of Drawable can have a graphics context (GC) created for them, and then they can be drawn on by sending messages to their associated GC. SWT images, and device objects such as the Display device and the Printer device, are drawables. IMPORTANT: This interface is not part of the SWT public API. It is marked public only so that it can be shared within the packages provided by SWT. It should never be referenced from application code. See Also: Device, Image, GC extends SharedScrolledComposite ScrolledForm is a control that is capable of scrolling an instance of the Form class. It should be created in a parent that will allow it to use all the available area (for example, a shell, a view or an editor). Children of the form should typically be created using FormToolkit to match the appearance and behaviour. When creating children, use a form body as a parent by calling \'getBody()\' on the form instance. Example: FormToolkit toolkit = new FormToolkit(parent.getDisplay()); ScrolledForm form = toolkit.createScrolledForm(parent); form.setText(\"Sample form\"); form.getBody().setLayout(new GridLayout()); toolkit.createButton(form.getBody(), \"Checkbox\", SWT.CHECK); No layout manager has been set on the body. Clients are required to set the desired layout manager explicitly. Although the class is not final, it is not expected to be be extended. Since: 3.0 Restriction: This class is not intended to be subclassed by clients. '
1264, 'org.eclipse.ui.forms.widgets.TableWrapLayout', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/forms/widgets/TableWrapLayout.html', 'Classes that extend abstract class Layout and implement this interface can take part in layout computation of the TableWrapLayout manager. This layout uses alternative algorithm that computes columns before rows. It allows it to \'flow\' wrapped text proportionally (similar to the way web browser renders tables). Custom layout managers that implement this interface will allow TableWrapLayout to properly compute width hint to pass. Since: 3.0 See Also: TableWrapLayout, ColumnLayout extends Layout implements ILayoutExtension This implementation of the layout algorithm attempts to position controls in the composite using a two-pass autolayout HTML table algorithm recommended by HTML 4.01 W3C specification (see http://www.w3.org/TR/html4/appendix/notes.html#h-B.5.2.2). The main differences with GridLayout is that it has two passes and that width and height are not calculated in the same pass. The advantage of the algorithm over GridLayout is that it is capable of flowing text controls capable of line wrap. These controls do not have natural \'preferred size\'. Instead, they are capable of providing the required height if the width is set. Consequently, this algorithm first calculates the widths that will be assigned to columns, and then passes those widths to the controls to calculate the height. When a composite with this layout is a child of the scrolling composite, they should interact in such a way that reduction in the scrolling composite width results in the reflow and increase of the overall height. If none of the columns contain expandable and wrappable controls, the end-result will be similar to the one provided by GridLayout. The difference will show up for layouts that contain controls whose minimum and maximum widths are not the same. Since: 3.0 See Also: TableWrapData '
1265, 'org.eclipse.ui.forms.widgets.TableWrapData', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/forms/widgets/TableWrapData.html', 'extends Object Layout data used in conjunction with TableWrapLayout. Children in a composite that uses this layout should call setLayoutData and pass an instance of this class to control physical placement in the parent. Since: 3.0 See Also: TableWrapLayout '
1266, 'org.eclipse.ui.forms.events.ExpansionAdapter', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/forms/events/ExpansionAdapter.html', 'Classes that implement this interface will be notified before and after the expandable control\'s expansion state changes. Since: 3.0 extends Object implements IExpansionListener This adapter class provides default implementations for the methods described by the ExpansionListener interface. Classes that wish to deal with ExpansionEvents can extend this class and override only the methods which they are interested in. Since: 3.0 See Also: IExpansionListener, ExpansionEvent '
1267, 'org.eclipse.ui.forms.widgets.ImageHyperlink', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/forms/widgets/ImageHyperlink.html', 'Implementers of Drawable can have a graphics context (GC) created for them, and then they can be drawn on by sending messages to their associated GC. SWT images, and device objects such as the Display device and the Printer device, are drawables. IMPORTANT: This interface is not part of the SWT public API. It is marked public only so that it can be shared within the packages provided by SWT. It should never be referenced from application code. See Also: Device, Image, GC extends Hyperlink This class extends hyperlink widget by adding the capability to render an image relative to the text. If no text has been set, only image will be shown. Images for hover and active states can be set in addition to the normal state image. When image is taller than the text, additional style can be provided to control vertical alignment (supported values are SWT.TOP, SWT.BOTTOM and SWT.CENTER). The class does not need to be sublassed but it is allowed to do so if some aspect of the image hyperlink needs to be modified. Styles: SWT.WRAP, SWT.BOTTOM, SWT.TOP, SWT.MIDDLE, SWT.LEFT, SWT.RIGHT Since: 3.0 '
1268, 'org.eclipse.ui.forms.widgets.Section', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/forms/widgets/Section.html', 'Implementers of Drawable can have a graphics context (GC) created for them, and then they can be drawn on by sending messages to their associated GC. SWT images, and device objects such as the Display device and the Printer device, are drawables. IMPORTANT: This interface is not part of the SWT public API. It is marked public only so that it can be shared within the packages provided by SWT. It should never be referenced from application code. See Also: Device, Image, GC extends ExpandableComposite A variation of the expandable composite that adds optional description below the title. Section is often used as a basic building block in forms because it provides for logical grouping of information. In case of the TITLE_BAR style, Section renders the title bar in a way compatible with the rest of the workbench. Since it is a widget, all the colors must be supplied directly. When created by the form toolkit, these colors are supplied by the toolkit. The toolkit initializes these colors based on the system colors. For this reason, it is recommended to create the section by the toolkit instead of through its own constructor. Since 3.1, it is possible to set a control to be used for section description. If used, DESCRIPTION style should not be set. A typical way to take advantage of the new method is to set an instance of FormText to provide for hyperlinks and images in the description area. Since: 3.0 '
1269, 'org.eclipse.ui.forms.widgets.FormText', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/forms/widgets/FormText.html', 'Implementers of Drawable can have a graphics context (GC) created for them, and then they can be drawn on by sending messages to their associated GC. SWT images, and device objects such as the Display device and the Printer device, are drawables. IMPORTANT: This interface is not part of the SWT public API. It is marked public only so that it can be shared within the packages provided by SWT. It should never be referenced from application code. See Also: Device, Image, GC extends Canvas This class is a read-only text control that is capable of rendering wrapped text. Text can be rendered as-is or by parsing the formatting XML tags. Independently, words that start with http:// can be converted into hyperlinks on the fly. When configured to use formatting XML, the control requires the root element form to be used and requires any ampersand (&) characters in the text to be replaced by the entity &amp;. The following tags can be children of the form element: p - for defining paragraphs. The following attributes are allowed: vspace - if set to \'false\', no vertical space will be added (default is \'true\') li - for defining list items. The following attributes are allowed: vspace - the same as with the p tag style - could be \'bullet\' (default), \'text\' and \'image\' value - not used for \'bullet\'. For text, it is the value of the text that is rendered as a bullet. For image, it is the href of the image to be rendered as a bullet. indent - the number of pixels to indent the text in the list item bindent - the number of pixels to indent the bullet itself Text in paragraphs and list items will be wrapped according to the width of the control. The following tags can appear as children of either p or li elements: img - to render an image. Element accepts attribute \'href\' that is a key to the Image set using \'setImage\' method. Vertical position of image relative to surrounding text is optionally controlled by the attribute align that can have values top, middle and bottom a - to render a hyperlink. Element accepts attribute \'href\' that will be provided to the hyperlink listeners via HyperlinkEvent object. The element also accepts \'nowrap\' attribute (default is false). When set to \'true\', the hyperlink will not be wrapped. Hyperlinks automatically created when \'http://\' is encountered in text are not wrapped. b - the enclosed text will use bold font. br - forced line break (no attributes). span - the enclosed text will have the color and font specified in the element attributes. Color is provided using \'color\' attribute and is a key to the Color object set by \'setColor\' method. Font is provided using \'font\' attribute and is a key to the Font object set by \'setFont\' method. As with hyperlinks, it is possible to block wrapping by setting \'nowrap\' to true (false by default). control (new in 3.1) - to place a control that is a child of the text control. Element accepts attribute \'href\' that is a key to the Control object set using \'setControl\' method. Optionally, attribute \'fill\' can be set to true to make the control fill the entire width of the text. Form text is not responsible for creating or disposing controls, it only places them relative to the surrounding text. Similar to img, vertical position of the control can be set using the align attribute. In addition, width and height attributes can be used to force the dimensions of the control. If not used, the preferred control size will be used. None of the elements can nest. For example, you cannot have b inside a span . This was done to keep everything simple and transparent. Since 3.1, an exception to this rule has been added to support nesting images and text inside the hyperlink tag (a). Image enclosed in the hyperlink tag acts as a hyperlink, can be clicked on and can accept and render selection focus. When both text and image is enclosed, selection and rendering will affect both as a single hyperlink. Since 3.1, it is possible to select text. Text selection can be programmatically accessed and also copied to clipboard. Non-textual objects (images, controls etc.) in the selection range are ignored. Care should be taken when using this control. Form text is not an HTML browser and should not be treated as such. If you need complex formatting capabilities, use Browser widget. If you need editing capabilities and font/color styles of text segments is all you need, use StyleText widget. Finally, if all you need is to wrap text, use SWT Label widget and create it with SWT.WRAP style. Since: 3.0 See Also: FormToolkit, TableWrapLayout '
1270, 'org.eclipse.ui.navigator.NavigatorActionService', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/navigator/NavigatorActionService.html', 'Clients may use mementos to persist interesting state between sessions. Clients should ensure that the memento keys are unique; generally by using the id of the content extension as a prefix. Since: 3.2 extends ActionGroup implements IMementoAware Provides context menu items and IActionBars contributions for a particular abstract viewer. The interface matches that of ActionGroup and may be used in the same manner. Clients must call prepareMenuForPlatformContributions(MenuManager, ISelectionProvider, boolean) when using this class to allow object or viewer contributions. The org.eclipse.ui.navigator.viewer/viewer/popupMenu element may override whether platform contributions are allowed to the menu with its allowsPlatformContributions attribute. \"Platform Contributions\" are menu items that are added through the org.eclipse.ui.popupMenus extension point. A CommonActionProvider has opportunities to contribute to the context menu and IActionBars whenever the selection in the viewer changes. Action Providers are selected based on the enablement expressions of their associated content extension or their own enablement expression if it is declared as a top-level <actionProvider /> element (of the org.eclipse.ui.navigator.navigatorContent extension point). See the schema documentation of org.eclipse.ui.navigator.navigatorContent for more information on how to specify an Action Provider. Clients that reuse this service outside of an instance of CommonNavigator must be sure that {fillActionBars(IActionBars) is called whenever the selection changes. The retargetable actions for each selection could change, based on who contributed the items. Since: 3.2 '
1271, 'org.eclipse.ui.actions.ActionContext', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/actions/ActionContext.html', 'extends Object An ActionContext represents the context used to determine which actions are added by an ActionGroup, and what their enabled state should be. This class encapsulates a selection and an input element. Clients may subclass this class to add more information to the context. '
1272, 'org.eclipse.ui.IWorkingSetUpdater', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/IWorkingSetUpdater.html', 'An IWorkingSetUpdater can be used to dynamically update the content of a working set. A working set updater manages a set of working sets. It is contributed via the attribute updaterClass of the org.eclipse.ui.workingSets extension point. Extensions of this extension point must therefore implement this interface. API under construction and subject to change at any time. Since: 3.1 '
1273, 'org.eclipse.ui.IWorkingSetElementAdapter', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/IWorkingSetElementAdapter.html', ' Interface that describes a mechanism that may be provided by working set extensions to help manage the addition of elements to working sets. Instances of this class are capable of transforming possible working set content into the most applicable form. Usage of this interface is achieved via the elementAdapterClass attribute of the org.eclipse.ui.workingSets extension point. Usage of this interface in org.eclipse.ui.workingSets extensions is optional. Since: 3.3 '
1274, 'org.eclipse.ui.dialogs.IWorkingSetEditWizard', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/dialogs/IWorkingSetEditWizard.html', 'Interface for a wizard. A wizard maintains a list of wizard pages, stacked on top of each other in card layout fashion. The class Wizard provides an abstract implementation of this interface. However, clients are also free to implement this interface if Wizard does not suit their needs. See Also: Wizard extends IWizard A working set edit wizard allows editing a working set using the IWorkingSetPage associated with the working set. See the org.eclipse.ui.workingSets extension point for details. Use org.eclipse.ui.IWorkingSetManager#createWorkingSetEditWizard(IWorkingSet) to create an instance of this wizard. This interface is not intended to be implemented by clients. Since: 2.1 See Also: IWorkingSetManager Restriction: This interface is not intended to be implemented by clients. '
1275, 'org.eclipse.ui.dialogs.IWorkingSetPage', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/dialogs/IWorkingSetPage.html', 'Interface for a page in a multi-page dialog. Interface for a page in a multi-page dialog. extends IDialogPage Interface for a wizard page. The class WizardPage provides an abstract implementation of this interface. However, clients are also free to implement this interface if WizardPage does not suit their needs. extends IWizardPage A working set page allows the user to edit an existing working set and create a new working set. Clients should implement this interface and include the name of their class in an extension contributed to the workbench\'s working set extension point (named \"org.eclipse.ui.workingSets\") if they want to provide a special wizard page for a particular working set element type. Clients implementing this interface may subclass from org.eclipse.jface.wizard.WizardPage. Since: 2.0 '
1276, 'org.eclipse.ui.dialogs.IWorkingSetSelectionDialog', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/dialogs/IWorkingSetSelectionDialog.html', 'A working set selection dialog displays the list of working sets available in the workbench. Use org.eclipse.ui.IWorkingSetManager#createWorkingSetSelectionDialog(Shell) to create an instance of this dialog. This interface is not intended to be implemented by clients. Since: 2.0 See Also: IWorkingSetManager Restriction: This interface is not intended to be implemented by clients. '
1277, 'org.eclipse.ui.dialogs.IWorkingSetNewWizard', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/dialogs/IWorkingSetNewWizard.html', 'Interface for a wizard. A wizard maintains a list of wizard pages, stacked on top of each other in card layout fashion. The class Wizard provides an abstract implementation of this interface. However, clients are also free to implement this interface if Wizard does not suit their needs. See Also: Wizard extends IWizard A working set new wizard allows creating new working sets using a plug-in specific working set page. Use org.eclipse.ui.IWorkingSetManager#createWorkingSetNewWizard(String[] workingSetIds) to create an instance of this wizard. This interface is not intended to be implemented by clients. Since: 3.1 See Also: IWorkingSetManager, IWorkingSetPage Restriction: This interface is not intended to be implemented by clients. '
1278, 'org.eclipse.jface.menus.IWidget', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/menus/IWidget.html', ' Provides a hook by which third-party code can contribute SWT widgets to a menu, tool bar or status line. This can be used, for example, to add a combo box to the status line, or a \"Location\" bar to the tool bar. It is possible for fill and dispose to be called multiple times for a single instance of IWidget. Clients may implement, but must not extend. Since: 3.2 '
1279, 'org.eclipse.ui.menus.MenuUtil', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/menus/MenuUtil.html', 'extends Object Provides utilities and constants for use with the new menus API. Since: 3.3 Restriction: This class is not intended to be subclassed by clients. Restriction: This class is not intended to be instantiated by clients. '
1280, 'org.eclipse.swt.widgets.TaskItem', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/widgets/TaskItem.html', 'extends Item Instances of this class represent a task item. Styles: (none) Events: (none) Since: 3.6 See Also: Sample code and further information Restriction: This class is not intended to be subclassed by clients. '
1281, 'org.eclipse.ui.IPerspectiveListener2', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/IPerspectiveListener2.html', 'Interface for listening to perspective lifecycle events. This interface may be implemented by clients. See Also: IPageService.addPerspectiveListener(IPerspectiveListener), PerspectiveAdapter extends IPerspectiveListener Extension interface to IPerspectiveListener which adds support for listening to part-specific perspective lifecycle events. For example, this allows a perspective listener to determine which view is being hidden during a CHANGE_VIEW_HIDE event. This interface may be implemented by clients. Since: 3.0 See Also: IPageService.addPerspectiveListener(IPerspectiveListener), PerspectiveAdapter '
1282, 'org.eclipse.ui.forms.widgets.ColumnLayout', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/forms/widgets/ColumnLayout.html', 'Classes that extend abstract class Layout and implement this interface can take part in layout computation of the TableWrapLayout manager. This layout uses alternative algorithm that computes columns before rows. It allows it to \'flow\' wrapped text proportionally (similar to the way web browser renders tables). Custom layout managers that implement this interface will allow TableWrapLayout to properly compute width hint to pass. Since: 3.0 See Also: TableWrapLayout, ColumnLayout extends Layout implements ILayoutExtension This layout manager arranges children of the composite parent in vertical columns. All the columns are identical size and children are stretched horizontally to fill the column width. The goal is to give layout some reasonable range of column numbers to allow it to handle various parent widths. That way, column number will drop to the lowest number in the range when width decreases, and grow up to the highest number in the range when allowed by the parent width. In addition, the layout attempts to \'fill the space\' equally i.e. to avoid large gaps at the and of the last column. Child controls are layed out according to their \'natural\' (preferred) size. For \'stretchy\' controls that do not have natural preferred size, it is possible to set width and/or height hints using ColumnLayoutData objects. Since: 3.0 See Also: ColumnLayoutData '
1283, 'org.eclipse.ui.forms.FormColors', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/forms/FormColors.html', 'extends Object Manages colors that will be applied to forms and form widgets. The colors are chosen to make the widgets look correct in the editor area. If a different set of colors is needed, subclass this class and override \'initialize\' and/or \'initializeColors\'. Since: 3.0 '
1284, 'org.eclipse.core.databinding.observable.IObservableCollection', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/databinding/observable/IObservableCollection.html', 'An object with state that allows to listen for state changes. Implementations must not manage listeners themselves, listener management must be delegated to a private instance of type ChangeSupport if it is not inherited from AbstractObservable. Since: 1.0 Restriction: This interface is not intended to be implemented by clients. Clients should instead subclass one of the classes in the framework that implement this interface. Note that direct implementers of this interface outside of the framework will be broken in future releases when methods are added to this interface. extends IObservable, Collection Interface for observable collections. Only general change listeners can be added to an observable collection. Listeners interested in incremental changes have to be added using more concrete subtypes such as IObservableList or IObservableSet. Since: 1.0 Restriction: This interface is not intended to be implemented by clients. Clients should instead subclass one of the classes that implement this interface. Note that direct implementers of this interface outside of the framework will be broken in future releases when methods are added to this interface. Restriction: This interface is not intended to be extended by clients. '
1285, 'org.eclipse.core.databinding.observable.set.SetChangeEvent', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/databinding/observable/set/SetChangeEvent.html', 'extends ObservableEvent List change event describing an incremental change of an IObservableSet object. Since: 1.0 See Also: Serialized Form '
1286, 'org.eclipse.core.resources.IWorkspaceRunnable', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/resources/IWorkspaceRunnable.html', 'A runnable which executes as a batch operation within the workspace. The IWorkspaceRunnable interface should be implemented by any class whose instances are intended to be run by IWorkspace.run. Clients may implement this interface. See Also: IWorkspace.run(IWorkspaceRunnable, IProgressMonitor) '
1287, 'org.eclipse.ui.navigator.NavigatorContentServiceFactory', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/navigator/NavigatorContentServiceFactory.html', 'extends Object Provides a factory pattern for creating INavigatorContentServices for given viewer ids. Clients may supply the viewer in createContentService(String, StructuredViewer) or wait until the content provider is created by the service and set on the viewer. When the content provider is set, the viewer will call inputChanged(), and the content service will update its managed viewer accordingly. Therefore, each content service should be attached to at most one viewer. Since: 3.2 '
1288, 'org.eclipse.ui.navigator.IPipelinedTreeContentProvider', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/navigator/IPipelinedTreeContentProvider.html', 'A content provider mediates between the viewer\'s model and the viewer itself. See Also: ContentViewer.setContentProvider(IContentProvider) Clients may use mementos to persist interesting state between sessions. Clients should ensure that the memento keys are unique; generally by using the id of the content extension as a prefix. Since: 3.2 A content provider mediates between the viewer\'s model and the viewer itself. See Also: ContentViewer.setContentProvider(IContentProvider) extends IContentProvider An interface to content providers for structured viewers. See Also: StructuredViewer A content provider mediates between the viewer\'s model and the viewer itself. See Also: ContentViewer.setContentProvider(IContentProvider) extends IContentProvider An interface to content providers for structured viewers. See Also: StructuredViewer extends IStructuredContentProvider An interface to content providers for tree-structure-oriented viewers. See Also: AbstractTreeViewer extends ITreeContentProvider, IMementoAware Allows extensions to vary their behavior based on properties in the extension model and the given memento. The state model should be initialized from values in the memento if necessary. Clients should refer to the org.eclipse.ui.navigator.navigatorContent extension point for more information on building a content extension. Clients may implement this interface if they require the methods defined here. ITreeContentProvider is respected by the Common Navigator. Since: 3.2 A content provider mediates between the viewer\'s model and the viewer itself. See Also: ContentViewer.setContentProvider(IContentProvider) Clients may use mementos to persist interesting state between sessions. Clients should ensure that the memento keys are unique; generally by using the id of the content extension as a prefix. Since: 3.2 A content provider mediates between the viewer\'s model and the viewer itself. See Also: ContentViewer.setContentProvider(IContentProvider) extends IContentProvider An interface to content providers for structured viewers. See Also: StructuredViewer A content provider mediates between the viewer\'s model and the viewer itself. See Also: ContentViewer.setContentProvider(IContentProvider) extends IContentProvider An interface to content providers for structured viewers. See Also: StructuredViewer extends IStructuredContentProvider An interface to content providers for tree-structure-oriented viewers. See Also: AbstractTreeViewer extends ICommonContentProvider To correctly implement pipelining you should implement IPipelinedTreeContentProvider2 which provides the additional ITreeContentProvider.hasChildren(Object) method. This allows the calculation of hasChildren to match what will be provided in calculating the children. If you don\'t implement the hasChildren, you may get \"false positive\" hasChildrens which will result in a \"+\" indication in the tree in the event that the pipelined children calculation. The only reason these are two separate interfaces is historical. Since: 3.2 '
1289, 'org.eclipse.ui.navigator.PipelinedShapeModification', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/navigator/PipelinedShapeModification.html', 'extends Object Indicates how a shape modification should be transformed when applied to the tree. Clients use PipelinedShapeModification as the input and return type from intercept methods on IPipelinedTreeContentProvider. Overriding extensions should use these to map attempts to directly modify the tree down to the overridden model. A shape modification can either be an add or remove shape modification, and the type is determined by the context of its use. If supplied to an interceptRemove method, then it is a remove shape modification, otherwise if supplied to an interceptAdd method, then it is an add shape modification. Since: 3.2 '
1290, 'org.eclipse.ui.navigator.PipelinedViewerUpdate', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/navigator/PipelinedViewerUpdate.html', 'extends Object A pipelined viewer update should map requests to refresh or update elements in the viewer to their correct, modified structure. Clients use PipelinedViewerUpdate as the input and return type from intercept methods on IPipelinedTreeContentProvider. Clients should use the viewer update to describe how the request from the upstream extension (see IPipelinedTreeContentProvider for more information on upstream extensions) should be reshaped when applied to the tree. A request from an upstream extension to refresh a given element could result in multiple refresh requests from downstream extensions. Therefore, the refresh targets are modeled as a set. Initially, this set will contain the original element that was passed to the refresh requests. Clients may squash the refresh by clearing the set, change the original target by removing the current element and adding a new target, or expand the refresh by adding more elements to the set. A pipelined extension may receive a PipelinedViewerUpdate as the result of a call to StructuredViewer.refresh()-methods or ColumnViewer.update(Object, String[])-methods. The properties field is only applicable for update() calls and the updateLabels field is only applicable for refresh() calls. Since: 3.2 '
1291, 'org.eclipse.ui.navigator.INavigatorContentExtension', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/navigator/INavigatorContentExtension.html', 'An interface for an adaptable object. Adaptable objects can be dynamically extended to provide different interfaces (or \"adapters\"). Adapters are created by adapter factories, which are in turn managed by type by adapter managers. For example, IAdaptable a = [some adaptable]; IFoo x = (IFoo)a.getAdapter(IFoo.class); if (x != null) [do IFoo things with x] This interface can be used without OSGi running. Clients may implement this interface, or obtain a default implementation of this interface by subclassing PlatformObject. See Also: IAdapterFactory, IAdapterManager, PlatformObject extends IAdaptable The content extension represents the components of a navigatorContent extension. These handles are managed by a content service INavigatorContentService. An extension is formed from the INavigatorContentDescriptor. There is a one-to-many correspondence between the INavigatorContentDescriptor and INavigatorContentExtension. An instance of the INavigatorContentExtension is created for each INavigatorContentDescriptor used by a INavigatorContentService. Since: 3.2 Restriction: This interface is not intended to be implemented by clients. Restriction: This interface is not intended to be extended by clients. '
1292, 'org.eclipse.ui.INewWizard', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/INewWizard.html', 'Interface for a wizard. A wizard maintains a list of wizard pages, stacked on top of each other in card layout fashion. The class Wizard provides an abstract implementation of this interface. However, clients are also free to implement this interface if Wizard does not suit their needs. See Also: Wizard Interface for a wizard. A wizard maintains a list of wizard pages, stacked on top of each other in card layout fashion. The class Wizard provides an abstract implementation of this interface. However, clients are also free to implement this interface if Wizard does not suit their needs. See Also: Wizard extends IWizard Implementors represent creation wizards that are to be contributed to the workbench\'s creation wizard extension point. See Also: IWizard extends IWorkbenchWizard Interface for creation wizards. Clients should implement this interface and include the name of their class in a wizard contributed to the workbench\'s creation wizard extension point (named \"org.eclipse.ui.newWizards\"). For example, the plug-in\'s XML markup might contain: <extension point=\"org.eclipse.ui.newWizards\"> <wizard id=\"com.example.myplugin.new.blob\" name=\"Blob\" class=\"com.example.myplugin.BlobCreator\" icon=\"icons/new_blob_wiz.gif\"> <description>Create a new BLOB file</description> <selection class=\"org.eclipse.core.resources.IResource\" /> </wizard> </extension> See Also: IWizard '
1293, 'org.eclipse.ui.IImportWizard', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/IImportWizard.html', 'Interface for a wizard. A wizard maintains a list of wizard pages, stacked on top of each other in card layout fashion. The class Wizard provides an abstract implementation of this interface. However, clients are also free to implement this interface if Wizard does not suit their needs. See Also: Wizard Interface for a wizard. A wizard maintains a list of wizard pages, stacked on top of each other in card layout fashion. The class Wizard provides an abstract implementation of this interface. However, clients are also free to implement this interface if Wizard does not suit their needs. See Also: Wizard extends IWizard Implementors represent creation wizards that are to be contributed to the workbench\'s creation wizard extension point. See Also: IWizard extends IWorkbenchWizard Interface for import wizards. Clients should implement this interface and include the name of their class in a wizard contributed to the workbench\'s import wizard extension point (named \"org.eclipse.ui.importWizards\"). For example, the plug-in\'s XML markup might contain: <extension point=\"org.eclipse.ui.importWizards\"> <wizard id=\"com.example.myplugin.blob\" name=\"Blob File\" class=\"com.example.myplugin.BlobFileImporter\" icon=\"icons/import_blob_wiz.gif\"> <description>Import resources from a BLOB file</description> <selection class=\"org.eclipse.core.resources.IResource\" /> </wizard> </extension> See Also: IWizard '
1294, 'org.eclipse.ui.IExportWizard', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/IExportWizard.html', 'Interface for a wizard. A wizard maintains a list of wizard pages, stacked on top of each other in card layout fashion. The class Wizard provides an abstract implementation of this interface. However, clients are also free to implement this interface if Wizard does not suit their needs. See Also: Wizard Interface for a wizard. A wizard maintains a list of wizard pages, stacked on top of each other in card layout fashion. The class Wizard provides an abstract implementation of this interface. However, clients are also free to implement this interface if Wizard does not suit their needs. See Also: Wizard extends IWizard Implementors represent creation wizards that are to be contributed to the workbench\'s creation wizard extension point. See Also: IWizard extends IWorkbenchWizard Interface for export wizards. Clients should implement this interface and include the name of their class in a wizard contributed to the workbench\'s export wizard extension point (named \"org.eclipse.ui.exportWizards\"). For example, the plug-in\'s XML markup might contain: <extension point=\"org.eclipse.ui.exportWizards\"> <wizard id=\"com.example.myplugin.blob\" name=\"Blob File\" class=\"com.example.myplugin.BlobFileExporter\" icon=\"icons/export_blob_wiz.gif\"> <description>Export resources to a BLOB file</description> <selection class=\"org.eclipse.core.resources.IResource\" /> </wizard> </extension> See Also: IWizard '
1295, 'org.eclipse.ui.navigator.IPipelinedTreeContentProvider2', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/navigator/IPipelinedTreeContentProvider2.html', 'A content provider mediates between the viewer\'s model and the viewer itself. See Also: ContentViewer.setContentProvider(IContentProvider) Clients may use mementos to persist interesting state between sessions. Clients should ensure that the memento keys are unique; generally by using the id of the content extension as a prefix. Since: 3.2 A content provider mediates between the viewer\'s model and the viewer itself. See Also: ContentViewer.setContentProvider(IContentProvider) extends IContentProvider An interface to content providers for structured viewers. See Also: StructuredViewer A content provider mediates between the viewer\'s model and the viewer itself. See Also: ContentViewer.setContentProvider(IContentProvider) extends IContentProvider An interface to content providers for structured viewers. See Also: StructuredViewer extends IStructuredContentProvider An interface to content providers for tree-structure-oriented viewers. See Also: AbstractTreeViewer extends ITreeContentProvider, IMementoAware Allows extensions to vary their behavior based on properties in the extension model and the given memento. The state model should be initialized from values in the memento if necessary. Clients should refer to the org.eclipse.ui.navigator.navigatorContent extension point for more information on building a content extension. Clients may implement this interface if they require the methods defined here. ITreeContentProvider is respected by the Common Navigator. Since: 3.2 A content provider mediates between the viewer\'s model and the viewer itself. See Also: ContentViewer.setContentProvider(IContentProvider) Clients may use mementos to persist interesting state between sessions. Clients should ensure that the memento keys are unique; generally by using the id of the content extension as a prefix. Since: 3.2 A content provider mediates between the viewer\'s model and the viewer itself. See Also: ContentViewer.setContentProvider(IContentProvider) Clients may use mementos to persist interesting state between sessions. Clients should ensure that the memento keys are unique; generally by using the id of the content extension as a prefix. Since: 3.2 A content provider mediates between the viewer\'s model and the viewer itself. See Also: ContentViewer.setContentProvider(IContentProvider) extends IContentProvider An interface to content providers for structured viewers. See Also: StructuredViewer A content provider mediates between the viewer\'s model and the viewer itself. See Also: ContentViewer.setContentProvider(IContentProvider) extends IContentProvider An interface to content providers for structured viewers. See Also: StructuredViewer extends IStructuredContentProvider An interface to content providers for tree-structure-oriented viewers. See Also: AbstractTreeViewer extends ITreeContentProvider, IMementoAware Allows extensions to vary their behavior based on properties in the extension model and the given memento. The state model should be initialized from values in the memento if necessary. Clients should refer to the org.eclipse.ui.navigator.navigatorContent extension point for more information on building a content extension. Clients may implement this interface if they require the methods defined here. ITreeContentProvider is respected by the Common Navigator. Since: 3.2 A content provider mediates between the viewer\'s model and the viewer itself. See Also: ContentViewer.setContentProvider(IContentProvider) Clients may use mementos to persist interesting state between sessions. Clients should ensure that the memento keys are unique; generally by using the id of the content extension as a prefix. Since: 3.2 A content provider mediates between the viewer\'s model and the viewer itself. See Also: ContentViewer.setContentProvider(IContentProvider) extends IContentProvider An interface to content providers for structured viewers. See Also: StructuredViewer A content provider mediates between the viewer\'s model and the viewer itself. See Also: ContentViewer.setContentProvider(IContentProvider) extends IContentProvider An interface to content providers for structured viewers. See Also: StructuredViewer extends IStructuredContentProvider An interface to content providers for tree-structure-oriented viewers. See Also: AbstractTreeViewer extends ICommonContentProvider To correctly implement pipelining you should implement IPipelinedTreeContentProvider2 which provides the additional ITreeContentProvider.hasChildren(Object) method. This allows the calculation of hasChildren to match what will be provided in calculating the children. If you don\'t implement the hasChildren, you may get \"false positive\" hasChildrens which will result in a \"+\" indication in the tree in the event that the pipelined children calculation. The only reason these are two separate interfaces is historical. Since: 3.2 A content provider mediates between the viewer\'s model and the viewer itself. See Also: ContentViewer.setContentProvider(IContentProvider) extends IContentProvider An interface to content providers for structured viewers. See Also: StructuredViewer A content provider mediates between the viewer\'s model and the viewer itself. See Also: ContentViewer.setContentProvider(IContentProvider) extends IContentProvider An interface to content providers for structured viewers. See Also: StructuredViewer extends IStructuredContentProvider An interface to content providers for tree-structure-oriented viewers. See Also: AbstractTreeViewer extends IPipelinedTreeContentProvider A pipelined content provider allows an extension to reshape the contributions of an upstream content extension. An \"upstream\" extension is either: the extension overridden by this extension using the org.eclipse.ui.navigatorContent/navigatorContent/override element, or another extension that overrides the same extension this extension overrides, but with higher priority than this extension. Overridden extensions form a tree where the nodes of the tree represent the content extensions, children represent overriding extensions, and the children are sorted by priority. Pipeline contributions traverse the tree, allowing children to override the contributions of their parent, giving precedence to the children of highest priority. ITreeContentProvider is respected by the Common Navigator. Note: this should be used instead of IPipelinedTreeContentProvider so that the hasChildren indication reflects the actual pipelined children that will be presented. Since: 3.5 See Also: INavigatorPipelineService, INavigatorContentService.getPipelineService() '
1296, 'org.eclipse.ui.ResourceWorkingSetFilter', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/ResourceWorkingSetFilter.html', 'extends ViewerFilter A resource working set filter filters resources from a view that are neither a parent nor children of a working set element. Since: 2.0 '
1297, 'org.eclipse.core.resources.IStorage', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/resources/IStorage.html', 'An interface for an adaptable object. Adaptable objects can be dynamically extended to provide different interfaces (or \"adapters\"). Adapters are created by adapter factories, which are in turn managed by type by adapter managers. For example, IAdaptable a = [some adaptable]; IFoo x = (IFoo)a.getAdapter(IFoo.class); if (x != null) [do IFoo things with x] This interface can be used without OSGi running. Clients may implement this interface, or obtain a default implementation of this interface by subclassing PlatformObject. See Also: IAdapterFactory, IAdapterManager, PlatformObject extends IAdaptable A storage object represents a set of bytes which can be accessed. These may be in the form of an IFile or IFileState or any other object supplied by user code. The main role of an IStorage is to provide a uniform API for access to, and presentation of, its content. Storage objects implement the IAdaptable interface; extensions are managed by the platform\'s adapter manager. Clients may implement this interface. '
1298, 'org.eclipse.ui.navigator.ICommonViewerMapper', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/navigator/ICommonViewerMapper.html', 'Allows improved performance by optimizing label updates of the CommonViewer. Often label updates come in the form of resource updates, and the resources themselves are not directly stored in the CommonViewer; instead other model objects are stored. In addition, it may be the case where the objects that have changed are not present in the Tree associated with the CommonViewer because they have not been opened or expanded. You can use an instance of this class to define a mapping between the current Tree Items associated with the CommonViewer and the (typically resource) objects where a change is notified. The change is notified to the CommonViewer.handleLabelProviderChanged(org.eclipse.jface.viewers.LabelProviderChangedEvent). The mapper object (implementing this interface) is associated with the CommonViewer using the CommonViewer.setMapper(ICommonViewerMapper) method. When this mapper wishes to update the CommonViewer, the CommonViewer.doUpdateItem(org.eclipse.swt.widgets.Widget) method is used. Since: 3.4 Restriction: This interface is not intended to be extended by clients. '
1299, 'org.eclipse.ui.navigator.CommonActionProvider', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/navigator/CommonActionProvider.html', 'Clients may use mementos to persist interesting state between sessions. Clients should ensure that the memento keys are unique; generally by using the id of the content extension as a prefix. Since: 3.2 extends ActionGroup implements IMementoAware Provides actions from extensions for menu and IActionBars contributions. This abstract class should be extended by clients of the org.eclipse.ui.navigator.navigatorContent extension point for top-level and nested actionProvider elements. CommonActionProviders may be declared as top-level elements in the extension point (e.g. an actionProvider element at the root of the extension point). Alternatively, actionProvider elements may be nested under a navigatorContent element, in which case they are considered to be \"associated\" with that content extension. For more information, see the org.eclipse.ui.navigator.navigatorContent extension point. Each action provider will have the opportunity to contribute to the context menu when a user right clicks and also contribute to the IActionBars each time the selection changes. Clients should re-configure the IActionBars each time that ActionGroup.fillActionBars(IActionBars) is called (which is once per selection changes). ActionGroup.updateActionBars() will never be called from the NavigatorActionService. This behavior is required since each selection could determine a different set of retargetable actions. For instance, the \"Delete\" operation for a custom model element is likely to be different than for a resource. Therefore, each extension will have an opportunity to contribute to the IActionBars based on the possibleChildren expression of the enclosing navigatorContent extension or the enablement expression of the actionProvider (for both top-level actionProviders and nested actionProviders which only support a subset of the enclosing content extensions possibleChildren expression). Clients may extend this class. Since: 3.2 '
1300, 'org.eclipse.ui.navigator.ILinkHelper', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/navigator/ILinkHelper.html', ' Provides information to the Common Navigator on how to link selections with active editors and vice versa. The Common Navigator allows clients to plug-in their own custom logic for linking selections from the Viewer to active editors. This interface is used by the org.eclipse.ui.navigator.linkHelper extension point to gather information and trigger editor activations. Since: 3.2 '
1301, 'org.eclipse.ui.navigator.resources.ResourceDragAdapterAssistant', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/navigator/resources/ResourceDragAdapterAssistant.html', 'extends CommonDragAdapterAssistant Clients may reference this class in the dragAssistant element of a org.eclipse.ui.navigator.viewer extension point. Clients may not extend or instantiate this class for any purpose other than INavigatorDnDService.bindDragAssistant(CommonDragAdapterAssistant). Clients may have no direct dependencies on the contract of this class. Since: 3.2 Restriction: This class is not intended to be subclassed by clients. '
1302, 'org.eclipse.ui.navigator.resources.ResourceDropAdapterAssistant', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/navigator/resources/ResourceDropAdapterAssistant.html', 'extends CommonDropAdapterAssistant Clients may reference this class in the dropAssistant element of a org.eclipse.ui.navigator.navigatorContent extension point. Clients may not extend or instantiate this class for any purpose. Clients may have no direct dependencies on the contract of this class. Since: 3.2 '
1303, 'org.eclipse.ui.navigator.ICommonActionExtensionSite', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/navigator/ICommonActionExtensionSite.html', 'Provides access to information required for the initialization of CommonActionProviders. See the documentation of the org.eclipse.ui.navigator.navigatorContent extension point and CommonActionProvider for more information on contributing actions. Since: 3.2 See Also: CommonActionProvider Restriction: This interface is not intended to be implemented by clients. Restriction: This interface is not intended to be extended by clients. '
1304, 'org.eclipse.ui.navigator.ICommonViewerWorkbenchSite', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/navigator/ICommonViewerWorkbenchSite.html', 'An interface for an adaptable object. Adaptable objects can be dynamically extended to provide different interfaces (or \"adapters\"). Adapters are created by adapter factories, which are in turn managed by type by adapter managers. For example, IAdaptable a = [some adaptable]; IFoo x = (IFoo)a.getAdapter(IFoo.class); if (x != null) [do IFoo things with x] This interface can be used without OSGi running. Clients may implement this interface, or obtain a default implementation of this interface by subclassing PlatformObject. See Also: IAdapterFactory, IAdapterManager, PlatformObject extends IAdaptable Provides context for extensions including a valid shell, a selection provider, and a unique identifier corresponding to the abstract viewer behind the viewer site. Since: 3.2 Restriction: This interface is not intended to be implemented by clients. Restriction: This interface is not intended to be extended by clients. extends ICommonViewerSite Provides a page, set of action bars, menu registration callback, and active window. Since: 3.2 Restriction: This interface is not intended to be implemented by clients. Restriction: This interface is not intended to be extended by clients. '
1305, 'org.eclipse.core.resources.IResourceDeltaVisitor', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/resources/IResourceDeltaVisitor.html', 'An objects that visits resource deltas. Usage: class Visitor implements IResourceDeltaVisitor { public boolean visit(IResourceDelta delta) { switch (delta.getKind()) { case IResourceDelta.ADDED : // handle added resource break; case IResourceDelta.REMOVED : // handle removed resource break; case IResourceDelta.CHANGED : // handle changed resource break; } return true; } } IResourceDelta rootDelta = ...; rootDelta.accept(new Visitor()); Clients may implement this interface. See Also: IResource.accept(IResourceVisitor) '
1306, 'org.eclipse.core.databinding.Binding', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/databinding/Binding.html', 'extends ValidationStatusProvider This abstract class represents a binding between a model and a target. Newly created instances need to be added to a data binding context using init(DataBindingContext). Since: 1.0 '
1307, 'org.eclipse.core.databinding.observable.value.ValueDiff', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/databinding/observable/value/ValueDiff.html', 'extends Object implements IDiff Since: 1.0 '
1308, 'org.eclipse.core.databinding.validation.IValidator', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/databinding/validation/IValidator.html', 'A validator. This validator is responsible for determining if a given value is valid. Validators can be used on target or model values. For example, a String2IntValidator would only accept source Strings that can successfully be converted to an integer value, and a PositiveIntegerValidator would only accept positive integers. Since: 1.0 '
1309, 'org.eclipse.core.databinding.conversion.Converter', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/databinding/conversion/Converter.html', 'A one-way converter. Since: 1.0 Restriction: This interface is not intended to be implemented by clients. Clients should subclass Converter. Restriction: This interface is not intended to be extended by clients. extends Object implements IConverter Abstract base class for converters. Since: 1.0 '
1310, 'org.eclipse.core.databinding.observable.list.ListDiffVisitor', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/databinding/observable/list/ListDiffVisitor.html', 'extends Object A visitor for processing differences in a ListDiff. Since: 1.1 See Also: ListDiff.accept(ListDiffVisitor) '
1311, 'org.eclipse.core.databinding.observable.set.WritableSet', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/databinding/observable/set/WritableSet.html', 'An object with state that allows to listen for state changes. Implementations must not manage listeners themselves, listener management must be delegated to a private instance of type ChangeSupport if it is not inherited from AbstractObservable. Since: 1.0 Restriction: This interface is not intended to be implemented by clients. Clients should instead subclass one of the classes in the framework that implement this interface. Note that direct implementers of this interface outside of the framework will be broken in future releases when methods are added to this interface. An object with state that allows to listen for state changes. Implementations must not manage listeners themselves, listener management must be delegated to a private instance of type ChangeSupport if it is not inherited from AbstractObservable. Since: 1.0 Restriction: This interface is not intended to be implemented by clients. Clients should instead subclass one of the classes in the framework that implement this interface. Note that direct implementers of this interface outside of the framework will be broken in future releases when methods are added to this interface. extends IObservable, Collection Interface for observable collections. Only general change listeners can be added to an observable collection. Listeners interested in incremental changes have to be added using more concrete subtypes such as IObservableList or IObservableSet. Since: 1.0 Restriction: This interface is not intended to be implemented by clients. Clients should instead subclass one of the classes that implement this interface. Note that direct implementers of this interface outside of the framework will be broken in future releases when methods are added to this interface. Restriction: This interface is not intended to be extended by clients. An object with state that allows to listen for state changes. Implementations must not manage listeners themselves, listener management must be delegated to a private instance of type ChangeSupport if it is not inherited from AbstractObservable. Since: 1.0 Restriction: This interface is not intended to be implemented by clients. Clients should instead subclass one of the classes in the framework that implement this interface. Note that direct implementers of this interface outside of the framework will be broken in future releases when methods are added to this interface. extends IObservable, Collection Interface for observable collections. Only general change listeners can be added to an observable collection. Listeners interested in incremental changes have to be added using more concrete subtypes such as IObservableList or IObservableSet. Since: 1.0 Restriction: This interface is not intended to be implemented by clients. Clients should instead subclass one of the classes that implement this interface. Note that direct implementers of this interface outside of the framework will be broken in future releases when methods are added to this interface. Restriction: This interface is not intended to be extended by clients. extends Set, IObservableCollection A set whose changes can be tracked by set change listeners. Since: 1.0 See Also: AbstractObservableSet, ObservableSet Restriction: This interface is not intended to be implemented by clients. Clients should instead subclass one of the classes that implement this interface. Note that direct implementers of this interface outside of the framework will be broken in future releases when methods are added to this interface. extends ObservableSet Mutable (writable) implementation of IObservableSet. This class is thread safe. All state accessing methods must be invoked from the current realm. Methods for adding and removing listeners may be invoked from any thread. Since: 1.0 '
1312, 'org.eclipse.core.databinding.observable.map.BidiObservableMap', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/databinding/observable/map/BidiObservableMap.html', 'An object with state that allows to listen for state changes. Implementations must not manage listeners themselves, listener management must be delegated to a private instance of type ChangeSupport if it is not inherited from AbstractObservable. Since: 1.0 Restriction: This interface is not intended to be implemented by clients. Clients should instead subclass one of the classes in the framework that implement this interface. Note that direct implementers of this interface outside of the framework will be broken in future releases when methods are added to this interface. extends IObservable Interface for observables which decorate other observables. Since: 1.2 Restriction: This interface is not intended to be implemented by clients. Clients should instead subclass one of the classes in the framework that implement this interface. Note that direct implementers of this interface outside of the framework will be broken in future releases when methods are added to this interface. An object with state that allows to listen for state changes. Implementations must not manage listeners themselves, listener management must be delegated to a private instance of type ChangeSupport if it is not inherited from AbstractObservable. Since: 1.0 Restriction: This interface is not intended to be implemented by clients. Clients should instead subclass one of the classes in the framework that implement this interface. Note that direct implementers of this interface outside of the framework will be broken in future releases when methods are added to this interface. An object with state that allows to listen for state changes. Implementations must not manage listeners themselves, listener management must be delegated to a private instance of type ChangeSupport if it is not inherited from AbstractObservable. Since: 1.0 Restriction: This interface is not intended to be implemented by clients. Clients should instead subclass one of the classes in the framework that implement this interface. Note that direct implementers of this interface outside of the framework will be broken in future releases when methods are added to this interface. extends Map, IObservable Observable Map. Since: 1.1 See Also: AbstractObservableMap, ObservableMap Restriction: This interface is not intended to be implemented by clients. Clients should instead subclass one of the classes that implement this interface. Note that direct implementers of this interface outside of the framework will be broken in future releases when methods are added to this interface. extends DecoratingObservableMap An This class is thread safe. All state accessing methods must be invoked from the current realm. Methods for adding and removing listeners may be invoked from any thread. Since: 1.2 '
1313, 'org.eclipse.core.databinding.observable.map.WritableMap', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/databinding/observable/map/WritableMap.html', 'An object with state that allows to listen for state changes. Implementations must not manage listeners themselves, listener management must be delegated to a private instance of type ChangeSupport if it is not inherited from AbstractObservable. Since: 1.0 Restriction: This interface is not intended to be implemented by clients. Clients should instead subclass one of the classes in the framework that implement this interface. Note that direct implementers of this interface outside of the framework will be broken in future releases when methods are added to this interface. An object with state that allows to listen for state changes. Implementations must not manage listeners themselves, listener management must be delegated to a private instance of type ChangeSupport if it is not inherited from AbstractObservable. Since: 1.0 Restriction: This interface is not intended to be implemented by clients. Clients should instead subclass one of the classes in the framework that implement this interface. Note that direct implementers of this interface outside of the framework will be broken in future releases when methods are added to this interface. extends Map, IObservable Observable Map. Since: 1.1 See Also: AbstractObservableMap, ObservableMap Restriction: This interface is not intended to be implemented by clients. Clients should instead subclass one of the classes that implement this interface. Note that direct implementers of this interface outside of the framework will be broken in future releases when methods are added to this interface. extends ObservableMap This class is thread safe. All state accessing methods must be invoked from the current realm. Methods for adding and removing listeners may be invoked from any thread. Since: 1.0 '
1314, 'org.eclipse.core.databinding.observable.map.BidirectionalMap', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/databinding/observable/map/BidirectionalMap.html', 'An object with state that allows to listen for state changes. Implementations must not manage listeners themselves, listener management must be delegated to a private instance of type ChangeSupport if it is not inherited from AbstractObservable. Since: 1.0 Restriction: This interface is not intended to be implemented by clients. Clients should instead subclass one of the classes in the framework that implement this interface. Note that direct implementers of this interface outside of the framework will be broken in future releases when methods are added to this interface. extends ObservableMap This class is thread safe. All state accessing methods must be invoked from the current realm. Methods for adding and removing listeners may be invoked from any thread. Since: 1.0 '
1315, 'org.eclipse.core.databinding.observable.map.CompositeMap', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/databinding/observable/map/CompositeMap.html', 'An object with state that allows to listen for state changes. Implementations must not manage listeners themselves, listener management must be delegated to a private instance of type ChangeSupport if it is not inherited from AbstractObservable. Since: 1.0 Restriction: This interface is not intended to be implemented by clients. Clients should instead subclass one of the classes in the framework that implement this interface. Note that direct implementers of this interface outside of the framework will be broken in future releases when methods are added to this interface. An object with state that allows to listen for state changes. Implementations must not manage listeners themselves, listener management must be delegated to a private instance of type ChangeSupport if it is not inherited from AbstractObservable. Since: 1.0 Restriction: This interface is not intended to be implemented by clients. Clients should instead subclass one of the classes in the framework that implement this interface. Note that direct implementers of this interface outside of the framework will be broken in future releases when methods are added to this interface. extends Map, IObservable Observable Map. Since: 1.1 See Also: AbstractObservableMap, ObservableMap Restriction: This interface is not intended to be implemented by clients. Clients should instead subclass one of the classes that implement this interface. Note that direct implementers of this interface outside of the framework will be broken in future releases when methods are added to this interface. extends ObservableMap A read-only observable map formed by the composition of two observable maps. If map1 maps keys a:A to values b1:B, and map2 maps keys b2:B to values c:C, the composite map maps keys a:A to values c:C. For example, map1 could map Order objects to their corresponding Customer objects, and map2 could map Customer objects to their \"last name\" property of type String. The composite map of map1 and map2 would then map Order objects to their customers\' last names. This class is thread safe. All state accessing methods must be invoked from the current realm. Methods for adding and removing listeners may be invoked from any thread. Since: 1.1 '
1316, 'org.eclipse.core.databinding.observable.AbstractObservable', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/databinding/observable/AbstractObservable.html', 'An object with state that allows to listen for state changes. Implementations must not manage listeners themselves, listener management must be delegated to a private instance of type ChangeSupport if it is not inherited from AbstractObservable. Since: 1.0 Restriction: This interface is not intended to be implemented by clients. Clients should instead subclass one of the classes in the framework that implement this interface. Note that direct implementers of this interface outside of the framework will be broken in future releases when methods are added to this interface. extends Object implements IObservable Since: 1.0 '
1317, 'org.eclipse.core.databinding.util.ILogger', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/databinding/util/ILogger.html', 'A mechanism to log errors throughout JFace Data Binding. Clients may provide their own implementation to change how errors are logged from within JFace Data Binding. Since: 1.1 See Also: Policy.getLog(), Policy.setLog(ILogger) '
1318, 'org.eclipse.core.databinding.observable.value.DuplexingObservableValue', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/databinding/observable/value/DuplexingObservableValue.html', 'An object with state that allows to listen for state changes. Implementations must not manage listeners themselves, listener management must be delegated to a private instance of type ChangeSupport if it is not inherited from AbstractObservable. Since: 1.0 Restriction: This interface is not intended to be implemented by clients. Clients should instead subclass one of the classes in the framework that implement this interface. Note that direct implementers of this interface outside of the framework will be broken in future releases when methods are added to this interface. An object with state that allows to listen for state changes. Implementations must not manage listeners themselves, listener management must be delegated to a private instance of type ChangeSupport if it is not inherited from AbstractObservable. Since: 1.0 Restriction: This interface is not intended to be implemented by clients. Clients should instead subclass one of the classes in the framework that implement this interface. Note that direct implementers of this interface outside of the framework will be broken in future releases when methods are added to this interface. extends IObservable A value whose changes can be tracked by value change listeners. Since: 1.0 See Also: AbstractObservableValue Restriction: This interface is not intended to be implemented by clients. Clients should instead subclass one of the classes that implement this interface. Note that direct implementers of this interface outside of the framework will be broken in future releases when methods are added to this interface. extends AbstractObservableValue Since: 1.2 '
1319, 'org.eclipse.core.databinding.observable.value.DateAndTimeObservableValue', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/databinding/observable/value/DateAndTimeObservableValue.html', 'An object with state that allows to listen for state changes. Implementations must not manage listeners themselves, listener management must be delegated to a private instance of type ChangeSupport if it is not inherited from AbstractObservable. Since: 1.0 Restriction: This interface is not intended to be implemented by clients. Clients should instead subclass one of the classes in the framework that implement this interface. Note that direct implementers of this interface outside of the framework will be broken in future releases when methods are added to this interface. extends IObservable A value whose changes can be tracked by value change listeners. Since: 1.0 See Also: AbstractObservableValue Restriction: This interface is not intended to be implemented by clients. Clients should instead subclass one of the classes that implement this interface. Note that direct implementers of this interface outside of the framework will be broken in future releases when methods are added to this interface. extends AbstractObservableValue An IObservableValue < Date > which supports scenarios where the date and time are presented as separate elements in the user interface. This class combines the year, month, and day portion of the date observable (an IObservableValue < Date >) and the hour, minute, second, and millisecond portion of the time observable (also an IObservableValue < Date >). This observable\'s value will be null whenever the date observable\'s value is null. Otherwise the value is the combination of the date portion of the date observable and the time portion of the time observable (a time observable value of null is treated the same as 0:00:00.000). When setting the value of this observable, setting a null value will set null on the date observable, and set a time of 0:00:00.000 on the time observable. When setting non-null values, the non-applicable fields of each observable are left intact. That is, the hour, minute, second and millisecond components of the date observable are preserved, and the year, month and day components of the time observable are preserved. The observables used for the date and time component may impose their own restrictions with regard to supported values. For example some observables do not allow a null value, because the underlying widget lacks support for a null value (example: DateTime). One use for this class is binding a date-and-time value to two separate user interface elements, one for editing date and one for editing time: DataBindingContext dbc = new DataBindingContext(); IObservableValue beanValue = BeansObservables.observeValue(...); IObservableValue dateObservable = WidgetProperties.selection().observe( dateWidget); IObservableValue timeObservable = WidgetProperties.selection().observe( timeWidget); dbc.bindValue(new DateAndTimeObservableValue(dateObservable, timeObservable), beanValue); A second use is editing only the date or time value of a date-and-time value. This can be accomplished by using a widget-specific observable for the editable value and a WritableValue as a container for the fixed value. The example below allows editing the date while preserving the time: DataBindingContext dbc = new DataBindingContext(); IObservableValue beanValue = BeansObservables.observeValue(...); IObservableValue dateObservable = WidgetProperties.selection().observe( dateWidget); IObservableValue timeObservable = new WritableValue(dateObservable.getRealm(), beanValue.getValue(), Date.class); dbc.bindValue(new DateAndTimeObservableValue(dateObservable, timeObservable), beanValue); Since: 1.2 '
1320, 'org.eclipse.core.runtime.jobs.ILock', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/runtime/jobs/ILock.html', 'A lock is used to control access to an exclusive resource. Locks are reentrant. That is, they can be acquired multiple times by the same thread without releasing. Locks are only released when the number of successful acquires equals the number of successful releases. Locks are capable of detecting and recovering from programming errors that cause circular waiting deadlocks. When a deadlock between two or more ILock instances is detected, detailed debugging information is printed to the log file. The locks will then automatically recover from the deadlock by employing a release and wait strategy. One thread will lose control of the locks it owns, thus breaking the deadlock and allowing other threads to proceed. Once that thread\'s locks are all available, it will be given exclusive access to all its locks and allowed to proceed. A thread can only lose locks while it is waiting on an acquire() call. Successive acquire attempts by different threads are queued and serviced on a first come, first served basis. It is very important that acquired locks eventually get released. Calls to release should be done in a finally block to ensure they execute. For example: try { lock.acquire(); // ... do work here ... } finally { lock.release(); } Note: although lock.acquire should never fail, it is good practice to place it inside the try block anyway. Releasing without acquiring is far less catastrophic than acquiring without releasing. Since: 3.0 See Also: IJobManager.newLock() Restriction: This interface is not intended to be implemented by clients. Restriction: This interface is not intended to be extended by clients. '
1321, 'org.eclipse.core.databinding.ObservablesManager', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/databinding/ObservablesManager.html', 'extends Object An observables manager can be used for lifecycle management of IObservable objects. Since: 1.0 Restriction: This class is not intended to be subclassed by clients. '
1322, 'org.eclipse.core.databinding.conversion.StringToNumberConverter', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/databinding/conversion/StringToNumberConverter.html', 'A one-way converter. Since: 1.0 Restriction: This interface is not intended to be implemented by clients. Clients should subclass Converter. Restriction: This interface is not intended to be extended by clients. extends org.eclipse.core.internal.databinding.validation.NumberFormatConverter Converts a String to a Number using NumberFormat.parse(...). This class is thread safe. Since: 1.0 '
1323, 'org.eclipse.core.databinding.conversion.NumberToStringConverter', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/databinding/conversion/NumberToStringConverter.html', 'A one-way converter. Since: 1.0 Restriction: This interface is not intended to be implemented by clients. Clients should subclass Converter. Restriction: This interface is not intended to be extended by clients. extends Converter Converts a Number to a String using NumberFormat.format(...). This class is thread safe. Since: 1.0 '
1324, 'org.eclipse.core.databinding.beans.IBeanObservable', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/databinding/beans/IBeanObservable.html', 'Mixin interface for IObservables that observe other objects. Since: 1.0 extends IObserving Provides access to details of bean observables. This interface is not meant to be implemented by clients. Since: 3.3 '
1325, 'org.eclipse.core.databinding.beans.BeanProperties', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/databinding/beans/BeanProperties.html', 'extends Object A factory for creating properties for Java objects that conform to the JavaBean specification for bound properties. Since: 1.2 '
1326, 'org.eclipse.core.databinding.beans.PojoProperties', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/databinding/beans/PojoProperties.html', 'extends Object A factory for creating properties for POJOs (plain old java objects) that conform to idea of an object with getters and setters but does not provide property change events on change. This factory is identical to BeanProperties except for this fact. Since: 1.2 '
1327, 'org.eclipse.core.databinding.AggregateValidationStatus', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/databinding/AggregateValidationStatus.html', 'An object with state that allows to listen for state changes. Implementations must not manage listeners themselves, listener management must be delegated to a private instance of type ChangeSupport if it is not inherited from AbstractObservable. Since: 1.0 Restriction: This interface is not intended to be implemented by clients. Clients should instead subclass one of the classes in the framework that implement this interface. Note that direct implementers of this interface outside of the framework will be broken in future releases when methods are added to this interface. An object with state that allows to listen for state changes. Implementations must not manage listeners themselves, listener management must be delegated to a private instance of type ChangeSupport if it is not inherited from AbstractObservable. Since: 1.0 Restriction: This interface is not intended to be implemented by clients. Clients should instead subclass one of the classes in the framework that implement this interface. Note that direct implementers of this interface outside of the framework will be broken in future releases when methods are added to this interface. extends IObservable A value whose changes can be tracked by value change listeners. Since: 1.0 See Also: AbstractObservableValue Restriction: This interface is not intended to be implemented by clients. Clients should instead subclass one of the classes that implement this interface. Note that direct implementers of this interface outside of the framework will be broken in future releases when methods are added to this interface. extends ComputedValue This class can be used to aggregate status values from a data binding context into a single status value. Instances of this class can be used as an observable value with a value type of IStatus, or the static methods can be called directly if an aggregated status result is only needed once. Since: 1.0 '
1328, 'org.eclipse.core.databinding.UpdateListStrategy', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/databinding/UpdateListStrategy.html', 'extends Object Customizes a Binding between two observable lists. The following behaviors can be customized via the strategy: Conversion Automatic processing Conversion: When elements are added they can be converted to the destination element type. Automatic processing: The processing to perform when the source observable changes. This behavior is configured via policies provided on construction of the strategy (e.g. POLICY_NEVER, POLICY_ON_REQUEST, POLICY_UPDATE). Since: 1.0 See Also: DataBindingContext.bindList(IObservableList, IObservableList, UpdateListStrategy, UpdateListStrategy), IConverter '
1329, 'org.eclipse.core.databinding.beans.IBeanProperty', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/databinding/beans/IBeanProperty.html', 'extends IProperty An IProperty extension interface providing access to details of bean properties. Since: 1.2 Restriction: This interface is not intended to be implemented by clients. Restriction: This interface is not intended to be extended by clients. '
1330, 'org.eclipse.core.databinding.BindingProperties', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/databinding/BindingProperties.html', 'extends Object A factory for creating properties for core types in the DataBinding framework e.g. DataBindingContext or ValidationStatusProvider. Since: 1.2 '
1331, 'org.eclipse.jface.databinding.viewers.ViewerSupport', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/databinding/viewers/ViewerSupport.html', 'extends Object Helper methods for binding observables to a StructuredViewer or AbstractTableViewer. Since: 1.3 '
1332, 'org.eclipse.jface.databinding.viewers.ObservableListTreeContentProvider', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/databinding/viewers/ObservableListTreeContentProvider.html', 'A content provider mediates between the viewer\'s model and the viewer itself. See Also: ContentViewer.setContentProvider(IContentProvider) A content provider mediates between the viewer\'s model and the viewer itself. See Also: ContentViewer.setContentProvider(IContentProvider) extends IContentProvider An interface to content providers for structured viewers. See Also: StructuredViewer A content provider mediates between the viewer\'s model and the viewer itself. See Also: ContentViewer.setContentProvider(IContentProvider) extends IContentProvider An interface to content providers for structured viewers. See Also: StructuredViewer extends IStructuredContentProvider An interface to content providers for tree-structure-oriented viewers. See Also: AbstractTreeViewer extends Object implements ITreeContentProvider An ITreeContentProvider for use with an AbstractTreeViewer, which uses the provided list factory to obtain the elements of a tree. Object of this class listen for changes to each IObservableList created by the factory, and will insert and remove viewer elements to reflect the observed changes. Since: 1.2 Restriction: This class is not intended to be subclassed by clients. '
1333, 'org.eclipse.jface.databinding.viewers.IViewerObservableValue', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/databinding/viewers/IViewerObservableValue.html', 'An object with state that allows to listen for state changes. Implementations must not manage listeners themselves, listener management must be delegated to a private instance of type ChangeSupport if it is not inherited from AbstractObservable. Since: 1.0 Restriction: This interface is not intended to be implemented by clients. Clients should instead subclass one of the classes in the framework that implement this interface. Note that direct implementers of this interface outside of the framework will be broken in future releases when methods are added to this interface. An object with state that allows to listen for state changes. Implementations must not manage listeners themselves, listener management must be delegated to a private instance of type ChangeSupport if it is not inherited from AbstractObservable. Since: 1.0 Restriction: This interface is not intended to be implemented by clients. Clients should instead subclass one of the classes in the framework that implement this interface. Note that direct implementers of this interface outside of the framework will be broken in future releases when methods are added to this interface. extends IObservable A value whose changes can be tracked by value change listeners. Since: 1.0 See Also: AbstractObservableValue Restriction: This interface is not intended to be implemented by clients. Clients should instead subclass one of the classes that implement this interface. Note that direct implementers of this interface outside of the framework will be broken in future releases when methods are added to this interface. extends IObservable IObservable observing a JFace Viewer. Since: 1.2 extends IObservableValue, IViewerObservable IObservableValue observing a JFace Viewer. Since: 1.2 '
1334, 'org.eclipse.jface.databinding.viewers.ViewersObservables', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/databinding/viewers/ViewersObservables.html', 'extends Object Factory methods for creating observables for JFace viewers Since: 1.1 '
1335, 'org.eclipse.jface.databinding.viewers.ObservableSetTreeContentProvider', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/databinding/viewers/ObservableSetTreeContentProvider.html', 'A content provider mediates between the viewer\'s model and the viewer itself. See Also: ContentViewer.setContentProvider(IContentProvider) A content provider mediates between the viewer\'s model and the viewer itself. See Also: ContentViewer.setContentProvider(IContentProvider) extends IContentProvider An interface to content providers for structured viewers. See Also: StructuredViewer A content provider mediates between the viewer\'s model and the viewer itself. See Also: ContentViewer.setContentProvider(IContentProvider) extends IContentProvider An interface to content providers for structured viewers. See Also: StructuredViewer extends IStructuredContentProvider An interface to content providers for tree-structure-oriented viewers. See Also: AbstractTreeViewer extends Object implements ITreeContentProvider An ITreeContentProvider for use with an AbstractTreeViewer, which uses the provided set factory to obtain the elements of a tree. Objects of this class listen for changes to each IObservableSet created by the factory, and will insert and remove viewer elements to reflect the observed changes. Since: 1.2 Restriction: This class is not intended to be subclassed by clients. '
1336, 'org.eclipse.jface.databinding.viewers.ObservableSetContentProvider', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/databinding/viewers/ObservableSetContentProvider.html', 'A content provider mediates between the viewer\'s model and the viewer itself. See Also: ContentViewer.setContentProvider(IContentProvider) A content provider mediates between the viewer\'s model and the viewer itself. See Also: ContentViewer.setContentProvider(IContentProvider) extends IContentProvider An interface to content providers for structured viewers. See Also: StructuredViewer extends Object implements IStructuredContentProvider A content provider for AbstractTableViewer or AbstractListViewer that provides elements of an IObservableSet when set as the viewer\'s input. Objects of this class listen for changes to the observable set, and will insert and remove viewer elements to reflect observed changes. Since: 1.1 Restriction: This class is not intended to be subclassed by clients. '
1337, 'org.eclipse.jface.databinding.wizard.WizardPageSupport', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/databinding/wizard/WizardPageSupport.html', 'extends DialogPageSupport Connects the validation result from the given data binding context to the given wizard page, updating the wizard page\'s completion state and its error message accordingly. The completion state of the wizard page will only be set to true if all of the following conditions are met: The validation result from the data binding context has none of the severities IStatus.ERROR or IStatus.CANCEL. None of the validation status observables of the data binding context is stale. Since: 1.1 Restriction: This class is not intended to be subclassed by clients. '
1338, 'org.eclipse.jface.text.TextViewer', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/text/TextViewer.html', 'A registry for IEditingSupports. This interface is not meant to be implemented outside the JFace text framework. Since: 3.1 See Also: IEditingSupport Restriction: This interface is not intended to be implemented by clients. Restriction: This interface is not intended to be extended by clients. Defines the target for text operations. canDoOperation informs the clients about the ability of the target to perform the specified operation at the current point in time. doOperation executes the specified operation. In order to provide backward compatibility for clients of ITextOperationTarget, extension interfaces are used as a means of evolution. The following extension interfaces exist: ITextOperationTargetExtension since version 2.0 introducing text operation enabling/disabling. See Also: ITextOperationTargetExtension Extension interface for ITextOperationTarget. Allows a client to control the enable state of operations provided by this target. Since: 2.0 See Also: ITextOperationTarget A text viewer connects a text widget with an IDocument. The document is used as the widget\'s text model. It supports the following kinds of listeners: view port listeners to inform about changes of the viewer\'s view port text listeners to inform about changes of the document and the subsequent viewer change text input listeners to inform about changes of the viewer\'s input document. A text viewer supports a set of configuration options and plug-ins defining its behavior: undo manager double click behavior auto indentation text hover Installed plug-ins are not automatically activated. Plug-ins must be activated with the activatePlugins call. Most plug-ins can be defined per content type. Content types are derived from a partitioning of the text viewer\'s input document. In case of documents that support multiple partitionings, the implementer is responsible for determining the partitioning to use. A text viewer also provides the concept of event consumption. Events handled by the viewer can be filtered and processed by a dynamic event consumer. With ITextViewerExtension, this mechanism has been replaced with the support for VerifyKeyListener. A text viewer provides several text editing functions, some of them are configurable, through a text operation target interface. It also supports a presentation mode in which it only shows a specified section of its document. By calling setVisibleRegion clients define which section is visible. Clients can get access to this section by calling getVisibleRegion. The viewer\'s presentation mode does not affect any client of the viewer other than text listeners. With ITextViewerExtension5 the visible region support has been reworked. With that extension interface, text viewers are allowed to show fractions of their input document. I.e. a widget selection of two visually neighboring characters is no longer guaranteed to be two neighboring characters in the viewer\'s input document. Thus, viewers implementing ITextViewerExtension5 are potentially forced to change the fractions of the input document that are shown when clients ask for the visible region. In order to provide backward compatibility for clients of ITextViewer, extension interfaces are used as a means of evolution. The following extension interfaces exist: ITextViewerExtension since version 2.0 replacing the event consumer mechanism and introducing the concept of rewrite targets and means to manage the viewer\'s redraw behavior ITextViewerExtension2since version 2.1 adding a way to invalidate a viewer\'s presentation and setters for hovers. ITextViewerExtension3 since version 2.1 which itself was replaced by ITextViewerExtension5 in version 3.0 ITextViewerExtension4 since version 3.0 introducing focus handling for widget token keepers and the concept of text presentation listeners. ITextViewerExtension5 since version 3.0 extending the visible region concept with explicit handling and conversion of widget and model coordinates. ITextViewerExtension6 since version 3.1 extending the text viewer with the ability to detect hyperlinks and access the undo manager. ITextViewerExtension7 since version 3.3 extending the text viewer with the ability to install tabs to spaces conversion. ITextViewerExtension8 since version 3.4 extending the text viewer with the ability to print and rich hover support. Clients may implement this interface and its extension interfaces or use the standard implementation TextViewer. See Also: ITextViewerExtension, ITextViewerExtension2, ITextViewerExtension3, ITextViewerExtension4, ITextViewerExtension5, ITextViewerExtension6, ITextViewerExtension7, ITextViewerExtension8, IDocument, ITextInputListener, IViewportListener, ITextListener, IEventConsumer Extension interface for ITextViewer. This extension interface replaces the event consumer mechanism ( ITextViewer.setEventConsumer(IEventConsumer)) with a set of methods that allow to manage a sequence of VerifyKeyListenerobjects. It also adds access to the control of this viewer marked region support as in emacs control of the viewer\'s redraw behavior by introducing setRedraw(boolean) access to the viewer\'s rewrite target. A rewrite target (IRewriteTarget) represents an facade offering the necessary methods to manipulate a document that is the input document of a text viewer. Since: 2.0 Extension interface for ITextViewer. It provides text presentation invalidation enhancements text hover management enhancements a replacement for auto indent strategies support for custom painters It extends the means for text presentation invalidation by allowing a specific region of the presentation to get invalidated. It replaces ITextViewer.setTextHover(ITextHover, String) with a new method that allows to specify state masks for a better control of the hover behavior. An IAutoEditStrategy is a generalization of the original IAutoIndentStrategy. Auto edit strategies can be arranged in a list that is executed like a pipeline when the viewer content is changed. A IPainteris creating and managing visual decorations on the viewer\'s text widget. Viewer\'s can have an open number of painters. Painters are informed about changes to the viewer content and state and can take the necessary action in responds to the notification. Since: 2.1 Extension interface for ITextViewer. Introduces the concept of text presentation listeners and improves focus handling among widget token keepers. A ITextPresentationListeneris a listener that is informed by the viewer that a text presentation is about to be applied. During this callback the listener is allowed to modify the presentation. Text presentation listeners are thus a mean to participate in the process of text presentation creation. Since: 3.0 Extension interface for ITextViewer. Introduces the concept of text hyperlinks and adds access to the undo manager. Since: 3.1 See Also: IHyperlink, IHyperlinkDetector Extension interface for ITextViewer. Adds the ability to install tabs to spaces conversion. Since: 3.3 Extension interface for ITextViewer. Adds the ability to print and set how hovers should be enriched when the mouse is moved into them. Since: 3.4 In order to display information in a temporary window, a widget token must be acquired. The intent behind this concept is that only one temporary window should be presented at any moment in time and also to avoid overlapping temporary windows. This concept is used by the ITextViewer. In order to provide backward compatibility for clients of IWidgetTokenOwner, extension interfaces are used as a means of evolution. The following extension interfaces exist: IWidgetTokenOwnerExtension since version 3.0 introducing priorities when requesting a widget token and thus replacing the non-prioritized scheme. Since: 2.0 See Also: IWidgetTokenOwnerExtension Extension interface for IWidgetTokenOwner. Replaces the original requestWidgetToken functionality with a new priority based approach. Since: 3.0 Interface common to all objects that provide an input. Interface common to all objects that provide an input. Interface common to all objects that provide a selection. See Also: ISelection, ISelectionChangedListener, SelectionChangedEvent extends IInputProvider, ISelectionProvider Interface common to all objects that provide both an input and a selection. Interface common to all objects that provide a selection. See Also: ISelection, ISelectionChangedListener, SelectionChangedEvent extends ISelectionProvider Selection provider extension interface to allow providers to notify about post selection changed events. A post selection changed event is equivalent to selection changed event if the selection change was triggered by the mouse, but it has a delay if the selection change is triggered by keyboard navigation. Since: 3.0 See Also: ISelectionProvider Interface common to all objects that provide a selection. See Also: ISelection, ISelectionChangedListener, SelectionChangedEvent extends Viewer implements ITextViewer, ITextViewerExtension, ITextViewerExtension2, ITextViewerExtension4, ITextViewerExtension6, ITextViewerExtension7, ITextViewerExtension8, IEditingSupportRegistry, ITextOperationTarget, ITextOperationTargetExtension, IWidgetTokenOwner, IWidgetTokenOwnerExtension, IPostSelectionProvider SWT based implementation of ITextViewer and its extension interfaces. Once the viewer and its SWT control have been created the viewer can only indirectly be disposed by disposing its SWT control. Clients are supposed to instantiate a text viewer and subsequently to communicate with it exclusively using the ITextViewer interface or any of the implemented extension interfaces. A text viewer serves as text operation target. It only partially supports the external control of the enable state of its text operations. A text viewer is also a widget token owner. Anything that wants to display an overlay window on top of a text viewer should implement the IWidgetTokenKeeper interface and participate in the widget token negotiation between the text viewer and all its potential widget token keepers. This class is not intended to be subclassed outside the JFace Text component. Restriction: This class is not intended to be subclassed by clients. '
1339, 'org.eclipse.jface.text.Document', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/text/Document.html', 'An IDocument represents text providing support for text manipulation positions partitions line information document change listeners document partition change listeners A document allows to set its content and to manipulate it. For manipulation a document provides the replace method which substitutes a given string for a specified text range in the document. On each document change, all registered document listeners are informed exactly once. Positions are stickers to the document\'s text that are updated when the document is changed. Positions are updated by IPositionUpdaters. Position updaters are managed as a list. The list defines the sequence in which position updaters are invoked. This way, position updaters may rely on each other. Positions are grouped into categories. A category is a ordered list of positions. the document defines the order of position in a category based on the position\'s offset based on the implementation of the method computeIndexInCategory. Each document must support a default position category whose name is specified by this interface. A document can be considered consisting of a sequence of not overlapping partitions. A partition is defined by its offset, its length, and its type. Partitions are updated on every document manipulation and ensured to be up-to-date when the document listeners are informed. A document uses an IDocumentPartitioner to manage its partitions. A document may be unpartitioned which happens when there is no partitioner. In this case, the document is considered as one single partition of a default type. The default type is specified by this interface. If a document change changes the document\'s partitioning all registered partitioning listeners are informed exactly once. The extension interface IDocumentExtension3 introduced in version 3.0 extends the concept of partitions and allows a document to not only manage one but multiple partitioning. Each partitioning has an id which must be used to refer to a particular partitioning. An IDocument provides methods to map line numbers and character positions onto each other based on the document\'s line delimiters. When moving text between documents using different line delimiters, the text must be converted to use the target document\'s line delimiters. An IDocument does not care about mixed line delimiters. Clients who want to ensure a single line delimiter in their document should use the line delimiter returned by TextUtilities.getDefaultLineDelimiter(IDocument). IDocument throws BadLocationException if the parameters of queries or manipulation requests are not inside the bounds of the document. The purpose of this style of exception handling is prepare document for multi-thread access allow clients to implement backtracking recovery methods prevent clients from up-front contract checking when dealing with documents. A document support for searching has deprecated since version 3.0. The recommended way for searching is to use a FindReplaceDocumentAdapter. In order to provide backward compatibility for clients of IDocument, extension interfaces are used to provide a means of evolution. The following extension interfaces exist: IDocumentExtension since version 2.0 introducing the concept of post notification replaces in order to allow document listeners to manipulate the document while receiving a document change notification IDocumentExtension2 since version 2.1 introducing configuration methods for post notification replaces and document change notification. IDocumentExtension3 since version 3.0 replacing the original partitioning concept by allowing multiple partitionings at the same time and introducing zero- length partitions in conjunction with the distinction between open and closed partitions. IDocumentExtension4 since version 3.1 introducing the concept of rewrite sessions. A rewrite session is a sequence of document replace operations that form a semantic unit. It also introduces a modification stamp and the ability to set the initial line delimiter and to query the default line delimiter. Clients may implement this interface and its extension interfaces or use the default implementation provided by AbstractDocument and Document. See Also: IDocumentExtension, IDocumentExtension2, IDocumentExtension3, IDocumentExtension4, Position, IPositionUpdater, IDocumentPartitioner, ILineTracker, IDocumentListener, IDocumentPartitioningListener Extension interface for IDocument. It introduces the notion of sequentially rewriting a document. This is to tell a document that a sequence of non-overlapping replace operation is about to be performed. Implementers can use this knowledge for internal optimization. Is also introduces the concept of post notification replaces. This is, a document listener who is informed about a document change can cause a derived document change. As the listener is not allowed to directly modify the document, it can register a replace operation that is performed directly after all document listeners have been notified. Since: 2.0 Extension interface for IDocument. It adds configuration methods to post notification replaces and document listener notification. Since: 2.1 Extension interface for IDocument. Adds the concept of multiple partitionings and the concept of zero-length partitions in conjunction with open and delimited partitions. A delimited partition has a well defined start delimiter and a well defined end delimiter. Between two delimited partitions there may be an open partition of length zero. In order to fulfill the contract of this interface, the document must be configured with a document partitioner implementing IDocumentPartitionerExtension2. Since: 3.0 See Also: IDocumentPartitionerExtension2 Extension interface for IDocument. It adds the following concepts: Rewrite sessions. A rewrite session is a sequence of replace operations that form a semantic unit. A modification stamp on the document The ability to set the initial line delimiter and to query the default line delimiter Since: 3.1 Tagging interface to be implemented by IDocument implementers that offer a line repair method on the documents. In order to provide backward compatibility for clients of IRepairableDocument, extension interfaces are used to provide a means of evolution. The following extension interfaces exist: IRepairableDocumentExtension since version 3.4 adds the ability to query whether the repairable document needs to be repaired. Since: 3.0 See Also: IDocument, IRepairableDocumentExtension Extension interface for IRepairableDocument. Adds the ability to query whether the repairable document would have to be repaired after replacing some text. Since: 3.4 See Also: IRepairableDocument extends AbstractDocument Default document implementation. Uses a GapTextStore wrapped inside a CopyOnWriteTextStore as text store. The used line tracker considers the following strings as line delimiters: \"\ \", \"\\r\", \"\\r\ \". In case of a text replacement across line delimiter boundaries and with different line delimiters, the line tracker might have to be repaired. Use isLineInformationRepairNeeded(int, int, String) before doing the text replace if you have the need to discover such a situation. The document is ready to use. It has a default position category for which a default position updater is installed. Performance: The implementation should perform reasonably well for typical source code documents. It is not designed for very large documents of a size of several megabytes. Space-saving implementations are initially used for both the text store and the line tracker; the first modification after a set incurs the cost to transform the document structures to efficiently handle updates. See GapTextStore and TreeLineTracker for algorithmic behavior of the used document structures. See Also: GapTextStore, CopyOnWriteTextStore '
1340, 'org.eclipse.ui.views.properties.tabbed.AbstractTabDescriptor', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/views/properties/tabbed/AbstractTabDescriptor.html', 'Represents a tab to be displayed in the tab list in the tabbed property sheet page. extends ITabItem Represents a tab descriptor for the tabbed property view. This interface should not be extended or implemented. New instances should be created using AbstractTabDescriptor. Since: 3.4 Represents a tab to be displayed in the tab list in the tabbed property sheet page. extends Object implements ITabDescriptor, Cloneable An abstract implementation of a tab descriptor for the tabbed property view. Since: 3.4 '
1341, 'org.eclipse.ui.views.properties.tabbed.ITabDescriptorProvider', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/views/properties/tabbed/ITabDescriptorProvider.html', 'Represents a tab descriptor provider for the tabbed property view. Since: 3.4 '
1342, 'org.eclipse.ui.views.properties.tabbed.AbstractPropertySection', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/views/properties/tabbed/AbstractPropertySection.html', 'Represents a section of properties for a given input. The lifecycle of an ISection is as follows: ISection.createControls() ISection.setInput() ISection.aboutToBeShown() ISection.refresh() ISection.aboutToBeHidden() ISection.dispose() Implementors of this class should be aware that a section instance might be reused for different input objects (as long as they are valid section inputs). It means that ISection.setInput can be called at any time between ISection.createControls and ISection.dispose. When an input change event occurs, such as a tab selection or a workbench selection change, an ISection is sent: ISection.setInput() ISection.refresh() When an part activation event occurs, such as the contributor part activation event, an ISection is sent: ISection.setInput() ISection.aboutToBeShown() ISection.refresh() ISection.setInput() ISection.refresh() This is because both a tab selection event and an input selection event have occurred. This interface should not be extended or implemented. New section instances should be created using AbstractPropertySection. See Also: TabbedPropertySheetPage extends Object implements ISection An abstract implementation of a section in a tab in the tabbed property sheet page. '
1343, 'org.eclipse.ui.views.properties.tabbed.AbstractSectionDescriptor', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/views/properties/tabbed/AbstractSectionDescriptor.html', 'Represents a section descriptor on the tabbed property sections extensions. This interface should not be extended or implemented. New instances should be created using AbstractSectionDescriptor. extends Object implements ISectionDescriptor An abstract implementation of a section descriptor for the tabbed property view. Since: 3.4 '
1344, 'org.eclipse.ui.views.properties.tabbed.IOverridableTabList', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/views/properties/tabbed/IOverridableTabList.html', 'Represents a list of tabs. Used by a section that overrides the tabs that are provided by the tabbed property registry with a new list of tabs. The overridable tab list is a content provider that provides both the sections and the tab labels. Since: 3.4 '
1345, 'org.eclipse.ui.views.properties.tabbed.ISectionDescriptorProvider', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/views/properties/tabbed/ISectionDescriptorProvider.html', 'Represents a section descriptor provider for tabbed property sections. '
1346, 'org.eclipse.ui.views.properties.tabbed.AbstractOverridableTabListPropertySection', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/views/properties/tabbed/AbstractOverridableTabListPropertySection.html', 'Represents a list of tabs. Used by a section that overrides the tabs that are provided by the tabbed property registry with a new list of tabs. The overridable tab list is a content provider that provides both the sections and the tab labels. Since: 3.4 Represents a section of properties for a given input. The lifecycle of an ISection is as follows: ISection.createControls() ISection.setInput() ISection.aboutToBeShown() ISection.refresh() ISection.aboutToBeHidden() ISection.dispose() Implementors of this class should be aware that a section instance might be reused for different input objects (as long as they are valid section inputs). It means that ISection.setInput can be called at any time between ISection.createControls and ISection.dispose. When an input change event occurs, such as a tab selection or a workbench selection change, an ISection is sent: ISection.setInput() ISection.refresh() When an part activation event occurs, such as the contributor part activation event, an ISection is sent: ISection.setInput() ISection.aboutToBeShown() ISection.refresh() ISection.setInput() ISection.refresh() This is because both a tab selection event and an input selection event have occurred. This interface should not be extended or implemented. New section instances should be created using AbstractPropertySection. See Also: TabbedPropertySheetPage extends AbstractPropertySection implements IOverridableTabList An abstract implementation of a section in a tab that overrides the tabs that are provided by the tabbed property registry with a new list of tabs. Since: 3.4 '
1347, 'org.eclipse.ui.views.properties.tabbed.ITypeMapper', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/views/properties/tabbed/ITypeMapper.html', 'Allows property sheet page contributors to map the input object type to a domain model type. The domain model type is then used for matching against the input attribute of the propertySection extension. The type mapper is most frequently used to return the type of the model object when selecting a view object in a workbench part. For example, nodes in a tree may all be TreeObjects in a structured selection. The type mapper will take the tree node and return the type of the model object the node represents. This interface should not be extended or implemented. New type mapper instances should be created using AbstractTypeMapper. '
1348, 'org.eclipse.ui.views.properties.tabbed.AdvancedPropertySection', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/views/properties/tabbed/AdvancedPropertySection.html', 'Represents a section of properties for a given input. The lifecycle of an ISection is as follows: ISection.createControls() ISection.setInput() ISection.aboutToBeShown() ISection.refresh() ISection.aboutToBeHidden() ISection.dispose() Implementors of this class should be aware that a section instance might be reused for different input objects (as long as they are valid section inputs). It means that ISection.setInput can be called at any time between ISection.createControls and ISection.dispose. When an input change event occurs, such as a tab selection or a workbench selection change, an ISection is sent: ISection.setInput() ISection.refresh() When an part activation event occurs, such as the contributor part activation event, an ISection is sent: ISection.setInput() ISection.aboutToBeShown() ISection.refresh() ISection.setInput() ISection.refresh() This is because both a tab selection event and an input selection event have occurred. This interface should not be extended or implemented. New section instances should be created using AbstractPropertySection. See Also: TabbedPropertySheetPage extends AbstractPropertySection An advanced section that is intended to show the original table format properties view provided by base Eclipse. '
1349, 'org.eclipse.ui.views.properties.PropertyDescriptor', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/views/properties/PropertyDescriptor.html', 'A descriptor for a property to be presented by a standard property sheet page (PropertySheetPage). These descriptors originate with property sources (IPropertySource). A property descriptor carries the following information: property id (required) display name (required) brief description of the property (optional) category for grouping related properties (optional) label provider used to display the property value (optional) cell editor for changing the property value (optional) help context id (optional) Clients may implement this interface to provide specialized property descriptors; however, there are standard implementations declared in this package that take care of the most common cases: PropertyDescriptor - read-only property TextPropertyDescriptor - edits with a TextCellEditor CheckboxPropertyDescriptor - edits with a CheckboxCellEditor ComboBoxPropertyDescriptor - edits with a ComboBoxCellEditor ColorPropertyDescriptor - edits with a ColorCellEditor See Also: IPropertySource.getPropertyDescriptors() extends Object implements IPropertyDescriptor Standard implementation for property descriptors. The required attributes of property descriptors (id and display name) are passed to the constructor; the optional attributes can be configured using the various set methods (all have reasonable default values): setDescription setCategory setLabelProvider setHelpContexts Subclasses should reimplement getPropertyEditor to provide a cell editor for changing the value; otherwise the property will be effectively read only. There are several concrete subclasses provided in this package that cover the most common cases: TextPropertyDescriptor - edits with a TextCellEditor ComboBoxPropertyDescriptor - edits with a ComboBoxCellEditor ColorPropertyDescriptor - edits with a ColorCellEditor '
1350, 'org.eclipse.ui.views.properties.tabbed.AbstractTypeMapper', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/views/properties/tabbed/AbstractTypeMapper.html', 'Allows property sheet page contributors to map the input object type to a domain model type. The domain model type is then used for matching against the input attribute of the propertySection extension. The type mapper is most frequently used to return the type of the model object when selecting a view object in a workbench part. For example, nodes in a tree may all be TreeObjects in a structured selection. The type mapper will take the tree node and return the type of the model object the node represents. This interface should not be extended or implemented. New type mapper instances should be created using AbstractTypeMapper. extends Object implements ITypeMapper Default implementation of a type mapper. '
1351, 'org.eclipse.ui.texteditor.MarkerUtilities', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/texteditor/MarkerUtilities.html', 'extends Object Utility class for accessing marker attributes. The static methods provided on this class provide internal exception handling (unexpected CoreExceptions are logged to workbench). This class provides static methods only; it is not intended to be instantiated or subclassed by clients. Restriction: This class is not intended to be instantiated by clients. '
1352, 'org.eclipse.ui.IContributorResourceAdapter', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/IContributorResourceAdapter.html', 'The IContributorResourceAdapter is an interface that defines the API required to get a resource that an object adapts to for use of object contributions, decorators and property pages that have adaptable = true. Implementors of this interface are typically registered with an IAdapterFactory for lookup via the getAdapter() mechanism. '
1353, 'org.eclipse.core.resources.mapping.ResourceTraversal', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/resources/mapping/ResourceTraversal.html', 'extends Object A resource traversal is simply a set of resources and the depth to which each is to be traversed. A set of traversals is used to describe the resources that constitute a model element. The flags of the traversal indicate which special resources should be included or excluded from the traversal. The flags used are the same as those passed to the IResource.accept(IResourceVisitor, int, int) method. This class may be instantiated or subclassed by clients. Since: 3.2 See Also: IResource '
1354, 'org.eclipse.core.resources.mapping.ResourceMappingContext', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/resources/mapping/ResourceMappingContext.html', 'extends Object A resource mapping context is provided to a resource mapping when traversing the resources of the mapping. The type of context may determine what resources are included in the traversals of a mapping. There are currently two resource mapping contexts: the local mapping context (represented by the singleton LOCAL_CONTEXT), and RemoteResourceMappingContext. Implementors of ResourceMapping should not assume that these are the only valid contexts (in order to allow future extensibility). Therefore, if the provided context is not of one of the above mentioned types, the implementor can assume that the context is a local context. This class may be subclassed by clients; this class is not intended to be instantiated directly. Since: 3.2 See Also: ResourceMapping, RemoteResourceMappingContext '
1355, 'org.eclipse.core.runtime.content.ITextContentDescriber', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/runtime/content/ITextContentDescriber.html', 'Content describers know how to retrieve metadata from contents. Note: It is expected that content describer implementations be declared in a package that is exempt from plug-in activation (using the Eclipse-AutoStart bundle manifest header). Since all describers are instantiated when the content type framework is initialized, failure in complying with this requirement causes premature activation, which must be avoided. Future implementations of the framework might refuse to instantiate describers if doing so would trigger activation of the corresponding plug-in. Describers for text-based content types should implement ITextContentDescriber instead. Clients may implement this interface. Since: 3.0 See Also: IContentDescription extends IContentDescriber Text content describers extend basic content describers to provide the ability of scanning character streams (readers). Describers for text-based content types must implement this interface instead of IContentDescription. Note: It is expected that content describer implementations be declared in a package that is exempt from plug-in activation (using the Eclipse-AutoStart bundle manifest header). Since all describers are instantiated when the content type framework is initialized, failure in complying with this requirement causes premature activation, which must be avoided. Future implementations of the framework might refuse to instantiate describers if doing so would trigger activation of the corresponding plug-in. Clients may implement this interface. Since: 3.0 See Also: IContentDescription '
1356, 'org.eclipse.ui.views.navigator.ResourceNavigator', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/views/navigator/ResourceNavigator.html', 'An interface for an adaptable object. Adaptable objects can be dynamically extended to provide different interfaces (or \"adapters\"). Adapters are created by adapter factories, which are in turn managed by type by adapter managers. For example, IAdaptable a = [some adaptable]; IFoo x = (IFoo)a.getAdapter(IFoo.class); if (x != null) [do IFoo things with x] This interface can be used without OSGi running. Clients may implement this interface, or obtain a default implementation of this interface by subclassing PlatformObject. See Also: IAdapterFactory, IAdapterManager, PlatformObject Interface for executable extension classes that require access to their configuration element, or implement an extension adapter. Extension adapters are typically required in cases where the extension implementation does not follow the interface rules specified by the provider of the extension point. In these cases, the role of the adapter is to map between the extension point interface, and the actual extension implementation. In general, adapters are used when attempting to plug-in existing Java implementations, or non-Java implementations (e.g., external executables). This interface can be used without OSGi running. Clients may implement this interface. See Also: IConfigurationElement.createExecutableExtension(String) Objects implementing this interface are capable of saving their state in an IMemento. Since: 3.1 An interface for an adaptable object. Adaptable objects can be dynamically extended to provide different interfaces (or \"adapters\"). Adapters are created by adapter factories, which are in turn managed by type by adapter managers. For example, IAdaptable a = [some adaptable]; IFoo x = (IFoo)a.getAdapter(IFoo.class); if (x != null) [do IFoo things with x] This interface can be used without OSGi running. Clients may implement this interface, or obtain a default implementation of this interface by subclassing PlatformObject. See Also: IAdapterFactory, IAdapterManager, PlatformObject Objects implementing this interface are capable of saving their state in an IMemento. Since: 3.1 An interface for an adaptable object. Adaptable objects can be dynamically extended to provide different interfaces (or \"adapters\"). Adapters are created by adapter factories, which are in turn managed by type by adapter managers. For example, IAdaptable a = [some adaptable]; IFoo x = (IFoo)a.getAdapter(IFoo.class); if (x != null) [do IFoo things with x] This interface can be used without OSGi running. Clients may implement this interface, or obtain a default implementation of this interface by subclassing PlatformObject. See Also: IAdapterFactory, IAdapterManager, PlatformObject extends IAdaptable A workbench part is a visual component within a workbench page. There are two subtypes: view and editor, as defined by IViewPart and IEditorPart. A view is typically used to navigate a hierarchy of information (like the workspace), open an editor, or display properties for the active editor. Modifications made in a view are saved immediately. An editor is typically used to edit or browse a document or input object. The input is identified using an IEditorInput. Modifications made in an editor part follow an open-save-close lifecycle model. This interface may be implemented directly. For convenience, a base implementation is defined in WorkbenchPart. The lifecycle of a workbench part is as follows: When a part extension is created: instantiate the part create a part site call part.init(site) When a part becomes visible in the workbench: add part to presentation by calling part.createPartControl(parent) to create actual widgets fire partOpened event to all listeners When a part is activated or gets focus: call part.setFocus() fire partActivated event to all listeners When a part is closed: if save is needed, do save; if it fails or is canceled return if part is active, deactivate part fire partClosed event to all listeners remove part from presentation; part controls are disposed as part of the SWT widget tree call part.dispose() After createPartControl has been called, the implementor may safely reference the controls created. When the part is closed these controls will be disposed as part of an SWT composite. This occurs before the IWorkbenchPart.dispose method is called. If there is a need to free SWT resources the part should define a dispose listener for its own control and free those resources from the dispose listener. If the part invokes any method on the disposed SWT controls after this point an SWTError will be thrown. The last method called on IWorkbenchPart is dispose. This signals the end of the part lifecycle. An important point to note about this lifecycle is that following a call to init, createPartControl may never be called. Thus in the dispose method, implementors must not assume controls were created. Workbench parts implement the IAdaptable interface; extensions are managed by the platform\'s adapter manager. See Also: IViewPart, IEditorPart extends IWorkbenchPart, IPersistable A view is a visual component within a workbench page. It is typically used to navigate a hierarchy of information (like the workspace), open an editor, or display properties for the active editor. Modifications made in a view are saved immediately (in contrast to an editor part, which conforms to a more elaborate open-save-close lifecycle). Only one instance of a particular view type may exist within a workbench page. This policy is designed to simplify part management for a user. This interface may be implemented directly. For convenience, a base implementation is defined in ViewPart. A view is added to the workbench in two steps: A view extension is contributed to the workbench registry. This extension defines the extension id and extension class. The view is included in the default layout for a perspective. Alternatively, the user may open the view from the Perspective menu. Views implement the IAdaptable interface; extensions are managed by the platform\'s adapter manager. As of 3.4, views may optionally adapt to ISizeProvider if they have a preferred size. The default presentation will make a best effort to allocate the preferred size to a view if it is the only part in a stack. If there is more than one part in the stack, the constraints will be disabled for that stack. The size constraints are adjusted for the size of the tab and border trim. Note that this is considered to be a hint to the presentation, and not all presentations may honor size constraints. See Also: IWorkbenchPage.showView(java.lang.String), ViewPart, ISizeProvider An interface for an adaptable object. Adaptable objects can be dynamically extended to provide different interfaces (or \"adapters\"). Adapters are created by adapter factories, which are in turn managed by type by adapter managers. For example, IAdaptable a = [some adaptable]; IFoo x = (IFoo)a.getAdapter(IFoo.class); if (x != null) [do IFoo things with x] This interface can be used without OSGi running. Clients may implement this interface, or obtain a default implementation of this interface by subclassing PlatformObject. See Also: IAdapterFactory, IAdapterManager, PlatformObject extends IAdaptable A workbench part is a visual component within a workbench page. There are two subtypes: view and editor, as defined by IViewPart and IEditorPart. A view is typically used to navigate a hierarchy of information (like the workspace), open an editor, or display properties for the active editor. Modifications made in a view are saved immediately. An editor is typically used to edit or browse a document or input object. The input is identified using an IEditorInput. Modifications made in an editor part follow an open-save-close lifecycle model. This interface may be implemented directly. For convenience, a base implementation is defined in WorkbenchPart. The lifecycle of a workbench part is as follows: When a part extension is created: instantiate the part create a part site call part.init(site) When a part becomes visible in the workbench: add part to presentation by calling part.createPartControl(parent) to create actual widgets fire partOpened event to all listeners When a part is activated or gets focus: call part.setFocus() fire partActivated event to all listeners When a part is closed: if save is needed, do save; if it fails or is canceled return if part is active, deactivate part fire partClosed event to all listeners remove part from presentation; part controls are disposed as part of the SWT widget tree call part.dispose() After createPartControl has been called, the implementor may safely reference the controls created. When the part is closed these controls will be disposed as part of an SWT composite. This occurs before the IWorkbenchPart.dispose method is called. If there is a need to free SWT resources the part should define a dispose listener for its own control and free those resources from the dispose listener. If the part invokes any method on the disposed SWT controls after this point an SWTError will be thrown. The last method called on IWorkbenchPart is dispose. This signals the end of the part lifecycle. An important point to note about this lifecycle is that following a call to init, createPartControl may never be called. Thus in the dispose method, implementors must not assume controls were created. Workbench parts implement the IAdaptable interface; extensions are managed by the platform\'s adapter manager. See Also: IViewPart, IEditorPart An interface for an adaptable object. Adaptable objects can be dynamically extended to provide different interfaces (or \"adapters\"). Adapters are created by adapter factories, which are in turn managed by type by adapter managers. For example, IAdaptable a = [some adaptable]; IFoo x = (IFoo)a.getAdapter(IFoo.class); if (x != null) [do IFoo things with x] This interface can be used without OSGi running. Clients may implement this interface, or obtain a default implementation of this interface by subclassing PlatformObject. See Also: IAdapterFactory, IAdapterManager, PlatformObject An interface for an adaptable object. Adaptable objects can be dynamically extended to provide different interfaces (or \"adapters\"). Adapters are created by adapter factories, which are in turn managed by type by adapter managers. For example, IAdaptable a = [some adaptable]; IFoo x = (IFoo)a.getAdapter(IFoo.class); if (x != null) [do IFoo things with x] This interface can be used without OSGi running. Clients may implement this interface, or obtain a default implementation of this interface by subclassing PlatformObject. See Also: IAdapterFactory, IAdapterManager, PlatformObject extends IAdaptable A workbench part is a visual component within a workbench page. There are two subtypes: view and editor, as defined by IViewPart and IEditorPart. A view is typically used to navigate a hierarchy of information (like the workspace), open an editor, or display properties for the active editor. Modifications made in a view are saved immediately. An editor is typically used to edit or browse a document or input object. The input is identified using an IEditorInput. Modifications made in an editor part follow an open-save-close lifecycle model. This interface may be implemented directly. For convenience, a base implementation is defined in WorkbenchPart. The lifecycle of a workbench part is as follows: When a part extension is created: instantiate the part create a part site call part.init(site) When a part becomes visible in the workbench: add part to presentation by calling part.createPartControl(parent) to create actual widgets fire partOpened event to all listeners When a part is activated or gets focus: call part.setFocus() fire partActivated event to all listeners When a part is closed: if save is needed, do save; if it fails or is canceled return if part is active, deactivate part fire partClosed event to all listeners remove part from presentation; part controls are disposed as part of the SWT widget tree call part.dispose() After createPartControl has been called, the implementor may safely reference the controls created. When the part is closed these controls will be disposed as part of an SWT composite. This occurs before the IWorkbenchPart.dispose method is called. If there is a need to free SWT resources the part should define a dispose listener for its own control and free those resources from the dispose listener. If the part invokes any method on the disposed SWT controls after this point an SWTError will be thrown. The last method called on IWorkbenchPart is dispose. This signals the end of the part lifecycle. An important point to note about this lifecycle is that following a call to init, createPartControl may never be called. Thus in the dispose method, implementors must not assume controls were created. Workbench parts implement the IAdaptable interface; extensions are managed by the platform\'s adapter manager. See Also: IViewPart, IEditorPart extends IWorkbenchPart Extends IWorkbenchPart, adding the name and status text properties. Prior to 3.0, a view\'s title was often modified to show both the part name and extra status text. With this interface, the distinction is made more explicit. Since: 3.0 An interface for an adaptable object. Adaptable objects can be dynamically extended to provide different interfaces (or \"adapters\"). Adapters are created by adapter factories, which are in turn managed by type by adapter managers. For example, IAdaptable a = [some adaptable]; IFoo x = (IFoo)a.getAdapter(IFoo.class); if (x != null) [do IFoo things with x] This interface can be used without OSGi running. Clients may implement this interface, or obtain a default implementation of this interface by subclassing PlatformObject. See Also: IAdapterFactory, IAdapterManager, PlatformObject An interface for an adaptable object. Adaptable objects can be dynamically extended to provide different interfaces (or \"adapters\"). Adapters are created by adapter factories, which are in turn managed by type by adapter managers. For example, IAdaptable a = [some adaptable]; IFoo x = (IFoo)a.getAdapter(IFoo.class); if (x != null) [do IFoo things with x] This interface can be used without OSGi running. Clients may implement this interface, or obtain a default implementation of this interface by subclassing PlatformObject. See Also: IAdapterFactory, IAdapterManager, PlatformObject extends IAdaptable A workbench part is a visual component within a workbench page. There are two subtypes: view and editor, as defined by IViewPart and IEditorPart. A view is typically used to navigate a hierarchy of information (like the workspace), open an editor, or display properties for the active editor. Modifications made in a view are saved immediately. An editor is typically used to edit or browse a document or input object. The input is identified using an IEditorInput. Modifications made in an editor part follow an open-save-close lifecycle model. This interface may be implemented directly. For convenience, a base implementation is defined in WorkbenchPart. The lifecycle of a workbench part is as follows: When a part extension is created: instantiate the part create a part site call part.init(site) When a part becomes visible in the workbench: add part to presentation by calling part.createPartControl(parent) to create actual widgets fire partOpened event to all listeners When a part is activated or gets focus: call part.setFocus() fire partActivated event to all listeners When a part is closed: if save is needed, do save; if it fails or is canceled return if part is active, deactivate part fire partClosed event to all listeners remove part from presentation; part controls are disposed as part of the SWT widget tree call part.dispose() After createPartControl has been called, the implementor may safely reference the controls created. When the part is closed these controls will be disposed as part of an SWT composite. This occurs before the IWorkbenchPart.dispose method is called. If there is a need to free SWT resources the part should define a dispose listener for its own control and free those resources from the dispose listener. If the part invokes any method on the disposed SWT controls after this point an SWTError will be thrown. The last method called on IWorkbenchPart is dispose. This signals the end of the part lifecycle. An important point to note about this lifecycle is that following a call to init, createPartControl may never be called. Thus in the dispose method, implementors must not assume controls were created. Workbench parts implement the IAdaptable interface; extensions are managed by the platform\'s adapter manager. See Also: IViewPart, IEditorPart extends IWorkbenchPart Extends IWorkbenchPart, adding the name and status text properties. Prior to 3.0, a view\'s title was often modified to show both the part name and extra status text. With this interface, the distinction is made more explicit. Since: 3.0 extends IWorkbenchPart2 A part can provide arbitrary properties. The properties will be persisted between sessions by the part reference, and will be available from the part reference as well as the part. The properties can only be set on a part, not on the reference. The properties will be available to the IPresentablePart. Setting a property must fire a PropertyChangeEvent. Since: 3.3 Interface for views which support reveal and select. This interface may be implemented by subclasses of ViewPart. This interface is commonly used by a New wizard to reveal and select a resource in a workbench part which it has just created. See Also: IViewPart, ViewPart The IWorkbenchPartOrientation is the interface that defines the orientation of the part. If a type does not implement this interface an orientation of SWT.NONE will be assumed. Since: 3.1 See Also: SWT.RIGHT_TO_LEFT, SWT.LEFT_TO_RIGHT, SWT.NONE, Window.getDefaultOrientation() extends ViewPart implements ISetSelectionTarget, IResourceNavigator Implements the Resource Navigator view. '
1357, 'org.eclipse.ui.texteditor.IDocumentProvider', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/texteditor/IDocumentProvider.html', 'A document provider maps between domain elements and documents. A document provider has the following responsibilities: create an annotation model of a domain model element create and manage a textual representation, i.e., a document, of a domain model element create and save the content of domain model elements based on given documents update the documents this document provider manages for domain model elements to changes directly applied to those domain model elements notify all element state listeners about changes directly applied to domain model elements this document provider manages a document for, i.e. the document provider must know which changes of a domain model element are to be interpreted as element moves, deletes, etc. Text editors use document providers to bridge the gap between their input elements and the documents they work on. A single document provider may be shared between multiple editors; the methods take the editors\' input elements as a parameter. This interface may be implemented by clients; or subclass the standard abstract base class AbstractDocumentProvider. In order to provided backward compatibility for clients of IDocumentProvider, extension interfaces are used to provide a means of evolution. The following extension interfaces exist: IDocumentProviderExtension since version 2.0 introducing state validation, extended read-only handling and synchronization. IDocumentProviderExtension2 since version 2.1 introducing adding support for a global progress monitor. IDocumentProviderExtension3 since version 3.0 adding a predicate for querying synchronization state. IDocumentProviderExtension4 since version 3.1 adding a predicate for querying an element\'s the content description. IDocumentProviderExtension5 since version 3.2 adding the ability to detect a non-synchronized exception. See Also: IDocument, AbstractDocumentProvider, IDocumentProviderExtension, IDocumentProviderExtension2, IDocumentProviderExtension3, IDocumentProviderExtension4, IDocumentProviderExtension5 '
1358, 'org.eclipse.core.runtime.jobs.IJobManager', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/runtime/jobs/IJobManager.html', 'The job manager provides facilities for scheduling, querying, and maintaining jobs and locks. In particular, the job manager provides the following services: Maintains a queue of jobs that are waiting to be run. Items can be added to the queue using the schedule method. Allows manipulation of groups of jobs called job families. Job families can be canceled, put to sleep, or woken up atomically. There is also a mechanism for querying the set of known jobs in a given family. Allows listeners to find out about progress on running jobs, and to find out when jobs have changed states. Provides a factory for creating lock objects. Lock objects are smart monitors that have strategies for avoiding deadlock. Provide feedback to a client that is waiting for a given job or family of jobs to complete. Since: 3.0 See Also: Job, ILock Restriction: This interface is not intended to be implemented by clients. Restriction: This interface is not intended to be extended by clients. '
1359, 'org.eclipse.ui.application.DisplayAccess', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/application/DisplayAccess.html', 'extends Object This class provides static methods that help RCP applications interact with the Display. Since: 3.4 '
1360, 'org.eclipse.jface.preference.PreferenceStore', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/preference/PreferenceStore.html', 'The IPreferenceStore interface represents a table mapping named preferences to values. If there is no value for a given name, then that preferences\'s default value is returned; and if there is no default value for that preference, then a default-default value is returned. The default-default values for the primitive types are as follows: boolean = false double = 0.0 float = 0.0f int = 0 long = 0 String = \"\" (the empty string) Thus a preference store maintains two values for each of a set of names: a current value and a default value. The typical usage is to establish the defaults for all known preferences and then restore previously stored values for preferences whose values were different from their defaults. After the current values of the preferences have been modified, it is a simple matter to write out only those preferences whose values are different from their defaults. This two-tiered approach to saving and restoring preference setting minimized the number of preferences that need to be persisted; indeed, the normal starting state does not require storing any preferences at all. A property change event is reported whenever a preferences current value actually changes (whether through setValue, setToDefault, or other unspecified means). Note, however, that manipulating default values (with setDefault) does not cause such events to be reported. Clients who need a preference store may implement this interface or instantiate the standard implementation PreferenceStore. See Also: PreferenceStore extends IPreferenceStore IPersistentPreferenceStore is a preference store that can be saved. The IPreferenceStore interface represents a table mapping named preferences to values. If there is no value for a given name, then that preferences\'s default value is returned; and if there is no default value for that preference, then a default-default value is returned. The default-default values for the primitive types are as follows: boolean = false double = 0.0 float = 0.0f int = 0 long = 0 String = \"\" (the empty string) Thus a preference store maintains two values for each of a set of names: a current value and a default value. The typical usage is to establish the defaults for all known preferences and then restore previously stored values for preferences whose values were different from their defaults. After the current values of the preferences have been modified, it is a simple matter to write out only those preferences whose values are different from their defaults. This two-tiered approach to saving and restoring preference setting minimized the number of preferences that need to be persisted; indeed, the normal starting state does not require storing any preferences at all. A property change event is reported whenever a preferences current value actually changes (whether through setValue, setToDefault, or other unspecified means). Note, however, that manipulating default values (with setDefault) does not cause such events to be reported. Clients who need a preference store may implement this interface or instantiate the standard implementation PreferenceStore. See Also: PreferenceStore extends EventManager implements IPersistentPreferenceStore A concrete preference store implementation based on an internal java.util.Properties object, with support for persisting the non-default preference values to files or streams. This class was not designed to be subclassed. See Also: IPreferenceStore Restriction: This class is not intended to be subclassed by clients. '
1361, 'org.eclipse.jface.preference.BooleanFieldEditor', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/preference/BooleanFieldEditor.html', 'extends FieldEditor A field editor for a boolean type preference. '
1362, 'org.eclipse.jface.preference.FieldEditorPreferencePage', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/preference/FieldEditorPreferencePage.html', 'Interface for a page in a multi-page dialog. Minimal interface to a message provider. Used for dialog pages which can provide a message with an icon. Since: 2.0 Interface for a page in a multi-page dialog. extends IDialogPage An interface for a preference page. This interface is used primarily by the page\'s container extends EventListener Listener for property changes. Usage: IPropertyChangeListener listener = new IPropertyChangeListener() { public void propertyChange(PropertyChangeEvent event) { ... // code to deal with occurrence of property change } }; emitter.addPropertyChangeListener(listener); ... emitter.removePropertyChangeListener(listener); extends PreferencePage implements IPropertyChangeListener A special abstract preference page to host field editors. Subclasses must implement the createFieldEditors method and should override createLayout if a special layout of the field editors is needed. '
1363, 'org.eclipse.jface.viewers.TreeNodeContentProvider', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/viewers/TreeNodeContentProvider.html', 'A content provider mediates between the viewer\'s model and the viewer itself. See Also: ContentViewer.setContentProvider(IContentProvider) A content provider mediates between the viewer\'s model and the viewer itself. See Also: ContentViewer.setContentProvider(IContentProvider) extends IContentProvider An interface to content providers for structured viewers. See Also: StructuredViewer A content provider mediates between the viewer\'s model and the viewer itself. See Also: ContentViewer.setContentProvider(IContentProvider) extends IContentProvider An interface to content providers for structured viewers. See Also: StructuredViewer extends IStructuredContentProvider An interface to content providers for tree-structure-oriented viewers. See Also: AbstractTreeViewer extends Object implements ITreeContentProvider A content provider that expects every element to be a TreeNode. Most methods delegate to TreeNode. dispose() and inputChanged(Viewer, Object, Object) do nothing by default. This class and all of its methods may be overridden or extended. Since: 3.2 See Also: TreeNode '
1364, 'org.eclipse.jface.viewers.IBasicPropertyConstants', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/viewers/IBasicPropertyConstants.html', 'Predefined property names used for elements displayed in viewers. See Also: StructuredViewer.update(Object, String[]), StructuredViewer.update(Object[], String[]), IBaseLabelProvider.isLabelProperty(java.lang.Object, java.lang.String), ViewerComparator.isSorterProperty(java.lang.Object, java.lang.String), ViewerFilter.isFilterProperty(java.lang.Object, java.lang.String) '
1365, 'org.eclipse.jface.viewers.TableTreeViewer', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/viewers/TableTreeViewer.html', 'Interface common to all objects that provide an input. Interface common to all objects that provide an input. Interface common to all objects that provide a selection. See Also: ISelection, ISelectionChangedListener, SelectionChangedEvent extends IInputProvider, ISelectionProvider Interface common to all objects that provide both an input and a selection. Interface common to all objects that provide a selection. See Also: ISelection, ISelectionChangedListener, SelectionChangedEvent extends ISelectionProvider Selection provider extension interface to allow providers to notify about post selection changed events. A post selection changed event is equivalent to selection changed event if the selection change was triggered by the mouse, but it has a delay if the selection change is triggered by keyboard navigation. Since: 3.0 See Also: ISelectionProvider extends AbstractTreeViewer A concrete viewer based on a SWT TableTree control. This class is not intended to be subclassed outside the viewer framework. It is designed to be instantiated with a pre-existing SWT table tree control and configured with a domain-specific content provider, label provider, element filter (optional), and element sorter (optional). Content providers for table tree viewers must implement the ITreeContentProvider interface. Label providers for table tree viewers must implement either the ITableLabelProvider or the ILabelProvider interface (see TableTreeViewer.setLabelProvider for more details). Restriction: This class is not intended to be subclassed by clients. '
1366, 'org.eclipse.jface.viewers.deferred.DeferredContentProvider', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/viewers/deferred/DeferredContentProvider.html', 'A content provider mediates between the viewer\'s model and the viewer itself. See Also: ContentViewer.setContentProvider(IContentProvider) A content provider mediates between the viewer\'s model and the viewer itself. See Also: ContentViewer.setContentProvider(IContentProvider) extends IContentProvider The ILazyContentProvider is the content provider for table viewers created using the SWT.VIRTUAL flag that only wish to return their contents as they are queried. NOTE: As the ILazyContentProvider does not have API for determining the total item count any changes to the number of items for this object while require a call to #setItemCount on the viewer that uses it. extends Object implements ILazyContentProvider Content provider that performs sorting and filtering in a background thread. Requires a TableViewer created with the SWT.VIRTUAL flag and an IConcurrentModel as input. The sorter and filter must be set directly on the content provider. Any sorter or filter on the TableViewer will be ignored. The real implementation is in BackgroundContentProvider. This object is a lightweight wrapper that adapts the algorithm to work with TableViewer. Since: 3.1 '
1367, 'org.eclipse.jface.viewers.deferred.SetModel', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/viewers/deferred/SetModel.html', 'Interface for a set of unordered elements that can fire change notifications. IConcurrentModel returns its contents asynchronous. Rather than implementing \"get\" methods, listeners can request an update and the model fires back information at its earliest convenience. The model is allowed to send back notifications to its listeners in any thread, and the listeners must not assume that the notifications will arrive in the UI thread. Not intended to be implemented by clients. Clients should subclass AbstractConcurrentModel instead. Since: 3.1 Restriction: This interface is not intended to be implemented by clients. extends AbstractConcurrentModel Trivial implementation of an IConcurrentModel. Implements an unordered set of elements that fires off change notifications whenever elements are added or removed from the set. All notifications are sent synchronously. Since: 3.1 '
1368, 'org.eclipse.jface.fieldassist.TextContentAdapter', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/fieldassist/TextContentAdapter.html', 'This interface is used to set and retrieve text content from an arbitrary control. Clients are expected to implement this interface when defining a ContentProposalAdapter, in order to specify how to retrieve and set the contents of the control being adapted. Since: 3.2 This interface is used by a ContentProposalAdapter in order to retrieve and set the selection range in a control. Since: 3.4 extends Object implements IControlContentAdapter, IControlContentAdapter2 An IControlContentAdapter for SWT Text controls. This is a convenience class for easily creating a ContentProposalAdapter for text fields. Since: 3.2 '
1369, 'org.eclipse.jface.fieldassist.ContentProposalAdapter', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/fieldassist/ContentProposalAdapter.html', 'extends Object ContentProposalAdapter can be used to attach content proposal behavior to a control. This behavior includes obtaining proposals, opening a popup dialog, managing the content of the control relative to the selections in the popup, and optionally opening up a secondary popup to further describe proposals. A number of configurable options are provided to determine how the control content is altered when a proposal is chosen, how the content proposal popup is activated, and whether any filtering should be done on the proposals as the user types characters. This class provides some overridable methods to allow clients to manually control the popup. However, most of the implementation remains private. Since: 3.2 '
1370, 'org.eclipse.jface.fieldassist.SimpleContentProposalProvider', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/fieldassist/SimpleContentProposalProvider.html', 'IContentProposalProvider provides an array of IContentProposals that are appropriate for a textual dialog field, given the field\'s current content and the current cursor position. Since: 3.2 See Also: SimpleContentProposalProvider extends Object implements IContentProposalProvider SimpleContentProposalProvider is a class designed to map a static list of Strings to content proposals. Since: 3.2 See Also: IContentProposalProvider '
1371, 'org.eclipse.jface.fieldassist.ComboContentAdapter', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/fieldassist/ComboContentAdapter.html', 'This interface is used to set and retrieve text content from an arbitrary control. Clients are expected to implement this interface when defining a ContentProposalAdapter, in order to specify how to retrieve and set the contents of the control being adapted. Since: 3.2 This interface is used by a ContentProposalAdapter in order to retrieve and set the selection range in a control. Since: 3.4 extends Object implements IControlContentAdapter, IControlContentAdapter2 An IControlContentAdapter for SWT Combo controls. This is a convenience class for easily creating a ContentProposalAdapter for combo fields. Since: 3.2 '
1372, 'org.eclipse.ui.help.WorkbenchHelp', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/help/WorkbenchHelp.html', 'extends Object Provides methods for accessing the help UI. The help UI is optional, to allow applications to be configured without one. The various setHelp methods allow context help to be hooked in to SWT menus, menu items, and controls, and into JFace actions. This involves furnishing a help context id. When the user requests help for one of the established widgets (for instance, by hitting F1), the context id is retrieved and passed to the help UI using WorkbenchHelp.displayContext(helpContext, xposition, yposition). In cases more dynamic situations, clients may hook their own help listener and call WorkbenchHelp.displayContext with an IContext. This class provides static methods only; it is not intended to be instantiated or subclassed. See Also: HelpSystem, IWorkbenchHelpSystem, IWorkbench.getHelpSystem() Restriction: This class is not intended to be subclassed by clients. Restriction: This class is not intended to be instantiated by clients. '
1373, 'org.eclipse.ui.dialogs.SearchPattern', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/dialogs/SearchPattern.html', 'extends Object A search pattern defines how search results are found. This class is intended to be subclassed by clients. A default behavior is provided for each of the methods above, that clients can override if they wish. Since: 3.3 '
1374, 'org.eclipse.ui.wizards.newresource.BasicNewFileResourceWizard', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/wizards/newresource/BasicNewFileResourceWizard.html', 'Interface for a wizard. A wizard maintains a list of wizard pages, stacked on top of each other in card layout fashion. The class Wizard provides an abstract implementation of this interface. However, clients are also free to implement this interface if Wizard does not suit their needs. See Also: Wizard Interface for a wizard. A wizard maintains a list of wizard pages, stacked on top of each other in card layout fashion. The class Wizard provides an abstract implementation of this interface. However, clients are also free to implement this interface if Wizard does not suit their needs. See Also: Wizard Interface for a wizard. A wizard maintains a list of wizard pages, stacked on top of each other in card layout fashion. The class Wizard provides an abstract implementation of this interface. However, clients are also free to implement this interface if Wizard does not suit their needs. See Also: Wizard extends IWizard Implementors represent creation wizards that are to be contributed to the workbench\'s creation wizard extension point. See Also: IWizard extends IWorkbenchWizard Interface for creation wizards. Clients should implement this interface and include the name of their class in a wizard contributed to the workbench\'s creation wizard extension point (named \"org.eclipse.ui.newWizards\"). For example, the plug-in\'s XML markup might contain: <extension point=\"org.eclipse.ui.newWizards\"> <wizard id=\"com.example.myplugin.new.blob\" name=\"Blob\" class=\"com.example.myplugin.BlobCreator\" icon=\"icons/new_blob_wiz.gif\"> <description>Create a new BLOB file</description> <selection class=\"org.eclipse.core.resources.IResource\" /> </wizard> </extension> See Also: IWizard Interface for a wizard. A wizard maintains a list of wizard pages, stacked on top of each other in card layout fashion. The class Wizard provides an abstract implementation of this interface. However, clients are also free to implement this interface if Wizard does not suit their needs. See Also: Wizard extends IWizard Implementors represent creation wizards that are to be contributed to the workbench\'s creation wizard extension point. See Also: IWizard extends BasicNewResourceWizard Standard workbench wizard that create a new file resource in the workspace. This class may be instantiated and used without further configuration; this class is not intended to be subclassed. Example: IWorkbenchWizard wizard = new BasicNewFileResourceWizard(); wizard.init(workbench, selection); WizardDialog dialog = new WizardDialog(shell, wizard); dialog.open(); During the call to open, the wizard dialog is presented to the user. When the user hits Finish, a file resource at the user-specified workspace path is created, the dialog closes, and the call to open returns. Restriction: This class is not intended to be subclassed by clients. '
1375, 'org.eclipse.ui.dialogs.WizardNewFileCreationPage', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/dialogs/WizardNewFileCreationPage.html', 'Interface for a page in a multi-page dialog. Minimal interface to a message provider. Used for dialog pages which can provide a message with an icon. Since: 2.0 Interface for a page in a multi-page dialog. extends IDialogPage Interface for a wizard page. The class WizardPage provides an abstract implementation of this interface. However, clients are also free to implement this interface if WizardPage does not suit their needs. Implementers of Listener provide a simple handleEvent() method that is used internally by SWT to dispatch events. After creating an instance of a class that implements this interface it can be added to a widget using the addListener(int eventType, Listener handler) method and removed using the removeListener (int eventType, Listener handler) method. When the specified event occurs, handleEvent(...) will be sent to the instance. Classes which implement this interface are described within SWT as providing the untyped listener API. Typically, widgets will also provide a higher-level typed listener API, that is based on the standard java.util.EventListener pattern. Note that, since all internal SWT event dispatching is based on untyped listeners, it is simple to build subsets of SWT for use on memory constrained, small footprint devices, by removing the classes and methods which implement the typed listener API. See Also: Widget.addListener(int, org.eclipse.swt.widgets.Listener), EventListener, org.eclipse.swt.events extends WizardPage implements Listener Standard main page for a wizard that creates a file resource. This page may be used by clients as-is; it may be also be subclassed to suit. Subclasses may override getInitialContents getNewFileLabel Subclasses may extend handleEvent '
1376, 'org.eclipse.ui.wizards.newresource.BasicNewFolderResourceWizard', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/wizards/newresource/BasicNewFolderResourceWizard.html', 'Interface for a wizard. A wizard maintains a list of wizard pages, stacked on top of each other in card layout fashion. The class Wizard provides an abstract implementation of this interface. However, clients are also free to implement this interface if Wizard does not suit their needs. See Also: Wizard Interface for a wizard. A wizard maintains a list of wizard pages, stacked on top of each other in card layout fashion. The class Wizard provides an abstract implementation of this interface. However, clients are also free to implement this interface if Wizard does not suit their needs. See Also: Wizard Interface for a wizard. A wizard maintains a list of wizard pages, stacked on top of each other in card layout fashion. The class Wizard provides an abstract implementation of this interface. However, clients are also free to implement this interface if Wizard does not suit their needs. See Also: Wizard extends IWizard Implementors represent creation wizards that are to be contributed to the workbench\'s creation wizard extension point. See Also: IWizard extends IWorkbenchWizard Interface for creation wizards. Clients should implement this interface and include the name of their class in a wizard contributed to the workbench\'s creation wizard extension point (named \"org.eclipse.ui.newWizards\"). For example, the plug-in\'s XML markup might contain: <extension point=\"org.eclipse.ui.newWizards\"> <wizard id=\"com.example.myplugin.new.blob\" name=\"Blob\" class=\"com.example.myplugin.BlobCreator\" icon=\"icons/new_blob_wiz.gif\"> <description>Create a new BLOB file</description> <selection class=\"org.eclipse.core.resources.IResource\" /> </wizard> </extension> See Also: IWizard Interface for a wizard. A wizard maintains a list of wizard pages, stacked on top of each other in card layout fashion. The class Wizard provides an abstract implementation of this interface. However, clients are also free to implement this interface if Wizard does not suit their needs. See Also: Wizard extends IWizard Implementors represent creation wizards that are to be contributed to the workbench\'s creation wizard extension point. See Also: IWizard extends BasicNewResourceWizard Standard workbench wizard that create a new folder resource in the workspace. This class may be instantiated and used without further configuration; this class is not intended to be subclassed. Example: IWorkbenchWizard wizard = new BasicNewFolderResourceWizard(); wizard.init(workbench, selection); WizardDialog dialog = new WizardDialog(shell, wizard); dialog.open(); During the call to open, the wizard dialog is presented to the user. When the user hits Finish, a folder resource at the user-specified workspace path is created, the dialog closes, and the call to open returns. Restriction: This class is not intended to be subclassed by clients. '
1377, 'org.eclipse.ui.wizards.newresource.BasicNewProjectResourceWizard', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/wizards/newresource/BasicNewProjectResourceWizard.html', 'Interface for executable extension classes that require access to their configuration element, or implement an extension adapter. Extension adapters are typically required in cases where the extension implementation does not follow the interface rules specified by the provider of the extension point. In these cases, the role of the adapter is to map between the extension point interface, and the actual extension implementation. In general, adapters are used when attempting to plug-in existing Java implementations, or non-Java implementations (e.g., external executables). This interface can be used without OSGi running. Clients may implement this interface. See Also: IConfigurationElement.createExecutableExtension(String) Interface for a wizard. A wizard maintains a list of wizard pages, stacked on top of each other in card layout fashion. The class Wizard provides an abstract implementation of this interface. However, clients are also free to implement this interface if Wizard does not suit their needs. See Also: Wizard Interface for a wizard. A wizard maintains a list of wizard pages, stacked on top of each other in card layout fashion. The class Wizard provides an abstract implementation of this interface. However, clients are also free to implement this interface if Wizard does not suit their needs. See Also: Wizard Interface for a wizard. A wizard maintains a list of wizard pages, stacked on top of each other in card layout fashion. The class Wizard provides an abstract implementation of this interface. However, clients are also free to implement this interface if Wizard does not suit their needs. See Also: Wizard extends IWizard Implementors represent creation wizards that are to be contributed to the workbench\'s creation wizard extension point. See Also: IWizard extends IWorkbenchWizard Interface for creation wizards. Clients should implement this interface and include the name of their class in a wizard contributed to the workbench\'s creation wizard extension point (named \"org.eclipse.ui.newWizards\"). For example, the plug-in\'s XML markup might contain: <extension point=\"org.eclipse.ui.newWizards\"> <wizard id=\"com.example.myplugin.new.blob\" name=\"Blob\" class=\"com.example.myplugin.BlobCreator\" icon=\"icons/new_blob_wiz.gif\"> <description>Create a new BLOB file</description> <selection class=\"org.eclipse.core.resources.IResource\" /> </wizard> </extension> See Also: IWizard Interface for a wizard. A wizard maintains a list of wizard pages, stacked on top of each other in card layout fashion. The class Wizard provides an abstract implementation of this interface. However, clients are also free to implement this interface if Wizard does not suit their needs. See Also: Wizard extends IWizard Implementors represent creation wizards that are to be contributed to the workbench\'s creation wizard extension point. See Also: IWizard extends BasicNewResourceWizard implements IExecutableExtension Standard workbench wizard that creates a new project resource in the workspace. This class may be instantiated and used without further configuration; this class is not intended to be subclassed. Example: IWorkbenchWizard wizard = new BasicNewProjectResourceWizard(); wizard.init(workbench, selection); WizardDialog dialog = new WizardDialog(shell, wizard); dialog.open(); During the call to open, the wizard dialog is presented to the user. When the user hits Finish, a project resource with the user-specified name is created, the dialog closes, and the call to open returns. Restriction: This class is not intended to be subclassed by clients. '
1378, 'org.eclipse.ui.dialogs.WizardNewProjectReferencePage', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/dialogs/WizardNewProjectReferencePage.html', 'Interface for a page in a multi-page dialog. Minimal interface to a message provider. Used for dialog pages which can provide a message with an icon. Since: 2.0 Interface for a page in a multi-page dialog. extends IDialogPage Interface for a wizard page. The class WizardPage provides an abstract implementation of this interface. However, clients are also free to implement this interface if WizardPage does not suit their needs. extends WizardPage Standard project reference page for a wizard that creates a project resource. This page may be used by clients as-is; it may be also be subclassed to suit. Example usage: referencePage = new WizardNewProjectReferencePage(\"basicReferenceProjectPage\"); referencePage.setTitle(\"Project\"); referencePage.setDescription(\"Select referenced projects.\"); '
1379, 'org.eclipse.ui.dialogs.YesNoCancelListSelectionDialog', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/dialogs/YesNoCancelListSelectionDialog.html', 'extends ListSelectionDialog YesNoCancelListSelectionDialog is a list selection dialog that also allows the user to select no as a result. '
1380, 'org.eclipse.jface.preference.FontFieldEditor', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/preference/FontFieldEditor.html', 'extends FieldEditor A field editor for a font type preference. '
1381, 'org.eclipse.jface.preference.ColorFieldEditor', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/preference/ColorFieldEditor.html', 'extends FieldEditor A field editor for a color type preference. '
1382, 'org.eclipse.jface.preference.PathEditor', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/preference/PathEditor.html', 'extends ListEditor A field editor to edit directory paths. '
1383, 'org.eclipse.ui.menus.ExtensionContributionFactory', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/menus/ExtensionContributionFactory.html', 'Interface for executable extension classes that require access to their configuration element, or implement an extension adapter. Extension adapters are typically required in cases where the extension implementation does not follow the interface rules specified by the provider of the extension point. In these cases, the role of the adapter is to map between the extension point interface, and the actual extension implementation. In general, adapters are used when attempting to plug-in existing Java implementations, or non-Java implementations (e.g., external executables). This interface can be used without OSGi running. Clients may implement this interface. See Also: IConfigurationElement.createExecutableExtension(String) extends AbstractContributionFactory implements IExecutableExtension Clients who wish to contribute factories via the org.eclipse.ui.menus extension point should subclass this class rather than the AbstractContributionFactory as this class provides a default constructor. Clients must be aware that the results of getLocation() and getNamespace() will not be valid until setInitializationData(IConfigurationElement, String, Object) is invoked. This will occur before AbstractContributionFactory.createContributionItems(org.eclipse.ui.services.IServiceLocator, IContributionRoot) is invoked. Since: 3.5 '
1384, 'org.eclipse.jface.text.FindReplaceDocumentAdapter', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/text/FindReplaceDocumentAdapter.html', 'extends Object implements CharSequence Provides search and replace operations on IDocument. Replaces IDocument.search(int, String, boolean, boolean, boolean). Since: 3.0 '
1385, 'org.eclipse.jface.text.IRegion', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/text/IRegion.html', 'A region describes a certain range in an indexed text store. Text stores are for example documents or strings. A region is defined by its offset into the text store and its length. A region is considered a value object. Its offset and length do not change over time. Clients may implement this interface or use the standard implementation Region. '
1386, 'org.eclipse.ui.views.navigator.ResourceSorter', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/views/navigator/ResourceSorter.html', 'extends ViewerSorter Sorter for viewers that display items of type IResource. The sorter supports two sort criteria: NAME: Folders are given order precedence, followed by files. Within these two groups resources are ordered by name. All name comparisons are case-insensitive. TYPE: Folders are given order precedence, followed by files. Within these two groups resources are ordered by extension. All extension comparisons are case-insensitive. This class may be instantiated; it is not intended to be subclassed. Restriction: This class is not intended to be subclassed by clients. '
1387, 'org.eclipse.ui.part.DrillDownAdapter', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/part/DrillDownAdapter.html', 'A listener which is notified when a viewer\'s selection changes. See Also: ISelection, ISelectionProvider, SelectionChangedEvent extends Object implements ISelectionChangedListener Implements a simple web style navigation metaphor for a TreeViewer. Home, back, and \"drill into\" functions are supported for the viewer, To use the DrillDownAdapter .. Create an instance of TreeViewer. Create a DrillDownAdapter for the viewer. Create a container for your viewer with a toolbar or a popup menu. Add actions for \"goBack\", \"goHome\", and \"goInto\" to either one by calling addNavigationActions with the popup menu or toolbar. If the input for the underlying viewer is changed by something other than the adapter the reset method should be called. This will clear the drill stack and update the navigation buttons to reflect the new state of the underlying viewer. '
1388, 'org.eclipse.core.expressions.ICountable', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/expressions/ICountable.html', 'Objects that are adaptable to ICountable can be used as the default variable in a count expression. Since: 3.3 See Also: IAdaptable, IAdapterManager '
1389, 'org.eclipse.core.expressions.IIterable', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/expressions/IIterable.html', 'Objects that are adaptable to IIterable can be used as the default variable in an iterate expression. Since: 3.3 See Also: IAdaptable, IAdapterManager '
1390, 'org.eclipse.ui.actions.AddBookmarkAction', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/actions/AddBookmarkAction.html', 'An action represents the non-UI side of a command which can be triggered by the end user. Actions are typically associated with buttons, menu items, and items in tool bars. The controls for a command are built by some container, which furnished the context where these controls appear and configures them with data from properties declared by the action. When the end user triggers the command via its control, the action\'s run method is invoked to do the real work. Actions support a predefined set of properties (and possibly others as well). Clients of an action may register property change listeners so that they get notified whenever the value of a property changes. Clients should subclass the abstract base class Action to define concrete actions rather than implementing IAction from scratch. This interface exists only to define the API for actions. It is not intended to be implemented by clients. See Also: Action Restriction: This interface is not intended to be implemented by clients. A listener which is notified when a viewer\'s selection changes. See Also: ISelection, ISelectionProvider, SelectionChangedEvent extends SelectionListenerAction Standard action for adding a bookmark to the currently selected file resource(s). This class may be instantiated; it is not intended to be subclassed. Restriction: This class is not intended to be subclassed by clients. '
1391, 'org.eclipse.ui.dialogs.PropertyDialogAction', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/dialogs/PropertyDialogAction.html', 'An action represents the non-UI side of a command which can be triggered by the end user. Actions are typically associated with buttons, menu items, and items in tool bars. The controls for a command are built by some container, which furnished the context where these controls appear and configures them with data from properties declared by the action. When the end user triggers the command via its control, the action\'s run method is invoked to do the real work. Actions support a predefined set of properties (and possibly others as well). Clients of an action may register property change listeners so that they get notified whenever the value of a property changes. Clients should subclass the abstract base class Action to define concrete actions rather than implementing IAction from scratch. This interface exists only to define the API for actions. It is not intended to be implemented by clients. See Also: Action Restriction: This interface is not intended to be implemented by clients. A listener which is notified when a viewer\'s selection changes. See Also: ISelection, ISelectionProvider, SelectionChangedEvent extends SelectionProviderAction Standard action for opening a Property Pages Dialog on the currently selected element. This class may be instantiated; it is not intended to be subclassed. Generally speaking, this action is useful in pop-up menus because it allows the user to browse and change properties of selected elements. When performed, the action will bring up a Property Pages Dialog containing property pages registered with the workbench for elements of the selected type. Although the action is capable of calculating if there are any applicable pages for the current selection, this calculation is costly because it require searching the workbench registry. Where performance is critical, the action can simply be added to the pop-up menu. In the event of no applicable pages, the action will just open an appropriate message dialog. Restriction: This class is not intended to be subclassed by clients. '
1392, 'org.eclipse.ui.views.markers.MarkerSupportView', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/views/markers/MarkerSupportView.html', 'An interface for an adaptable object. Adaptable objects can be dynamically extended to provide different interfaces (or \"adapters\"). Adapters are created by adapter factories, which are in turn managed by type by adapter managers. For example, IAdaptable a = [some adaptable]; IFoo x = (IFoo)a.getAdapter(IFoo.class); if (x != null) [do IFoo things with x] This interface can be used without OSGi running. Clients may implement this interface, or obtain a default implementation of this interface by subclassing PlatformObject. See Also: IAdapterFactory, IAdapterManager, PlatformObject Interface for executable extension classes that require access to their configuration element, or implement an extension adapter. Extension adapters are typically required in cases where the extension implementation does not follow the interface rules specified by the provider of the extension point. In these cases, the role of the adapter is to map between the extension point interface, and the actual extension implementation. In general, adapters are used when attempting to plug-in existing Java implementations, or non-Java implementations (e.g., external executables). This interface can be used without OSGi running. Clients may implement this interface. See Also: IConfigurationElement.createExecutableExtension(String) Objects implementing this interface are capable of saving their state in an IMemento. Since: 3.1 An interface for an adaptable object. Adaptable objects can be dynamically extended to provide different interfaces (or \"adapters\"). Adapters are created by adapter factories, which are in turn managed by type by adapter managers. For example, IAdaptable a = [some adaptable]; IFoo x = (IFoo)a.getAdapter(IFoo.class); if (x != null) [do IFoo things with x] This interface can be used without OSGi running. Clients may implement this interface, or obtain a default implementation of this interface by subclassing PlatformObject. See Also: IAdapterFactory, IAdapterManager, PlatformObject Objects implementing this interface are capable of saving their state in an IMemento. Since: 3.1 An interface for an adaptable object. Adaptable objects can be dynamically extended to provide different interfaces (or \"adapters\"). Adapters are created by adapter factories, which are in turn managed by type by adapter managers. For example, IAdaptable a = [some adaptable]; IFoo x = (IFoo)a.getAdapter(IFoo.class); if (x != null) [do IFoo things with x] This interface can be used without OSGi running. Clients may implement this interface, or obtain a default implementation of this interface by subclassing PlatformObject. See Also: IAdapterFactory, IAdapterManager, PlatformObject extends IAdaptable A workbench part is a visual component within a workbench page. There are two subtypes: view and editor, as defined by IViewPart and IEditorPart. A view is typically used to navigate a hierarchy of information (like the workspace), open an editor, or display properties for the active editor. Modifications made in a view are saved immediately. An editor is typically used to edit or browse a document or input object. The input is identified using an IEditorInput. Modifications made in an editor part follow an open-save-close lifecycle model. This interface may be implemented directly. For convenience, a base implementation is defined in WorkbenchPart. The lifecycle of a workbench part is as follows: When a part extension is created: instantiate the part create a part site call part.init(site) When a part becomes visible in the workbench: add part to presentation by calling part.createPartControl(parent) to create actual widgets fire partOpened event to all listeners When a part is activated or gets focus: call part.setFocus() fire partActivated event to all listeners When a part is closed: if save is needed, do save; if it fails or is canceled return if part is active, deactivate part fire partClosed event to all listeners remove part from presentation; part controls are disposed as part of the SWT widget tree call part.dispose() After createPartControl has been called, the implementor may safely reference the controls created. When the part is closed these controls will be disposed as part of an SWT composite. This occurs before the IWorkbenchPart.dispose method is called. If there is a need to free SWT resources the part should define a dispose listener for its own control and free those resources from the dispose listener. If the part invokes any method on the disposed SWT controls after this point an SWTError will be thrown. The last method called on IWorkbenchPart is dispose. This signals the end of the part lifecycle. An important point to note about this lifecycle is that following a call to init, createPartControl may never be called. Thus in the dispose method, implementors must not assume controls were created. Workbench parts implement the IAdaptable interface; extensions are managed by the platform\'s adapter manager. See Also: IViewPart, IEditorPart extends IWorkbenchPart, IPersistable A view is a visual component within a workbench page. It is typically used to navigate a hierarchy of information (like the workspace), open an editor, or display properties for the active editor. Modifications made in a view are saved immediately (in contrast to an editor part, which conforms to a more elaborate open-save-close lifecycle). Only one instance of a particular view type may exist within a workbench page. This policy is designed to simplify part management for a user. This interface may be implemented directly. For convenience, a base implementation is defined in ViewPart. A view is added to the workbench in two steps: A view extension is contributed to the workbench registry. This extension defines the extension id and extension class. The view is included in the default layout for a perspective. Alternatively, the user may open the view from the Perspective menu. Views implement the IAdaptable interface; extensions are managed by the platform\'s adapter manager. As of 3.4, views may optionally adapt to ISizeProvider if they have a preferred size. The default presentation will make a best effort to allocate the preferred size to a view if it is the only part in a stack. If there is more than one part in the stack, the constraints will be disabled for that stack. The size constraints are adjusted for the size of the tab and border trim. Note that this is considered to be a hint to the presentation, and not all presentations may honor size constraints. See Also: IWorkbenchPage.showView(java.lang.String), ViewPart, ISizeProvider An interface for an adaptable object. Adaptable objects can be dynamically extended to provide different interfaces (or \"adapters\"). Adapters are created by adapter factories, which are in turn managed by type by adapter managers. For example, IAdaptable a = [some adaptable]; IFoo x = (IFoo)a.getAdapter(IFoo.class); if (x != null) [do IFoo things with x] This interface can be used without OSGi running. Clients may implement this interface, or obtain a default implementation of this interface by subclassing PlatformObject. See Also: IAdapterFactory, IAdapterManager, PlatformObject extends IAdaptable A workbench part is a visual component within a workbench page. There are two subtypes: view and editor, as defined by IViewPart and IEditorPart. A view is typically used to navigate a hierarchy of information (like the workspace), open an editor, or display properties for the active editor. Modifications made in a view are saved immediately. An editor is typically used to edit or browse a document or input object. The input is identified using an IEditorInput. Modifications made in an editor part follow an open-save-close lifecycle model. This interface may be implemented directly. For convenience, a base implementation is defined in WorkbenchPart. The lifecycle of a workbench part is as follows: When a part extension is created: instantiate the part create a part site call part.init(site) When a part becomes visible in the workbench: add part to presentation by calling part.createPartControl(parent) to create actual widgets fire partOpened event to all listeners When a part is activated or gets focus: call part.setFocus() fire partActivated event to all listeners When a part is closed: if save is needed, do save; if it fails or is canceled return if part is active, deactivate part fire partClosed event to all listeners remove part from presentation; part controls are disposed as part of the SWT widget tree call part.dispose() After createPartControl has been called, the implementor may safely reference the controls created. When the part is closed these controls will be disposed as part of an SWT composite. This occurs before the IWorkbenchPart.dispose method is called. If there is a need to free SWT resources the part should define a dispose listener for its own control and free those resources from the dispose listener. If the part invokes any method on the disposed SWT controls after this point an SWTError will be thrown. The last method called on IWorkbenchPart is dispose. This signals the end of the part lifecycle. An important point to note about this lifecycle is that following a call to init, createPartControl may never be called. Thus in the dispose method, implementors must not assume controls were created. Workbench parts implement the IAdaptable interface; extensions are managed by the platform\'s adapter manager. See Also: IViewPart, IEditorPart An interface for an adaptable object. Adaptable objects can be dynamically extended to provide different interfaces (or \"adapters\"). Adapters are created by adapter factories, which are in turn managed by type by adapter managers. For example, IAdaptable a = [some adaptable]; IFoo x = (IFoo)a.getAdapter(IFoo.class); if (x != null) [do IFoo things with x] This interface can be used without OSGi running. Clients may implement this interface, or obtain a default implementation of this interface by subclassing PlatformObject. See Also: IAdapterFactory, IAdapterManager, PlatformObject An interface for an adaptable object. Adaptable objects can be dynamically extended to provide different interfaces (or \"adapters\"). Adapters are created by adapter factories, which are in turn managed by type by adapter managers. For example, IAdaptable a = [some adaptable]; IFoo x = (IFoo)a.getAdapter(IFoo.class); if (x != null) [do IFoo things with x] This interface can be used without OSGi running. Clients may implement this interface, or obtain a default implementation of this interface by subclassing PlatformObject. See Also: IAdapterFactory, IAdapterManager, PlatformObject extends IAdaptable A workbench part is a visual component within a workbench page. There are two subtypes: view and editor, as defined by IViewPart and IEditorPart. A view is typically used to navigate a hierarchy of information (like the workspace), open an editor, or display properties for the active editor. Modifications made in a view are saved immediately. An editor is typically used to edit or browse a document or input object. The input is identified using an IEditorInput. Modifications made in an editor part follow an open-save-close lifecycle model. This interface may be implemented directly. For convenience, a base implementation is defined in WorkbenchPart. The lifecycle of a workbench part is as follows: When a part extension is created: instantiate the part create a part site call part.init(site) When a part becomes visible in the workbench: add part to presentation by calling part.createPartControl(parent) to create actual widgets fire partOpened event to all listeners When a part is activated or gets focus: call part.setFocus() fire partActivated event to all listeners When a part is closed: if save is needed, do save; if it fails or is canceled return if part is active, deactivate part fire partClosed event to all listeners remove part from presentation; part controls are disposed as part of the SWT widget tree call part.dispose() After createPartControl has been called, the implementor may safely reference the controls created. When the part is closed these controls will be disposed as part of an SWT composite. This occurs before the IWorkbenchPart.dispose method is called. If there is a need to free SWT resources the part should define a dispose listener for its own control and free those resources from the dispose listener. If the part invokes any method on the disposed SWT controls after this point an SWTError will be thrown. The last method called on IWorkbenchPart is dispose. This signals the end of the part lifecycle. An important point to note about this lifecycle is that following a call to init, createPartControl may never be called. Thus in the dispose method, implementors must not assume controls were created. Workbench parts implement the IAdaptable interface; extensions are managed by the platform\'s adapter manager. See Also: IViewPart, IEditorPart extends IWorkbenchPart Extends IWorkbenchPart, adding the name and status text properties. Prior to 3.0, a view\'s title was often modified to show both the part name and extra status text. With this interface, the distinction is made more explicit. Since: 3.0 An interface for an adaptable object. Adaptable objects can be dynamically extended to provide different interfaces (or \"adapters\"). Adapters are created by adapter factories, which are in turn managed by type by adapter managers. For example, IAdaptable a = [some adaptable]; IFoo x = (IFoo)a.getAdapter(IFoo.class); if (x != null) [do IFoo things with x] This interface can be used without OSGi running. Clients may implement this interface, or obtain a default implementation of this interface by subclassing PlatformObject. See Also: IAdapterFactory, IAdapterManager, PlatformObject An interface for an adaptable object. Adaptable objects can be dynamically extended to provide different interfaces (or \"adapters\"). Adapters are created by adapter factories, which are in turn managed by type by adapter managers. For example, IAdaptable a = [some adaptable]; IFoo x = (IFoo)a.getAdapter(IFoo.class); if (x != null) [do IFoo things with x] This interface can be used without OSGi running. Clients may implement this interface, or obtain a default implementation of this interface by subclassing PlatformObject. See Also: IAdapterFactory, IAdapterManager, PlatformObject extends IAdaptable A workbench part is a visual component within a workbench page. There are two subtypes: view and editor, as defined by IViewPart and IEditorPart. A view is typically used to navigate a hierarchy of information (like the workspace), open an editor, or display properties for the active editor. Modifications made in a view are saved immediately. An editor is typically used to edit or browse a document or input object. The input is identified using an IEditorInput. Modifications made in an editor part follow an open-save-close lifecycle model. This interface may be implemented directly. For convenience, a base implementation is defined in WorkbenchPart. The lifecycle of a workbench part is as follows: When a part extension is created: instantiate the part create a part site call part.init(site) When a part becomes visible in the workbench: add part to presentation by calling part.createPartControl(parent) to create actual widgets fire partOpened event to all listeners When a part is activated or gets focus: call part.setFocus() fire partActivated event to all listeners When a part is closed: if save is needed, do save; if it fails or is canceled return if part is active, deactivate part fire partClosed event to all listeners remove part from presentation; part controls are disposed as part of the SWT widget tree call part.dispose() After createPartControl has been called, the implementor may safely reference the controls created. When the part is closed these controls will be disposed as part of an SWT composite. This occurs before the IWorkbenchPart.dispose method is called. If there is a need to free SWT resources the part should define a dispose listener for its own control and free those resources from the dispose listener. If the part invokes any method on the disposed SWT controls after this point an SWTError will be thrown. The last method called on IWorkbenchPart is dispose. This signals the end of the part lifecycle. An important point to note about this lifecycle is that following a call to init, createPartControl may never be called. Thus in the dispose method, implementors must not assume controls were created. Workbench parts implement the IAdaptable interface; extensions are managed by the platform\'s adapter manager. See Also: IViewPart, IEditorPart extends IWorkbenchPart Extends IWorkbenchPart, adding the name and status text properties. Prior to 3.0, a view\'s title was often modified to show both the part name and extra status text. With this interface, the distinction is made more explicit. Since: 3.0 extends IWorkbenchPart2 A part can provide arbitrary properties. The properties will be persisted between sessions by the part reference, and will be available from the part reference as well as the part. The properties can only be set on a part, not on the reference. The properties will be available to the IPresentablePart. Setting a property must fire a PropertyChangeEvent. Since: 3.3 The IWorkbenchPartOrientation is the interface that defines the orientation of the part. If a type does not implement this interface an orientation of SWT.NONE will be assumed. Since: 3.1 See Also: SWT.RIGHT_TO_LEFT, SWT.LEFT_TO_RIGHT, SWT.NONE, Window.getDefaultOrientation() extends org.eclipse.ui.internal.views.markers.ExtendedMarkersView The MarkerSupportView is a view that supports the extensions in the markerSupport extension point. Since: 3.4 '
1393, 'org.eclipse.ui.IMarkerResolutionGenerator2', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/IMarkerResolutionGenerator2.html', 'Creates resolutions for a given marker. When run, a resolution would typically eliminate the need for the marker. Since: 2.0 extends IMarkerResolutionGenerator A marker resolution generator should implement this interface rather than IMarkerResolutionGenerator if it can determine whether a particular marker has any resolutions more efficiently than computing all the resolutions. Since: 2.1 '
1394, 'org.eclipse.ui.views.markers.FiltersContributionParameters', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/views/markers/FiltersContributionParameters.html', 'extends Object A MarkerFieldParameters is a class that specifies a Map of parameters to be passed to a MarkerFieldFilter. Since: 3.4 '
1395, 'org.eclipse.ui.contexts.EnabledSubmission', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/contexts/EnabledSubmission.html', 'extends Object implements Comparable An instance of this class represents a request to enabled a context. An enabled submission specifies a list of conditions under which it would be appropriate for a particular context to be enabled. These conditions include things like the active part or the active shell. So, it is possible to say things like: \"when the java editor is active, please consider enabling the \'editing java\' context\". The workbench considers all of the submissions it has received and choses the ones it views as the best possible match. This class is not intended to be extended by clients. Note: this class has a natural ordering that is inconsistent with equals. Since: 3.0 See Also: IWorkbenchContextSupport, IContextService '
1396, 'org.eclipse.ui.contexts.IContext', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/contexts/IContext.html', 'extends Comparable An instance of this interface is an context as defined by the extension point org.eclipse.ui.contexts. An instance of this interface can be obtained from an instance of IContextManager for any identifier, whether or not an context with that identifier is defined in the extension registry. The handle-based nature of this API allows it to work well with runtime plugin activation and deactivation. If a context is defined, that means that its corresponding plug-in is active. If the plug-in is then deactivated, the context will still exist but it will be undefined. An attempts to use an undefined context will result in a NotDefinedException being thrown. This interface is not intended to be extended or implemented by clients. Since: 3.0 See Also: IContextManager, Context Restriction: This interface is not intended to be implemented by clients. '
1397, 'org.eclipse.ui.part.MessagePage', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/part/MessagePage.html', 'extends IPage Interface for a page in a pagebook view. Pages should implement this interface. See Also: PageBookView, Page extends Page A message page display a message in a pagebook view. This class may be instantiated; it is not intended to be subclassed. See Also: PageBookView Restriction: This class is not intended to be subclassed by clients. '
1398, 'org.eclipse.ui.contexts.IContextManager', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/contexts/IContextManager.html', ' A context manager tracks the sets of defined and enabled contexts within the application. The manager sends notification events to listeners when these sets change. It is also possible to retrieve any given context with its identifier. This interface is not intended to be extended or implemented by clients. Since: 3.0 See Also: ContextManager Restriction: This interface is not intended to be implemented by clients. '
1399, 'org.eclipse.ui.fieldassist.ContentAssistCommandAdapter', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/fieldassist/ContentAssistCommandAdapter.html', 'extends ContentProposalAdapter ContentAssistCommandAdapter extends ContentProposalAdapter to invoke content proposals using a specified Command. The ability to specify a KeyStroke that explicitly invokes content proposals is hidden by this class, and instead the String id of a command is used. If no command id is specified by the client, then the default workbench content assist command is used. As of 3.3, ContentAssistCommandAdapter can be optionally configured to install the content assist decoration on its control. This class is not intended to be subclassed. Since: 3.2 '
1400, 'org.eclipse.ui.part.EditorActionBarContributor', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/part/EditorActionBarContributor.html', 'A editor action bar contributor defines the actions for one or more editors. Within the workbench there may be more than one open editor of a particular type. For instance, there may be 1 or more open Java Editors. To avoid the creation of duplicate actions and action images the editor concept has been split into two. An action contributor is responsible for the creation of actions. The editor is responsible for action implementation. Furthermore, the contributor is shared by each open editor. As a result of this design there is only 1 set of actions for 1 or more open editors. The relationship between editor and contributor is defined by the org.eclipse.ui.editors extension point in the plugin registry. This interface should not be implemented directly. An implementation of this interface has been created in EditorActionBarContributor. Implementors should subclass this and specialize as required. See Also: IEditorActionBarContributor extends Object implements IEditorActionBarContributor Standard implementation of IEditorActionBarContributor. If instantiated and used as-is, nothing is contribututed. Clients should subclass in order to contribute to some or all of the action bars. Subclasses may reimplement the following methods: contributeToMenu - reimplement to contribute to menu contributeToToolBar - reimplement to contribute to tool bar contributeToStatusLine - reimplement to contribute to status line setActiveEditor - reimplement to react to editor changes '
1401, 'org.eclipse.ui.handlers.RegistryRadioState', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/handlers/RegistryRadioState.html', 'Interface for executable extension classes that require access to their configuration element, or implement an extension adapter. Extension adapters are typically required in cases where the extension implementation does not follow the interface rules specified by the provider of the extension point. In these cases, the role of the adapter is to map between the extension point interface, and the actual extension implementation. In general, adapters are used when attempting to plug-in existing Java implementations, or non-Java implementations (e.g., external executables). This interface can be used without OSGi running. Clients may implement this interface. See Also: IConfigurationElement.createExecutableExtension(String) extends RadioState implements IExecutableExtension A radio state that can be read from the registry. This stores a piece of boolean state information that is grouped with other boolean state to form a radio group. In a single radio group, there can be at most one state who value is Boolean.TRUE all the others must be Boolean.FALSE. When parsing from the registry, this state understands three parameters: default, which is the default value for this item; persisted, which is whether the state should be persisted between sessions; id, which is the identifier of the group to which this radio handler belongs. The default parameter defaults to false, and the persisted parameter defaults to true. If only one parameter is passed (i.e., using the class name followed by a colon), then it is assumed to be the id parameter. The id is required for this class to function properly. Clients may instantiate this class, but must not extend. Since: 3.2 '
1402, 'org.eclipse.ui.commands.ActionHandler', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/commands/ActionHandler.html', 'A handler is the pluggable piece of a command that handles execution. Each command can have zero or more handlers associated with it (in general), of which only one will be active at any given moment in time. When the command is asked to execute, it will simply pass that request on to its active handler, if any. This interface is not intended to be extended by clients. Since: 3.0 See Also: IHandler extends AbstractHandler This class adapts instances of IAction to IHandler. Since: 3.0 See Also: ActionHandler '
1403, 'org.eclipse.ui.views.properties.ComboBoxPropertyDescriptor', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/views/properties/ComboBoxPropertyDescriptor.html', 'A descriptor for a property to be presented by a standard property sheet page (PropertySheetPage). These descriptors originate with property sources (IPropertySource). A property descriptor carries the following information: property id (required) display name (required) brief description of the property (optional) category for grouping related properties (optional) label provider used to display the property value (optional) cell editor for changing the property value (optional) help context id (optional) Clients may implement this interface to provide specialized property descriptors; however, there are standard implementations declared in this package that take care of the most common cases: PropertyDescriptor - read-only property TextPropertyDescriptor - edits with a TextCellEditor CheckboxPropertyDescriptor - edits with a CheckboxCellEditor ComboBoxPropertyDescriptor - edits with a ComboBoxCellEditor ColorPropertyDescriptor - edits with a ColorCellEditor See Also: IPropertySource.getPropertyDescriptors() extends PropertyDescriptor Descriptor for a property that has a value which should be edited with a combo box cell editor. This class provides a default ILabelProvider that will render the label of the given descriptor as the String found in the labels array at the currently selected index. The value of the property is a 0-based Integer index into the labels array. This class may be instantiated; it is not intended to be subclassed. Example: String[] values = {\"Top left\", \"Top right\", \"Bottom left\", \"Bottom right\"}; IPropertyDescriptor pd = new ComboBoxPropertyDescriptor(\"origin\", \"Origin\", values); Restriction: This class is not intended to be subclassed by clients. '
1404, 'org.eclipse.ui.views.properties.ComboBoxLabelProvider', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/views/properties/ComboBoxLabelProvider.html', 'A label provider maps an element of the viewer\'s model to an optional image and optional text string used to display the element in the viewer\'s control. Certain label providers may allow multiple labels per element. This is an \"abstract interface\", defining methods common to all label providers, but does not actually define the methods to get the label(s) for an element. This interface should never be directly implemented. Most viewers will take either an ILabelProvider or an ITableLabelProvider. A label provider must not be shared between viewers since a label provider generally manages SWT resources (images), which must be disposed when the viewer is disposed. To simplify life cycle management, the current label provider of a viewer is disposed when the viewer is disposed. Label providers can be used outside the context of viewers wherever images are needed. When label providers are used in this fashion it is the responsibility of the user to ensure dispose is called when the provider is no longer needed. See Also: ILabelProvider, ITableLabelProvider A label provider maps an element of the viewer\'s model to an optional image and optional text string used to display the element in the viewer\'s control. Certain label providers may allow multiple labels per element. This is an \"abstract interface\", defining methods common to all label providers, but does not actually define the methods to get the label(s) for an element. This interface should never be directly implemented. Most viewers will take either an ILabelProvider or an ITableLabelProvider. A label provider must not be shared between viewers since a label provider generally manages SWT resources (images), which must be disposed when the viewer is disposed. To simplify life cycle management, the current label provider of a viewer is disposed when the viewer is disposed. Label providers can be used outside the context of viewers wherever images are needed. When label providers are used in this fashion it is the responsibility of the user to ensure dispose is called when the provider is no longer needed. See Also: ILabelProvider, ITableLabelProvider extends IBaseLabelProvider Extends IBaseLabelProvider with the methods to provide the text and/or image for the label of a given element. Used by most structured viewers, except table viewers. extends LabelProvider An ILabelProvider that assists in rendering labels for ComboBoxPropertyDescriptors. The label for a given Integer value is the String at the value in the provided values array. Since: 3.0 '
1405, 'org.eclipse.ui.views.properties.NewPropertySheetHandler', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/views/properties/NewPropertySheetHandler.html', 'A handler is the pluggable piece of a command that handles execution. Each command can have zero or more handlers associated with it (in general), of which only one will be active at any given moment in time. When the command is asked to execute, it will simply pass that request on to its active handler, if any. Since: 3.1 See Also: AbstractHandler A handler is the pluggable piece of a command that handles execution. Each command can have zero or more handlers associated with it (in general), of which only one will be active at any given moment in time. When the command is asked to execute, it will simply pass that request on to its active handler, if any. Since: 3.1 See Also: AbstractHandler extends IHandler Extend the IHandler interface to provide some context for isEnabled() requests. Clients should use AbstractHandler unless they need to provide their own listener mechanism. Since: 3.4 See Also: AbstractHandler extends AbstractHandler Since: 3.4 '
1406, 'org.eclipse.ui.keys.SWTKeySupport', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/keys/SWTKeySupport.html', 'extends Object A utility class for converting SWT events into key strokes. Since: 3.0 '
1407, 'org.eclipse.ui.texteditor.AbstractTextEditor', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/texteditor/AbstractTextEditor.html', 'An interface for an adaptable object. Adaptable objects can be dynamically extended to provide different interfaces (or \"adapters\"). Adapters are created by adapter factories, which are in turn managed by type by adapter managers. For example, IAdaptable a = [some adaptable]; IFoo x = (IFoo)a.getAdapter(IFoo.class); if (x != null) [do IFoo things with x] This interface can be used without OSGi running. Clients may implement this interface, or obtain a default implementation of this interface by subclassing PlatformObject. See Also: IAdapterFactory, IAdapterManager, PlatformObject Interface for executable extension classes that require access to their configuration element, or implement an extension adapter. Extension adapters are typically required in cases where the extension implementation does not follow the interface rules specified by the provider of the extension point. In these cases, the role of the adapter is to map between the extension point interface, and the actual extension implementation. In general, adapters are used when attempting to plug-in existing Java implementations, or non-Java implementations (e.g., external executables). This interface can be used without OSGi running. Clients may implement this interface. See Also: IConfigurationElement.createExecutableExtension(String) An interface for an adaptable object. Adaptable objects can be dynamically extended to provide different interfaces (or \"adapters\"). Adapters are created by adapter factories, which are in turn managed by type by adapter managers. For example, IAdaptable a = [some adaptable]; IFoo x = (IFoo)a.getAdapter(IFoo.class); if (x != null) [do IFoo things with x] This interface can be used without OSGi running. Clients may implement this interface, or obtain a default implementation of this interface by subclassing PlatformObject. See Also: IAdapterFactory, IAdapterManager, PlatformObject Workbench parts implement or adapt to this interface to participate in the enablement and execution of the Save and Save As actions. Since: 2.1 See Also: IEditorPart An interface for an adaptable object. Adaptable objects can be dynamically extended to provide different interfaces (or \"adapters\"). Adapters are created by adapter factories, which are in turn managed by type by adapter managers. For example, IAdaptable a = [some adaptable]; IFoo x = (IFoo)a.getAdapter(IFoo.class); if (x != null) [do IFoo things with x] This interface can be used without OSGi running. Clients may implement this interface, or obtain a default implementation of this interface by subclassing PlatformObject. See Also: IAdapterFactory, IAdapterManager, PlatformObject extends IAdaptable A workbench part is a visual component within a workbench page. There are two subtypes: view and editor, as defined by IViewPart and IEditorPart. A view is typically used to navigate a hierarchy of information (like the workspace), open an editor, or display properties for the active editor. Modifications made in a view are saved immediately. An editor is typically used to edit or browse a document or input object. The input is identified using an IEditorInput. Modifications made in an editor part follow an open-save-close lifecycle model. This interface may be implemented directly. For convenience, a base implementation is defined in WorkbenchPart. The lifecycle of a workbench part is as follows: When a part extension is created: instantiate the part create a part site call part.init(site) When a part becomes visible in the workbench: add part to presentation by calling part.createPartControl(parent) to create actual widgets fire partOpened event to all listeners When a part is activated or gets focus: call part.setFocus() fire partActivated event to all listeners When a part is closed: if save is needed, do save; if it fails or is canceled return if part is active, deactivate part fire partClosed event to all listeners remove part from presentation; part controls are disposed as part of the SWT widget tree call part.dispose() After createPartControl has been called, the implementor may safely reference the controls created. When the part is closed these controls will be disposed as part of an SWT composite. This occurs before the IWorkbenchPart.dispose method is called. If there is a need to free SWT resources the part should define a dispose listener for its own control and free those resources from the dispose listener. If the part invokes any method on the disposed SWT controls after this point an SWTError will be thrown. The last method called on IWorkbenchPart is dispose. This signals the end of the part lifecycle. An important point to note about this lifecycle is that following a call to init, createPartControl may never be called. Thus in the dispose method, implementors must not assume controls were created. Workbench parts implement the IAdaptable interface; extensions are managed by the platform\'s adapter manager. See Also: IViewPart, IEditorPart extends IWorkbenchPart, ISaveablePart An editor is a visual component within a workbench page. It is typically used to edit or browse a document or input object. The input is identified using an IEditorInput. Modifications made in an editor part follow an open-save-close lifecycle model (in contrast to a view part, where modifications are saved to the workbench immediately). An editor is document or input-centric. Each editor has an input, and only one editor can exist for each editor input within a page. This policy has been designed to simplify part management. An editor should be used in place of a view whenever more than one instance of a document type can exist. This interface may be implemented directly. For convenience, a base implementation is defined in EditorPart. An editor part is added to the workbench in two stages: An editor extension is contributed to the workbench registry. This extension defines the extension id, extension class, and the file extensions which are supported by the editor. An editor part based upon the extension is created and added to the workbench when the user opens a file with one of the supported file extensions (or some other suitable form of editor input). All editor parts implement the IAdaptable interface; extensions are managed by the platform\'s adapter manager. See Also: IWorkbenchPage.openEditor(IEditorInput, String), EditorPart Should be implemented by editors that wish to contribute to the navigation history. The message createNavigationLocation will be sent when a new location is marked in the history. Since: 2.1 Objects implementing this interface are capable of saving their state in an IMemento. Since: 3.1 Objects implementing this interface are capable of saving their state in an IMemento. Since: 3.1 extends IPersistable An editor can implement this interface and participate in the workbench session save/restore cycle using IMemento, similar to how IViewPart currently works. Refer to IWorkbenchPart for the part lifecycle. If a memento is available, restoreState(*) will be inserted into the editor startup. editor.init(site, input) editor.restoreState(memento) editor.createPartControl(parent) ... On workbench shutdown, the editor state will be persisted when the editor references are saved. Since: 3.3 An interface for an adaptable object. Adaptable objects can be dynamically extended to provide different interfaces (or \"adapters\"). Adapters are created by adapter factories, which are in turn managed by type by adapter managers. For example, IAdaptable a = [some adaptable]; IFoo x = (IFoo)a.getAdapter(IFoo.class); if (x != null) [do IFoo things with x] This interface can be used without OSGi running. Clients may implement this interface, or obtain a default implementation of this interface by subclassing PlatformObject. See Also: IAdapterFactory, IAdapterManager, PlatformObject An interface for an adaptable object. Adaptable objects can be dynamically extended to provide different interfaces (or \"adapters\"). Adapters are created by adapter factories, which are in turn managed by type by adapter managers. For example, IAdaptable a = [some adaptable]; IFoo x = (IFoo)a.getAdapter(IFoo.class); if (x != null) [do IFoo things with x] This interface can be used without OSGi running. Clients may implement this interface, or obtain a default implementation of this interface by subclassing PlatformObject. See Also: IAdapterFactory, IAdapterManager, PlatformObject Workbench parts implement or adapt to this interface to participate in the enablement and execution of the Save and Save As actions. Since: 2.1 See Also: IEditorPart An interface for an adaptable object. Adaptable objects can be dynamically extended to provide different interfaces (or \"adapters\"). Adapters are created by adapter factories, which are in turn managed by type by adapter managers. For example, IAdaptable a = [some adaptable]; IFoo x = (IFoo)a.getAdapter(IFoo.class); if (x != null) [do IFoo things with x] This interface can be used without OSGi running. Clients may implement this interface, or obtain a default implementation of this interface by subclassing PlatformObject. See Also: IAdapterFactory, IAdapterManager, PlatformObject extends IAdaptable A workbench part is a visual component within a workbench page. There are two subtypes: view and editor, as defined by IViewPart and IEditorPart. A view is typically used to navigate a hierarchy of information (like the workspace), open an editor, or display properties for the active editor. Modifications made in a view are saved immediately. An editor is typically used to edit or browse a document or input object. The input is identified using an IEditorInput. Modifications made in an editor part follow an open-save-close lifecycle model. This interface may be implemented directly. For convenience, a base implementation is defined in WorkbenchPart. The lifecycle of a workbench part is as follows: When a part extension is created: instantiate the part create a part site call part.init(site) When a part becomes visible in the workbench: add part to presentation by calling part.createPartControl(parent) to create actual widgets fire partOpened event to all listeners When a part is activated or gets focus: call part.setFocus() fire partActivated event to all listeners When a part is closed: if save is needed, do save; if it fails or is canceled return if part is active, deactivate part fire partClosed event to all listeners remove part from presentation; part controls are disposed as part of the SWT widget tree call part.dispose() After createPartControl has been called, the implementor may safely reference the controls created. When the part is closed these controls will be disposed as part of an SWT composite. This occurs before the IWorkbenchPart.dispose method is called. If there is a need to free SWT resources the part should define a dispose listener for its own control and free those resources from the dispose listener. If the part invokes any method on the disposed SWT controls after this point an SWTError will be thrown. The last method called on IWorkbenchPart is dispose. This signals the end of the part lifecycle. An important point to note about this lifecycle is that following a call to init, createPartControl may never be called. Thus in the dispose method, implementors must not assume controls were created. Workbench parts implement the IAdaptable interface; extensions are managed by the platform\'s adapter manager. See Also: IViewPart, IEditorPart extends IWorkbenchPart, ISaveablePart An editor is a visual component within a workbench page. It is typically used to edit or browse a document or input object. The input is identified using an IEditorInput. Modifications made in an editor part follow an open-save-close lifecycle model (in contrast to a view part, where modifications are saved to the workbench immediately). An editor is document or input-centric. Each editor has an input, and only one editor can exist for each editor input within a page. This policy has been designed to simplify part management. An editor should be used in place of a view whenever more than one instance of a document type can exist. This interface may be implemented directly. For convenience, a base implementation is defined in EditorPart. An editor part is added to the workbench in two stages: An editor extension is contributed to the workbench registry. This extension defines the extension id, extension class, and the file extensions which are supported by the editor. An editor part based upon the extension is created and added to the workbench when the user opens a file with one of the supported file extensions (or some other suitable form of editor input). All editor parts implement the IAdaptable interface; extensions are managed by the platform\'s adapter manager. See Also: IWorkbenchPage.openEditor(IEditorInput, String), EditorPart Workbench parts implement or adapt to this interface to participate in the enablement and execution of the Save and Save As actions. Since: 2.1 See Also: IEditorPart An interface for an adaptable object. Adaptable objects can be dynamically extended to provide different interfaces (or \"adapters\"). Adapters are created by adapter factories, which are in turn managed by type by adapter managers. For example, IAdaptable a = [some adaptable]; IFoo x = (IFoo)a.getAdapter(IFoo.class); if (x != null) [do IFoo things with x] This interface can be used without OSGi running. Clients may implement this interface, or obtain a default implementation of this interface by subclassing PlatformObject. See Also: IAdapterFactory, IAdapterManager, PlatformObject extends IAdaptable A workbench part is a visual component within a workbench page. There are two subtypes: view and editor, as defined by IViewPart and IEditorPart. A view is typically used to navigate a hierarchy of information (like the workspace), open an editor, or display properties for the active editor. Modifications made in a view are saved immediately. An editor is typically used to edit or browse a document or input object. The input is identified using an IEditorInput. Modifications made in an editor part follow an open-save-close lifecycle model. This interface may be implemented directly. For convenience, a base implementation is defined in WorkbenchPart. The lifecycle of a workbench part is as follows: When a part extension is created: instantiate the part create a part site call part.init(site) When a part becomes visible in the workbench: add part to presentation by calling part.createPartControl(parent) to create actual widgets fire partOpened event to all listeners When a part is activated or gets focus: call part.setFocus() fire partActivated event to all listeners When a part is closed: if save is needed, do save; if it fails or is canceled return if part is active, deactivate part fire partClosed event to all listeners remove part from presentation; part controls are disposed as part of the SWT widget tree call part.dispose() After createPartControl has been called, the implementor may safely reference the controls created. When the part is closed these controls will be disposed as part of an SWT composite. This occurs before the IWorkbenchPart.dispose method is called. If there is a need to free SWT resources the part should define a dispose listener for its own control and free those resources from the dispose listener. If the part invokes any method on the disposed SWT controls after this point an SWTError will be thrown. The last method called on IWorkbenchPart is dispose. This signals the end of the part lifecycle. An important point to note about this lifecycle is that following a call to init, createPartControl may never be called. Thus in the dispose method, implementors must not assume controls were created. Workbench parts implement the IAdaptable interface; extensions are managed by the platform\'s adapter manager. See Also: IViewPart, IEditorPart extends IEditorPart Interface for reusable editors. An editors may support changing its input so that the workbench may change its contents instead of opening a new editor. Workbench parts implement or adapt to this interface to participate in the enablement and execution of the Save and Save As actions. Since: 2.1 See Also: IEditorPart Represents a source of Saveable objects (units of saveability). Workbench parts that show more than one unit of saveability, or whose units of saveability change over time, should implement this interface in order to provide better integration with workbench facilities like the Save command, prompts to save on part close or shutdown, etc. IMPORTANT: As of 3.2, implementers of ISaveablesSource must satisfy the following conditions: If ISaveablesSource is implemented by an IWorkbenchPart: the part must implement ISaveablePart if any of its Saveable objects are dirty, the part must return true from ISaveablePart.isDirty() the part must return true from ISaveablePart.isSaveOnCloseNeeded() if it is dirty (the default behaviour implemented by EditorPart) the part must not implement ISaveablePart2 If ISaveablesSource is implemented by a non-part (possible as of 3.2.1 and 3.3): the Workbench\'s ISaveablesLifecycleListener (obtained from the Workbench by calling workbench.getService(ISaveablesLifecycleListener.class)) must be notified of any change to the result of getSaveables() getActiveSaveables() should be implemented to return an empty array If any of these conditions are not met, it is undefined whether the Workbench will prompt to save dirty Saveables when closing parts or the Workbench. These conditions may be relaxed in future releases. Since: 3.2 An interface for an adaptable object. Adaptable objects can be dynamically extended to provide different interfaces (or \"adapters\"). Adapters are created by adapter factories, which are in turn managed by type by adapter managers. For example, IAdaptable a = [some adaptable]; IFoo x = (IFoo)a.getAdapter(IFoo.class); if (x != null) [do IFoo things with x] This interface can be used without OSGi running. Clients may implement this interface, or obtain a default implementation of this interface by subclassing PlatformObject. See Also: IAdapterFactory, IAdapterManager, PlatformObject extends IAdaptable A workbench part is a visual component within a workbench page. There are two subtypes: view and editor, as defined by IViewPart and IEditorPart. A view is typically used to navigate a hierarchy of information (like the workspace), open an editor, or display properties for the active editor. Modifications made in a view are saved immediately. An editor is typically used to edit or browse a document or input object. The input is identified using an IEditorInput. Modifications made in an editor part follow an open-save-close lifecycle model. This interface may be implemented directly. For convenience, a base implementation is defined in WorkbenchPart. The lifecycle of a workbench part is as follows: When a part extension is created: instantiate the part create a part site call part.init(site) When a part becomes visible in the workbench: add part to presentation by calling part.createPartControl(parent) to create actual widgets fire partOpened event to all listeners When a part is activated or gets focus: call part.setFocus() fire partActivated event to all listeners When a part is closed: if save is needed, do save; if it fails or is canceled return if part is active, deactivate part fire partClosed event to all listeners remove part from presentation; part controls are disposed as part of the SWT widget tree call part.dispose() After createPartControl has been called, the implementor may safely reference the controls created. When the part is closed these controls will be disposed as part of an SWT composite. This occurs before the IWorkbenchPart.dispose method is called. If there is a need to free SWT resources the part should define a dispose listener for its own control and free those resources from the dispose listener. If the part invokes any method on the disposed SWT controls after this point an SWTError will be thrown. The last method called on IWorkbenchPart is dispose. This signals the end of the part lifecycle. An important point to note about this lifecycle is that following a call to init, createPartControl may never be called. Thus in the dispose method, implementors must not assume controls were created. Workbench parts implement the IAdaptable interface; extensions are managed by the platform\'s adapter manager. See Also: IViewPart, IEditorPart An interface for an adaptable object. Adaptable objects can be dynamically extended to provide different interfaces (or \"adapters\"). Adapters are created by adapter factories, which are in turn managed by type by adapter managers. For example, IAdaptable a = [some adaptable]; IFoo x = (IFoo)a.getAdapter(IFoo.class); if (x != null) [do IFoo things with x] This interface can be used without OSGi running. Clients may implement this interface, or obtain a default implementation of this interface by subclassing PlatformObject. See Also: IAdapterFactory, IAdapterManager, PlatformObject An interface for an adaptable object. Adaptable objects can be dynamically extended to provide different interfaces (or \"adapters\"). Adapters are created by adapter factories, which are in turn managed by type by adapter managers. For example, IAdaptable a = [some adaptable]; IFoo x = (IFoo)a.getAdapter(IFoo.class); if (x != null) [do IFoo things with x] This interface can be used without OSGi running. Clients may implement this interface, or obtain a default implementation of this interface by subclassing PlatformObject. See Also: IAdapterFactory, IAdapterManager, PlatformObject extends IAdaptable A workbench part is a visual component within a workbench page. There are two subtypes: view and editor, as defined by IViewPart and IEditorPart. A view is typically used to navigate a hierarchy of information (like the workspace), open an editor, or display properties for the active editor. Modifications made in a view are saved immediately. An editor is typically used to edit or browse a document or input object. The input is identified using an IEditorInput. Modifications made in an editor part follow an open-save-close lifecycle model. This interface may be implemented directly. For convenience, a base implementation is defined in WorkbenchPart. The lifecycle of a workbench part is as follows: When a part extension is created: instantiate the part create a part site call part.init(site) When a part becomes visible in the workbench: add part to presentation by calling part.createPartControl(parent) to create actual widgets fire partOpened event to all listeners When a part is activated or gets focus: call part.setFocus() fire partActivated event to all listeners When a part is closed: if save is needed, do save; if it fails or is canceled return if part is active, deactivate part fire partClosed event to all listeners remove part from presentation; part controls are disposed as part of the SWT widget tree call part.dispose() After createPartControl has been called, the implementor may safely reference the controls created. When the part is closed these controls will be disposed as part of an SWT composite. This occurs before the IWorkbenchPart.dispose method is called. If there is a need to free SWT resources the part should define a dispose listener for its own control and free those resources from the dispose listener. If the part invokes any method on the disposed SWT controls after this point an SWTError will be thrown. The last method called on IWorkbenchPart is dispose. This signals the end of the part lifecycle. An important point to note about this lifecycle is that following a call to init, createPartControl may never be called. Thus in the dispose method, implementors must not assume controls were created. Workbench parts implement the IAdaptable interface; extensions are managed by the platform\'s adapter manager. See Also: IViewPart, IEditorPart extends IWorkbenchPart Extends IWorkbenchPart, adding the name and status text properties. Prior to 3.0, a view\'s title was often modified to show both the part name and extra status text. With this interface, the distinction is made more explicit. Since: 3.0 An interface for an adaptable object. Adaptable objects can be dynamically extended to provide different interfaces (or \"adapters\"). Adapters are created by adapter factories, which are in turn managed by type by adapter managers. For example, IAdaptable a = [some adaptable]; IFoo x = (IFoo)a.getAdapter(IFoo.class); if (x != null) [do IFoo things with x] This interface can be used without OSGi running. Clients may implement this interface, or obtain a default implementation of this interface by subclassing PlatformObject. See Also: IAdapterFactory, IAdapterManager, PlatformObject An interface for an adaptable object. Adaptable objects can be dynamically extended to provide different interfaces (or \"adapters\"). Adapters are created by adapter factories, which are in turn managed by type by adapter managers. For example, IAdaptable a = [some adaptable]; IFoo x = (IFoo)a.getAdapter(IFoo.class); if (x != null) [do IFoo things with x] This interface can be used without OSGi running. Clients may implement this interface, or obtain a default implementation of this interface by subclassing PlatformObject. See Also: IAdapterFactory, IAdapterManager, PlatformObject extends IAdaptable A workbench part is a visual component within a workbench page. There are two subtypes: view and editor, as defined by IViewPart and IEditorPart. A view is typically used to navigate a hierarchy of information (like the workspace), open an editor, or display properties for the active editor. Modifications made in a view are saved immediately. An editor is typically used to edit or browse a document or input object. The input is identified using an IEditorInput. Modifications made in an editor part follow an open-save-close lifecycle model. This interface may be implemented directly. For convenience, a base implementation is defined in WorkbenchPart. The lifecycle of a workbench part is as follows: When a part extension is created: instantiate the part create a part site call part.init(site) When a part becomes visible in the workbench: add part to presentation by calling part.createPartControl(parent) to create actual widgets fire partOpened event to all listeners When a part is activated or gets focus: call part.setFocus() fire partActivated event to all listeners When a part is closed: if save is needed, do save; if it fails or is canceled return if part is active, deactivate part fire partClosed event to all listeners remove part from presentation; part controls are disposed as part of the SWT widget tree call part.dispose() After createPartControl has been called, the implementor may safely reference the controls created. When the part is closed these controls will be disposed as part of an SWT composite. This occurs before the IWorkbenchPart.dispose method is called. If there is a need to free SWT resources the part should define a dispose listener for its own control and free those resources from the dispose listener. If the part invokes any method on the disposed SWT controls after this point an SWTError will be thrown. The last method called on IWorkbenchPart is dispose. This signals the end of the part lifecycle. An important point to note about this lifecycle is that following a call to init, createPartControl may never be called. Thus in the dispose method, implementors must not assume controls were created. Workbench parts implement the IAdaptable interface; extensions are managed by the platform\'s adapter manager. See Also: IViewPart, IEditorPart extends IWorkbenchPart Extends IWorkbenchPart, adding the name and status text properties. Prior to 3.0, a view\'s title was often modified to show both the part name and extra status text. With this interface, the distinction is made more explicit. Since: 3.0 extends IWorkbenchPart2 A part can provide arbitrary properties. The properties will be persisted between sessions by the part reference, and will be available from the part reference as well as the part. The properties can only be set on a part, not on the reference. The properties will be available to the IPresentablePart. Setting a property must fire a PropertyChangeEvent. Since: 3.3 The IWorkbenchPartOrientation is the interface that defines the orientation of the part. If a type does not implement this interface an orientation of SWT.NONE will be assumed. Since: 3.1 See Also: SWT.RIGHT_TO_LEFT, SWT.LEFT_TO_RIGHT, SWT.NONE, Window.getDefaultOrientation() An interface for an adaptable object. Adaptable objects can be dynamically extended to provide different interfaces (or \"adapters\"). Adapters are created by adapter factories, which are in turn managed by type by adapter managers. For example, IAdaptable a = [some adaptable]; IFoo x = (IFoo)a.getAdapter(IFoo.class); if (x != null) [do IFoo things with x] This interface can be used without OSGi running. Clients may implement this interface, or obtain a default implementation of this interface by subclassing PlatformObject. See Also: IAdapterFactory, IAdapterManager, PlatformObject An interface for an adaptable object. Adaptable objects can be dynamically extended to provide different interfaces (or \"adapters\"). Adapters are created by adapter factories, which are in turn managed by type by adapter managers. For example, IAdaptable a = [some adaptable]; IFoo x = (IFoo)a.getAdapter(IFoo.class); if (x != null) [do IFoo things with x] This interface can be used without OSGi running. Clients may implement this interface, or obtain a default implementation of this interface by subclassing PlatformObject. See Also: IAdapterFactory, IAdapterManager, PlatformObject Workbench parts implement or adapt to this interface to participate in the enablement and execution of the Save and Save As actions. Since: 2.1 See Also: IEditorPart An interface for an adaptable object. Adaptable objects can be dynamically extended to provide different interfaces (or \"adapters\"). Adapters are created by adapter factories, which are in turn managed by type by adapter managers. For example, IAdaptable a = [some adaptable]; IFoo x = (IFoo)a.getAdapter(IFoo.class); if (x != null) [do IFoo things with x] This interface can be used without OSGi running. Clients may implement this interface, or obtain a default implementation of this interface by subclassing PlatformObject. See Also: IAdapterFactory, IAdapterManager, PlatformObject extends IAdaptable A workbench part is a visual component within a workbench page. There are two subtypes: view and editor, as defined by IViewPart and IEditorPart. A view is typically used to navigate a hierarchy of information (like the workspace), open an editor, or display properties for the active editor. Modifications made in a view are saved immediately. An editor is typically used to edit or browse a document or input object. The input is identified using an IEditorInput. Modifications made in an editor part follow an open-save-close lifecycle model. This interface may be implemented directly. For convenience, a base implementation is defined in WorkbenchPart. The lifecycle of a workbench part is as follows: When a part extension is created: instantiate the part create a part site call part.init(site) When a part becomes visible in the workbench: add part to presentation by calling part.createPartControl(parent) to create actual widgets fire partOpened event to all listeners When a part is activated or gets focus: call part.setFocus() fire partActivated event to all listeners When a part is closed: if save is needed, do save; if it fails or is canceled return if part is active, deactivate part fire partClosed event to all listeners remove part from presentation; part controls are disposed as part of the SWT widget tree call part.dispose() After createPartControl has been called, the implementor may safely reference the controls created. When the part is closed these controls will be disposed as part of an SWT composite. This occurs before the IWorkbenchPart.dispose method is called. If there is a need to free SWT resources the part should define a dispose listener for its own control and free those resources from the dispose listener. If the part invokes any method on the disposed SWT controls after this point an SWTError will be thrown. The last method called on IWorkbenchPart is dispose. This signals the end of the part lifecycle. An important point to note about this lifecycle is that following a call to init, createPartControl may never be called. Thus in the dispose method, implementors must not assume controls were created. Workbench parts implement the IAdaptable interface; extensions are managed by the platform\'s adapter manager. See Also: IViewPart, IEditorPart extends IWorkbenchPart, ISaveablePart An editor is a visual component within a workbench page. It is typically used to edit or browse a document or input object. The input is identified using an IEditorInput. Modifications made in an editor part follow an open-save-close lifecycle model (in contrast to a view part, where modifications are saved to the workbench immediately). An editor is document or input-centric. Each editor has an input, and only one editor can exist for each editor input within a page. This policy has been designed to simplify part management. An editor should be used in place of a view whenever more than one instance of a document type can exist. This interface may be implemented directly. For convenience, a base implementation is defined in EditorPart. An editor part is added to the workbench in two stages: An editor extension is contributed to the workbench registry. This extension defines the extension id, extension class, and the file extensions which are supported by the editor. An editor part based upon the extension is created and added to the workbench when the user opens a file with one of the supported file extensions (or some other suitable form of editor input). All editor parts implement the IAdaptable interface; extensions are managed by the platform\'s adapter manager. See Also: IWorkbenchPage.openEditor(IEditorInput, String), EditorPart Workbench parts implement or adapt to this interface to participate in the enablement and execution of the Save and Save As actions. Since: 2.1 See Also: IEditorPart An interface for an adaptable object. Adaptable objects can be dynamically extended to provide different interfaces (or \"adapters\"). Adapters are created by adapter factories, which are in turn managed by type by adapter managers. For example, IAdaptable a = [some adaptable]; IFoo x = (IFoo)a.getAdapter(IFoo.class); if (x != null) [do IFoo things with x] This interface can be used without OSGi running. Clients may implement this interface, or obtain a default implementation of this interface by subclassing PlatformObject. See Also: IAdapterFactory, IAdapterManager, PlatformObject extends IAdaptable A workbench part is a visual component within a workbench page. There are two subtypes: view and editor, as defined by IViewPart and IEditorPart. A view is typically used to navigate a hierarchy of information (like the workspace), open an editor, or display properties for the active editor. Modifications made in a view are saved immediately. An editor is typically used to edit or browse a document or input object. The input is identified using an IEditorInput. Modifications made in an editor part follow an open-save-close lifecycle model. This interface may be implemented directly. For convenience, a base implementation is defined in WorkbenchPart. The lifecycle of a workbench part is as follows: When a part extension is created: instantiate the part create a part site call part.init(site) When a part becomes visible in the workbench: add part to presentation by calling part.createPartControl(parent) to create actual widgets fire partOpened event to all listeners When a part is activated or gets focus: call part.setFocus() fire partActivated event to all listeners When a part is closed: if save is needed, do save; if it fails or is canceled return if part is active, deactivate part fire partClosed event to all listeners remove part from presentation; part controls are disposed as part of the SWT widget tree call part.dispose() After createPartControl has been called, the implementor may safely reference the controls created. When the part is closed these controls will be disposed as part of an SWT composite. This occurs before the IWorkbenchPart.dispose method is called. If there is a need to free SWT resources the part should define a dispose listener for its own control and free those resources from the dispose listener. If the part invokes any method on the disposed SWT controls after this point an SWTError will be thrown. The last method called on IWorkbenchPart is dispose. This signals the end of the part lifecycle. An important point to note about this lifecycle is that following a call to init, createPartControl may never be called. Thus in the dispose method, implementors must not assume controls were created. Workbench parts implement the IAdaptable interface; extensions are managed by the platform\'s adapter manager. See Also: IViewPart, IEditorPart extends IEditorPart Interface to a text editor. This interface defines functional extensions to IEditorPart as well as the configuration capabilities of a text editor. Text editors are configured with an IDocumentProvider which delivers a textual presentation (IDocument) of the editor\'s input. The editor works on the document and forwards all input element related calls, such as save, to the document provider. The provider also delivers the input\'s annotation model which is used by the editor\'s vertical ruler. Clients may implement this interface from scratch, but the recommended way is to subclass the abstract base class AbstractTextEditor. In order to provided backward compatibility for clients of ITextEditor, extension interfaces are used to provide a means of evolution. The following extension interfaces exist: ITextEditorExtension since version 2.0 introducing status fields, read-only state and ruler context menu listeners. ITextEditorExtension2 since version 2.1 introducing modifiable state for the editor input and validate state handling. ITextEditorExtension3 since version 3.0 adding input state and change information control. ITextEditorExtension4 since version 3.2 adding annotation navigation and revision information display. ITextEditorExtension5 since version 3.5 adding block selection mode. See Also: IDocumentProvider, IAnnotationModel, ITextEditorExtension, ITextEditorExtension2, ITextEditorExtension3, ITextEditorExtension4, ITextEditorExtension5 Extension interface for ITextEditor. Adds the following functions: status fields read-only state of the editor\'s input ruler context menu listeners. Since: 2.0 Extension interface for ITextEditor. Adds the following functions: modifiable state of the editor\'s input validate state of editor input Since: 2.1 Extension interface for ITextEditor. Adds the following functions: insert mode management Since: 3.0 Extension interface for ITextEditor. Adds the following functions: annotation navigation revision information display This interface may be implemented by clients. Since: 3.2 Extension interface for ITextEditor. Adds the following functions: block selection mode This interface may be implemented by clients. Since: 3.5 extends EditorPart implements ITextEditor, IReusableEditor, ITextEditorExtension, ITextEditorExtension2, ITextEditorExtension3, ITextEditorExtension4, ITextEditorExtension5, INavigationLocationProvider, ISaveablesSource, IPersistableEditor Abstract base implementation of a text editor. Subclasses are responsible for configuring the editor appropriately. The standard text editor, TextEditor, is one such example. If a subclass calls setEditorContextMenuId the argument is used as the id under which the editor\'s context menu is registered for extensions. If no id is set, the context menu is registered under [editor_id].EditorContext whereby [editor_id] is replaced with the editor\'s part id. If the editor is instructed to run in version 1.0 context menu registration compatibility mode, the latter form of the registration even happens if a context menu id has been set via setEditorContextMenuId. If no id is set while in compatibility mode, the menu is registered under DEFAULT_EDITOR_CONTEXT_MENU_ID. If a subclass calls setRulerContextMenuId the argument is used as the id under which the ruler\'s context menu is registered for extensions. If no id is set, the context menu is registered under [editor_id].RulerContext whereby [editor_id] is replaced with the editor\'s part id. If the editor is instructed to run in version 1.0 context menu registration compatibility mode, the latter form of the registration even happens if a context menu id has been set via setRulerContextMenuId. If no id is set while in compatibility mode, the menu is registered under DEFAULT_RULER_CONTEXT_MENU_ID. As of 3.5, contributers can contribute editor and ruler context menu actions to all subclasses of this class by using COMMON_EDITOR_CONTEXT_MENU_ID and COMMON_RULER_CONTEXT_MENU_ID. '
1408, 'org.eclipse.core.runtime.PluginVersionIdentifier', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/runtime/PluginVersionIdentifier.html', 'extends Object Version identifier for a plug-in. In its string representation, it consists of up to 4 tokens separated by a decimal point. The first 3 tokens are positive integer numbers, the last token is an uninterpreted string (no whitespace characters allowed). For example, the following are valid version identifiers (as strings): 0.0.0 1.0.127564 3.7.2.build-127J 1.9 (interpreted as 1.9.0) 3 (interpreted as 3.0.0) The version identifier can be decomposed into a major, minor, service level component and qualifier components. A difference in the major component is interpreted as an incompatible version change. A difference in the minor (and not the major) component is interpreted as a compatible version change. The service level component is interpreted as a cumulative and compatible service update of the minor version component. The qualifier is not interpreted, other than in version comparisons. The qualifiers are compared using lexicographical string comparison. Version identifiers can be matched as perfectly equal, equivalent, compatible or greaterOrEqual. This class can be used without OSGi running. Clients may instantiate; not intended to be subclassed by clients. See Also: String.compareTo(java.lang.String) '
1409, 'org.eclipse.jface.text.source.ISourceViewer', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/text/source/ISourceViewer.html', 'A text viewer connects a text widget with an IDocument. The document is used as the widget\'s text model. It supports the following kinds of listeners: view port listeners to inform about changes of the viewer\'s view port text listeners to inform about changes of the document and the subsequent viewer change text input listeners to inform about changes of the viewer\'s input document. A text viewer supports a set of configuration options and plug-ins defining its behavior: undo manager double click behavior auto indentation text hover Installed plug-ins are not automatically activated. Plug-ins must be activated with the activatePlugins call. Most plug-ins can be defined per content type. Content types are derived from a partitioning of the text viewer\'s input document. In case of documents that support multiple partitionings, the implementer is responsible for determining the partitioning to use. A text viewer also provides the concept of event consumption. Events handled by the viewer can be filtered and processed by a dynamic event consumer. With ITextViewerExtension, this mechanism has been replaced with the support for VerifyKeyListener. A text viewer provides several text editing functions, some of them are configurable, through a text operation target interface. It also supports a presentation mode in which it only shows a specified section of its document. By calling setVisibleRegion clients define which section is visible. Clients can get access to this section by calling getVisibleRegion. The viewer\'s presentation mode does not affect any client of the viewer other than text listeners. With ITextViewerExtension5 the visible region support has been reworked. With that extension interface, text viewers are allowed to show fractions of their input document. I.e. a widget selection of two visually neighboring characters is no longer guaranteed to be two neighboring characters in the viewer\'s input document. Thus, viewers implementing ITextViewerExtension5 are potentially forced to change the fractions of the input document that are shown when clients ask for the visible region. In order to provide backward compatibility for clients of ITextViewer, extension interfaces are used as a means of evolution. The following extension interfaces exist: ITextViewerExtension since version 2.0 replacing the event consumer mechanism and introducing the concept of rewrite targets and means to manage the viewer\'s redraw behavior ITextViewerExtension2since version 2.1 adding a way to invalidate a viewer\'s presentation and setters for hovers. ITextViewerExtension3 since version 2.1 which itself was replaced by ITextViewerExtension5 in version 3.0 ITextViewerExtension4 since version 3.0 introducing focus handling for widget token keepers and the concept of text presentation listeners. ITextViewerExtension5 since version 3.0 extending the visible region concept with explicit handling and conversion of widget and model coordinates. ITextViewerExtension6 since version 3.1 extending the text viewer with the ability to detect hyperlinks and access the undo manager. ITextViewerExtension7 since version 3.3 extending the text viewer with the ability to install tabs to spaces conversion. ITextViewerExtension8 since version 3.4 extending the text viewer with the ability to print and rich hover support. Clients may implement this interface and its extension interfaces or use the standard implementation TextViewer. See Also: ITextViewerExtension, ITextViewerExtension2, ITextViewerExtension3, ITextViewerExtension4, ITextViewerExtension5, ITextViewerExtension6, ITextViewerExtension7, ITextViewerExtension8, IDocument, ITextInputListener, IViewportListener, ITextListener, IEventConsumer extends ITextViewer In addition to the text viewer functionality a source viewer supports: visual annotations based on an annotation model visual range indication management of text viewer add-ons explicit configuration It is assumed that range indication and visual annotations are shown inside the same presentation area. There are no assumptions about whether this area is different from the viewer\'s text widget. As the visibility of visual annotations can dynamically be changed, it is assumed that the annotation presentation area can dynamically be hidden if it is different from the text widget. In order to provide backward compatibility for clients of ISourceViewer, extension interfaces are used as a means of evolution. The following extension interfaces exist: ISourceViewerExtension since version 2.1 introducing the concept of an annotation overview. ISourceViewerExtension2 since version 3.0 allowing source viewers to roll back a previously performed configuration and allows access to the viewer\'s visual annotation model. ISourceViewerExtension3 since version 3.2 introducing the concept of a quick assist assistant and providing access to the quick assist invocation context as well as the current annotation hover. ISourceViewerExtension4 since version 3.4 introducing API to access a minimal set of content assistant APIs. Clients may implement this interface and its extension interfaces or use the default implementation provided by SourceViewer. See Also: ISourceViewerExtension, ISourceViewerExtension2, ISourceViewerExtension3, ISourceViewerExtension4 '
1410, 'org.eclipse.jface.text.source.IVerticalRuler', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/text/source/IVerticalRuler.html', 'A vertical ruler is a visual component which may serve text viewers as an annotation presentation area. The vertical ruler info provides interested clients with the mapping and interaction aspect of the vertical ruler. This covers the mapping between coordinates of the ruler\'s control and line numbers based on the connected text viewer\'s document. In order to provide backward compatibility for clients of IVerticalRulerInfo, extension interfaces are used as a means of evolution. The following extension interfaces exist: IVerticalRulerInfoExtension since version 3.0 allowing custom annotation hovers and specific annotation models. Since: 2.0 See Also: IVerticalRulerInfoExtension extends IVerticalRulerInfo This interface defines a visual component which may serve text viewers as an annotation presentation area. Implementers of this interface have to define the presentation modus. This can either depend on the connected viewer\'s view port or not. If the modus is view port dependent the ruler only shows those annotations that are attached to document regions that are visible in the view port. If independent, the presented annotations can also be attached to invisible document regions. This interfaces comprises three contracts: The vertical ruler retrieves the annotations it presents from an annotation model. The ruler is a visual component which must be integrated in a hierarchy of SWT controls. The ruler provides interested clients with mapping and interaction information. This covers the mapping between coordinates of the ruler\'s control and line numbers based on the connected text viewer\'s document (see IVerticalRulerInfo). In order to provide backward compatibility for clients of IVerticalRuler, extension interfaces are used as a means of evolution. The following extension interfaces exist: IVerticalRulerExtension since version 2.0 introducing setters for font and mouse button activity location. Clients may implement this interface or use the default implementation provided by CompositeRuler and VerticalRuler. See Also: IVerticalRulerExtension, ITextViewer '
1411, 'org.eclipse.jface.text.source.SourceViewer', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/text/source/SourceViewer.html', 'A registry for IEditingSupports. This interface is not meant to be implemented outside the JFace text framework. Since: 3.1 See Also: IEditingSupport Restriction: This interface is not intended to be implemented by clients. Restriction: This interface is not intended to be extended by clients. Defines the target for text operations. canDoOperation informs the clients about the ability of the target to perform the specified operation at the current point in time. doOperation executes the specified operation. In order to provide backward compatibility for clients of ITextOperationTarget, extension interfaces are used as a means of evolution. The following extension interfaces exist: ITextOperationTargetExtension since version 2.0 introducing text operation enabling/disabling. See Also: ITextOperationTargetExtension Extension interface for ITextOperationTarget. Allows a client to control the enable state of operations provided by this target. Since: 2.0 See Also: ITextOperationTarget A text viewer connects a text widget with an IDocument. The document is used as the widget\'s text model. It supports the following kinds of listeners: view port listeners to inform about changes of the viewer\'s view port text listeners to inform about changes of the document and the subsequent viewer change text input listeners to inform about changes of the viewer\'s input document. A text viewer supports a set of configuration options and plug-ins defining its behavior: undo manager double click behavior auto indentation text hover Installed plug-ins are not automatically activated. Plug-ins must be activated with the activatePlugins call. Most plug-ins can be defined per content type. Content types are derived from a partitioning of the text viewer\'s input document. In case of documents that support multiple partitionings, the implementer is responsible for determining the partitioning to use. A text viewer also provides the concept of event consumption. Events handled by the viewer can be filtered and processed by a dynamic event consumer. With ITextViewerExtension, this mechanism has been replaced with the support for VerifyKeyListener. A text viewer provides several text editing functions, some of them are configurable, through a text operation target interface. It also supports a presentation mode in which it only shows a specified section of its document. By calling setVisibleRegion clients define which section is visible. Clients can get access to this section by calling getVisibleRegion. The viewer\'s presentation mode does not affect any client of the viewer other than text listeners. With ITextViewerExtension5 the visible region support has been reworked. With that extension interface, text viewers are allowed to show fractions of their input document. I.e. a widget selection of two visually neighboring characters is no longer guaranteed to be two neighboring characters in the viewer\'s input document. Thus, viewers implementing ITextViewerExtension5 are potentially forced to change the fractions of the input document that are shown when clients ask for the visible region. In order to provide backward compatibility for clients of ITextViewer, extension interfaces are used as a means of evolution. The following extension interfaces exist: ITextViewerExtension since version 2.0 replacing the event consumer mechanism and introducing the concept of rewrite targets and means to manage the viewer\'s redraw behavior ITextViewerExtension2since version 2.1 adding a way to invalidate a viewer\'s presentation and setters for hovers. ITextViewerExtension3 since version 2.1 which itself was replaced by ITextViewerExtension5 in version 3.0 ITextViewerExtension4 since version 3.0 introducing focus handling for widget token keepers and the concept of text presentation listeners. ITextViewerExtension5 since version 3.0 extending the visible region concept with explicit handling and conversion of widget and model coordinates. ITextViewerExtension6 since version 3.1 extending the text viewer with the ability to detect hyperlinks and access the undo manager. ITextViewerExtension7 since version 3.3 extending the text viewer with the ability to install tabs to spaces conversion. ITextViewerExtension8 since version 3.4 extending the text viewer with the ability to print and rich hover support. Clients may implement this interface and its extension interfaces or use the standard implementation TextViewer. See Also: ITextViewerExtension, ITextViewerExtension2, ITextViewerExtension3, ITextViewerExtension4, ITextViewerExtension5, ITextViewerExtension6, ITextViewerExtension7, ITextViewerExtension8, IDocument, ITextInputListener, IViewportListener, ITextListener, IEventConsumer Extension interface for ITextViewer. This extension interface replaces the event consumer mechanism ( ITextViewer.setEventConsumer(IEventConsumer)) with a set of methods that allow to manage a sequence of VerifyKeyListenerobjects. It also adds access to the control of this viewer marked region support as in emacs control of the viewer\'s redraw behavior by introducing setRedraw(boolean) access to the viewer\'s rewrite target. A rewrite target (IRewriteTarget) represents an facade offering the necessary methods to manipulate a document that is the input document of a text viewer. Since: 2.0 Extension interface for ITextViewer. It provides text presentation invalidation enhancements text hover management enhancements a replacement for auto indent strategies support for custom painters It extends the means for text presentation invalidation by allowing a specific region of the presentation to get invalidated. It replaces ITextViewer.setTextHover(ITextHover, String) with a new method that allows to specify state masks for a better control of the hover behavior. An IAutoEditStrategy is a generalization of the original IAutoIndentStrategy. Auto edit strategies can be arranged in a list that is executed like a pipeline when the viewer content is changed. A IPainteris creating and managing visual decorations on the viewer\'s text widget. Viewer\'s can have an open number of painters. Painters are informed about changes to the viewer content and state and can take the necessary action in responds to the notification. Since: 2.1 Extension interface for ITextViewer. Introduces the concept of text presentation listeners and improves focus handling among widget token keepers. A ITextPresentationListeneris a listener that is informed by the viewer that a text presentation is about to be applied. During this callback the listener is allowed to modify the presentation. Text presentation listeners are thus a mean to participate in the process of text presentation creation. Since: 3.0 Extension interface for ITextViewer. Introduces the concept of text hyperlinks and adds access to the undo manager. Since: 3.1 See Also: IHyperlink, IHyperlinkDetector Extension interface for ITextViewer. Adds the ability to install tabs to spaces conversion. Since: 3.3 Extension interface for ITextViewer. Adds the ability to print and set how hovers should be enriched when the mouse is moved into them. Since: 3.4 In order to display information in a temporary window, a widget token must be acquired. The intent behind this concept is that only one temporary window should be presented at any moment in time and also to avoid overlapping temporary windows. This concept is used by the ITextViewer. In order to provide backward compatibility for clients of IWidgetTokenOwner, extension interfaces are used as a means of evolution. The following extension interfaces exist: IWidgetTokenOwnerExtension since version 3.0 introducing priorities when requesting a widget token and thus replacing the non-prioritized scheme. Since: 2.0 See Also: IWidgetTokenOwnerExtension Extension interface for IWidgetTokenOwner. Replaces the original requestWidgetToken functionality with a new priority based approach. Since: 3.0 A text viewer connects a text widget with an IDocument. The document is used as the widget\'s text model. It supports the following kinds of listeners: view port listeners to inform about changes of the viewer\'s view port text listeners to inform about changes of the document and the subsequent viewer change text input listeners to inform about changes of the viewer\'s input document. A text viewer supports a set of configuration options and plug-ins defining its behavior: undo manager double click behavior auto indentation text hover Installed plug-ins are not automatically activated. Plug-ins must be activated with the activatePlugins call. Most plug-ins can be defined per content type. Content types are derived from a partitioning of the text viewer\'s input document. In case of documents that support multiple partitionings, the implementer is responsible for determining the partitioning to use. A text viewer also provides the concept of event consumption. Events handled by the viewer can be filtered and processed by a dynamic event consumer. With ITextViewerExtension, this mechanism has been replaced with the support for VerifyKeyListener. A text viewer provides several text editing functions, some of them are configurable, through a text operation target interface. It also supports a presentation mode in which it only shows a specified section of its document. By calling setVisibleRegion clients define which section is visible. Clients can get access to this section by calling getVisibleRegion. The viewer\'s presentation mode does not affect any client of the viewer other than text listeners. With ITextViewerExtension5 the visible region support has been reworked. With that extension interface, text viewers are allowed to show fractions of their input document. I.e. a widget selection of two visually neighboring characters is no longer guaranteed to be two neighboring characters in the viewer\'s input document. Thus, viewers implementing ITextViewerExtension5 are potentially forced to change the fractions of the input document that are shown when clients ask for the visible region. In order to provide backward compatibility for clients of ITextViewer, extension interfaces are used as a means of evolution. The following extension interfaces exist: ITextViewerExtension since version 2.0 replacing the event consumer mechanism and introducing the concept of rewrite targets and means to manage the viewer\'s redraw behavior ITextViewerExtension2since version 2.1 adding a way to invalidate a viewer\'s presentation and setters for hovers. ITextViewerExtension3 since version 2.1 which itself was replaced by ITextViewerExtension5 in version 3.0 ITextViewerExtension4 since version 3.0 introducing focus handling for widget token keepers and the concept of text presentation listeners. ITextViewerExtension5 since version 3.0 extending the visible region concept with explicit handling and conversion of widget and model coordinates. ITextViewerExtension6 since version 3.1 extending the text viewer with the ability to detect hyperlinks and access the undo manager. ITextViewerExtension7 since version 3.3 extending the text viewer with the ability to install tabs to spaces conversion. ITextViewerExtension8 since version 3.4 extending the text viewer with the ability to print and rich hover support. Clients may implement this interface and its extension interfaces or use the standard implementation TextViewer. See Also: ITextViewerExtension, ITextViewerExtension2, ITextViewerExtension3, ITextViewerExtension4, ITextViewerExtension5, ITextViewerExtension6, ITextViewerExtension7, ITextViewerExtension8, IDocument, ITextInputListener, IViewportListener, ITextListener, IEventConsumer extends ITextViewer In addition to the text viewer functionality a source viewer supports: visual annotations based on an annotation model visual range indication management of text viewer add-ons explicit configuration It is assumed that range indication and visual annotations are shown inside the same presentation area. There are no assumptions about whether this area is different from the viewer\'s text widget. As the visibility of visual annotations can dynamically be changed, it is assumed that the annotation presentation area can dynamically be hidden if it is different from the text widget. In order to provide backward compatibility for clients of ISourceViewer, extension interfaces are used as a means of evolution. The following extension interfaces exist: ISourceViewerExtension since version 2.1 introducing the concept of an annotation overview. ISourceViewerExtension2 since version 3.0 allowing source viewers to roll back a previously performed configuration and allows access to the viewer\'s visual annotation model. ISourceViewerExtension3 since version 3.2 introducing the concept of a quick assist assistant and providing access to the quick assist invocation context as well as the current annotation hover. ISourceViewerExtension4 since version 3.4 introducing API to access a minimal set of content assistant APIs. Clients may implement this interface and its extension interfaces or use the default implementation provided by SourceViewer. See Also: ISourceViewerExtension, ISourceViewerExtension2, ISourceViewerExtension3, ISourceViewerExtension4 Extension interface for ISourceViewer. Extends the source viewer with the concept of an annotation overview. The annotation overview differs from the annotation presentation in that it is independent from the viewer\'s view port, i.e. the annotations of the whole document are visible. There are no assumptions about the area in which the annotation overview is shown. As the visibility of annotation overview can dynamically be changed, it is assumed that the presentation area can dynamically be hidden if it is different from the text widget. Since: 2.1 See Also: ISourceViewer Extension interface for ISourceViewer. Allows the source viewer to roll back a previous configuration process and allows clients access to the viewer\'s visual annotation model. Since: 3.0 Extension interface for ISourceViewer. It introduces the concept of a quick assist assistant and provides access to the quick assist invocation context. It also gives access to any currently showing annotation hover. Since: 3.2 See Also: IQuickAssistAssistant, IQuickAssistInvocationContext Extension interface for ISourceViewer. It introduces API to access a minimal set of content assistant APIs. Since: 3.4 See Also: IContentAssistant Interface common to all objects that provide an input. Interface common to all objects that provide an input. Interface common to all objects that provide a selection. See Also: ISelection, ISelectionChangedListener, SelectionChangedEvent extends IInputProvider, ISelectionProvider Interface common to all objects that provide both an input and a selection. Interface common to all objects that provide a selection. See Also: ISelection, ISelectionChangedListener, SelectionChangedEvent extends ISelectionProvider Selection provider extension interface to allow providers to notify about post selection changed events. A post selection changed event is equivalent to selection changed event if the selection change was triggered by the mouse, but it has a delay if the selection change is triggered by keyboard navigation. Since: 3.0 See Also: ISelectionProvider Interface common to all objects that provide a selection. See Also: ISelection, ISelectionChangedListener, SelectionChangedEvent extends TextViewer implements ISourceViewer, ISourceViewerExtension, ISourceViewerExtension2, ISourceViewerExtension3, ISourceViewerExtension4 SWT based implementation of ISourceViewer and its extension interfaces. The same rules apply as for TextViewer. A source viewer uses an IVerticalRuler as its annotation presentation area. The vertical ruler is a small strip shown left of the viewer\'s text widget. A source viewer uses an IOverviewRuler as its presentation area for the annotation overview. The overview ruler is a small strip shown right of the viewer\'s text widget. Clients are supposed to instantiate a source viewer and subsequently to communicate with it exclusively using the ISourceViewer and its extension interfaces. Clients may subclass this class but should expect some breakage by future releases. '
1412, 'org.eclipse.core.commands.operations.ObjectUndoContext', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/commands/operations/ObjectUndoContext.html', ' An undo context is used to \"tag\" operations as being applicable to a certain context. The undo context is used to filter the history of operations available for undo or redo so that only operations appropriate for a given undo context are shown when the application is presenting that context. The scope of an undo context is defined by the application that is making undo and redo of operations available. Undo contexts may be related to application models, or may be associated with UI objects that are providing undo and redo support. An undo context may be defined as \"matching\" another context. This allows applications to provide specialized implementations of an undo context that will appear in the operation history for their matching context. Since: 3.1 extends UndoContext An undo context that can be used to represent any given object. Clients can add matching contexts to this context. This class may be instantiated by clients. Since: 3.1 '
1413, 'org.eclipse.core.commands.operations.IAdvancedUndoableOperation', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/commands/operations/IAdvancedUndoableOperation.html', ' IAdvancedUndoableOperation defines an interface for undoable operations that modify one or more elements in a model and attempt to keep model listeners up to date with changes that occur in the undo and redo history involving particular model elements. It also defines methods for computing the validity of an operation for undo or redo before attempting to perform the undo or redo. This interface is intended to be used by legacy frameworks that are adapting their original undo and redo support to this framework. The methods in this interface allow legacy clients to maintain features not supported in the basic operations framework. Since: 3.1 '
1414, 'org.eclipse.core.commands.operations.OperationHistoryEvent', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/commands/operations/OperationHistoryEvent.html', 'extends Object OperationHistoryEvent is used to communicate changes that occur in a DefaultOperationHistory, including the addition or removal of operations, and the execution, undo, and redo of operations. Operation history listeners must be prepared to receive notifications from a background thread. Any UI access occurring inside the implementation must be properly synchronized using the techniques specified by the client\'s widget library. Since: 3.1 '
1415, 'org.eclipse.core.commands.operations.OperationStatus', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/commands/operations/OperationStatus.html', 'A status object represents the outcome of an operation. All CoreExceptions carry a status object to indicate what went wrong. Status objects are also returned by methods needing to provide details of failures (e.g., validation methods). A status carries the following information: plug-in identifier (required) severity (required) status code (required) message (required) - localized to current locale exception (optional) - for problems stemming from a failure at a lower level Some status objects, known as multi-statuses, have other status objects as children. The class Status is the standard public implementation of status objects; the subclass MultiStatus is the implements multi-status objects. This interface can be used without OSGi running. See Also: MultiStatus, Status extends Status OperationStatus describes the status of a request to execute, undo, or redo an operation. This class may be instantiated by clients. Since: 3.1 '
1416, 'org.eclipse.ui.ide.undo.CreateMarkersOperation', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/ide/undo/CreateMarkersOperation.html', ' IAdvancedUndoableOperation defines an interface for undoable operations that modify one or more elements in a model and attempt to keep model listeners up to date with changes that occur in the undo and redo history involving particular model elements. It also defines methods for computing the validity of an operation for undo or redo before attempting to perform the undo or redo. This interface is intended to be used by legacy frameworks that are adapting their original undo and redo support to this framework. The methods in this interface allow legacy clients to maintain features not supported in the basic operations framework. Since: 3.1 IAdvancedUndoableOperation2 defines a method for computing the validity of executing an operation before attempting to execute it. It also defines a way for clients to specify that computing status should be done quietly, without consulting the user. This interface is useful when implementing IOperationApprover2, or any other object that performs validation of the undo history. It also allows operations to specify whether they should be run in the UI thread. Since: 3.3 IUndoableOperation defines an operation that can be executed, undone, and redone. Operations typically have fully defined parameters. That is, they are usually created after the user has been queried for any input needed to define the operation. Operations determine their ability to execute, undo, or redo according to the current state of the application. They do not make decisions about their validity based on where they occur in the operation history. That is left to the particular operation history. Since: 3.1 extends AbstractWorkspaceOperation A CreateMarkersOperation represents an undoable operation for creating one or more markers on one or more resources in the workspace. Clients may call the public API from a background thread. This class is intended to be instantiated and used by clients. It is not intended to be subclassed by clients. Since: 3.3 '
1417, 'org.eclipse.ui.ide.undo.DeleteMarkersOperation', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/ide/undo/DeleteMarkersOperation.html', ' IAdvancedUndoableOperation defines an interface for undoable operations that modify one or more elements in a model and attempt to keep model listeners up to date with changes that occur in the undo and redo history involving particular model elements. It also defines methods for computing the validity of an operation for undo or redo before attempting to perform the undo or redo. This interface is intended to be used by legacy frameworks that are adapting their original undo and redo support to this framework. The methods in this interface allow legacy clients to maintain features not supported in the basic operations framework. Since: 3.1 IAdvancedUndoableOperation2 defines a method for computing the validity of executing an operation before attempting to execute it. It also defines a way for clients to specify that computing status should be done quietly, without consulting the user. This interface is useful when implementing IOperationApprover2, or any other object that performs validation of the undo history. It also allows operations to specify whether they should be run in the UI thread. Since: 3.3 IUndoableOperation defines an operation that can be executed, undone, and redone. Operations typically have fully defined parameters. That is, they are usually created after the user has been queried for any input needed to define the operation. Operations determine their ability to execute, undo, or redo according to the current state of the application. They do not make decisions about their validity based on where they occur in the operation history. That is left to the particular operation history. Since: 3.1 extends AbstractWorkspaceOperation A DeleteMarkersOperation represents an undoable operation for deleting one or more markers in the workspace. Clients may call the public API from a background thread. This class is intended to be instantiated and used by clients. It is not intended to be subclassed by clients. Since: 3.3 '
1418, 'org.eclipse.ui.ide.undo.CreateProjectOperation', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/ide/undo/CreateProjectOperation.html', ' IAdvancedUndoableOperation defines an interface for undoable operations that modify one or more elements in a model and attempt to keep model listeners up to date with changes that occur in the undo and redo history involving particular model elements. It also defines methods for computing the validity of an operation for undo or redo before attempting to perform the undo or redo. This interface is intended to be used by legacy frameworks that are adapting their original undo and redo support to this framework. The methods in this interface allow legacy clients to maintain features not supported in the basic operations framework. Since: 3.1 IAdvancedUndoableOperation2 defines a method for computing the validity of executing an operation before attempting to execute it. It also defines a way for clients to specify that computing status should be done quietly, without consulting the user. This interface is useful when implementing IOperationApprover2, or any other object that performs validation of the undo history. It also allows operations to specify whether they should be run in the UI thread. Since: 3.3 IUndoableOperation defines an operation that can be executed, undone, and redone. Operations typically have fully defined parameters. That is, they are usually created after the user has been queried for any input needed to define the operation. Operations determine their ability to execute, undo, or redo according to the current state of the application. They do not make decisions about their validity based on where they occur in the operation history. That is left to the particular operation history. Since: 3.1 extends AbstractWorkspaceOperation A CreateProjectOperation represents an undoable operation for creating a project in the workspace. Clients may call the public API from a background thread. This class is intended to be instantiated and used by clients. It is not intended to be subclassed by clients. Since: 3.3 Restriction: This class is not intended to be subclassed by clients. '
1419, 'org.eclipse.ui.ide.undo.MoveProjectOperation', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/ide/undo/MoveProjectOperation.html', ' IAdvancedUndoableOperation defines an interface for undoable operations that modify one or more elements in a model and attempt to keep model listeners up to date with changes that occur in the undo and redo history involving particular model elements. It also defines methods for computing the validity of an operation for undo or redo before attempting to perform the undo or redo. This interface is intended to be used by legacy frameworks that are adapting their original undo and redo support to this framework. The methods in this interface allow legacy clients to maintain features not supported in the basic operations framework. Since: 3.1 IAdvancedUndoableOperation2 defines a method for computing the validity of executing an operation before attempting to execute it. It also defines a way for clients to specify that computing status should be done quietly, without consulting the user. This interface is useful when implementing IOperationApprover2, or any other object that performs validation of the undo history. It also allows operations to specify whether they should be run in the UI thread. Since: 3.3 IUndoableOperation defines an operation that can be executed, undone, and redone. Operations typically have fully defined parameters. That is, they are usually created after the user has been queried for any input needed to define the operation. Operations determine their ability to execute, undo, or redo according to the current state of the application. They do not make decisions about their validity based on where they occur in the operation history. That is left to the particular operation history. Since: 3.1 extends AbstractWorkspaceOperation A MoveProjectOperation represents an undoable operation for moving a project\'s content to a different location. Clients may call the public API from a background thread. This class is intended to be instantiated and used by clients. It is not intended to be subclassed by clients. Since: 3.3 Restriction: This class is not intended to be subclassed by clients. '
1420, 'org.eclipse.ui.ide.undo.CopyProjectOperation', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/ide/undo/CopyProjectOperation.html', ' IAdvancedUndoableOperation defines an interface for undoable operations that modify one or more elements in a model and attempt to keep model listeners up to date with changes that occur in the undo and redo history involving particular model elements. It also defines methods for computing the validity of an operation for undo or redo before attempting to perform the undo or redo. This interface is intended to be used by legacy frameworks that are adapting their original undo and redo support to this framework. The methods in this interface allow legacy clients to maintain features not supported in the basic operations framework. Since: 3.1 IAdvancedUndoableOperation2 defines a method for computing the validity of executing an operation before attempting to execute it. It also defines a way for clients to specify that computing status should be done quietly, without consulting the user. This interface is useful when implementing IOperationApprover2, or any other object that performs validation of the undo history. It also allows operations to specify whether they should be run in the UI thread. Since: 3.3 IUndoableOperation defines an operation that can be executed, undone, and redone. Operations typically have fully defined parameters. That is, they are usually created after the user has been queried for any input needed to define the operation. Operations determine their ability to execute, undo, or redo according to the current state of the application. They do not make decisions about their validity based on where they occur in the operation history. That is left to the particular operation history. Since: 3.1 extends AbstractWorkspaceOperation A CopyProjectOperation represents an undoable operation for copying a project, also specifying the location of its contents. Clients may call the public API from a background thread. This class is intended to be instantiated and used by clients. It is not intended to be subclassed by clients. Since: 3.3 Restriction: This class is not intended to be subclassed by clients. '
1421, 'org.eclipse.ui.ide.undo.MoveResourcesOperation', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/ide/undo/MoveResourcesOperation.html', ' IAdvancedUndoableOperation defines an interface for undoable operations that modify one or more elements in a model and attempt to keep model listeners up to date with changes that occur in the undo and redo history involving particular model elements. It also defines methods for computing the validity of an operation for undo or redo before attempting to perform the undo or redo. This interface is intended to be used by legacy frameworks that are adapting their original undo and redo support to this framework. The methods in this interface allow legacy clients to maintain features not supported in the basic operations framework. Since: 3.1 IAdvancedUndoableOperation2 defines a method for computing the validity of executing an operation before attempting to execute it. It also defines a way for clients to specify that computing status should be done quietly, without consulting the user. This interface is useful when implementing IOperationApprover2, or any other object that performs validation of the undo history. It also allows operations to specify whether they should be run in the UI thread. Since: 3.3 IUndoableOperation defines an operation that can be executed, undone, and redone. Operations typically have fully defined parameters. That is, they are usually created after the user has been queried for any input needed to define the operation. Operations determine their ability to execute, undo, or redo according to the current state of the application. They do not make decisions about their validity based on where they occur in the operation history. That is left to the particular operation history. Since: 3.1 extends AbstractWorkspaceOperation A MoveResourcesOperation represents an undoable operation for moving one or more resources in the workspace. Clients may call the public API from a background thread. This operation can track any overwritten resources and restore them when the move is undone. It is up to clients to determine whether overwrites are allowed. If a resource should not be overwritten, it should not be included in this operation. In addition to checking for overwrites, the target location for the move is assumed to have already been validated by the client. It will not be revalidated on undo and redo. This class is intended to be instantiated and used by clients. It is not intended to be subclassed by clients. Since: 3.3 Restriction: This class is not intended to be subclassed by clients. '
1422, 'org.eclipse.ui.ide.undo.CreateFileOperation', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/ide/undo/CreateFileOperation.html', ' IAdvancedUndoableOperation defines an interface for undoable operations that modify one or more elements in a model and attempt to keep model listeners up to date with changes that occur in the undo and redo history involving particular model elements. It also defines methods for computing the validity of an operation for undo or redo before attempting to perform the undo or redo. This interface is intended to be used by legacy frameworks that are adapting their original undo and redo support to this framework. The methods in this interface allow legacy clients to maintain features not supported in the basic operations framework. Since: 3.1 IAdvancedUndoableOperation2 defines a method for computing the validity of executing an operation before attempting to execute it. It also defines a way for clients to specify that computing status should be done quietly, without consulting the user. This interface is useful when implementing IOperationApprover2, or any other object that performs validation of the undo history. It also allows operations to specify whether they should be run in the UI thread. Since: 3.3 IUndoableOperation defines an operation that can be executed, undone, and redone. Operations typically have fully defined parameters. That is, they are usually created after the user has been queried for any input needed to define the operation. Operations determine their ability to execute, undo, or redo according to the current state of the application. They do not make decisions about their validity based on where they occur in the operation history. That is left to the particular operation history. Since: 3.1 extends AbstractWorkspaceOperation A CreateFileOperation represents an undoable operation for creating a file in the workspace. If a link location is specified, the file is considered to be linked to the file at the specified location. If a link location is not specified, the file will be created in the location specified by the handle, and the entire containment path of the file will be created if it does not exist. The file should not already exist, and the existence of the containment path should not be changed between the time this operation is created and the time it is executed. Clients may call the public API from a background thread. This class is intended to be instantiated and used by clients. It is not intended to be subclassed by clients. Since: 3.3 Restriction: This class is not intended to be subclassed by clients. '
1423, 'org.eclipse.core.commands.operations.ICompositeOperation', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/commands/operations/ICompositeOperation.html', ' IUndoableOperation defines an operation that can be executed, undone, and redone. Operations typically have fully defined parameters. That is, they are usually created after the user has been queried for any input needed to define the operation. Operations determine their ability to execute, undo, or redo according to the current state of the application. They do not make decisions about their validity based on where they occur in the operation history. That is left to the particular operation history. Since: 3.1 extends IUndoableOperation ICompositeOperation defines an undoable operation that is composed of child operations. Requests to execute, undo, or redo a composite result in the the execution, undo, or redo of the composite as a whole. Similarly, a request to dispose the composite should result in all child operations being disposed. Since: 3.1 '
1424, 'org.eclipse.core.commands.operations.DefaultOperationHistory', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/commands/operations/DefaultOperationHistory.html', ' IOperationHistory tracks a history of operations that can be undone or redone. Operations are added to the history once they have been initially executed. Clients may choose whether to have the operations history perform the initial execution or to simply add an already-executed operation to the history. Once operations are added to the history, the methods canRedo(IUndoContext) and canUndo(IUndoContext) are used to determine whether there is an operation available for undo and redo in a given undo context. The context-based protocol implies that there is only one operation that can be undone or redone at a given time in a given context. This is typical of a linear undo model, when only the most recently executed operation is available for undo. When this protocol is used, a linear model is enforced by the history. It is up to clients to determine how to maintain a history that is invalid or stale. For example, when the most recent operation for a context cannot be performed, clients may wish to dispose the history for that context. Additional protocol allows direct undo and redo of a specified operation, regardless of its position in the history. When a more flexible undo model is supported, these methods can be implemented to undo and redo directly specified operations. If an implementer of IOperationHistory does not allow direct undo and redo, these methods can return a status indicating that it is not allowed. Listeners (IOperationHistoryListener) can listen for notifications about changes in the history (operations added or removed), and for notification before and after any operation is executed, undone or redone. Notification of operation execution only occurs when clients direct the history to execute the operation. If the operation is added after it is executed, there can be no notification of its execution. IOperationApprover defines an interface for approving an undo or redo before it occurs. This is useful for injecting policy-decisions into the undo model - whether direct undo and redo are supported, or warning the user about certain kinds of operations. It can also be used when clients maintain state related to an operation and need to determine whether an undo or redo will cause any conflicts with their local state. Since: 3.1 extends Object implements IOperationHistory A base implementation of IOperationHistory that implements a linear undo and redo model . The most recently added operation is available for undo, and the most recently undone operation is available for redo. If the operation eligible for undo is not in a state where it can be undone, then no undo is available. No other operations are considered. Likewise, if the operation available for redo cannot be redone, then no redo is available. Implementations for the direct undo and redo of a specified operation are available. If a strict linear undo is to be enforced, than an IOperationApprover should be installed that prevents undo and redo of any operation that is not the most recently undone or redone operation in all of its undo contexts. The data structures used by the DefaultOperationHistory are synchronized, and entry points that modify the undo and redo history concurrently are also synchronized. This means that the DefaultOperationHistory is relatively \"thread-friendly\" in its implementation. Outbound notifications or operation approval requests will occur on the thread that initiated the request. Clients may use DefaultOperationHistory API from any thread; however, listeners or operation approvers that receive notifications from the DefaultOperationHistory must be prepared to receive these notifications from a background thread. Any UI access occurring inside these notifications must be properly synchronized using the techniques specified by the client\'s widget library. This implementation is not intended to be subclassed. Since: 3.1 See Also: IOperationHistory, IOperationApprover '
1425, 'org.eclipse.core.commands.operations.TriggeredOperations', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/commands/operations/TriggeredOperations.html', ' IAdvancedUndoableOperation defines an interface for undoable operations that modify one or more elements in a model and attempt to keep model listeners up to date with changes that occur in the undo and redo history involving particular model elements. It also defines methods for computing the validity of an operation for undo or redo before attempting to perform the undo or redo. This interface is intended to be used by legacy frameworks that are adapting their original undo and redo support to this framework. The methods in this interface allow legacy clients to maintain features not supported in the basic operations framework. Since: 3.1 IAdvancedUndoableOperation2 defines a method for computing the validity of executing an operation before attempting to execute it. It also defines a way for clients to specify that computing status should be done quietly, without consulting the user. This interface is useful when implementing IOperationApprover2, or any other object that performs validation of the undo history. It also allows operations to specify whether they should be run in the UI thread. Since: 3.3 IUndoableOperation defines an operation that can be executed, undone, and redone. Operations typically have fully defined parameters. That is, they are usually created after the user has been queried for any input needed to define the operation. Operations determine their ability to execute, undo, or redo according to the current state of the application. They do not make decisions about their validity based on where they occur in the operation history. That is left to the particular operation history. Since: 3.1 extends IUndoableOperation ICompositeOperation defines an undoable operation that is composed of child operations. Requests to execute, undo, or redo a composite result in the the execution, undo, or redo of the composite as a whole. Similarly, a request to dispose the composite should result in all child operations being disposed. Since: 3.1 IContextReplacingOperation defines an interface for undoable operations that can replace one undo context with another undo context. It is used by operations, such as composite operations, where removing and adding an undo context would not have the same semantic as replacing one undo context with another. Since: 3.2 IUndoableOperation defines an operation that can be executed, undone, and redone. Operations typically have fully defined parameters. That is, they are usually created after the user has been queried for any input needed to define the operation. Operations determine their ability to execute, undo, or redo according to the current state of the application. They do not make decisions about their validity based on where they occur in the operation history. That is left to the particular operation history. Since: 3.1 extends AbstractOperation implements ICompositeOperation, IAdvancedUndoableOperation, IAdvancedUndoableOperation2, IContextReplacingOperation Triggered operations are a specialized implementation of a composite operation that keeps track of operations triggered by the execution of some primary operation. The composite knows which operation was the trigger for subsequent operations, and adds all triggered operations as children. When execution, undo, or redo is performed, only the triggered operation is executed, undone, or redone if it is still present. If the trigger is removed from the triggered operations, then the child operations will replace the triggered operations in the history. This class may be instantiated by clients. Since: 3.1 '
1426, 'org.eclipse.core.commands.operations.LinearUndoEnforcer', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/commands/operations/LinearUndoEnforcer.html', ' IOperationApprover defines an interface for approving the undo or redo of a particular operation within an operation history. Operations that are candidates for undo or redo have already been validated against their current state and according to the rules of the history. By the time an IOperationApprover is consulted, the undo has already been requested. Approvers should return an IStatus object with severity OK if the operation should proceed, and any other severity if it should not. When an operation is not approved, it is expected that the object not allowing the operation has already consulted the user if necessary or otherwise provided any necessary information to the user about the fact that the operation is not approved. Operation approvers must be prepared to receive the approval messages from a background thread. Any UI access occurring inside the implementation must be properly synchronized using the techniques specified by the client\'s widget library. Since: 3.1 extends LinearUndoViolationDetector An operation approver that enforces a strict linear undo. It does not allow the undo or redo of any operation that is not the latest available operation in all of its undo contexts. This class may be instantiated by clients. Since: 3.1 '
1427, 'org.eclipse.core.commands.operations.OperationHistoryFactory', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/commands/operations/OperationHistoryFactory.html', 'extends Object This class is used to maintain the instance of the operation history that should be used by classes that access the undo or redo history and add undoable operations to the history. It is intended that an application can create an operation history appropriate for its needs and set it into this class. Otherwise, a default operation history will be created. The operation history may only be set one time. All classes that access an operations history use this class to obtain the correct instance. Since: 3.1 '
1428, 'org.eclipse.core.commands.operations.IOperationApprover2', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/commands/operations/IOperationApprover2.html', ' IOperationApprover defines an interface for approving the undo or redo of a particular operation within an operation history. Operations that are candidates for undo or redo have already been validated against their current state and according to the rules of the history. By the time an IOperationApprover is consulted, the undo has already been requested. Approvers should return an IStatus object with severity OK if the operation should proceed, and any other severity if it should not. When an operation is not approved, it is expected that the object not allowing the operation has already consulted the user if necessary or otherwise provided any necessary information to the user about the fact that the operation is not approved. Operation approvers must be prepared to receive the approval messages from a background thread. Any UI access occurring inside the implementation must be properly synchronized using the techniques specified by the client\'s widget library. Since: 3.1 extends IOperationApprover Extends IOperationApprover to approve the execution of a particular operation within an operation history. Operations that are candidates for execution have already been validated against their current state and according to the rules of the history. Prior to 3.2, an operation approver was only consulted for undo and redo of an operation, not its initial execution. By the time an IOperationApprover2 is consulted, the execution has already been requested and it has been determined that the operation is valid. Approvers should return an IStatus object with severity OK if the operation should proceed, and any other severity if it should not. When an operation is not approved, it is expected that the object not allowing the operation has already consulted the user if necessary or otherwise provided any necessary information to the user about the fact that the operation is not approved. Like IOperationApprover, implementers of this extension must be prepared to receive the approval messages from a background thread. Any UI access occurring inside the implementation must be properly synchronized using the techniques specified by the client\'s widget library. Since: 3.2 '
1429, 'org.eclipse.ui.activities.WorkbenchTriggerPointAdvisor', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/activities/WorkbenchTriggerPointAdvisor.html', 'Interface for executable extension classes that require access to their configuration element, or implement an extension adapter. Extension adapters are typically required in cases where the extension implementation does not follow the interface rules specified by the provider of the extension point. In these cases, the role of the adapter is to map between the extension point interface, and the actual extension implementation. In general, adapters are used when attempting to plug-in existing Java implementations, or non-Java implementations (e.g., external executables). This interface can be used without OSGi running. Clients may implement this interface. See Also: IConfigurationElement.createExecutableExtension(String) The trigger point advisor is a mechanism provided by the workbench that is consulted whenever code that is considered a trigger point is hit. It is the role of the advisor to determine what, if any, activities should be enabled as a consequence of this action. The advisor also has the option of vetoing the operation. Since: 3.1 See Also: ITriggerPoint Restriction: This interface is not intended to be implemented by clients. Restriction: This interface is not intended to be extended by clients. extends Object implements ITriggerPointAdvisor, IExecutableExtension Workbench implementation prompts the user with a dialog unless they\'ve said that they don\'t want to be prompted. You may provide the certain strings to this class via method #2 of IExecutableExtension. This is provided as API so that non-SDK Eclipse applications can reuse and augment the default SDK trigger point behaviour. Since: 3.1 See Also: PROCEED_MULTI, PROCEED_SINGLE, DONT_ASK, NO_DETAILS '
1430, 'org.eclipse.ui.activities.IActivityListener', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/activities/IActivityListener.html', 'An instance of this interface can be used by clients to receive notification of changes to one or more instances of IActivity. This interface may be implemented by clients. Since: 3.0 See Also: IActivity.addActivityListener(IActivityListener), IActivity.removeActivityListener(IActivityListener) '
1431, 'org.eclipse.ui.activities.ICategoryListener', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/activities/ICategoryListener.html', 'An instance of this interface can be used by clients to receive notification of changes to one or more instances of ICategory. This interface may be implemented by clients. Since: 3.0 See Also: ICategory.addCategoryListener(ICategoryListener), ICategory.removeCategoryListener(ICategoryListener) '
1432, 'org.eclipse.core.runtime.ContributorFactoryOSGi', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/runtime/ContributorFactoryOSGi.html', 'extends Object The contributor factory creates new registry contributors for use in OSGi-based registries. This class can not be extended or instantiated by clients. Note: This class/interface is part of an interim API that is still under development and expected to change significantly before reaching stability. It is being made available at this early stage to solicit feedback from pioneering adopters on the understanding that any code that uses this API will almost certainly be broken (repeatedly) as the API evolves. Since: org.eclipse.equinox.registry 3.2 Restriction: This class is not intended to be subclassed by clients. Restriction: This class is not intended to be instantiated by clients. '
1433, 'org.eclipse.ui.BasicWorkingSetElementAdapter', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/BasicWorkingSetElementAdapter.html', 'Interface for executable extension classes that require access to their configuration element, or implement an extension adapter. Extension adapters are typically required in cases where the extension implementation does not follow the interface rules specified by the provider of the extension point. In these cases, the role of the adapter is to map between the extension point interface, and the actual extension implementation. In general, adapters are used when attempting to plug-in existing Java implementations, or non-Java implementations (e.g., external executables). This interface can be used without OSGi running. Clients may implement this interface. See Also: IConfigurationElement.createExecutableExtension(String) Interface that describes a mechanism that may be provided by working set extensions to help manage the addition of elements to working sets. Instances of this class are capable of transforming possible working set content into the most applicable form. Usage of this interface is achieved via the elementAdapterClass attribute of the org.eclipse.ui.workingSets extension point. Usage of this interface in org.eclipse.ui.workingSets extensions is optional. Since: 3.3 extends Object implements IWorkingSetElementAdapter, IExecutableExtension Basic IWorkingSetElementAdapter implementation that allows plugins to decribe simple declarative element adapters. The executable extension format for this class is as follows: <workingSet elementAdapterClass=\"org.eclipse.ui.BasicWorkingSetElementAdapter:class1.to.adapt.to[;option1=value1][;option2=value2],class2.to.adapt.to[;option1=value1][;option2=value2],...\"> ... </workingSet> The valid options are: adapt Values: true or true. Specifies whether or not the platform IAdapterManager and the IAdaptable interface should be consulted. Please see the adaptElements(IWorkingSet, IAdaptable[]) method for details on behavior of this implementation. Since: 3.3 '
1434, 'org.eclipse.core.resources.IResourceVisitor', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/resources/IResourceVisitor.html', 'This interface is implemented by objects that visit resource trees. Usage: class Visitor implements IResourceVisitor { public boolean visit(IResource res) { // your code here return true; } } IResource root = ...; root.accept(new Visitor()); Clients may implement this interface. See Also: IResource.accept(IResourceVisitor) '
1435, 'org.eclipse.ui.dialogs.WorkingSetConfigurationBlock', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/dialogs/WorkingSetConfigurationBlock.html', 'extends Object Instances of this class provide a reusable composite with controls that allow the selection of working sets. This class is most useful in IWizardPage instances that wish to create resources and pre-install them into particular working sets. Since: 3.4 '
1436, 'org.eclipse.ui.part.IntroPart', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/part/IntroPart.html', 'An interface for an adaptable object. Adaptable objects can be dynamically extended to provide different interfaces (or \"adapters\"). Adapters are created by adapter factories, which are in turn managed by type by adapter managers. For example, IAdaptable a = [some adaptable]; IFoo x = (IFoo)a.getAdapter(IFoo.class); if (x != null) [do IFoo things with x] This interface can be used without OSGi running. Clients may implement this interface, or obtain a default implementation of this interface by subclassing PlatformObject. See Also: IAdapterFactory, IAdapterManager, PlatformObject Interface for executable extension classes that require access to their configuration element, or implement an extension adapter. Extension adapters are typically required in cases where the extension implementation does not follow the interface rules specified by the provider of the extension point. In these cases, the role of the adapter is to map between the extension point interface, and the actual extension implementation. In general, adapters are used when attempting to plug-in existing Java implementations, or non-Java implementations (e.g., external executables). This interface can be used without OSGi running. Clients may implement this interface. See Also: IConfigurationElement.createExecutableExtension(String) An interface for an adaptable object. Adaptable objects can be dynamically extended to provide different interfaces (or \"adapters\"). Adapters are created by adapter factories, which are in turn managed by type by adapter managers. For example, IAdaptable a = [some adaptable]; IFoo x = (IFoo)a.getAdapter(IFoo.class); if (x != null) [do IFoo things with x] This interface can be used without OSGi running. Clients may implement this interface, or obtain a default implementation of this interface by subclassing PlatformObject. See Also: IAdapterFactory, IAdapterManager, PlatformObject extends IAdaptable The intro part is a visual component within the workbench responsible for introducing the product to new users. The intro part is typically shown the first time a product is started up. The intro part implementation is contributed to the workbench via the org.eclipse.ui.intro extension point. There can be several intro part implementations, and associations between intro part implementations and products. The workbench will only make use of the intro part implementation for the current product (as given by Platform.getProduct(). There is at most one intro part instance in the entire workbench, and it resides in exactly one workbench window at a time. This interface in not intended to be directly implemented. Rather, clients providing a intro part implementation should subclass IntroPart. Since: 3.0 See Also: IIntroManager.showIntro(org.eclipse.ui.IWorkbenchWindow, boolean) Restriction: This interface is not intended to be implemented by clients. extends EventManager implements IIntroPart, IExecutableExtension Abstract base implementation of an intro part. Subclasses must implement the following methods: createPartControl- to create the intro part\'s controls setFocus- to accept focus standbyStateChanged- to change the standby mode Subclasses may extend or reimplement the following methods as required: setInitializationData- extend to provide additional initialization when the intro extension is instantiated init(IIntroSite, IMemento)- extend to provide additional initialization when intro is assigned its site dispose- extend to provide additional cleanup getAdapter- reimplement to make their intro adaptable Since: 3.0 '
1437, 'org.eclipse.ui.help.AbstractHelpUI', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/help/AbstractHelpUI.html', 'extends Object Abstract base class for the help system UI. The Eclipse platform provides an extension point (\"org.eclipse.ui.helpSupport\") for plugging in a help system UI. The help system UI is an optional component; applications may provide a UI for presenting help to the user by implementing a subclass and including the name of their class in the <config> element in an extension to the \"org.eclipse.ui.helpSupport\" extension point. Note that the standard implementation of the help system UI is provided by the \"org.eclipse.help.ui\" plug-in. Since the platform can only make use of a single help system UI implementation, make sure that the platform is not configured with more than one plug-in trying to extend this extension point. Since: 3.0 '
1438, 'org.eclipse.core.databinding.ListBinding', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/databinding/ListBinding.html', 'extends Binding Since: 1.0 '
1439, 'org.eclipse.core.databinding.SetBinding', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/databinding/SetBinding.html', 'extends Binding Since: 1.1 '
1440, 'org.eclipse.core.databinding.UpdateSetStrategy', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/databinding/UpdateSetStrategy.html', 'extends Object Customizes a Binding between two observable sets. The following behaviors can be customized via the strategy: Conversion Automatic processing Conversion: When elements are added they can be converted to the destination element type. Automatic processing: The processing to perform when the source observable changes. This behavior is configured via policies provided on construction of the strategy (e.g. POLICY_NEVER, POLICY_ON_REQUEST, POLICY_UPDATE). Since: 1.1 See Also: DataBindingContext.bindSet(IObservableSet, IObservableSet, UpdateSetStrategy, UpdateSetStrategy), IConverter '
1441, 'org.eclipse.core.databinding.property.list.ListProperty', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/databinding/property/list/ListProperty.html', 'extends IProperty Interface for list-typed properties. Since: 1.2 See Also: ListProperty, SimpleListProperty Restriction: This interface is not intended to be implemented by clients. Clients should instead subclass one of the classes that implement this interface. Note that direct implementers of this interface outside of the framework will be broken in future releases when methods are added to this interface. extends Object implements IListProperty Abstract implementation of IListProperty. Since: 1.2 '
1442, 'org.eclipse.core.databinding.property.value.SimpleValueProperty', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/databinding/property/value/SimpleValueProperty.html', 'extends IProperty Interface for value-typed properties Since: 1.2 See Also: ValueProperty, SimpleValueProperty Restriction: This interface is not intended to be implemented by clients. Clients should instead subclass one of the classes that implement this interface. Note that direct implementers of this interface outside of the framework will be broken in future releases when methods are added to this interface. extends ValueProperty Simplified abstract implementation of IValueProperty. This class takes care of most of the functional requirements for an IValueProperty implementation, leaving only the property-specific details to subclasses. Subclasses must implement these methods: IValueProperty.getValueType() doGetValue(Object) doSetValue(Object, Object) adaptListener(ISimplePropertyListener) In addition, we recommended overriding Object.toString() to return a description suitable for debugging purposes. Since: 1.2 '
1443, 'org.eclipse.core.databinding.observable.map.ObservableMap', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/databinding/observable/map/ObservableMap.html', 'An object with state that allows to listen for state changes. Implementations must not manage listeners themselves, listener management must be delegated to a private instance of type ChangeSupport if it is not inherited from AbstractObservable. Since: 1.0 Restriction: This interface is not intended to be implemented by clients. Clients should instead subclass one of the classes in the framework that implement this interface. Note that direct implementers of this interface outside of the framework will be broken in future releases when methods are added to this interface. An object with state that allows to listen for state changes. Implementations must not manage listeners themselves, listener management must be delegated to a private instance of type ChangeSupport if it is not inherited from AbstractObservable. Since: 1.0 Restriction: This interface is not intended to be implemented by clients. Clients should instead subclass one of the classes in the framework that implement this interface. Note that direct implementers of this interface outside of the framework will be broken in future releases when methods are added to this interface. extends Map, IObservable Observable Map. Since: 1.1 See Also: AbstractObservableMap, ObservableMap Restriction: This interface is not intended to be implemented by clients. Clients should instead subclass one of the classes that implement this interface. Note that direct implementers of this interface outside of the framework will be broken in future releases when methods are added to this interface. extends AbstractObservable implements IObservableMap This class is thread safe. All state accessing methods must be invoked from the current realm. Methods for adding and removing listeners may be invoked from any thread. Since: 1.0 '
1444, 'org.eclipse.core.databinding.observable.set.ObservableSet', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/databinding/observable/set/ObservableSet.html', 'An object with state that allows to listen for state changes. Implementations must not manage listeners themselves, listener management must be delegated to a private instance of type ChangeSupport if it is not inherited from AbstractObservable. Since: 1.0 Restriction: This interface is not intended to be implemented by clients. Clients should instead subclass one of the classes in the framework that implement this interface. Note that direct implementers of this interface outside of the framework will be broken in future releases when methods are added to this interface. An object with state that allows to listen for state changes. Implementations must not manage listeners themselves, listener management must be delegated to a private instance of type ChangeSupport if it is not inherited from AbstractObservable. Since: 1.0 Restriction: This interface is not intended to be implemented by clients. Clients should instead subclass one of the classes in the framework that implement this interface. Note that direct implementers of this interface outside of the framework will be broken in future releases when methods are added to this interface. extends IObservable, Collection Interface for observable collections. Only general change listeners can be added to an observable collection. Listeners interested in incremental changes have to be added using more concrete subtypes such as IObservableList or IObservableSet. Since: 1.0 Restriction: This interface is not intended to be implemented by clients. Clients should instead subclass one of the classes that implement this interface. Note that direct implementers of this interface outside of the framework will be broken in future releases when methods are added to this interface. Restriction: This interface is not intended to be extended by clients. An object with state that allows to listen for state changes. Implementations must not manage listeners themselves, listener management must be delegated to a private instance of type ChangeSupport if it is not inherited from AbstractObservable. Since: 1.0 Restriction: This interface is not intended to be implemented by clients. Clients should instead subclass one of the classes in the framework that implement this interface. Note that direct implementers of this interface outside of the framework will be broken in future releases when methods are added to this interface. extends IObservable, Collection Interface for observable collections. Only general change listeners can be added to an observable collection. Listeners interested in incremental changes have to be added using more concrete subtypes such as IObservableList or IObservableSet. Since: 1.0 Restriction: This interface is not intended to be implemented by clients. Clients should instead subclass one of the classes that implement this interface. Note that direct implementers of this interface outside of the framework will be broken in future releases when methods are added to this interface. Restriction: This interface is not intended to be extended by clients. extends Set, IObservableCollection A set whose changes can be tracked by set change listeners. Since: 1.0 See Also: AbstractObservableSet, ObservableSet Restriction: This interface is not intended to be implemented by clients. Clients should instead subclass one of the classes that implement this interface. Note that direct implementers of this interface outside of the framework will be broken in future releases when methods are added to this interface. extends AbstractObservable implements IObservableSet Abstract implementation of IObservableSet. This class is thread safe. All state accessing methods must be invoked from the current realm. Methods for adding and removing listeners may be invoked from any thread. Since: 1.0 '
1445, 'org.eclipse.core.databinding.observable.value.AbstractObservableValue', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/databinding/observable/value/AbstractObservableValue.html', 'An object with state that allows to listen for state changes. Implementations must not manage listeners themselves, listener management must be delegated to a private instance of type ChangeSupport if it is not inherited from AbstractObservable. Since: 1.0 Restriction: This interface is not intended to be implemented by clients. Clients should instead subclass one of the classes in the framework that implement this interface. Note that direct implementers of this interface outside of the framework will be broken in future releases when methods are added to this interface. An object with state that allows to listen for state changes. Implementations must not manage listeners themselves, listener management must be delegated to a private instance of type ChangeSupport if it is not inherited from AbstractObservable. Since: 1.0 Restriction: This interface is not intended to be implemented by clients. Clients should instead subclass one of the classes in the framework that implement this interface. Note that direct implementers of this interface outside of the framework will be broken in future releases when methods are added to this interface. extends IObservable A value whose changes can be tracked by value change listeners. Since: 1.0 See Also: AbstractObservableValue Restriction: This interface is not intended to be implemented by clients. Clients should instead subclass one of the classes that implement this interface. Note that direct implementers of this interface outside of the framework will be broken in future releases when methods are added to this interface. extends AbstractObservable implements IObservableValue This class is thread safe. All state accessing methods must be invoked from the current realm. Methods for adding and removing listeners may be invoked from any thread. Since: 1.0 '
1446, 'org.eclipse.jface.viewers.ICellEditorValidator', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/viewers/ICellEditorValidator.html', 'An interface for validating a cell editor\'s input. This interface should be implemented by classes that wish to act as cell editor validators. '
1447, 'org.eclipse.ui.part.CellEditorActionHandler', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/part/CellEditorActionHandler.html', 'extends Object Handles the redirection of the global actions Cut, Copy, Paste, Delete, Select All, Find, Undo and Redo to either the current inline cell editor or the part\'s supplied action handler. This class may be instantiated; it is not intended to be subclassed. Example usage: actionHandler = new CellEditorActionHandler(this.getViewSite().getActionBars()); actionHandler.addCellEditor(textCellEditor1); actionHandler.addCellEditor(textCellEditor2); actionHandler.setSelectAllAction(selectAllAction); Restriction: This class is not intended to be subclassed by clients. '
1448, 'org.eclipse.ui.help.IContextComputer', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/help/IContextComputer.html', 'A content computer is used to dynamically calculate help support contexts at the time the user requests help. This interface may be implemented by clients. '
1449, 'org.eclipse.jface.viewers.ColorCellEditor', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/viewers/ColorCellEditor.html', 'extends DialogCellEditor A cell editor that manages a color field. The cell editor\'s value is the color (an SWT RBG). This class may be instantiated; it is not intended to be subclassed. Restriction: This class is not intended to be subclassed by clients. '
1450, 'org.eclipse.ui.navigator.Priority', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/navigator/Priority.html', 'extends Object Enumeration of the Priority values supported by the Common Navigator. Since: 3.2 '
1451, 'org.eclipse.ui.views.properties.tabbed.ISectionDescriptor', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/views/properties/tabbed/ISectionDescriptor.html', 'Represents a section descriptor on the tabbed property sections extensions. This interface should not be extended or implemented. New instances should be created using AbstractSectionDescriptor. '
1452, 'org.eclipse.core.commands.operations.IOperationApprover', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/commands/operations/IOperationApprover.html', ' IOperationApprover defines an interface for approving the undo or redo of a particular operation within an operation history. Operations that are candidates for undo or redo have already been validated against their current state and according to the rules of the history. By the time an IOperationApprover is consulted, the undo has already been requested. Approvers should return an IStatus object with severity OK if the operation should proceed, and any other severity if it should not. When an operation is not approved, it is expected that the object not allowing the operation has already consulted the user if necessary or otherwise provided any necessary information to the user about the fact that the operation is not approved. Operation approvers must be prepared to receive the approval messages from a background thread. Any UI access occurring inside the implementation must be properly synchronized using the techniques specified by the client\'s widget library. Since: 3.1 '
1453, 'org.eclipse.ui.services.IServiceWithSources', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/services/IServiceWithSources.html', ' The interface that should be implemented by services that make themselves available through the IAdaptable mechanism. This is the interface that drives the majority of services provided at the workbench level. A service has life-cycle. When the constructor completes, the service must be fully functional. When it comes time for the service to go away, then the service will receive a dispose() call. At this point, the service must release all resources and detach all listeners. A service can only be disposed once; it cannot be reused. This interface has nothing to do with OSGi services. This interface can be extended or implemented by clients. Since: 3.2 extends IDisposable A service that responds to changes in one or more sources. These sources can be plugged into the service. Sources represent a common event framework for services. Clients must not extend or implement. Since: 3.2 '
1454, 'org.eclipse.ui.forms.widgets.LayoutCache', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/forms/widgets/LayoutCache.html', 'extends Object Caches the preferred sizes of an array of controls Since: 3.0 '
1455, 'org.eclipse.swt.dnd.DragSourceEffect', 'http://help.eclipse.org/kepler/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/dnd/DragSourceEffect.html', 'extends org.eclipse.swt.internal.SWTEventListener The DragSourceListener class provides event notification to the application for DragSource events. When the user drops data on a DropTarget, the application which defines the DragSource must provide the dropped data by implementing dragSetData. In the dragSetData, the application must support all the data types that were specified in the DragSource#setTransfer method. After the drop has completed successfully or has been aborted, the application which defines the DragSource is required to take the appropriate cleanup action. In the case of a successful move operation, the application must remove the data that was transferred. extends DragSourceAdapter This class provides default implementations to display a drag source effect during a drag and drop operation. The current implementation does not provide any visual feedback. The drag source effect has the same API as the DragSourceAdapter so that it can provide custom visual feedback when a DragSourceEvent occurs. Classes that wish to provide their own drag source effect such as displaying a default source image during a drag can extend the DragSourceEffect class, override the DragSourceAdapter.dragStart method and set the field DragSourceEvent.image with their own image. The image should be disposed when DragSourceAdapter.dragFinished is called. Since: 3.3 See Also: DragSourceAdapter, DragSourceEvent, Sample code and further information '
